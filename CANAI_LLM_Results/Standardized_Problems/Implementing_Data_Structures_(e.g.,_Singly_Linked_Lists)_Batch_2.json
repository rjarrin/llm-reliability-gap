[{"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just opened a \u201cTech Help Window.\u201d Students can borrow small gadgets (USB cables, adapters, etc.) for 30-minute slots.  \nA Raspberry Pi at the window only runs C, so you must build a tiny inventory manager that keeps the gadget queue in memory using a **singly linked list**.  \nEach time a student checks out an item, it is appended to the end of the list; when the item is returned, it is removed from the front.  \nThe manager must also be able to show the current waiting list on request.\n\n## Functional Requirements\n1. Represent every gadget with a unique ID (positive integer) and a short name (\u226420 characters).\n2. Maintain the queue strictly in FIFO order.\n3. Provide an interactive menu with the following choices:\n   1. Check out (enqueue) a gadget  \n   2. Return (dequeue) a gadget  \n   3. Display current queue  \n   4. Exit program  \n4. On enqueue, read ID and name from stdin; silently ignore duplicate IDs.  \n5. On dequeue, print the ID and name of the gadget that was removed; if the queue is empty, print `Queue empty`.  \n6. On display, print one line per gadget in the format `ID: name`; if the queue is empty, print `Queue empty`.\n\n## Simple Input/Output Example\n```\n1\n101 powerbank\n1\n102 usbc_cable\n3\n2\n4\n```\nExpected output\n```\nQueue empty\n101: powerbank\n102: usbc_cable\n101 powerbank\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent each gadget node.  \n- All queue operations (enqueue, dequeue, display) must be implemented in **one** user-defined function each (three functions total besides `main`).  \n- The program must terminate when the user chooses menu option **4**.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 81}, {"text": "# STEP 1: PROBLEM\n\n## Context\nA local library is digitizing its card-catalog system.  \nEach \u201ccard\u201d will be stored as a node in a singly linked list, and the only information kept is the book\u2019s unique ID (an integer).  \nThe head librarian wants a tiny demo program that can add books to the front of the list, remove a book by ID, and print the current catalog.\n\n## Requirements\n1. Represent each book with a node that stores:\n   - an integer ID\n   - a pointer to the next node\n2. Provide three user commands:\n   - `add <id>` \u2013 insert a new book with the given ID at the head of the list\n   - `remove <id>` \u2013 delete the first node whose ID matches the given value; do nothing if the ID is absent\n   - `print` \u2013 display every ID in the list from head to tail, separated by a single space and followed by a newline\n3. The program must read commands until the user types `exit`, at which point it should free all remaining nodes and terminate\n4. Assume IDs are non-negative integers and that no two books share the same ID\n\n## Simple Example\nInput\n```\nadd 5\nadd 3\nprint\nremove 5\nprint\nexit\n```\nOutput\n```\n3 5\n3\n```\n\n### CONSTRAINTS\n- You must use a `struct` to represent the primary data entity (the book node).  \n- All dynamic memory must be freed before the program exits.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 82}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library is digitizing its magazine rack.  \nEach magazine is stored as a single stapled issue, and students can only add new issues to the front of the rack or remove the most recent issue (LIFO style).  \nYour task is to model this rack as a **singly linked list** and provide a tiny terminal interface so the librarian can keep track of the magazines.\n\n## Requirements\n1. A magazine has two pieces of data:  \n   - `title` \u2013 a single-word string (\u226430 chars)  \n   - `issue` \u2013 an integer (\u22651)  \n2. Represent each magazine node with a `struct`.  \n3. Provide the following operations in a menu loop:  \n   1. **Push** a new magazine to the front of the list.  \n   2. **Pop** the magazine at the front and print its details.  \n   3. **Display** the entire rack from most-recent to oldest.  \n   4. **EXIT** the program (option 4).  \n4. After every operation, re-display the menu (except when exiting).  \n5. Handle empty-list cases gracefully with the message `\"Rack is empty\"`.\n\n## Example Run\n```\n1. Push\n2. Pop\n3. Display\n4. Exit\nChoice: 1\nTitle: Wired\nIssue: 202304\n1. Push\n2. Pop\n3. Display\n4. Exit\nChoice: 1\nTitle: Nature\nIssue: 202312\n1. Push\n2. Pop\n3. Display\n4. Exit\nChoice: 3\nNature 202312\nWired 202304\n1. Push\n2. Pop\n3. Display\n4. Exit\nChoice: 2\nRemoved: Nature 202312\n1. Push\n2. Pop\n3. Display\n4. Exit\nChoice: 4\n```\n\n### CONSTRAINTS\n- You **must** use a `struct` to represent the magazine node.  \n- The logic that prints the details of **one** magazine must be encapsulated in a function named `displayMagazine`.  \n- The solution must be implemented with **only one** additional function besides `main()`\u2014i.e., all list operations (push, pop, display list) must be handled inline inside `main()` or via the single extra function.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 83}, {"text": "# STEP 1: PROBLEM\n## Background Story\nThe campus library has a \u201cTake-a-Book, Leave-a-Book\u201d shelf that is literally a single line of books.  \nStudents may only add a book to the front of the line or borrow the book at the front.  \nTo keep track of what is on the shelf, the librarian has asked you to write a tiny inventory system that models the shelf as a **singly linked list** of book nodes.\n\n## Task\nImplement a console program that maintains the shelf.  \nEach book has:\n- a unique 5-digit ID (int)\n- a title string (up to 50 characters, no spaces)\n\nThe program must support the following commands in a loop:\n\n1. `ADD id title` \u2013 insert the new book at the **front** of the list.  \n   If an ID already exists anywhere on the shelf, print `ID already exists` and do nothing.\n2. `BORROW` \u2013 remove the book at the **front** of the list and print `Borrowed: id title`.  \n   If the shelf is empty, print `Shelf is empty`.\n3. `LIST` \u2013 print every book currently on the shelf, **one per line**, in order from front to back.  \n   If the shelf is empty, print `Shelf is empty`.\n4. `EXIT` \u2013 terminate the program.\n\n## Simple Example\n### Input\n```\nADD 10001 Pride\nADD 10002 Prejudice\nBORROW\nLIST\nADD 10001 Pride\nEXIT\n```\n\n### Output\n```\nBorrowed: 10001 Pride\nShelf is empty\nID already exists\n```\n\n### CONSTRAINTS\n1. You **must** use a `struct` to represent a book node (it must contain at least the fields `id`, `title`, and a pointer to the next node).\n2. All list operations (insert at front, remove from front, traversal) must be implemented **manually**; you may **not** use STL containers such as `list` or `forward_list`.\n3. The only functions allowed besides `main()` are:\n   - `void displayEntity(const Book* b)` \u2013 prints the ID and title of the single book passed to it.\n   - One helper function of your choice (e.g., `bool idExists(Book* head, int id)`).\n4. Memory allocated with `new` must be freed before the program exits; no leaks.\n5. The menu option to EXIT the program is the keyword `EXIT`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 84}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou are helping a small music-streaming startup called \u201cBeatChain\u201d keep track of the songs queued by users.  \nEach user has a personal playlist that is stored as a singly linked list.  \nA node in the list holds the song title (\u2264100 characters) and a play-count (\u22650).  \nThe playlist is always built in \u201cappend-to-end\u201d order; the newest song is always added at the tail.\n\n## Precise Requirements\n1. Define a structure `SongNode` that contains:\n   - a character array for the title\n   - an integer for play-count\n   - a pointer to the next node\n2. Provide exactly four operations (menu driven):\n   1. Add Song \u2013 read a title and a play-count, append a new node to the tail of the list\n   2. Play Next \u2013 remove the node at the head, print its title and play-count, and free it\n   3. Show Playlist \u2013 print every song in order, one per line, as `title (playCount)`\n   4. Exit \u2013 free every remaining node and terminate the program\n3. After every operation (except Exit), re-display the menu and wait for the next choice\n4. If the user tries to Play Next when the list is empty, print `Playlist empty` and continue\n\n## Simple Example\nInput\n```\n1\nBohemian Rhapsody\n42\n1\nImagine\n7\n3\n2\n3\n4\n```\n\nOutput\n```\nMenu:\n1. Add Song\n2. Play Next\n3. Show Playlist\n4. Exit\nChoice: 1\nTitle: Bohemian Rhapsody\nPlay count: 42\nMenu:\n1. Add Song\n2. Play Next\n3. Show Playlist\n4. Exit\nChoice: 1\nTitle: Imagine\nPlay count: 7\nMenu:\n1. Add Song\n2. Play Next\n3. Show Playlist\n4. Exit\nChoice: 3\nBohemian Rhapsody (42)\nImagine (7)\nMenu:\n1. Add Song\n2. Play Next\n3. Show Playlist\n4. Exit\nChoice: 2\nPlaying: Bohemian Rhapsody (42)\nMenu:\n1. Add Song\n2. Play Next\n3. Show Playlist\n4. Exit\nChoice: 3\nImagine (7)\nMenu:\n1. Add Song\n2. Play Next\n3. Show Playlist\n4. Exit\nChoice: 4\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent the primary data entity (`SongNode`)\n- Logic for displaying the details of ONE specific entity must be in a function called `displaySong`\n- The program must terminate only when the user chooses menu option 4 (Exit)", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 85}, {"text": "# STEP 1: PROBLEM\n\n## Context\nYou\u2019ve been hired by the campus music club to build a tiny, self-contained \u201cNow-Playing\u201d playlist manager.  \nThe club DJ keeps adding songs to the end of the playlist and sometimes needs to remove the song that just finished playing (always at the front).  \nYour job is to implement the playlist as a **singly linked list** that can grow and shrink from opposite ends.\n\n## Requirements\n1. Each song is stored in a node that contains:\n   - an integer id (unique within a session)  \n   - a string title  \n   - a string artist  \n   - a pointer to the next node  \n2. Maintain only two external pointers:\n   - `head` \u2013 points to the song that will play next  \n   - `tail` \u2013 points to the most-recently added song  \n3. Support exactly three user commands (menu driven):\n   1. **Add Song** \u2013 append a new song to the end of the list  \n   2. **Play Next** \u2013 remove and display the song at the front (id, title, artist)  \n   3. **Exit** \u2013 free all remaining nodes and terminate (menu option 3)  \n4. After every command, print the count of songs currently in the playlist.\n\n## Example Session (user input after prompt `>`)\n```\n1\n> Please enter song id, title, artist: 101 Bohemian Rhapsody Queen\nSongs in playlist: 1\n\n1\n> Please enter song id, title, artist: 102 Imagine Dragons\nSongs in playlist: 2\n\n2\nNow playing: 101 Bohemian Rhapsody Queen\nSongs in playlist: 1\n\n3\nGoodbye!\n```\n\n## Deliverables\nYour program must present the menu in a loop until the user chooses 3.\n\n### CONSTRAINTS\n- Must use a `struct` to represent each song node.  \n- All list operations (insert at tail, remove from head, memory cleanup) must be implemented **inside a single user-defined function** besides `main()` (call it `playlistManager`).  \n- Menu option 3 is the only way to exit; it must also free every remaining node.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 86}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just opened a \u201cTech-Help\u201d desk where students can donate spare USB flash drives.  \nTo keep track of the drives, the student assistant needs a tiny inventory system that stores the drives in the exact order they were donated.  \nBecause the number of drives changes constantly, a singly linked list is the perfect structure.\n\n## Requirements\nImplement a console program that maintains a singly linked list of donated USB flash drives.  \nEach drive stores:\n- `id` \u2013 a unique positive integer (the library labels them sequentially)\n- `capacityGB` \u2013 an integer \u2265 1\n- `brand` \u2013 a string without spaces (e.g., SanDisk, Kingston)\n\nThe program must support the following operations:\n1. Insert a new drive (always appended to the tail of the list)\n2. Remove the drive with a given id\n3. Display the entire inventory in order from head to tail\n4. Display full details of the drive with a given id\n5. Exit the program\n\n## Simple Example\nInput (user choices shown after the menu prompt):\n\n```\n1\n101 64 Kingston\n1\n102 32 SanDisk\n3\n4\n101\n5\n```\n\nCorresponding output:\n\n```\n=== USB Inventory ===\nID:101 GB:64 Brand:Kingston\nID:102 GB:32 Brand:SanDisk\n=== Details ===\nID:101 GB:64 Brand:Kingston\nGood-bye!\n```\n\n## Menu Layout\n```\nUSB Drive Inventory\n1) Donate (insert)\n2) Remove by id\n3) Show all\n4) Show one\n5) Exit\nChoice:\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent each USB drive node.  \n- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.  \n- The solution must be implemented with a single function besides `main()`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 87}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library is digitising its \u201creservation queue\u201d for study rooms.  \nStudents can join the queue, cancel their reservation, or check their current position.  \nYour task is to implement the queue as a singly linked list that the librarian will control from a simple text menu.\n\n## Requirements\n1. Each queue node stores a student\u2019s first name (\u2264 30 characters) and a 6-digit student ID.\n2. The list must be kept in strictly increasing order of student ID at all times (no separate sorting step after every insertion).\n3. Provide a menu with the following choices:\n   1. Add a new reservation (insert student in sorted order)  \n   2. Cancel a reservation (remove by student ID)  \n   3. Show the current queue (print ID and name, one per line)  \n   4. EXIT (terminates the program)\n4. After every successful insert or delete, print the current length of the queue.\n5. If the user tries to add a duplicate ID, print \u201cID already in queue\u201d and leave the queue unchanged.\n6. If the user tries to cancel a non-existent ID, print \u201cID not found\u201d.\n\n## Simple Example of Expected Input/Output\n```\n1\nAlice 123456\nLength: 1\n1\nBob 100001\nLength: 2\n3\n100001 Bob\n123456 Alice\n2\n123456\nLength: 1\n4\n```\n(The program terminates.)\n\n## CONSTRAINTS\n- Must use a struct to represent the primary data entity (the node).  \n- Logic for displaying the details of ONE specific node must be in a function called displayEntity.  \n- The entire solution must be implemented with a single function besides main().", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 88}, {"text": "# STEP 1: PROBLEM\n\n## Context\nThe campus bookstore needs a tiny inventory system to keep track of textbooks.  \nEach book has:  \n- a unique ISBN (string, 13 digits)  \n- a title (string, up to 50 characters)  \n- a quantity in stock (integer \u2265 0)\n\nBecause the system will run on an embedded board with very little RAM, you are asked to store the collection as a **singly linked list** that you implement yourself.  \nNo arrays, no STL containers.\n\n## Requirements\n1. Represent each book with a `struct Book` that contains the three fields above and a `next` pointer.\n2. Maintain the list in **ascending alphabetical order by title** (A\u2192Z).\n3. Support the following operations shown in a simple text menu:\n   1. Add a new book (insert in the correct position; if the ISBN already exists, just update the quantity).\n   2. Sell a book (decrease its quantity by 1; if quantity reaches 0, remove the node).\n   3. Display the full inventory in order (one line per book: `ISBN title qty`).\n   4. Exit the program (option 4).\n4. After every operation, re-display the menu until the user chooses 4.\n5. You may assume that all inputs are well-formed (no need to validate ISBN length, etc.).\n\n## Simple Example Run\n```\n1. Add\n2. Sell\n3. Display\n4. Exit\nChoice: 1\nISBN: 9780131103627\nTitle: The C Programming Language\nQuantity: 3\n1. Add\n2. Sell\n3. Display\n4. Exit\nChoice: 1\nISBN: 9780201310092\nTitle: Advanced Programming in the UNIX Environment\nQuantity: 2\n1. Add\n2. Sell\n3. Display\n4. Exit\nChoice: 3\n9780201310092 Advanced Programming in the UNIX Environment 2\n9780131103627 The C Programming Language 3\n1. Add\n2. Sell\n3. Display\n4. Exit\nChoice: 2\nTitle to sell: The C Programming Language\n1. Add\n2. Sell\n3. Display\n4. Exit\nChoice: 3\n9780201310092 Advanced Programming in the UNIX Environment 2\n9780131103627 The C Programming Language 2\n1. Add\n2. Sell\n3. Display\n4. Exit\nChoice: 4\nGoodbye!\n```\n\n### CONSTRAINTS\n- Must use a `struct Book` to represent the primary data entity.  \n- Logic for displaying the details of ONE specific book must be in a function called `displayBook`.  \n- The solution must be implemented with **only one additional function besides `main()`** (you may overload this function if you wish, but only one user-defined name other than `main`).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 89}, {"text": "# STEP 1: PROBLEM\n\n## BACKGROUND STORY  \nThe campus library has replaced its paper card catalog with a tiny, battery-powered \u201cbook finder\u201d gadget that only stores book titles in the order they were added. Because memory is precious, the gadget must keep the list as a **singly linked list** and never allocate more nodes than strictly necessary.  \nYour task is to write the firmware that lets a librarian add new titles to the back of the list and, on request, print the full current catalog.\n\n## PRECISE REQUIREMENTS  \n1. Represent each book as a node that stores one `std::string` title.  \n2. Maintain a singly linked list that always appends new books at the tail.  \n3. Provide two user commands:  \n   - `ADD <title>` \u2013 insert the given title at the end of the list (case-sensitive, may contain spaces).  \n   - `PRINT` \u2013 output the entire list, one title per line, in the same order the books were added.  \n4. Stop the program only when the user types `EXIT` (case-insensitive).  \n5. You may assume every command is on a single line and input is well-formed.\n\n## SIMPLE EXAMPLE  \n**Input**  \nADD The Great Gatsby  \nADD To Kill a Mockingbird  \nPRINT  \nEXIT  \n\n**Output**  \nThe Great Gatsby  \nTo Kill a Mockingbird  \n\n## NOTE  \nNo dynamic arrays, vectors, or STL containers are allowed\u2014only raw pointers and your own linked-list logic.\n\n### CONSTRAINTS  \n- Must use a `struct` named `BookNode` to represent each list element.  \n- All list manipulation (add, traverse) must be implemented in **one** user-defined function besides `main()`.  \n- The menu option to EXIT the program must be the keyword `EXIT`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 90}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou are helping the campus music club manage its vinyl-record collection.  \nEach record has a catalog number (unique integer), album title, and artist name.  \nBecause the collection keeps growing, the club wants a tiny terminal program that stores the records in a singly linked list and lets them add or search records quickly.\n\n## Required Functionality\n1. When the program starts, the list is empty.\n2. The program repeatedly shows a menu:\n   1) Add a new record  \n   2) Search for a record by catalog number  \n   3) Show every record (in the order they were added)  \n   4) Exit  \n3. Option 1: Prompt user for catalog number, album title, and artist name; insert the new record at the **head** of the list.  \n4. Option 2: Prompt for a catalog number; if it exists, print the record\u2019s details; otherwise print \u201cNot found\u201d.  \n5. Option 3: Print every record, one per line, in the same order they were added (i.e., reverse of insertion order).  \n6. Option 4: Print \u201cGoodbye!\u201d and terminate.\n\n## Simple Example Run\n```\n1) Add\n2) Search\n3) Show All\n4) Exit\nChoice: 1\nCatalog #: 101\nTitle: Rumours\nArtist: Fleetwood Mac\nAdded.\n\n1) Add\n2) Search\n3) Show All\n4) Exit\nChoice: 1\nCatalog #: 102\nTitle: Abbey Road\nArtist: The Beatles\nAdded.\n\n1) Add\n2) Search\n3) Show All\n4) Exit\nChoice: 2\nEnter catalog #: 101\n101 | Rumours | Fleetwood Mac\n\n1) Add\n2) Search\n3) Show All\n4) Exit\nChoice: 3\n102 | Abbey Road | The Beatles\n101 | Rumours | Fleetwood Mac\n\n1) Add\n2) Search\n3) Show All\n4) Exit\nChoice: 4\nGoodbye!\n```\n\n### CONSTRAINTS\n- You must define a `struct` to represent a record (node).  \n- All list operations (add, search, display) must be implemented in **one** user-defined function besides `main()`.  \n- Menu option 4 is the only way to exit; typing 4 must terminate the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 91}, {"text": "# STEP 1: PROBLEM\n\n**Background Story**  \nThe campus library has a \u201cFast-Return\u201d box where students drop returned books.  \nA student volunteer robot can only pick up one book at a time from the top of the pile and  \nstore it on a cart.  \nYour task is to write a tiny \u201ccart-tracker\u201d that records the titles in the exact order the  \nrobot stores them. Because the robot can only access the most recently added book,  \nyou must model the cart as a **singly linked list** that always grows at the head (LIFO style).\n\n**Requirements**  \n1. Represent each book with a struct that contains at least:  \n   \u2013 a unique title (C-string, \u226480 chars)  \n   \u2013 a pointer to the next book in the cart  \n2. Provide an interactive menu with the following choices:  \n   1) Add a new book (push onto the head)  \n   2) Remove the last added book (pop from the head)  \n   3) Display the current cart from newest to oldest  \n   4) Exit the program (must be option 4)  \n3. After every operation, print the updated size of the cart.  \n4. If the cart is empty and the user tries to pop or display, print \u201cCart is empty.\u201d\n\n**Simple Example**  \nInput (user responses in brackets)\n```\nWelcome to Cart-Tracker\n1) Add book\n2) Remove last book\n3) Display cart\n4) Exit\n[1]\nEnter title: Introduction to Algorithms\nSize: 1\n[1]\nEnter title: Clean Code\nSize: 2\n[3]\nCart (newest \u2192 oldest):\nClean Code\nIntroduction to Algorithms\n[2]\nRemoved: Clean Code\nSize: 1\n[4]\nGoodbye!\n```\n\n### CONSTRAINTS\n- Must use a struct named Book to represent the primary data entity.  \n- All list operations (push, pop, display) must be implemented in a **single function** besides main().  \n- Menu option 4 must immediately terminate the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 92}, {"text": "# STEP 1: PROBLEM\n\n## Context  \nThe campus library has just reopened and is still using paper cards to keep track of who has borrowed which book.  \nTo modernise the process, you decide to build a tiny, single-session console program that stores the waiting list for one popular textbook.  \nThe list must be a **singly linked list** of students, each holding:  \n- a unique 6-digit student ID  \n- the student\u2019s first name (\u2264 20 characters)  \n- the day of the month (1-31) on which the book was reserved  \n\n## Requirements  \n1. Represent every student node with a `struct` that contains the three data fields above.  \n2. Provide a text menu that lets the user repeatedly choose among the following actions:  \n   1. Add a new student to the **end** of the list.  \n   2. Display the full waiting list in order (one student per line: ID, name, day).  \n   3. Remove the student at the **front** of the list (the next person to receive the book).  \n   4. Search for a student by ID and print their details if found.  \n   5. **EXIT** the program.  \n3. After every successful operation print a short confirmation message.  \n4. All list operations must run in O(1) or O(n) time as appropriate; no auxiliary arrays or STL containers are allowed.  \n5. Free all dynamically allocated memory before exit.\n\n## Simple Example Run  \n```\nWelcome to Library Waiting List Manager\n1. Add student\n2. Display list\n3. Serve first student\n4. Search by ID\n5. EXIT\nChoice: 1\nEnter ID: 123456\nEnter first name: Ada\nEnter reservation day: 12\nStudent added.\n\nChoice: 1\nEnter ID: 654321\nEnter first name: Alan\nEnter reservation day: 13\nStudent added.\n\nChoice: 2\nWaiting list:\n123456 Ada 12\n654321 Alan 13\n\nChoice: 3\n123456 Ada has been served and removed.\n\nChoice: 5\nGood-bye!\n```\n\n### CONSTRAINTS  \n- You must use a `struct` to represent each student node.  \n- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.  \n- The only functions besides `main()` are:  \n  - `displayEntity` (as specified)  \n  - plus any utility functions you need for list operations (add, remove, search, free).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 93}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library is modernizing its card-catalogue system.  \nInstead of physical drawers, they want a tiny terminal program that keeps track of book records in a **singly linked list**.  \nEach record stores the book\u2019s title, author, and year of publication.  \nStudents can add new books, remove the oldest book, or print the catalogue in the order the books were added.\n\n---\n\n## Required Functionality\n1. Maintain the catalogue as a singly linked list.\n2. Support three user commands:\n   - `add <title> \"<author>\" <year>`  \n      (title and author strings may contain spaces; author is always wrapped in double quotes)\n   - `remove`  \n      (always removes the first book that was added, i.e. head of the list)\n   - `print`  \n      (prints the entire catalogue, one book per line, in the format shown below)\n3. After every command, print the number of books currently in the catalogue.\n4. The program must loop until the user types `exit`.\n\n---\n\n## Simple Example Session (user input is preceded by `>`)\n\n```\n> add \"The Pragmatic Programmer\" \"Andrew Hunt\" 1999\n1\n> add Clean Code \"Robert C. Martin\" 2008\n2\n> print\n\"The Pragmatic Programmer\" by Andrew Hunt (1999)\n\"Clean Code\" by Robert C. Martin (2008)\n2\n> remove\n1\n> exit\n```\n\n---\n\n### CONSTRAINTS\n- You must use a `struct` named `Book` to represent each record and a `struct` named `Node` for the list nodes.  \n- All list manipulation logic (insert, delete, print) must be implemented in **one user-defined function** besides `main()`; you may choose any signature for that function.  \n- No global variables are allowed.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 94}, {"text": "# STEP 1: PROBLEM\n## Background Story\nThe campus library has replaced its old card-catalogue with a tiny computer that can only remember one thing at a time.  To help it keep track of which books are on the shelf, you will build an in-memory \u201cshelf list\u201d using a **singly linked list**.  Each node represents one book.  When a book is returned you add it to the front of the list; when a book is borrowed you remove it by title.  The librarian should also be able to print the current shelf (in order from front to back) and, of course, finish the work day.\n\n## Functional Requirements\n1. Represent a book with at least the following data:  \n   - title (a single word, \u226430 characters)  \n   - author (a single word, \u226430 characters)  \n   - year (int)  \n\n2. Maintain the shelf as a singly linked list whose head pointer is kept in `main`.\n\n3. Provide a **console menu** with four choices:\n   ```\n   1  Return a book (insert at front)\n   2  Borrow a book (remove by exact title match, case-sensitive)\n   3  Show shelf\n   4  Exit\n   ```\n4. For menu option 1, prompt the user for title, author, and year, then insert a new node at the **front** of the list.\n\n5. For menu option 2, prompt for the title; if the book is on the shelf, delete **only the first matching node** and print `Borrowed.`, otherwise print `Not found.`.\n\n6. For menu option 3, print the shelf contents one book per line in the format  \n   `title (year) by author`  \n   or print `Shelf is empty.` if nothing is stored.\n\n7. After every operation, redisplay the menu until the user chooses option 4.\n\n## Simple Example Run\n```\n1\nMoby_Dick Melville 1851\n1\n1984 Orwell 1949\n3\n1984 (1949) by Orwell\nMoby_Dick (1851) by Melville\n2\n1984\nBorrowed.\n3\nMoby_Dick (1851) by Melville\n4\n```\n(Program ends.)\n\n### CONSTRAINTS\n- Must use a `struct` called `Book` to represent the primary data entity.  \n- Logic for displaying the details of ONE specific book must be in a function called `displayBook`.  \n- The solution must be implemented with a single function besides `main()` (i.e., only one additional function definition is permitted, and `displayBook` must be that function).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 95}, {"text": "# STEP 1: PROBLEM\n\n**Background Story**  \nThe campus bookstore has run out of shelf space. To keep track of which books are stored in which sealed box, the clerk wants a tiny \u201cinventory\u201d program that remembers the order in which boxes were stacked. Each box is labelled with a unique ID (positive integer) and a short description (one word, \u226430 characters). Because boxes are stacked on top of one another, the most recently added box must be the first one removed (LIFO). You will implement this behaviour with a **singly linked list** that only allows insertions and deletions at the head.\n\n**Functional Requirements**  \n1. Represent every box as a node that stores:\n   - an integer id (the label)  \n   - a C-string description (\u226430 characters)  \n   - a pointer to the next node  \n2. Provide a text menu that repeatedly offers the following choices:  \n   1. Push a new box onto the stack  \n   2. Pop the top box from the stack  \n   3. Display the current stack (from top to bottom)  \n   4. Exit  \n3. Push: read an id and a description from stdin; prepend the node to the list.  \n4. Pop: remove the head node, print its id and description, and free its memory.  \n   - If the stack is empty, print \u201cStack underflow\u201d and do nothing.  \n5. Display: print one line per box in the format  \n   `id description`  \n   starting from the top. If the stack is empty, print \u201cEmpty stack\u201d.  \n\n**Simple Example**  \nInput  \n```\n1 42 physics\n2 17 chemistry\n3\n1\n4\n```\nOutput  \n```\n17 chemistry\n42 physics\nEmpty stack\n```\n\n**Explanation of Example**  \n- 42 physics is pushed.  \n- 17 chemistry is pushed.  \n- Pop prints \u201c17 chemistry\u201d.  \n- Display prints \u201c42 physics\u201d.  \n- Another pop prints \u201c42 physics\u201d.  \n- Final display prints \u201cEmpty stack\u201d.  \n\n### CONSTRAINTS  \n- You **must** use a single `struct` named `Box` to represent each node.  \n- The logic that prints the details of **one** box must be placed in a function called `displayBox`.  \n- The entire solution must be implemented with **only one additional function besides main()** (you may choose which one).  \n- The menu option to **Exit the program** is number **4**.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 96}, {"text": "# STEP 1: PROBLEM\n\n## Context\nYou are helping the campus music club manage their vinyl-record queue.  \nEach record has a catalog number (positive integer) and a title.  \nClub members can add a new record to the **front** of the queue, remove the **front** record after it is played, or print the entire queue from front to back.  \nAll operations must run in O(1) time for add/remove and O(n) time for printing.\n\n## Requirements\n1. Represent each record with a node that stores catalog number, title, and a pointer to the next node.\n2. Provide the user with a text menu:\n   ```\n   1) Add record to front\n   2) Play (remove) front record\n   3) Show queue\n   4) Exit\n   ```\n3. After every operation print one brief status line:\n   - \"Added: <title>\"\n   - \"Played: <title>\"\n   - \"Queue empty\" (if removal attempted on empty list)\n   - (No extra text when merely showing the queue.)\n\n4. The queue must be implemented as a **singly linked list** you build yourself; no STL/Collections containers allowed.\n\n## Simple Example\nInput (user choices):\n```\n1\n1801\nAbbey Road\n1\n2105\nRumours\n3\n2\n4\n```\n\nCorresponding console output:\n```\nAdded: Abbey Road\nAdded: Rumours\n(1801) Abbey Road\n(2105) Rumours\nPlayed: Abbey Road\n```\n\n### CONSTRAINTS\n- The primary data entity (a record node) must be defined with a C/C++ `struct`.\n- All list operations must be performed through a single user-defined function besides `main()` (e.g., `void listManager(int choice, ...)`).\n- Menu option 4 is the only way to exit the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 97}, {"text": "# STEP 1: PROBLEM  \n## Background Story  \nThe campus music club keeps its vinyl-record playlist as a **singly linked list**. Each record stores the album title, the band name, and the year of release. The club hires you to write a tiny console program that lets a DJ quickly grow, shrink, and review the playlist between shows.\n\n## Requirements  \n1. The playlist is stored only as a singly linked list whose nodes are dynamically allocated.  \n2. The user is shown a menu with the following choices:  \n   1) Add a new record to the **front** of the list  \n   2) Remove the **first** record that matches a supplied album title  \n   3) Display the entire playlist (one record per line)  \n   4) Count how many records in the list are **older than a given year**  \n   5) Exit the program (terminates)  \n3. All inputs are from `stdin`; all outputs go to `stdout`.  \n4. If an operation is requested on an empty list, print `Playlist empty.` and redisplay the menu.  \n5. After every successful operation (except Exit), redisplay the menu.  \n\n## Simple Example Run (user input shown after `>`)  \n```\n1\n>Album: Pet Sounds\n>Band: The Beach Boys\n>Year: 1966\n1\n>Album: Rumours\n>Band: Fleetwood Mac\n>Year: 1977\n3\nPet Sounds (The Beach Boys, 1966)\nRumours (Fleetwood Mac, 1977)\n4\n>Year: 1970\nRecords older than 1970: 1\n2\n>Album: Pet Sounds\nRemoved.\n3\nRumours (Fleetwood Mac, 1977)\n5\n```\nProgram terminates.\n\n### CONSTRAINTS  \n- You **must** define a `struct Record` containing the three data fields and a pointer to the next node.  \n- The logic for displaying a single record must be placed in a function called `displayEntity`.  \n- Apart from `main`, your solution may contain **only one additional function** that performs all list operations (add, remove, print, count); use a switch or similar inside that function to dispatch work.  \n- Menu option **5** is the only way to exit the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 98}, {"text": "# STEP 1: PROBLEM  \n**Story:**  \nThe campus library is digitizing its small \u201cBook-Swap\u201d shelf. Every time a student donates a book, the title is written on an index card and placed at the **front** of the shelf (a LIFO pile). When another student borrows a book, they always take the **top** card. Your task is to write a tiny program that keeps track of the current order of books on this shelf using a **singly linked list**.  \n\n**Precise Requirements:**  \n1. Represent each book with a node that stores the title (a single string of \u2264 50 characters) and a next-pointer.  \n2. Provide a menu with three operations:  \n   - `1` \u2013 Donate a book (add to the front of the list).  \n   - `2` \u2013 Borrow a book (remove and print the title of the front book).  \n   - `3` \u2013 Show all books currently on the shelf (from front to back).  \n   - `4` \u2013 EXIT the program.  \n3. If the shelf is empty and a borrow or show is attempted, print `Shelf is empty`.  \n4. All list operations must be implemented **manually** (no `STL`/`Collections`).  \n\n**Simple Example Run:**  \n```\n1\nDonate title: Clean Code\n1\nDonate title: Algorithms Unlocked\n3\nShelf: Algorithms Unlocked -> Clean Code -> END\n2\nBorrowed: Algorithms Unlocked\n3\nShelf: Clean Code -> END\n4\nGoodbye!\n```\n\n### CONSTRAINTS  \n- Must use a `struct` called `BookNode` to represent the primary data entity.  \n- All list manipulation must be done with **one single user-defined function** besides `main()` (e.g., a helper that performs insert, delete, and display).  \n- Menu option `4` must EXIT the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 99}, {"text": "# STEP 1: PROBLEM\n\n**Background Story**  \nYou are the keeper of the \u201cScroll of Tasks,\u201d a magical parchment that can only hold one quest at a time.  \nEach quest is written on a tiny slip that is linked to the next slip by a silver thread, forming a chain.  \nWhen an adventurer completes the current quest, the slip vanishes and the next quest slides to the front.  \nYour job is to write the spells (code) that let the guild add new quests, complete (remove) the current quest, peek at the current quest, display the entire chain, and dissolve the guild (exit).\n\n**Precise Requirements**  \n1. Represent each quest with a struct that stores:  \n   - a unique id (positive integer)  \n   - a short title (string, \u226430 chars)  \n   - a pointer to the next quest (or NULL if last).  \n2. Maintain the quests as a **singly linked list** whose head is the **current active quest**.  \n3. Provide a console menu with the following options:  \n   1. Add new quest (insert at the tail)  \n   2. Complete current quest (remove head)  \n   3. Peek at current quest  \n   4. Display entire quest chain  \n   5. Exit (dissolve guild)  \n4. After every operation, re-display the menu until the user chooses 5.  \n5. Handle edge cases gracefully:  \n   - Completing or peeking when the list is empty should print \u201cNo active quests.\u201d  \n   - Adding the first quest should make it the new head.  \n\n**Simple Example Run**  \n```\nMenu:\n1. Add quest\n2. Complete quest\n3. Peek current quest\n4. Display chain\n5. Exit\nChoice: 1\nEnter quest id: 101\nEnter quest title: RescueCat\nChoice: 1\nEnter quest id: 102\nEnter quest title: FetchWater\nChoice: 3\nCurrent quest: [101] RescueCat\nChoice: 2\nQuest 101 completed!\nChoice: 4\nQuest chain:\n[102] FetchWater\nChoice: 5\nGood-bye!\n```\n\n### CONSTRAINTS  \n- You must use a struct named Quest to represent each node.  \n- All list operations (insert, remove, peek, display) must be implemented in **one user-defined function** besides main(); name that function listManager().  \n- The program must terminate only when the user selects menu option 5.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 100}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library is digitizing its old card-catalog.  \nEach drawer is a singly linked list of cards; each card stores a book\u2019s call-number (a unique string) and title.  \nYour job is to write a mini-catalog program that keeps the list alphabetically sorted by call-number while letting the librarian add and search cards.\n\n## Functional Requirements\n1. Represent each card as a node in a singly linked list.\n2. Provide an interactive menu with the following choices:\n   1. Add a new card (insert in ascending alphabetical order by call-number; reject duplicates).\n   2. Search for a card by call-number and display its title.\n   3. Display the entire catalog in order.\n   4. Exit the program.\n3. If the catalog is empty, any display operation must print `Catalog is empty.`\n4. All dynamic memory must be freed before the program exits.\n\n## Example Session (user input after `>`)\n```\n1\n> 1\nEnter call-number: QA76.73.C15\nEnter title: The C Programming Language\nCard added.\n> 1\nEnter call-number: QA76.6.B67\nEnter title: Algorithms to Live By\nCard added.\n> 3\nQA76.6.B67 : Algorithms to Live By\nQA76.73.C15 : The C Programming Language\n> 2\nEnter call-number: QA76.73.C15\nTitle: The C Programming Language\n> 4\nGood-bye!\n```\n\n## Technical Details\n- Use C or C++.\n- All list operations must be implemented \u201cby hand\u201d (no STL or built-in containers).\n\n### CONSTRAINTS\n- Must use a `struct` named `Card` to represent each node (call-number string, title string, next pointer).\n- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.\n- Menu option `4` is the only way to exit the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 1}, {"text": "# STEP 1: PROBLEM  \n**Topic:** Implementing Data Structures (Singly Linked Lists)\n\n## Background Story  \nThe tiny town of Bitville has only one bus route, but the stops change every week.  \nTo keep riders informed, the mayor wants a console program that can:  \n- Add a new stop anywhere on the route  \n- Remove the stop that is farthest from the depot (largest distance value)  \n- Print the entire route from first to last  \n\nBecause the route changes so often, a singly linked list is perfect: cheap insertions and deletions.\n\n## Requirements  \n1. Represent each bus stop with:  \n   - `id` (positive integer)  \n   - `name` (single-word string, \u226420 chars)  \n   - `distance` (integer kilometres from the depot, >0)  \n2. Maintain stops in a singly linked list in the exact order they are inserted (unless repositioned).  \n3. Support three user commands:  \n   - `ADD_AFTER id_new name distance prev_id`  \n     \u2013 Insert the new stop immediately after the stop whose id equals `prev_id`.  \n     \u2013 If `prev_id` is 0, insert at the front.  \n     \u2013 Print `Added` on success.  \n     \u2013 If `prev_id` does not exist, print `Invalid prev_id`.  \n   - `REMOVE_FARTHEST`  \n     \u2013 Delete the single stop with the largest `distance`.  \n     \u2013 If several stops tie for largest distance, remove the first one that appears in the list.  \n     \u2013 Print `Removed id name distance`.  \n     \u2013 If the list is empty, print `Empty route`.  \n   - `PRINT_ROUTE`  \n     \u2013 Print all stops in order, one per line: `id name distance`  \n     \u2013 If the list is empty, print `Route is empty`.  \n4. The program must loop until the user chooses option `0 EXIT`.\n\n## Simple Example (user input after `>`)  \n```\n> ADD_AFTER 1 Depot 0\nAdded\n> ADD_AFTER 2 Square 5 1\nAdded\n> ADD_AFTER 3 Beach 12 2\nAdded\n> ADD_AFTER 4 Park 7 2\nAdded\n> PRINT_ROUTE\n1 Depot 0\n2 Square 5\n4 Park 7\n3 Beach 12\n> REMOVE_FARTHEST\nRemoved 3 Beach 12\n> PRINT_ROUTE\n1 Depot 0\n2 Square 5\n4 Park 7\n> 0\n```  \nProgram terminates.\n\n## CONSTRAINTS  \n- Must use a `struct` to represent each bus stop (node).  \n- All list operations (insert, find, delete) must be implemented manually; STL containers are forbidden.  \n- The only functions allowed besides `main()` are:  \n  - `void addAfter(...)`  \n  - `void removeFarthest()`  \n  - `void printRoute()`", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 2}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just digitised its card-catalogue system.  \nEach \u201ccard\u201d is now a small record that contains a book\u2019s ID (a positive integer) and its title.  \nAll cards are kept in a singly linked list in **increasing order of ID**.  \nThe head librarian has hired you to write a tiny maintenance program that lets a clerk add a new card, remove an old one, or print the entire catalogue.  \nBecause the catalogue must always stay sorted by ID, every insertion has to preserve the order.\n\n## Precise Requirements\n1. Represent a card with two fields: `int id` and `string title`.\n2. Maintain the cards in a **singly linked list** whose nodes are always arranged in **strictly increasing order of ID**.\n3. Implement exactly three operations:\n   - `1` \u2013 Insert a new card (ID and title are supplied by the user).  \n     If an ID already exists, print `Duplicate ID` and leave the list unchanged.\n   - `2` \u2013 Remove the card with a given ID.  \n     If the ID is not found, print `ID not found`.\n   - `3` \u2013 Print the whole catalogue, one card per line in the format `ID: title`.\n4. Operation `0` exits the program (see CONSTRAINTS).\n\n## Simple Example\nInput\n```\n1 7 \"The Pragmatic Programmer\"\n1 3 \"Clean Code\"\n1 5 \"Design Patterns\"\n3\n2 7\n3\n0\n```\nOutput\n```\n3: Clean Code\n5: Design Patterns\n7: The Pragmatic Programmer\nID not found\n3: Clean Code\n5: Design Patterns\n```\n\n## CONSTRAINTS\n- Must use a `struct` to represent the primary data entity (a card/node).  \n- All list operations (insert, remove, print) must be implemented inside **one single user-defined function** besides `main()`; `main()` is only allowed to handle the menu loop and call that function.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 3}, {"text": "# STEP 1: PROBLEM\n\nBackground Story  \nThe campus bookstore keeps its bargain-bin inventory in a hand-written notebook. To modernize, the manager wants a tiny console program that records the titles in the exact order they arrive, but still allows \u201cfirst-in, first-out\u201d removal when books are sold. You will implement this simple inventory as a **singly linked list** where each node stores one book title.\n\nProgram Requirements  \n1. Represent every book with a node that has a title (C-string, \u2264 80 chars) and a *next* pointer.  \n2. Keep an external pointer to the **front** of the list.  \n3. Provide three operations that the user may repeat until they choose to quit:  \n   a. **enqueue** (add a book title to the **tail** of the list).  \n   b. **dequeue** (remove the book title from the **head** of the list and print it).  \n   c. **display** (print all titles from head to tail, one per line).  \n4. If the user tries to dequeue or display when the list is empty, print the exact message:  \n   `List is empty.`  \n5. All list operations must be implemented **manually** (no STL containers or built-in lists).  \n6. Free every allocated node before the program exits.\n\nExample Session (user input after prompt `>`)  \n```\n1\n> Learning C\n1\n> Data Structures\n2\nLearning C\n3\nData Structures\n4\n```\nOutput produced by the program:\n```\n1. Enqueue book\n2. Dequeue book\n3. Display books\n4. Exit\n1\nTitle: Learning C\n1. Enqueue book\n2. Dequeue book\n3. Display books\n4. Exit\n1\nTitle: Data Structures\n1. Enqueue book\n2. Dequeue book\n3. Display books\n4. Exit\n2\nSold: Learning C\n1. Enqueue book\n2. Dequeue book\n3. Display books\n4. Exit\n3\nData Structures\n1. Enqueue book\n2. Dequeue book\n3. Display books\n4. Exit\n4\n```\n\n### CONSTRAINTS  \n- Must use a `struct` named `Book` (or `Node`) to represent each list element.  \n- The logic for displaying the **entire** list must be placed in a function called `displayList`.  \n- The solution must be implemented with **only one additional function besides main()** (choose wisely).  \n- Menu option `4` is the **only** way to exit the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 4}, {"text": "# STEP 1: PROBLEM\n\n## Story  \nThe campus library\u2019s reference desk keeps its \u201cmost-asked-for\u201d bookmarks in a paper chain.  \nEach link in the chain contains a bookmark title and a reference count (how many times it was asked for).  \nTo stay within the desk\u2019s limited space, the librarian only wants the bookmarks that have been requested at least k times.  \nYour task is to model this paper chain with a singly linked list and then remove the \u201cunpopular\u201d bookmarks (those whose count < k).  \nThe popular ones must remain in their original relative order.\n\n## Requirements  \n1. Represent each link (node) with:  \n   - `title` \u2013 a C-style string (\u2264 100 characters)  \n   - `count` \u2013 an integer  \n   - `next` \u2013 a pointer to the next node  \n2. Provide the following operations:  \n   a. Insert a new bookmark at the **head** of the list.  \n   b. Remove all bookmarks whose `count` is **strictly less than** a user-supplied integer `k`.  \n   c. Display the current list from head to tail (one line per bookmark: `title,count`).  \n   d. Exit the program.  \n3. All operations must run on the same list instance that is created at start-up and modified in-place.  \n4. Memory allocated with `malloc()` must be freed before the program exits.\n\n## Example Session (user input shown after `>`)  \n```\n1> CS101,15\n1> Python,8\n1> C,4\n1> Java,12\n2> 10\n3>\nPython,8\nJava,12\nCS101,15\n4>\n```\n\n### CONSTRAINTS  \n- Must use a `struct` to represent the primary data entity (a node).  \n- The logic for displaying the details of ONE specific node must be in a function called `displayNode`.  \n- The solution must be implemented with a single function besides `main()`.  \n- If a menu is implemented, option `4` must EXIT the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 5}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just opened a \u201cTech-Checkout Station\u201d where students can borrow one of 20 identical Wi-Fi hotspots.  \nTo keep track of which hotspot is currently checked-out to which student, the station needs a tiny inventory system that stores the hotspot-ID and the borrower\u2019s name in the order they were borrowed.  \nYou will build this inventory as a **singly linked list** that grows when hotspots are loaned out and shrinks when they are returned.\n\n## Requirements\n1. Each hotspot record holds:\n   - a unique 4-digit ID (int)\n   - the borrower\u2019s first name (\u226420 characters, no spaces)\n2. The program keeps the records in a **singly linked list** whose head pointer is always the most-recently borrowed item.\n3. The program must support exactly three commands from a menu:\n   ```\n   1 Borrow\n   2 Return\n   3 Exit\n   ```\n4. \u201cBorrow\u201d (`1`):\n   - Read an ID and a name.\n   - If the ID is already in the list, print \u201cID already borrowed.\u201d and do nothing.\n   - Otherwise add a new node at the **head** of the list and print \u201cBorrowed.\u201d\n5. \u201cReturn\u201d (`2`):\n   - Read an ID.\n   - If the ID exists, remove that node (keep the others in the same order) and print \u201cReturned.\u201d\n   - Otherwise print \u201cID not found.\u201d\n6. After every command, print the current list in order from most-recently borrowed to least-recently borrowed, one record per line: `ID name`\n7. The program must terminate **only** when the user chooses menu option `3`.\n\n## Simple Example\nInput\n```\n1 1001 Alice\n1 1002 Bob\n2 1001\n3\n```\nOutput\n```\nBorrowed.\n1002 Bob\n1001 Alice\nBorrowed.\n1002 Bob\n1001 Alice\nReturned.\n1002 Bob\n```\n(Program exits after the final \u201c3\u201d.)\n\n### CONSTRAINTS\n- You **must** use a `struct` to represent each list node.\n- All list operations (insert, delete, display) must be implemented **recursively**; no loops are allowed in any function that touches the nodes.\n- The entire solution must be written with **only two user-defined functions** besides `main()`:  \n  \u2013 one that performs **all** recursive insert/delete operations, and  \n  \u2013 one that performs the **recursive** display of the list.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 6}, {"text": "# STEP 1: PROBLEM\n\n## Context\nThe campus library is digitizing its card-catalog system.  \nEach book is represented by an old-fashioned \u201ccatalog card\u201d that contains only three pieces of information:  \n- a unique call-number (an integer)  \n- the book\u2019s title (a string, \u2264100 chars)  \n- a pointer to the next card in the drawer  \n\nThe librarian wants a tiny demo that keeps the cards in call-number order and supports a few quick operations.  \nYou will implement the drawer as a **singly linked list** of catalog cards.\n\n## Functional Requirements\n1. Insert a new catalog card **in ascending order** by call-number.  \n2. Search for a book by call-number and display its title (or \u201cNot found\u201d).  \n3. Remove a catalog card by call-number.  \n4. Display the entire drawer in order, one card per line:  \n   `call-number: title`  \n5. Provide a menu-driven interface with the following choices:  \n   1. Insert  \n   2. Search  \n   3. Remove  \n   4. Display  \n   5. Exit  \n\n## Simple Example Run\n```\n=== Library Catalog Demo ===\n1. Insert\n2. Search\n3. Remove\n4. Display\n5. Exit\nChoice: 1\nCall-number: 42\nTitle: Hitchhiker's Guide\nChoice: 1\nCall-number: 7\nTitle: Harry Potter\nChoice: 4\n7: Harry Potter\n42: Hitchhiker's Guide\nChoice: 2\nCall-number: 7\nFound: Harry Potter\nChoice: 5\nGoodbye!\n```\n\n### CONSTRAINTS\n- Must use a `struct` named `CatalogCard` to represent the primary data entity.  \n- Logic for displaying the details of ONE specific entity must be in a function called `displayCard`.  \n- The only functions allowed are `main()` and `displayCard()`; all list operations must be handled inline inside `main()`.  \n- Menu option `5` must EXIT the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 7}, {"text": "# STEP 1: PROBLEM\n\n## Context\nThe campus library has a tiny help\u2013desk bell that rings every time a book is returned.  \nTo keep track of the order in which books are returned (and therefore who is next in the \u201cfirst-come, first-served\u201d hold queue), the librarian asks you to build an electronic log.  \nYou decide to model the log as a singly linked list where each node stores one book ID (a positive integer).  \nBooks are always added to the tail of the list (they arrive in time order) and removed from the head (the next book to be processed).\n\n## Requirements\n1. Represent the log as a singly linked list of book IDs.\n2. Provide a console menu with exactly four choices:\n   1. Ring bell & return book (adds a new ID to the tail)  \n   2. Process next hold (removes and displays the ID at the head)  \n   3. Display current queue (prints every ID from head to tail, space-separated on one line)  \n   4. Exit  \n3. If the user tries to process a hold when the queue is empty, print `Queue empty` instead of a book ID.\n4. All dynamic memory must be freed before the program exits.\n\n## Simple Example Run\n```\n1\n101\n1\n102\n1\n103\n3\n101 102 103\n2\nProcessed: 101\n3\n102 103\n4\n```\n\n### CONSTRAINTS\n- You must use a `struct` to represent each node of the linked list.  \n- All list operations (insert at tail, delete from head, display queue) must be performed by a **single helper function** besides `main()`.  \n- The menu option to EXIT the program is number **4**.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 8}, {"text": "# STEP 1: PROBLEM\n\n**Background Story**  \nThe campus library has installed a new book-drop slot that only works in \u201clast-in, first-out\u201d order.  \nTo keep things fair, the head librarian wants a tiny piece of software that records the exact order in which books are dropped and can tell her, at any moment, which book is currently on the top of the stack (the one that will be picked up first).  \nYour task is to model this book-drop slot as a singly linked list that always grows at the front (like a stack) and never has to delete anything\u2014only insert and inspect.\n\n**Functional Requirements**  \n1. Represent each book with two data members:  \n   - a unique integer ID (1\u20131000)  \n   - a title string (up to 50 characters, no spaces)  \n2. Provide an interactive menu with the following choices:  \n   1) Drop a new book (insert at the front)  \n   2) See the top book (display the head node only)  \n   3) List every book currently in the slot (from most-recent to oldest)  \n   4) Exit  \n3. After every successful operation, print a short confirmation message.  \n4. If the user tries to see the top book or list books when the slot is empty, print \u201cSlot is empty.\u201d\n\n**Simple Example Run**  \n```\n1) Drop 2) Top 3) List 4) Exit\nChoice: 1\nEnter ID: 42\nTitle: CleanCode\nBook 42 dropped.\n\n1) Drop 2) Top 3) List 4) Exit\nChoice: 1\nEnter ID: 7\nTitle: PragProg\nBook 7 dropped.\n\n1) Drop 2) Top 3) List 4) Exit\nChoice: 2\nTop book: 7 PragProg\n\n1) Drop 2) Top 3) List 4) Exit\nChoice: 3\n7 PragProg\n42 CleanCode\n\n1) Drop 2) Top 3) List 4) Exit\nChoice: 4\nGood-bye!\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent the primary data entity (a book node).  \n- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.  \n- The solution must be implemented with a single function besides `main()`.  \n- Menu option 4 is the required EXIT keyword.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 9}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou are helping the campus music club manage their vinyl-record lending shelf.  \nEach record is stored in a sleeve that has a unique catalog number (an integer) and the album\u2019s title (a string).  \nAll sleeves are kept in a single chain\u2014like a singly linked list\u2014hung on a wall.  \nMembers can:  \n- add a new record to the front of the chain,  \n- remove a record by catalog number,  \n- search for a record by catalog number, and  \n- print the entire chain in order.  \n\nYour task is to write the tiny library system that the club volunteers will run from a simple text menu.\n\n## Functional Requirements\n1. Represent each record with a catalog number (int) and album title (string).  \n2. Store the collection as a singly linked list whose nodes are dynamically allocated.  \n3. Provide a text menu with four numbered operations:  \n   1) Add a record  \n   2) Remove a record  \n   3) Search for a record  \n   4) Print all records  \n   5) Exit  \n4. \u201cAdd\u201d inserts at the head of the list.  \n5. \u201cRemove\u201d deletes the first node with the given catalog number; if none exists, print \u201cNot found.\u201d  \n6. \u201cSearch\u201d prints the catalog number and title if found; otherwise print \u201cNot found.\u201d  \n7. \u201cPrint all\u201d displays every record in the list, one per line, in the format  \n   `<catalog #>: <album title>`  \n   or print \u201cEmpty shelf.\u201d if the list is empty.  \n8. After every operation (except Exit), re-display the menu.  \n9. No global variables except for the head pointer, which must be declared in main().  \n\n## Simple Example Run (user input after `>`)\n```\n1\n> 12345\n> Kind of Blue\n1\n> 12346\n> A Love Supreme\n4\n12346: A Love Supreme\n12345: Kind of Blue\n3\n> 12345\n12345: Kind of Blue\n2\n> 12346\n4\n12345: Kind of Blue\n5\n```\n\n### CONSTRAINTS\n- You must define a `struct` to represent each node (record).  \n- All list operations (add, remove, search, print) must be implemented as exactly four standalone functions besides `main()`.  \n- The only functions allowed in your source file are: `main()`, `addRecord()`, `removeRecord()`, `searchRecord()`, `printRecords()`.  \n- Menu option 5 is the only way to exit; the program must terminate cleanly with return code 0.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 10}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just opened a 24-hour self-service kiosk where students can borrow and return books without staff present.  \nTo keep track of which books are currently on the shelf, the kiosk needs a tiny in-memory inventory system that uses a **singly linked list**.  \nEach book is identified only by its (unique) ISBN string.  \nYour task is to write the kiosk\u2019s brain: a console program that lets a student add a book (when it is returned) and remove a book (when it is borrowed) in O(1) time at the head of the list.\n\n## Requirements\n1. Represent the inventory as a singly linked list of books.\n2. Support two commands:\n   - `ADD <ISBN>` \u2013 insert the book at the head of the list.\n   - `BORROW <ISBN>` \u2013 remove the first occurrence of that ISBN (starting from the head) and print `Removed <ISBN>`; if the ISBN is not found, print `Not found`.\n3. After every command, print the current inventory in order from head to tail, one ISBN per line, followed by a line containing only `---`.\n4. The program terminates when the user enters the keyword `EXIT`.\n\n## Simple Example\n### Input\n```\nADD 9780131103627\nADD 9780201633610\nBORROW 9780131103627\nBORROW 9780000000000\nEXIT\n```\n\n### Expected Output\n```\n9780131103627\n---\n9780201633610\n9780131103627\n---\nRemoved 9780131103627\n9780201633610\n---\nNot found\n9780201633610\n---\n```\n\n### CONSTRAINTS\n- You must use a `struct` to represent a book node.  \n- All list operations (add, remove, display) must be implemented in a single user-defined function called `processCommand` besides `main()`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 11}, {"text": "# STEP 1: PROBLEM\n\n## Topic: Implementing Data Structures (e.g., Singly Linked Lists)\n\n### Background Story\nYou are helping a local library digitise its small\u2010 magazine collection. Each magazine has a unique 4\u2010digit ID and a title. The librarian wants a tiny console program that can add a new magazine to the front of the list, show the whole list, and exit.\n\n### Requirements\n1. Represent each magazine as a node in a singly linked list.  \n2. Provide a console menu with two options:  \n   1) Add new magazine  \n   2) Exit  \n3. When the user chooses \u201cAdd\u201d, the program must insert the new magazine at the **head** of the list and print the updated list.  \n4. When the user chooses \u201cExit\u201d, the program must print the full list once more and terminate.\n\n### Example Input/Output\n```\n1\n1234\nNew Yorker\n1\n5678\nTime\n2\n5678 Time 1234 New Yorker\n```\n\n### CONSTRAINTS\n- The magazine must be stored as a struct with two fields: an integer id and a string title.  \n- The list must be implemented as a singly linked list.  \n- The program must use a menu option 2 to exit.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 12}, {"text": "# STEP 1: PROBLEM\n\nContext  \nYou are the last\u2011minute substitute TA for \u201cCSC 152: Intro to Machine Org.\u201d The instructor left a flash drive containing every student\u2019s grade history as a plain text log of integer scores. Your task is to write a tiny emergency tool that rebuilds the log as a singly linked list so the registrar can append or query grades even if the drive is unplugged.\n\nProblem  \nWrite a console program that\n\n 1. starts with an empty singes\u2011linked list whose nodes hold one int (the grade);\n 2. supports three commands:\n      insert  <grade>     \u2192 append grade to tail  \n      print               \u2192 display entire list  \n      exit                \u2192 quit\n\nThe program must keep the list alive until exit.\n\nInput / Output  \nSample session  \ninsert 73  \ninsert 81  \nprint  \n81  \n73  \ninsert 90  \nprint  \n90  \n81  \nexit  \n\n### CONSTRAINTS  \n1. You must define a struct GradeNode.  \n2. Logic for displaying the list must be in a function displayEntity().  \n3. You must implement only one function besides main().", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 13}, {"text": "# STEP 1: PROBLEM\n\n## Context\nThe campus library is digitising its CD-audio collection.  \nEach CD has a unique 6-digit ID, a title, and the number of tracks.  \nYour task is to write a tiny cataloguing system that keeps these CDs in **the exact order they were inserted** (i.e. a singly linked list with *append-only* behaviour).  \nLibrarians should be able to add a new CD, list every CD currently stored, or exit the program.\n\n## Functional Requirements\n1. Represent a CD with the attributes:\n   - `id` (positive 6-digit integer)\n   - `title` (single-word string, \u226430 characters)\n   - `tracks` (positive integer)\n2. Maintain a singly linked list that always appends new CDs at the end.\n3. Implement a console menu with the following options:\n   1. Add a new CD  \n   2. List all CDs  \n   3. Exit  \n4. If the user tries to add a CD whose ID already exists anywhere in the list, refuse the insertion and print `Duplicate ID`.\n5. Listing must show every CD on a single line in the format:  \n   `<id>: <title> (<tracks> tracks)`  \n   (one CD per line, in insertion order).\n\n## Simple Example\nInput\n```\n1\n123456\nMozart25\n8\n1\n123457\nBeethoven5\n4\n2\n3\n```\nOutput\n```\n123456: Mozart25 (8 tracks)\n123457: Beethoven5 (4 tracks)\n```\n\n## CONSTRAINTS\n- You must define a `struct` called `CD` to represent the primary data entity.  \n- All code (except `main`) must be encapsulated in **exactly one additional function**; that function must be named `menu`.  \n- Menu option `3` must immediately terminate the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 14}, {"text": "# STEP 1: PROBLEM\n\n## Context\nYou are helping the campus music club manage the queue for their weekly open-mic night. Musicians add their names to a waiting list that is processed in strict first-come-first-served order. To keep things digital, the club wants a tiny command-line program that uses a **singly linked list** to maintain the waiting list and lets them add performers, call the next performer to the stage, and print the current queue at any moment.\n\n## Requirements\n1. Provide a text menu with three choices:\n   1) Add performer  \n   2) Call next performer  \n   3) Exit  \n2. \"Add performer\" reads a single name (no spaces) and appends it to the end of the queue.  \n3. \"Call next performer\" removes the front node and prints \"Now on stage: <name>\".  \n4. If the queue is empty and the user tries to call the next performer, print \"Queue is empty - no performers waiting.\"  \n5. After every operation (except exit) re-display the menu.  \n6. On exit, release all dynamically allocated memory.\n\n## Example Session\n```\n1) Add performer\n2) Call next performer\n3) Exit\nChoice: 1\nName: Alice\n1) Add performer\n2) Call next performer\n3) Exit\nChoice: 1\nName: Bob\n1) Add performer\n2) Call next performer\n3) Exit\nChoice: 2\nNow on stage: Alice\n1) Add performer\n2) Call next performer\n3) Exit\nChoice: 3\nGoodbye!\n```\n\n### CONSTRAINTS\n- Use a `struct` to represent each performer (node).  \n- All list operations (insert at tail, delete from head, and printing) must be implemented in functions other than `main()`.  \n- The menu option to EXIT the program is option `3`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 15}, {"text": "# STEP 1: PROBLEM\n\n**Background Story**  \nThe campus library is digitizing its help-desk ticket system. Every time a student has a question, a new \u201cticket\u201d is created. The tickets must be kept in the exact order they arrive, but staff need to be able to:  \n- add a ticket to the end of the queue,  \n- remove the first ticket when it is answered, and  \n- display the current queue at any moment.  \n\nYou will implement the queue as a **singly linked list** whose nodes hold the ticket ID (a positive integer) and the student\u2019s question (a short string).\n\n**Precise Functional Requirements**  \n1. Represent each ticket with a node that stores:  \n   - an `int ticketID`  \n   - a `char question[60]`  \n   - a pointer to the next node.  \n2. Maintain two global pointers:  \n   - `front` \u2013 points to the head of the list (oldest unanswered ticket).  \n   - `rear` \u2013 points to the tail of the list (newest ticket).  \n3. Provide exactly three user operations triggered by a console menu:  \n   1. Add a new ticket (read ID and question; append to rear).  \n   2. Answer the next ticket (remove from front and print its details).  \n   3. Display the current queue (print every ticket ID and question in order).  \n   4. Exit the program.  \n4. After every operation, re-display the menu unless the user chose Exit.  \n5. Handle underflow gracefully: if the queue is empty and the user chooses \u201cAnswer,\u201d print `Queue empty` and redisplay the menu.  \n6. Do **not** use arrays or any STL containers; the queue must be managed with your linked-list nodes.\n\n**Simple Example Run**  \n```\n=== Library Help-Desk Ticket System ===\n1. Add ticket\n2. Answer ticket\n3. Display queue\n4. Exit\nChoice: 1\nEnter ticket ID: 101\nEnter question: How do I print double-sided?\nTicket added.\n\n1. Add ticket\n2. Answer ticket\n3. Display queue\n4. Exit\nChoice: 1\nEnter ticket ID: 102\nEnter question: Where is the quiet zone?\nTicket added.\n\n1. Add ticket\n2. Answer ticket\n3. Display queue\n4. Exit\nChoice: 3\nQueue:\n101 How do I print double-sided?\n102 Where is the quiet zone?\n\n1. Add ticket\n2. Answer ticket\n3. Display queue\n4. Exit\nChoice: 2\nAnswered ticket 101: How do I print double-sided?\n\n1. Add ticket\n2. Answer ticket\n3. Display queue\n4. Exit\nChoice: 4\nGood-bye!\n```\n\n### CONSTRAINTS  \n- Must use a `struct` to represent the primary data entity (the ticket node).  \n- Logic for displaying the details of ONE specific ticket must be in a function called `displayTicket`.  \n- The solution must be implemented with a single function besides `main()` (you may have as many helper functions as you like, but only one additional \u201cmajor\u201d function besides `main`).  \n- Menu option 4 is the only way to exit the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 16}, {"text": "# STEP 1: PROBLEM  \n## Background  \nThe campus library has installed a new self-checkout kiosk. Instead of scanning bar-codes, the kiosk keeps a running list of book IDs (positive integers) in the order they are checked out. After each checkout, the kiosk must:  \n1. Print the complete current list (in order) so the patron can verify it.  \n2. Be able to remove the most-recently-added book if the patron changes their mind.  \n\n## Requirements  \nYour task is to implement the kiosk\u2019s memory as a singly linked list of book IDs.  \nProvide these operations:  \n- `addBook(id)` \u2013 append a new book ID to the end of the list.  \n- `removeLast()` \u2013 delete the last added ID (if the list is empty, do nothing).  \n- `displayList()` \u2013 print the entire list in the order the books were added, one ID per line.  \n\n## Input/Output Format  \nThe program reads commands from standard input until the user types `exit`.  \nCommands:  \n- `add <id>` \u2013 call `addBook` with the given positive integer `<id>`.  \n- `remove` \u2013 call `removeLast`.  \n- `display` \u2013 call `displayList`.  \n- `exit` \u2013 terminate the program (must be option 0 if a menu is used).  \n\n### Simple Example  \nInput  \n```\nadd 101\ndisplay\nadd 102\nadd 103\nremove\ndisplay\nexit\n```  \nOutput  \n```\n101\n101\n102\n```\n\n### CONSTRAINTS  \n1. Must use a `struct` named `BookNode` to represent each node.  \n2. Logic for printing the entire list must be in a function called `displayList`.  \n3. The solution must be implemented with **only one** function besides `main()` (i.e., `displayList` is that function; all other logic may be placed inline in `main`).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 17}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has a small \u201cTake-One-Leave-One\u201d book crate that works only through a *last-in, first-out* rule: when a student donates a book, it is placed on the *top* of the pile; the next student who wants a free book must take the one that is currently on top.  \nTo keep track of the crate without arrays (because the crate can grow or shrink unpredictably), the librarian asks you to build a tiny digital ledger that remembers the titles in the exact order they were donated.\n\n## Requirements\nYour program must:\n1. Represent every donated book as a node in a **singly linked list**.\n2. Provide a menu-driven interface that lets the librarian repeatedly choose one of the following actions:\n   - `1` Donate a book (push title on the top of the pile)\n   - `2` Lend a book (pop title from the top of the pile and show it)\n   - `3` Peek at the top book (show its title without removing it)\n   - `4` Print the entire pile from top to bottom (one title per line)\n   - `0` Exit the program\n3. After every operation, automatically return to the menu until the user chooses `0`.\n4. If the crate is empty and the librarian tries to lend or peek, print:\n   ```\n   Crate is empty!\n   ```\n\n## Simple Example of Expected Input/Output\n```\n=== Book-Crate Ledger ===\n1 Donate\n2 Lend\n3 Peek\n4 Show all\n0 Exit\nChoice: 1\nTitle: Clean Code\nChoice: 1\nTitle: The Pragmatic Programmer\nChoice: 3\nTop book: The Pragmatic Programmer\nChoice: 2\nLent: The Pragmatic Programmer\nChoice: 4\nClean Code\nChoice: 0\nGood-bye!\n```\n\n### CONSTRAINTS\n- You must define a `struct` named `Book` to represent each node (it needs at least a title and a pointer to the next book).\n- All list manipulation (push, pop, peek, print) must be performed by **a single helper function** you write yourself, called `listOp()`, which takes an integer operation code and any other parameters it needs.  \n  *No other user-defined function besides* `main()` *and* `listOp()` *is allowed.*", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 18}, {"text": "# STEP 1: PROBLEM\n\n## Story\nThe tiny town of Byteville has only one public library, and it still keeps its book inventory on paper cards.  \nThe head librarian, Ms. Ada, has hired you to digitize the card catalogue.  \nFor now she only wants to keep the books in the order they were added, but she must be able to:\n\n- add a new book to the end of the catalogue,  \n- remove a book by its unique shelf-id (a positive integer),  \n- list every book currently on file, and  \n- quit the program when she is done for the day.\n\nBecause the collection is small, a singly-linked list is perfect for the job.\n\n## Requirements\n1. Represent each book with a struct that contains:\n   - shelf-id (positive int, unique across the catalogue)  \n   - title (string, no commas)  \n   - author (string, no commas)  \n   - pointer to next book (or NULL if last)\n2. Maintain the list in \u201carrival order\u201d (new books appended at the tail).\n3. Implement exactly four user commands:\n   - `add` \u2013 read one line \u201cshelf-id title author\u201d and append the book.  \n   - `remove` \u2013 read one integer (shelf-id) and delete that book if it exists; print \u201cRemoved\u201d or \u201cNot found\u201d.  \n   - `list` \u2013 print the entire catalogue, one book per line, in the format \u201cshelf-id) Title by Author\u201d.  \n   - `exit` \u2013 free all dynamically allocated memory and terminate the program.\n4. All list operations must be performed by manipulating the linked nodes; no arrays or STL containers.\n5. The program must keep running until the user types `exit`.\n\n## Simple Example\n**Input**\n```\nadd 42 HitchhikersGuide DouglasAdams\nadd 7 GEB Hofstadter\nlist\nremove 42\nremove 99\nexit\n```\n\n**Expected Output**\n```\n42) HitchhikersGuide by DouglasAdams\n7) GEB by Hofstadter\nRemoved\nNot found\n```\n\n### CONSTRAINTS\n- You must use a single struct called `Book` to represent each node.  \n- All dynamic memory (malloc/new) must be released before the program exits.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 19}, {"text": "# STEP 1: PROBLEM  \n**Topic:** Implementing a Singly Linked List  \n\n**Background Story**  \nYou are helping the campus library automate its waiting list for newly\u2013arrived books. Every time a student wants a book that is still \u201cin transit\u201d, the student is added to a queue. When the book arrives, the first student in the queue is notified and removed. You will implement this queue as a singly linked list.\n\n**Requirements**  \n1. Each node stores a student ID (integer) and a next pointer.  \n2. Provide the following operations:  \n   - `enqueue(id)` \u2013 add a new student to the tail of the list.  \n   - `dequeue()` \u2013 remove the student at the head and return the ID.  \n   - `display()` \u2013 print the entire list from head to tail, space-separated.  \n3. A menu must keep running until the user chooses to exit.  \n4. All memory must be dynamically allocated and freed before the program ends.\n\n**Example Interaction**  \nInput  \n```\n1 101\n1 102\n1 103\n2\n3\n4\n```\nOutput  \n```\n101 102 103  \n102  \n102 103  \n```\n### CONSTRAINTS  \n- Implement queue logic only with a singly linked list.  \n- Must use a struct to represent each node.  \n- No global variables allowed.  \n- The menu must offer option 4 to EXIT.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 20}, {"text": "# STEP 1: PROBLEM  \nTopic: Implementing a Singly Linked List  \n\nStory  \nYou are the TA for a course whose professor keeps losing the grade sheet.  The professor wants a tiny \u201cGrade Sheet\u201d program that stores nothing more than the student\u2019s ID (an int) and the grade (a char: A \u2026 F).  The program must be able to insert a new grade at the head, delete one grade, print the entire list, and exit.\n\nRequirements  \n1. Represent one grade as a struct with two members: int id; char grade;  \n2. Keep all grades in a singly linked list.  \n3. Provide exactly four menu choices:  \n   1 insert  2 delete  3 print  4 exit  \n4. insert must add the new grade at the head of the list.  \n5. delete must remove the first node with a matching id (if any).  \n6. print must display every node as \u201cid grade\u201d on one line.  \n7. After every command the program returns to the menu; choice 4 ends the program.\n\nExample Input / Output  \nInput  \n1 101 A  3  1 102 B  3  4  \n\nOutput  \n1 A  3  \n1 A  3  \n\nCONSTRAINTS  \nThe solution must be implemented with a single function besides main().", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 21}, {"text": "# STEP 1: PROBLEM  \nTopic: Implementing Data Structures (e.g., Singly Linked Lists)\n\nYou are a Computer Science professor designing an undergraduate curriculum.  \nGenerate a novel programming problem on Implementing Data Structures (e.g., Singly Linked Lists). Your response must begin with the header # STEP 1: PROBLEM.  \nThe problem statement must be clear, unambiguous, and suitable for a student who has just learned this topic.  \nRequirements:  \n1. Clear background story or context.  \n2. A precise list of requirements for the program's functionality.  \n3. Simple Example of expected Input/Output.  \n4. Additional constraints such as 'Must use a 'struct' to represent the primary data entity.', 'Logic for displaying the details of ONE specific entity must be in a function called 'displayEntity'.' or 'The solution must be implemented with a single function besides main()'. The constraint(s) should be listed under the header ### CONSTRAINTS.  \n4. MANDATORY CONSTRAINTS IF A MENU IS IMPLEMENTED:  \n   - Must include a specific menu option to EXIT the program (clearly state the number or keyword).\n\n---\n\n# STEP 1: PROBLEM\n\nContext  \nYou are a teaching assistant helping a student who has just learned about singly linked lists.  \nWrite a small program that stores a list of positive integers and allows the user to insert, delete, and display the elements.\n\nBackground story  \nA local bakery wants to record the temperature (in \u00b0C) of its ovens every minute.  \nThe temperatures are always positive integers and are stored in a sing singly linked list.\n\nPrecise requirements  \n1. Define a struct Node containing an integer value and a pointer to the next node.  \n2. Implement the following menu options:  \n   - insert at the end  \n   - delete a value  \n   - display the list  \n   - exit  \n3. The program must keep the list in ascending order at all times.  \n4. After each operation, display the updated list.  \n5. The program must be implemented using only one function besides main().\n\nSimple Example Input/Output  \nInput:  \n1 10  \n1 20  \n1 30  \n2 25  \n3  \n4  \n\nOutput:  \n10 20 30  \n25 30  \n\n### CONSTRAINTS  \n- Must use a struct to represent the primary data entity.  \n- Logic for displaying the details of ONE specific entity must be in a function called displayEntity.  \n- The solution must be implemented with a single function besides main().", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 22}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library is digitizing its old card-catalog.  \nEach card contains a book\u2019s ID (a positive integer) and its title.  \nYour task is to write a tiny catalog that keeps the cards in **ascending order of ID** and supports quick insertions, deletions, and look-ups.\n\n## Requirements\n1. Represent each card with a struct named `Card` that stores:\n   - `int id`\n   - `char title[60]`\n   - `Card *next`\n2. Maintain the cards in a **singly linked list** sorted by `id`.\n3. Implement exactly **one helper function** (besides `main`):\n   - `Card *insertCard(Card *head, int id, const char *title)`  \n     - If `id` already exists, update the title and return the head unchanged.\n     - Otherwise insert the new card in the correct position and return the new head.\n4. Inside `main`, repeatedly read commands from standard input until the user chooses to exit:\n   - `1 id title` : insert/update a card\n   - `2 id`      : delete the card with that id (ignore if not found)\n   - `3`         : print the entire catalog, one card per line in the format `id: title`\n   - `0`         : EXIT the program (guaranteed to be called at least once)\n\n## Simple Example\nInput\n```\n1 7 PrideAndPrejudice\n1 3 Hamlet\n1 5 Odyssey\n3\n2 5\n3\n0\n```\nOutput\n```\n3: Hamlet\n5: Odyssey\n7: PrideAndPrejudice\n3: Hamlet\n7: PrideAndPrejudice\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent the primary data entity (`Card`).\n- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 23}, {"text": "# STEP 1: PROBLEM  \n**Topic:** Implementing a Singly Linked List  \n\n**Background Story:**  \nThe campus library has asked you to write a tiny program that keeps track of the next book they will process for digitization. Each book is added to a \u201cqueue\u201d (really a list) and is removed from the front when the librarian clicks \u201cprocess.\u201d Because the collection is small, the library wants the simplest possible structure\u2014no arrays, no STL containers\u2014just a classic hand-rolled singly linked list.\n\n**Requirements (what your program must do):**  \n1. Represent each book with a node that stores:  \n   - an integer id (unique, > 0)  \n   - a string title  \n   - a pointer to the next node  \n2. Maintain the list in **strict ascending order by id**.  \n3. Support exactly three user commands from a console menu:  \n   1. `add` \u2013 read an id and title, insert a new node in the correct ordered position.  \n   2. `process` \u2013 remove and print the *smallest-id* node (the head).  \n   3. `exit` \u2013 free all remaining nodes and terminate the program.  \n4. After every successful `add` or `process`, print the updated list as a single space-separated sequence of ids (or \u201cempty\u201d if none).  \n5. Reject duplicate ids with the message \u201cduplicate id\u201d and leave the list unchanged.\n\n**Simple Example Run (user input shown after the prompt `>`):**  \n```\n> add 5 Pride\n5\n> add 2 Sense\n2 5\n> add 7 Magic\n2 5 7\n> process\nprocessing 2\n5 7\n> add 5\nduplicate id\n5 7\n> exit\n```\n\n### CONSTRAINTS  \n- You must define the node with a `struct`.  \n- All list operations (insert ordered, remove head) must be implemented in **one single function** besides `main()`.  \n- The menu option to EXIT the program is the number `3`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 24}, {"text": "# STEP 1: PROBLEM  \n## Background  \nThe campus library is digitising its old card-catalogue. Each index card contains a single book title and the next card\u2019s drawer number (a non-negative int). Your job is to write a tiny program that lets the librarian keep the catalogue in memory as a **singly linked list** of these cards.  \n\n## Requirements  \n1. Represent each \u201ccard\u201d with a node that stores:  \n   - a string (the book title)  \n   - an integer (the drawer number of the next card, \u20131 if this card is the last one)  \n2. Maintain the list in **ascending order of drawer numbers** (ties keep insertion order).  \n3. Provide an interactive menu with the following choices:  \n   1. Add a new card  \n   2. Remove the card with a given drawer number  \n   3. Display the full catalogue (one card per line: `title drawer#`)  \n   4. Count how many cards are currently stored  \n   5. Exit  \n4. After every successful Add or Remove, print the updated count.  \n5. All list operations must be performed **in-place**; no arrays or STL containers.  \n\n## Simple Example  \nInput  \n```\n1\nPride and Prejudice\n7\n1\nThe Hobbit\n3\n1\nDune\n5\n3\n2\n3\n5\n```  \nOutput  \n```\nAdded. Total cards: 1\nAdded. Total cards: 2\nAdded. Total cards: 3\nDune 3\nPride and Prejudice 5\nThe Hobbit 7\nRemoved. Total cards: 2\n```  \n\n### CONSTRAINTS  \n- Must use a `struct Card` to represent each node.  \n- The only functions allowed besides `main()` are:  \n  - `void addCard(string title, int drawer)`  \n  - `void removeCard(int drawer)`  \n  - `void displayCatalogue()`  \n  - `int cardCount()`  \n- Menu option **5** must terminate the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 25}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just opened a new \u201cTech-to-Lend\u201d kiosk that loans out small electronic gadgets (e.g., noise-canceling headphones, phone chargers, tablets) to students for up to 24 h.  \nTo keep the inventory simple, the librarian keeps all gadgets in a single chain (a singly-linked list) in the order they were donated.  \nYour task is to write a tiny inventory program that lets the librarian add a new gadget, show the full current list, or search for a gadget by its ID number.\n\n## Requirements\n1. Represent each gadget with:  \n   - `int id` \u2013 unique 4-digit identifier (1000\u20139999)  \n   - `char name[32]` \u2013 short description (e.g., \u201cHeadphones-Sony\u201d)  \n   - `int qty` \u2013 how many identical units are available  \n2. Maintain the gadgets in a singly-linked list in the order they were added.  \n3. Implement a text menu with three options (and a fourth to exit):  \n   1. Add new gadget  \n   2. Display entire inventory  \n   3. Search gadget by ID  \n   4. Exit  \n4. On \u201cSearch\u201d, print the first matching gadget\u2019s details or \u201cNot found.\u201d  \n5. Do not use any STL or Java collections; implement your own nodes.\n\n## Example Session\n```\n1. Add new gadget\n2. Display inventory\n3. Search gadget by ID\n4. Exit\nChoice: 1\nEnter ID: 1001\nEnter name: Headphones-Sony\nEnter quantity: 5\nGadget added.\n\nChoice: 1\nEnter ID: 1005\nEnter name: Charger-USB-C\nEnter quantity: 3\nGadget added.\n\nChoice: 3\nEnter ID to search: 1005\nID: 1005  Name: Charger-USB-C  Qty: 3\n\nChoice: 3\nEnter ID to search: 9999\nNot found.\n\nChoice: 4\nGood-bye!\n```\n\n### CONSTRAINTS\n- You must define a `struct Node` that contains the gadget data and a pointer to the next node.  \n- The logic that prints the details of exactly one gadget must be placed in a function called `displayEntity()`.  \n- The entire solution must be implemented with only one additional function besides `main()` (you may use `displayEntity()` and any helper functions you need, but the core list operations must be handled inside `main()`).  \n- The menu option to exit the program is option number 4.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 26}, {"text": "# STEP 1: PROBLEM\n\n**Context**  \nThe campus library has replaced its old card\u2013catalog drawers with a tiny Raspberry Pi-powered kiosk that only understands text commands. The head librarian has hired you to write the backend that stores the current list of \u201covernight-loan\u201d books. Because the kiosk has very little memory, the library wants the list stored as a singly linked list that is kept in alphabetical order by title at all times (i.e., inserts must maintain order). No arrays or STL/Boost containers may be used.\n\n**Required Functionality**  \n1. Start with an empty list.  \n2. Repeatedly read single-letter commands from `cin` until the user types `X` (uppercase) to exit.  \n3. Command \u201cA\u201d (Add): read one book title (possibly containing spaces) and insert it into the list so that titles stay in strictly ascending alphabetical order.  \n   - If the title is already present, silently ignore the request (no duplicates).  \n4. Command \u201cR\u201d (Remove): read one book title and delete the first matching node if it exists; if the title is not found, do nothing.  \n5. Command \u201cP\u201d (Print): output every title in order, one per line, preceded by \u201cCatalog:\u201d. If the catalog is empty, output only the line \u201cCatalog: empty\u201d.  \n6. Command \u201cC\u201d (Count): print the total number of distinct titles currently stored.  \n7. All dynamic memory must be released before the program exits.\n\n**Simple Example Run**  \nInput  \n```\nA The Great Gatsby\nA Animal Farm\nP\nR The Great Gatsby\nC\nX\n```\nOutput  \n```\nCatalog:\nAnimal Farm\nThe Great Gatsby\n1\n```\n\n### CONSTRAINTS  \n- You must use a `struct` called `BookNode` to represent each node of the list.  \n- All list operations (insert, delete, print, count) must be implemented inside **one single user-defined function** besides `main()`; give that function the prototype  \n  `void processCommand(char cmd, std::istream& in, BookNode*& head);`  \n- The program must terminate when the user enters the menu option `X`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 27}, {"text": "# STEP 1: PROBLEM\n\n## Topic: Implementing Data Structures \u2013 Singly Linked Lists\n\n### Background Story\nYou are helping the campus library build a tiny\u2010text archive of old book\u2010borrowing histories. Each history entry is just a (year, month) pair plus a short sentence describing what happened that month. The archive must support two operations: (1) add a new history entry at the **front** of the list, and (2) display every entry in the exact order it was added. The library wants the whole archive kept in memory as a singly linked list.\n\n### Requirements\n1. Define a struct that represents one history entry.\n2. Maintain a singly linked list in the order entries were added.\n3. Provide two functions:\n   - `addEntry()` \u2013 insert a new history entry at the front of the list.\n   - `displayArchive()` \u2013 print every entry in the list, one per line.\n4. The program must never add duplicate entries (same year and month).\n5. The program must be able to handle multiple operations until the user exits.\n\n### Example Input/Output\n```\nEnter 1 to add, 2 to display, 3 to exit.\n1\nEnter year and month: 2021 5\nEnter description: \"Borrowing history for May 2021\"\nEnter 1 to add, 2 to display, 3 to exit.\n1\nEnter year and description: 2021 5\n\"Borrowing history for May 2021\"\nEntry already exists.\nEnter 1 to add, 2 to display, 3 to exit.\n2\n2021 5: Borrowing history for May 2021\nEnter 1 to add, 2 to display, 3 to exit.\n3\n```\n\n### CONSTRAINTS\n- You must define a struct to represent the history entry.\n- You must implement a function `displayArchive()` to print the entire list.\n- You must not use any dynamic arrays or standard containers.\n- You must not use any global variables.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 28}, {"text": "# STEP 1: PROBLEM\n\n**Background Story**  \nThe campus library has hired you to write a tiny catalog system that keeps track of the next book to be shelved.  \nEach book is represented by its call-number (a positive integer).  \nAll books waiting to be shelved form a queue that must behave like a **singly linked list**; only the first book may be removed, and every new book is always added at the end of the queue.\n\n**Precise Functional Requirements**  \n1. Represent every book with a node that stores:  \n   - `callNo` \u2013 an `unsigned int`  \n   - `next` \u2013 a pointer to the next node (or `nullptr` if it is the last book).  \n2. Maintain two external pointers:  \n   - `head` \u2013 always points to the front of the queue (the next book to shelve).  \n   - `tail` \u2013 always points to the last node in the list (where the next book will be appended).  \n3. Provide exactly three operations (case-insensitive single-letter commands):  \n   - `A <callNo>` \u2013 append a book with the given call-number to the tail of the queue.  \n   - `S` \u2013 shelve (remove) the book at the head of the queue and print its call-number.  \n     If the queue is empty, print `Queue empty`.  \n   - `P` \u2013 print the entire queue from head to tail, space-separated on one line.  \n     If the queue is empty, print `Queue empty`.  \n4. The program must terminate only when the user chooses menu option `X`.  \n5. You may assume every input line is syntactically correct.\n\n**Simple Example**  \nInput  \n```\nA 101\nA 202\nP\nS\nP\nX\n```\nOutput  \n```\n101 202\n101\n202\n```\n\n### CONSTRAINTS  \n- You must use a `struct` called `Book` to represent each node.  \n- All list manipulation logic (append, remove, print) must be implemented in **one single function** besides `main()`.  \n- The menu option to EXIT the program is the single uppercase letter `X`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 29}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just opened a \u201cTech Lending Locker.\u201d  \nStudents can borrow one of 20 identical Arduino kits for up to 7 days.  \nTo keep things fair, the librarian wants a tiny console program that records who has which kit and when it is due\u2014using nothing more advanced than a singly linked list.\n\n## Requirements\n1. Each kit is represented by a node that stores:\n   - kit ID (unique integer 1-20)\n   - borrower name (single-word string, \u226420 chars)\n   - due day (integer 1-31, inclusive)\n2. The list is initially empty.\n3. The program repeatedly presents a menu with four choices:\n   1. Check-out a kit\n   2. Return a kit\n   3. Show all currently borrowed kits\n   4. Exit (ends the program)\n4. Check-out (option 1):\n   - Read kit ID, borrower name, due day.\n   - Reject if kit ID is not in range or already borrowed.\n   - Insert at the **front** of the list.\n5. Return (option 2):\n   - Read kit ID.\n   - If found, remove that node; print \u201cKit <id> returned.\u201d\n   - Else print \u201cKit <id> not found.\u201d\n6. Show all (option 3):\n   - Print one line per borrowed kit in the exact format:\n     ```\n     Kit <id>: <name> due day <day>\n     ```\n   - If the list is empty, print \u201cNo kits currently borrowed.\u201d\n7. All list operations must be performed on your own singly linked list; no STL/Collection libraries allowed.\n\n## Simple Example Run\n```\n1. Check-out\n2. Return\n3. Show all\n4. Exit\nChoice: 1\nKit ID: 7\nBorrower: Alice\nDue day: 12\n1. Check-out\n2. Return\n3. Show all\n4. Exit\nChoice: 3\nKit 7: Alice due day 12\n1. Check-out\n2. Return\n3. Show all\n4. Exit\nChoice: 2\nKit ID: 7\nKit 7 returned.\n1. Check-out\n2. Return\n3. Show all\n4. Exit\nChoice: 3\nNo kits currently borrowed.\n1. Check-out\n2. Return\n3. Show all\n4. Exit\nChoice: 4\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent each kit node.\n- All list manipulation (insert, delete, traverse) must be coded in **one user-defined function** besides `main()`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 30}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou are helping the university registrar\u2019s office build a tiny in-memory waiting list for an over-enrolled course. Students are added to the list in the order they request a seat, but the registrar also needs to remove a student when they withdraw or when a seat opens and the first student in line is admitted. You will implement this \u201cwaiting list\u201d as a **singly linked list** where each node stores a student\u2019s ID (integer) and last name (\u226420 letters).\n\n## Requirements\n1. Represent each list node with a student\u2019s ID and last name.\n2. Provide the following operations:\n   - **1** \u2013 Add a new student to the **back** of the list.  \n   - **2** \u2013 Remove the student from the **front** of the list (they got a seat).  \n   - **3** \u2013 Display the entire waiting list in order, one line per student:  \n     ```\n     ID lastName\n     ```\n   - **4** \u2013 Exit the program.\n3. After every operation, print the updated list length.  \n   Format: `List now holds N student(s).`  \n   (If the list is empty, print `List is empty.`)\n4. All operations must run in O(1) time except Display, which is O(n).\n\n## Simple Example\nInput\n```\n1 101 Smith\n1 102 Jones\n3\n2\n4\n```\n\nOutput\n```\nList now holds 1 student(s).\nList now holds 2 student(s).\n101 Smith\n102 Jones\nList now holds 2 student(s).\nAdmitted: 101 Smith\nList now holds 1 student(s).\n```\n\n### CONSTRAINTS\n- You must use a `struct` to represent each list node.\n- The logic that prints the details of a **single** node must be encapsulated in a function called `displayEntity`.\n- The entire solution must be implemented with only **one** user-defined function besides `main()`.  \n- Menu option **4** is the required EXIT option.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 31}, {"text": "# STEP 1: PROBLEM\nBackground Story  \nYou have just been hired as the \u201cNight Shift Librarian\u201d for the city\u2019s oldest library.  \nThe previous librarian kept all book records on paper cards.  \nYour first task is to digitize the card catalog.  \nEach card holds only three things: a unique ID number, the book\u2019s title, and a pointer to the next card.  \nYour job is to write a tiny program that lets you add new cards, list every card in order, and then lock up for the night.\n\nProgram Requirements  \n1. Represent each card with a struct named Card that contains  \n   - an int id  \n   - a string title (\u2264100 characters)  \n   - a pointer to the next Card.  \n2. Maintain the cards as a singly linked list in ascending order of id.  \n3. Provide a text menu with exactly three choices:  \n   1) Add a new card  \n   2) List all cards  \n   3) Exit  \n4. On \u201cAdd\u201d, read an id and title from stdin.  \n   - Reject duplicate ids with the message \u201cDuplicate ID.\u201d  \n   - Insert the new card so the list stays sorted.  \n5. On \u201cList\u201d, print every card in order, one per line, in the exact format  \n   ID: <id>, Title: <title>  \n6. On \u201cExit\u201d, free every allocated node and terminate the program.  \n7. You may assume every input line is well-formed and within length limits.\n\nSimple Example  \nInput  \n1  \n103  \nPride and Prejudice  \n1  \n101  \nThe Great Gatsby  \n2  \n3  \n\nOutput  \nID: 101, Title: The Great Gatsby  \nID: 103, Title: Pride and Prejudice  \n\n### CONSTRAINTS  \n- Must use a struct named Card to represent each card.  \n- The logic for inserting a new Card into the list must be implemented in a single function named insertCard.  \n- The logic for displaying the details of ONE specific Card must be in a function named displayCard.  \n- The only functions allowed besides main() are insertCard and displayCard.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 32}, {"text": "# STEP 1: PROBLEM\n## Background\nYou are helping a music-streaming startup build an ultra-light \u201cNow-Playing\u201d history.  \nEach song played is stored in a singly linked list so that the most recent song is always at the head.  \nWhen the user quits the app, the history is printed from newest to oldest.\n\n## Requirements\n1. Define a `struct Song` that stores:\n   - a unique integer id (0\u201310 000),\n   - title (\u226430 chars, no spaces),\n   - artist (\u226430 chars, no spaces).\n2. Maintain a global pointer `head` that always points at the most-recently played song.\n3. Implement exactly one function besides `main()`:\n   ```c\n   void pushSong(int id, const char* title, const char* artist);\n   ```\n   - It inserts a new song at the head of the list.\n   - If an id already exists anywhere in the list, print `Duplicate id` and do nothing.\n4. Inside `main()`:\n   - Repeatedly read commands from standard input until the user types `0`.\n   - Commands:\n     - `1 id title artist` \u2192 call `pushSong`.\n     - `0` \u2192 print the entire history (one line per song, fields separated by space) and exit.\n\n## Example\nInput\n```\n1 7 BlindingLights TheWeeknd\n1 3 Levitating DuaLipa\n1 7 BlindingLights TheWeeknd\n0\n```\nOutput\n```\nDuplicate id\n3 Levitating DuaLipa\n7 BlindingLights TheWeeknd\n```\n\n## CONSTRAINTS\n- Must use a `struct` to represent the primary data entity (`Song`).  \n- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 33}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just opened a \u201cTech-Help\u201d window staffed entirely by robots.  \nEach robot is represented by a unique ID string and a battery level (0-100).  \nWhen a robot\u2019s battery drops below 10 % it must leave the line to recharge.  \nYour task is to model the queue of robots **as a singly linked list** so that the head of the list is always the robot currently at the window.\n\n## Requirements\n1. Represent every robot with a node that stores:\n   - `id` (C-string, \u2264 20 characters)  \n   - `battery` (integer 0-100)  \n   - `next` pointer\n2. Maintain the list in FIFO order; new robots are always appended to the tail.\n3. Implement a text menu that lets the user:\n   - `1` Add a robot (read id and battery, append).  \n   - `2` Remove the robot at the window (head) **only if** its battery < 10; otherwise print \u201cRobot still has juice, cannot remove.\u201d  \n   - `3` Display the complete queue from head to tail, one robot per line:  \n     `ID: R2D2 Battery: 45`\n   - `4` Exit the program.\n4. All list operations must be done **in place** (no auxiliary arrays or STL containers).\n\n## Simple Example\nInput (user choices in brackets):\n```\n[1] R2D2 45\n[1] BB8 7\n[3]\n[2]\n[3]\n[4]\n```\n\nOutput:\n```\nID: R2D2 Battery: 45\nID: BB8 Battery: 7\nRobot still has juice, cannot remove.\nID: R2D2 Battery: 45\nID: BB8 Battery: 7\n```\n\n### CONSTRAINTS\n- Must use a `struct Node` to represent the primary data entity.  \n- Logic for displaying the details of ONE specific robot must be in a function called `displayRobot`.  \n- The solution must be implemented with a single function besides `main()` (you may have helper functions, but all list manipulation must be done inside that one function).  \n- Menu option `4` must immediately terminate the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 34}, {"text": "# STEP 1: PROBLEM  \nTopic: Implementing a Singly Linked List\n\nStory  \nYou are a teaching assistant helping freshmen register their ID cards.  \nEach card contains only two fields: an integer ID (unique) and a 3-letter name.  \nAll cards are stored in a single box that behaves like a stack:  \nnew cards are inserted at the top; when a student leaves, the top card is removed.  \nYour job is to maintain this box entirely in C without arrays or STL containers.\n\nTask  \nImplement a minimal \u201ccard box\u201d as a singly linked list that supports the following commands:\n\n1 insert <id> <name>  \n   Add a new card to the top.  \n2 remove  \n   Remove the top card.  \n3 list  \n   Print every card from top to bottom, one per line:  \n   <id> <name>  \n4 exit  \n   Release all memory and terminate.\n\nInput/Output Example  \ninsert 101 bob  \ninsert 102 ana  \nlist  \n102 ana  \n101 bob  \nremove  \nlist  \n101 bob  \nexit  \n\n### CONSTRAINTS  \n- Must use a struct Node {int id; char name[4]; Node *next;}.  \n- Must use only one function besides main().  \n- No global variables.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 35}, {"text": "# STEP 1: PROBLEM  \nTopic: Implementing Data Structures (e.g., Singly Linked Lists)\n\nYou are a Computer Science professor designing an undergraduate curriculum.  \nGenerate a novel programming problem on Implementing Data Structures (e.g., Singly Linked Lists). Your response must begin with the header # STEP 1: PROBLEM.  \nThe problem statement must be clear, unambiguous, and suitable for a student who has just learned this topic.  \nRequirements:  \n1. Clear background story or context.  \n2. A precise list of requirements for the program's functionality.  \n3. Simple Example of expected Input/Output.  \n4. Additional constraints, such as 'Must use a 'struct' to represent the primary data entity.', 'Logic for displaying the details of ONE specific entity must be in a function called 'displayEntity'.' or 'The solution must be implemented with a single function besides main()'. The constraint(s) should be listed under the ### CONSTRAINTS.  \n4. MANDATORY CONSTRAINTS IF A MENU IS IMPLEMENTED:  \n   - Must include a specific menu option to EXIT the program (clearly state the number or keyword).\n\n# STEP 1: PROBLEM  \nTopic: Implementing Data Structures (e.g., Sing Singly Linked Lists)\n\nYou are a Computer Science professor designing an undergraduate curriculum.  \nGenerate a novel programming problem on Implementing Data Structures (e.g., Sing Singly Linked Lists). Your response must begin with the header # STEP 1: PROBLEM.  \nThe problem statement must be clear, unambiguous, and suitable for a student who has just learned this topic.  \nRequirements:  \n1. Clear background story or context.  \n2. A precise list of requirements for the program's functionality.  \n3. Simple Example of expected Input/Output.  \n4. Additional constraints, such as 'Must use a 'struct' to represent the primary data entity.', 'Logic for displaying the details of ONE specific entity must be in a function called 'displayEntity'.' or 'The solution must be implemented with a single function besides main()'. The constraint(s) should be listed under the ### CONSTRAINTS.  \n4. MANDATORY CONSTRAINTS IF A MENU IS IMPLEMENTED:  \n   - Must include a specific menu option to EXIT the program (clearly state the number or keyword).\n\n# STEP 1: PROBLEM  \nTopic: Implementing Data Structures (e.g., Sing Singly Linked Lists)\n\nYou are a Computer Science professor designing an undergraduate curriculum.  \nGenerate a novel programming problem on Implementing Data Structures (e.g., Sing Singly Linked Lists). Your response must begin with the header # STEP 1: PROBLEM.  \nThe problem statement must be clear, unambiguous, and suitable for a student who has just learned this topic.  \nRequirements:  \n1. Clear background story or context.  \n2. A precise list of requirements for the program's functionality.  \n3. Simple Example of expected Input/Output.  \n4. Additional constraints, such as 'Must use a 'struct' to represent the primary data entity.', 'Logic for displaying the details of ONE specific entity must be in a function called 'displayEntity'.' or 'The solution must be implemented with a single function besides main()'. The constraint(s) should be listed under the ### CONSTRAINTS.  \n4. MANDATORY CONSTRAINTS IF A MENU IS IMPLEMENTED:  \n   - Must include a specific menu option to EXIT the program (clearly state the number or keyword).\n\n# STEP 1: PROBLEM  \nTopic: Implementing Data Structures (e.g., Sing Singly Linked Lists)\n\nYou are a Computer Science professor designing an undergraduate curriculum.  \nGenerate a novel programming problem on Implementing Data Structures (e.g., Sing Singly Linked Lists).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 36}, {"text": "# STEP 1: PROBLEM  \nTopic: Implementing Singly Linked Lists  \n\nBackground  \nA small town library has hired you to replace its old card\u2010catalog system with a tiny digital one.  Each book is represented only by its ISBN (a positive integer).  The librarian will type commands to add a new book to the front of the shelf, remove the first book, or display the entire shelf in order.\n\nRequirements  \n1. Represent the shelf as a singly linked list whose nodes store one ISBN.  \n2. Implement the following commands:  \n   - `add <ISBN>` \u2013 insert a new node at the head of the list.  \n   - `remove` \u2013 delete the head node and print its ISBN; if the list is empty, print `empty`.  \n   - `display` \u2013 print the list contents in order, one ISBN per line; if empty, print `empty`.  \n3. Stop when the user types `exit`.\n\nExample  \nInput  \n```\nadd 101  \nadd 102  \ndisplay  \nremove  \ndisplay  \nexit  \n```\n\nOutput  \n```\n102  \n101  \n102  \n101  \n```\n\n### CONSTRAINTS  \n- Must use a `struct` to represent a node.  \n- Must have exactly one function besides `main()`; all list operations must be inside that function.  \n- Menu option `exit` must terminate the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 37}, {"text": "# STEP 1: PROBLEM\n\n**Background Story**  \nThe campus library has just opened a \u201cFast-Return\u201d desk that only accepts books in the exact order they were borrowed. To keep track of the waiting list, you decide to build a tiny terminal program that models the queue of books using a **singly linked list**. Each book is identified only by its unique accession number (a positive integer).  \n\n**Task**  \nImplement an interactive system that lets the librarian:  \n1. **Add** a new book to the *back* of the queue.  \n2. **Return** the book at the *front* of the queue (i.e., remove and display it).  \n3. **Display** the entire current queue from front to back.  \n4. **Exit** the program.  \n\nThe program must keep the queue in the correct order at all times.\n\n**Simple Example (user input shown after `>`)**  \n```\n1> 123\n1> 124\n1> 125\n2\nReturned book 123\n3\nQueue: 124 125\n0\nGood-bye!\n```\n\n### CONSTRAINTS  \n- You must use a `struct` called `Book` to represent each node (it holds at least the accession number and a next-pointer).  \n- All list operations (insert at tail, delete from head, display) must be implemented **manually**\u2014do **not** use `std::list`, `vector`, etc.  \n- The logic that prints the accession number of **one** book must be placed in a function called `displayEntity`.  \n- The only functions allowed besides `main()` are:  \n  \u2013 `void enqueue(Book*&, int)`  \n  \u2013 `int dequeue(Book*&, Book*&)` (returns accession # or -1 if empty)  \n  \u2013 `void displayQueue(Book*)`  \n  \u2013 `void displayEntity(Book*)`  \n- The menu must offer option **0** to EXIT the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 38}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has asked your CS class to build a \u201cmini-catalog\u201d system that keeps track of books currently on a single shelf.  \nEach book has a unique call-number (an integer), a title, and an author.  \nBecause the shelf is narrow, books are physically stored in a singly-linked list so they can be easily inserted or removed without shifting the entire row.  \nYour job is to implement the core data structure and the basic operations the librarian needs.\n\n## Requirements\n1. Represent a book as a node in a singly-linked list.  \n2. Provide the following operations (menu-driven):\n   1) Add a new book to the front of the list.  \n   2) Remove a book by call-number.  \n   3) Search for a book by call-number and display its title & author.  \n   4) Display the full shelf (all books, in order).  \n   5) Exit the program.  \n3. After every operation, show the updated shelf contents (except for the search operation, which only shows the requested book).  \n4. If an operation cannot be performed (e.g., removing a non-existent book), print an appropriate error message.\n\n## Example Session (user input in **bold**)\n```\n1) Add\n2) Remove\n3) Search\n4) Display\n5) Exit\nChoice: **1**\nCall-number: **101**\nTitle: **The Pragmatic Programmer**\nAuthor: **Andrew Hunt**\nShelf: [101:The Pragmatic Programmer by Andrew Hunt]\n\nChoice: **1**\nCall-number: **102**\nTitle: **Clean Code**\nAuthor: **Robert Martin**\nShelf: [102:Clean Code by Robert Martin] -> [101:The Pragmatic Programmer by Andrew Hunt]\n\nChoice: **3**\nCall-number: **101**\nFound: 101:The Pragmatic Programmer by Andrew Hunt\n\nChoice: **2**\nCall-number: **101**\nRemoved. Shelf: [102:Clean Code by Robert Martin]\n\nChoice: **5**\nGoodbye!\n```\n\n### CONSTRAINTS\n- Must use a struct named `Book` to represent the primary data entity.  \n- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.  \n- The entire solution must be implemented with only one additional function besides `main()` (you may use helper functions internally, but only one user-defined function prototype besides main is allowed).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 39}, {"text": "# STEP 1: PROBLEM\n\n**Background Story**  \nThe campus library is modernizing its manual \u201chold request\u201d list. Each student can place only one hold on a book, and the system must keep the requests in the order they arrive. You have been asked to build a tiny prototype that records, cancels, and prints the queue of waiting students using a **singly linked list**.  \n\n**Requirements**  \n1. Represent each hold request with a node that stores the student\u2019s full name (\u226430 characters).  \n2. Maintain the queue strictly as a singly linked list.  \n3. Provide a menu-driven interface with the following options:  \n   1. Add a new hold request (enqueue at the tail).  \n   2. Cancel the oldest hold request (dequeue from the head).  \n   3. Display the current queue.  \n   4. Exit the program.  \n4. After every operation, print the updated queue or the cancelled student\u2019s name.  \n5. Handle empty-queue cancellations gracefully with the message \u201cQueue is empty.\u201d  \n\n**Simple Example of Expected I/O**  \n```\n===== Library Hold Queue =====\n1. Add Request\n2. Cancel Oldest\n3. Display Queue\n4. Exit\nChoice: 1\nEnter student name: Alice\nQueue: Alice\n\nChoice: 1\nEnter student name: Bob\nQueue: Alice -> Bob\n\nChoice: 3\nQueue: Alice -> Bob\n\nChoice: 2\nCancelled: Alice\nQueue: Bob\n\nChoice: 4\nGoodbye!\n```\n\n### CONSTRAINTS  \n- Must use a `struct` to represent the primary data entity (the node).  \n- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.  \n- The solution must be implemented with a single function besides `main()`.  \n- If a menu is implemented (as required above), option 4 must EXIT the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 40}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just opened a \u201cTech-Takeaway\u201d window where students can borrow small gadgets (portable chargers, calculators, adapters) for a short period. Each gadget is stored in a numbered cubby, and the window is so narrow that the attendant can only add or remove items from the front of the shelf. To keep track of what\u2019s available, you will write a tiny inventory manager that stores the gadgets in a **singly linked list**. Each node represents one cubby and holds the gadget\u2019s name and a checkout flag.\n\n## Functional Requirements\n1. Represent every cubby as a node in a singly linked list.\n2. Provide a menu-driven console program with the following options:\n   - 1 Add a new gadget (insert at the front of the list)\n   - 2 Check-out a gadget (remove the first node whose checkout flag is false, mark it as checked-out, and print its name)\n   - 3 Return a gadget (append it back to the front of the list as \u201cavailable\u201d again)\n   - 4 List all cubbies (print each gadget\u2019s name and its current status: \u201cavailable\u201d or \u201cchecked-out\u201d)\n   - 5 Exit the program\n3. After every successful operation, print a short confirmation message (e.g., \u201cAdded power-bank\u201d, \u201cChecked-out calculator\u201d, \u201cReturned adapter\u201d).\n\n## Simple Example Run\n```\n=== Tech-Takeaway Inventory ===\n1 Add gadget\n2 Check-out gadget\n3 Return gadget\n4 List cubbies\n5 Exit\nChoice: 1\nGadget name: power-bank\nAdded power-bank\n\nChoice: 1\nGadget name: calculator\nAdded calculator\n\nChoice: 2\nChecked-out calculator\n\nChoice: 4\ncubby 0: calculator (checked-out)\ncubby 1: power-bank (available)\n\nChoice: 3\nReturned calculator\n\nChoice: 4\ncubby 0: calculator (available)\ncubby 1: power-bank (available)\n\nChoice: 5\nGood-bye!\n```\n\n### CONSTRAINTS\n- You must define a struct named `Cubby` that represents a node (gadget name, checkout flag, next pointer).\n- All list operations must be implemented in a single function besides `main()`; name that function `processMenu`.\n- The menu option to EXIT the program is `5`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 41}, {"text": "# STEP 1: PROBLEM\n\n**Background Story**  \nThe campus library has just digitised its old card-catalogue. Each catalogue card contains a book\u2019s ID (a positive integer) and its title (a single word with no spaces).  \nAll cards arrived in a box in **strictly increasing order of ID**, but some cards are **duplicates** (same ID and title).  \nYour task is to write a program that stores the cards in a **singly linked list**, removes every duplicate while preserving the order, and then lets the librarian query the list.\n\n**Functional Requirements**  \n1. Read an unknown number of catalogue cards from standard input until the word \u201cEND\u201d is encountered.  \n2. Each non-END line contains:  \n   `<ID> <title>`  \n   where ID is a positive int and title is a single word.  \n3. Build a singly linked list in the exact order the cards arrive.  \n4. Remove **all duplicate cards** (two cards are equal when both ID and title match).  \n   - Keep the **first** occurrence of every duplicate.  \n5. After all input is read, repeatedly display a menu with the following options:  \n   1. Display the entire list (one card per line: ID and title).  \n   2. Search for a book by ID; display the first matching card or \u201cNot found\u201d.  \n   3. Exit the program.  \n\n**Simple Example**  \nInput  \n```\n101 Algorithms\n102 Biology\n101 Algorithms\n103 Chemistry\n102 Biology\nEND\n```\nMenu interaction (user choices shown after prompt)  \n```\n1. Display list\n2. Search by ID\n3. Exit\nChoice: 1\n101 Algorithms\n102 Biology\n103 Chemistry\nChoice: 2\nEnter ID: 102\n102 Biology\nChoice: 3\n```\nProgram terminates.\n\n### CONSTRAINTS  \n- Must use a `struct` to represent a catalogue card (node).  \n- Logic for displaying the details of ONE specific card must be in a function called `displayCard`.  \n- The solution must be implemented with **only one function besides main()** (you may choose which single helper function to write; all other logic must be inside main).  \n- If the menu is implemented, option **3** is the required EXIT option.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 42}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just opened a \u201cTech Lending Locker\u201d that loans out gadgets (calculators, phone chargers, tablets, etc.) to students for 24-hour periods.  \nTo keep track of what is in stock, the student tech-clerk needs a tiny inventory system that remembers which items are currently available and which have been checked out.  \nYou will build a **singly-linked list** that stores each gadget as a node and lets the clerk add, delete, search, display, and exit.\n\n## Functional Requirements\n1. Each gadget has:\n   - an integer ID (unique in the list)  \n   - a string name (e.g., \u201cTI-84 Calculator\u201d)  \n   - a bool available (true = in locker, false = checked-out)\n\n2. The program must start with an empty list (no dummy head node).\n\n3. The program must repeatedly show a menu:\n   ```\n   1 Add gadget\n   2 Delete gadget by ID\n   3 Search gadget by ID\n   4 Display all gadgets\n   5 Exit\n   ```\n\n4. Menu actions:\n   - **Add**: Read ID, name, available; insert at the **head** of the list; silently ignore (do nothing) if that ID already exists.\n   - **Delete**: Read an ID; if found, remove that node and print `<ID> removed.`; otherwise print `<ID> not found.`\n   - **Search**: Read an ID; if found, print the gadget\u2019s name and availability on one line separated by space; otherwise print `Not found.`\n   - **Display**: Print one line per node in the exact format `ID name status` where status is `available` or `checked-out`.\n\n5. No global variables except possibly a head pointer.\n\n6. You may assume all inputs are well-formed (no type errors).\n\n## Simple Example Run\nInput:\n```\n1\n101\nPowerBank-Anker\n1\n1\n102\nCalculator-TI84\n0\n3\n101\n2\n103\n4\n5\n```\n\nCorresponding Output:\n```\n101 PowerBank-Anker available\n103 not found.\n101 PowerBank-Anker available\n102 Calculator-TI84 checked-out\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent the primary data entity (the gadget node).  \n- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.  \n- Menu option 5 is the only way to EXIT the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 43}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just opened a \u201cTech-Help\u201d desk where students can borrow basic electronics (e.g., calculators, phone chargers, Arduinos).  \nTo keep track of who has what, you will build a tiny inventory system that stores the items in memory as a **singly linked list**.  \nEach node represents one item; the list grows when items are donated and shrinks when items are checked out.\n\n## Requirements\n1. Represent every item with at least these fields:  \n   - `id` (unique integer \u2265 1)  \n   - `name` (string, \u2264 30 characters)  \n   - `quantity` (integer \u2265 0)  \n2. Maintain the items in a singly linked list that is always **sorted in ascending order by id**.  \n3. Provide a text menu with these choices:  \n   1) Add new item (insert in the correct sorted position; reject duplicate ids)  \n   2) Remove item by id (print \u201cItem not found.\u201d if it does not exist)  \n   3) Display all items (one per line: `id name quantity`)  \n   4) Exit program  \n4. After every successful insertion or removal, immediately display the updated list.  \n5. The program must keep running until the user chooses option 4.\n\n## Simple Example Run\n```\n1) Add\n2) Remove\n3) Display\n4) Exit\nChoice: 1\nEnter id name quantity: 102 Arduino 5\nCurrent inventory:\n102 Arduino 5\n1) Add\n2) Remove\n3) Display\n4) Exit\nChoice: 1\nEnter id name quantity: 101 Calculator 12\nCurrent inventory:\n101 Calculator 12\n102 Arduino 5\n1) Add\n2) Remove\n3) Display\n4) Exit\nChoice: 2\nEnter id to remove: 102\nCurrent inventory:\n101 Calculator 12\n1) Add\n2) Remove\n3) Display\n4) Exit\nChoice: 4\nGood-bye!\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent each node/item.  \n- Logic for displaying the details of ONE specific node must be in a function called `displayEntity`.  \n- The entire solution must be implemented with **only one additional function besides `main()`** (you may use helper macros or inline code inside main, but only one standalone function).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 44}, {"text": "# STEP 1: PROBLEM\n\n## Story\nYou are the keeper of the Great Library of Alexandria, reborn as a tiny kiosk in the campus bookstore.  \nStudents slide scrolls (really, titles of books) through a slot.  \nYour job is to store them in the exact order they arrive, but you may later be asked to \u201close\u201d a scroll by title (someone bought the last copy).  \nAt any moment the curator can ask you to recite the current catalog from oldest to newest.  \nTo stay historically accurate, you must store the scrolls in a chain\u2014exactly like the ancient scroll racks\u2014implemented as a singly linked list.\n\n## Requirements\n1. Represent each scroll with a node that stores:\n   - A unique title (C-string, \u2264 100 characters, no spaces).  \n   - A pointer to the next node.  \n2. Provide a text menu that loops until the user chooses to exit:\n   1. Add a scroll (append to the tail of the list).  \n   2. Remove a scroll by title (delete first exact match).  \n   3. Display the full catalog (print titles in order, one per line).  \n   4. Exit the program (terminates the loop).  \n3. After every operation, the program must return to the menu.  \n4. If the list is empty and a display or remove is requested, print `Collection is empty.`  \n\n## Example Session (user input after `>`)\n```\n1\n> Learn C Pointers\n1\n> Mythical Man-Month\n3\nLearn C Pointers\nMythical Man-Month\n2\n> Learn C Pointers\n3\nMythical Man-Month\n4\n```\nThe program ends.\n\n### CONSTRAINTS\n- You must use a `struct` named `Scroll` to represent each node.  \n- All list operations (add, remove, display) must be implemented inside a single user-defined function called `manageLibrary()`; `main()` may only handle the menu loop and call `manageLibrary()`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 45}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe tiny village of Nodelia keeps its history in a chain of carved wooden plaques.  \nEach plaque stores a single year (an int) and a pointer to the next plaque.  \nThe village scribe has asked you to write a program that lets her:\n- add a new plaque to the front of the chain,\n- remove the front plaque,\n- print the whole chain from oldest to newest,\n- count how many plaques are currently stored, and\n- exit when she is done.\n\n## Requirements\n1. Represent one plaque with a struct that contains:\n   - an integer field `year`\n   - a pointer to the next plaque (or NULL if it is the last one).\n2. Maintain a global head pointer that always points to the first plaque.\n3. Provide a text menu with the following options:\n   - 1 \u2013 Add a new plaque (ask for the year and push it to the front).\n   - 2 \u2013 Remove the front plaque.\n   - 3 \u2013 Display the chain from oldest to newest, one year per line.\n   - 4 \u2013 Report the current number of plaques.\n   - 5 \u2013 Exit the program.\n4. After every operation (except Exit) re-display the menu.\n5. If the user chooses an invalid option, print \u201cInvalid choice.\u201d and re-display the menu.\n6. If the user tries to remove or display when the chain is empty, print \u201cEmpty chain.\u201d\n\n## Example Session\n```\n1\nEnter year: 2020\n1\nEnter year: 2021\n3\n2020\n2021\n2\n3\n2020\n5\n```\n\n### CONSTRAINTS\n- You must use a struct to represent each plaque.\n- All list operations (insert, remove, display, count) must be implemented in a single user-defined function besides main().\n- Menu option 5 is the only way to exit the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 46}, {"text": "# STEP 1: PROBLEM\n\n## Background Story  \nA local music-streaming startup keeps the playlist for each user as a singly linked list of songs.  \nEach song node stores the song title (\u226430 characters) and its duration in seconds.  \nYour task is to build the core linked-list engine that lets the user insert new songs, delete songs, and display the current playlist.\n\n## Requirements  \n1. Start with an **empty** playlist (head = NULL).  \n2. Support the following menu choices (loop until the user chooses EXIT):  \n   1. Insert a song at the **end** of the playlist.  \n   2. Delete a song by its exact title (case-sensitive).  \n   3. Show the current playlist (one song per line: `title (duration s)`).  \n   4. EXIT the program with the keyword `4`.  \n3. If a delete operation fails (title not found), print:  \n   `Song not found.`  \n4. After every insert or delete, the playlist must remain a valid singly linked list.\n\n## Example Session (user input in **bold**)  \n```\n1\n**Midnight City 240**\n1\n**Daylight 195**\n3\nMidnight City (240 s)\nDaylight (195 s)\n2\n**Midnight City**\n3\nDaylight (195 s)\n4\n```\n\n### CONSTRAINTS  \n- Must use a single `struct` called `Song` to represent a node (title, duration, next pointer).  \n- All list operations (insert, delete, display) must be implemented in **one** user-defined function besides `main()`.  \n- The menu option to EXIT the program is `4`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 47}, {"text": "# STEP 1: PROBLEM\nBackground  \nThe campus library has a tiny help-desk called \u201cQuickShelf\u201d that stores the names of books students ask for in the order they are requested. Because the desk is so small, only the oldest request can be served (FIFO). To keep the software simple, the desk clerk insists that the program must run in a single loop and that the entire queue is always printed after each operation so she can see the current waiting list.\n\nPrecise Requirements  \n1. Represent each book request with a struct containing an integer id and a string title.  \n2. Maintain a singly-linked list that models the queue.  \n3. Implement exactly four operations (menu options):  \n   1. Enqueue a new request (read id and title from stdin).  \n   2. Dequeue the oldest request.  \n   3. Print the current queue from front to back.  \n   4. Exit the program (option 4).  \n4. After every enqueue or dequeue, automatically print the queue content on one line, space-separated, in the format  \n   id:title id:title \u2026  \n   or print \u201cempty\u201d if the queue is empty.  \n5. All list manipulations must be done with pointer operations; no STL containers or Java collections allowed.\n\nSimple Example  \nInput  \n1 100 HarryPotter  \n1 101 Hobbit  \n2  \n4  \n\nOutput  \n100:HarryPotter  \n100:HarryPotter 101:Hobbit  \n101:Hobbit  \n(empty line, program ends)\n\n### CONSTRAINTS  \n- Must use a struct to represent the primary data entity (the book request).  \n- The queue logic (enqueue, dequeue, print) must be implemented with a single function besides main().  \n- Menu option 4 must exit the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 48}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has installed a new \u201csmart\u201d book return bin.  \nEvery time a student drops a book in the slot, the bin stores its ISBN in the order it arrived.  \nYour task is to write the tiny embedded program that records the returns and, on request, prints the list in the exact order they were received so the librarian can check them back in.\n\n## Requirements\n1. Represent the queue of returned ISBNs with a **singly linked list**.\n2. Provide a console menu with exactly three choices:\n   1. Return a book (read an ISBN and append it to the list)  \n   2. Display the current return queue (print ISBNs one per line, oldest first)  \n   3. Exit the program (clearly numbered as option 3)\n3. After every operation the menu must re-appear until the user chooses 3.\n4. Assume ISBNs are strings of at most 20 characters with no spaces.\n\n## Simple Example\nInput  \n```\n1\n9780131103627\n1\n9780131103634\n2\n3\n```\n\nOutput  \n```\nMenu:\n1 Return book\n2 Show queue\n3 Exit\nChoice: 1\nISBN: 9780131103627\nMenu:\n1 Return book\n2 Show queue\n3 Exit\nChoice: 1\nISBN: 9780131103634\nMenu:\n1 Return book\n2 Show queue\n3 Exit\nChoice: 2\nQueue:\n9780131103627\n9780131103634\nMenu:\n1 Return book\n2 Show queue\n3 Exit\nChoice: 3\nGoodbye!\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent each node of the linked list.  \n- Logic for displaying the queue must be encapsulated in a single function named `displayQueue`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 49}, {"text": "# STEP 1: PROBLEM\n\n### Background Story\nThe campus library has a \u201cFast-Return\u201d box where students drop books without lining up at the desk.  \nTo keep track of what comes in, the librarian wants a tiny terminal program that remembers the **order** of returned books.  \nYour task is to simulate this with a **singly linked list** that stores book IDs (positive integers).  \nEvery time a student drops a book, the ID is appended to the list; when the librarian is ready to process returns, she removes the **oldest** ID (FIFO).  \nShe also needs to peek at the next book to be processed and to see the whole queue at any moment.\n\n### Functional Requirements\n1. Read commands from standard input until the user chooses to exit.\n2. Support four commands (case-insensitive):\n   - `ADD <id>`  \u2013 append the book ID (positive int) to the tail of the list.  \n   - `PROCESS`   \u2013 remove the ID from the head and print `Processing book <id>`.  \n     If the list is empty, print `Box is empty`.  \n   - `PEEK`      \u2013 print the ID at the head without removing it.  \n     If the list is empty, print `Box is empty`.  \n   - `LIST`      \u2013 print the IDs in order from head to tail, space-separated on one line.  \n     If the list is empty, print `Box is empty`.  \n3. The program must terminate **only** when the user selects the EXIT option.\n\n### Simple Example Input/Output\nInput\n```\nADD 101\nADD 102\nPEEK\nLIST\nPROCESS\nLIST\nEXIT\n```\n\nOutput\n```\n101\n101 102\nProcessing book 101\n102\n```\n\n### CONSTRAINTS\n- You **must** use a `struct` to represent each node of the singly linked list.  \n- All list operations (add, remove, peek, display) must be implemented in **one single function** besides `main()`.  \n- The menu option to EXIT is the integer `0`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 50}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has asked your CS class to build a tiny, self-contained system that keeps track of the next book to be shelved.  \nInstead of an array (which shifts are expensive), you decide to model the \u201cto-shelve\u201d list as a **singly linked list** where every node stores a book\u2019s ID (an int) and a string with the book\u2019s title.  \nThe librarian can add new books to the **front** (they\u2019re the most urgent) and, once a book is shelved, remove it from the **front**.  \nAt any moment the librarian may also ask to see the current list in order.\n\n## Precise Requirements\n1. Represent each book with a node that contains:\n   - `id` (positive int)\n   - `title` (C-string, \u2264 80 chars, no spaces)\n2. Maintain a singly linked list whose **head pointer is a global variable**.\n3. Implement exactly three operations (choose via a simple text menu):\n   - `1` Add a book to the **front** of the list  \n     (read id and title from stdin; if id already exists, ignore the request and print `Duplicate ID`)\n   - `2` Remove the book at the **front**  \n     (print `Removed: <id> <title>` or `Empty` if nothing to remove)\n   - `3` Print the entire list from head to tail, one line per book:  \n     `<id> <title>`\n   - `4` Exit the program\n4. No memory leaks: every removed node must be freed.\n\n## Simple Example Run\n```\n1\n101 AtlasShrugged\n1\n202 AnimalFarm\n3\n202 AnimalFarm\n101 AtlasShrugged\n2\nRemoved: 202 AnimalFarm\n3\n101 AtlasShrugged\n4\n```\n(Program ends.)\n\n### CONSTRAINTS\n- Must use a `struct Node` to represent each list element.  \n- All list operations (insert, delete, print) must be implemented in **a single function** besides `main()`.  \n- Menu option `4` must immediately terminate the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 51}, {"text": "# STEP 1: PROBLEM\n\n## Context\nThe campus library is digitising its card-catalogue system.  \nFor every book they store only three things (in this order):\n1. a unique integer ID\n2. the book\u2019s title\n3. the author\u2019s name\n\nBecause the collection is small, the librarian insists on keeping the books in **alphabetical order by title** (A\u2192Z) so that visitors can browse the list quickly.  \nYour job is to write a tiny command-line program that lets the staff insert new books while maintaining that order, and to list all books whenever asked.\n\n## Requirements\n1. Represent each book with a `struct` containing the three fields above.\n2. Keep the collection as a **singly linked list** whose nodes are ordered by `title` (case-sensitive, lexicographic).\n3. Support exactly two user commands (plus exit):\n   - `insert id title author`  \n     Insert a new book with the given id, title, and author.  \n     If a book with the same id already exists, print `Duplicate ID` and do nothing.\n   - `list`  \n     Print every book in order, one per line, in the exact format  \n     `id) Title by Author`  \n     If the collection is empty, print `Empty catalogue`.\n   - `0` (the number zero)  \n     Exit the program.\n4. After each command (except exit) the program must return to the prompt and wait for the next command.\n5. All dynamic memory you allocate must be freed before the program exits.\n\n## Simple Example\nInput\n```\ninsert 7 ThePragmaticProgrammer AndrewHunt\ninsert 3 CleanCode RobertMartin\nlist\ninsert 7 Refactoring MartinFowler\n0\n```\n\nOutput\n```\n3) CleanCode by RobertMartin\n7) ThePragmaticProgrammer by AndrewHunt\nDuplicate ID\n```\n\n## CONSTRAINTS\n- You must use a `struct` to represent each book node.\n- The only functions you may write besides `main()` are:\n  - `insertBook()` \u2013 inserts a book in the correct position\n  - `displayCatalogue()` \u2013 prints the entire list\n- No global variables are allowed; pass the head pointer around explicitly.\n- The menu option to EXIT the program is the number `0`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 52}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library is digitizing its old card-catalogue system.  \nEach index card contains a book\u2019s call-number (a unique string) and its title.  \nYour task is to write a tiny in-memory catalogue that keeps the cards in the same order they were entered (like a stack on the librarian\u2019s desk) and lets the librarian add, inspect, and discard cards.\n\n## Requirements\n1. Represent each card with two fields:  \n   - `callNumber` (C-string, max 19 chars + terminating null)  \n   - `title` (C-string, max 99 chars + terminating null)  \n2. Store the cards in a **singly linked list** whose nodes are created with dynamic memory (`malloc`).  \n3. Provide a **text menu** with exactly these choices:  \n   1) Add a new card to the **front** of the list  \n   2) Display every card in order (one per line: `callNumber: title`)  \n   3) Remove the **first** card (the one most recently added)  \n   4) Exit the program  \n4. After every operation, re-display the menu (loop until the user chooses 4).  \n5. Handle empty-list cases gracefully (print nothing for \u201cDisplay\u201d and \u201cCannot remove from empty catalogue\u201d for \u201cRemove\u201d).  \n6. No global variables except possibly the head pointer inside `main`.\n\n## Simple Example Run\n```\n1) Add  2) Display  3) Remove  4) Exit\nChoice: 1\nCall number: QA76.6  Title: Introduction to Algorithms\n1) Add  2) Display  3) Remove  4) Exit\nChoice: 1\nCall number: TK7895  Title: Computer Architecture\n1) Add  2) Display  3) Remove  4) Exit\nChoice: 2\nTK7895: Computer Architecture\nQA76.6: Introduction to Algorithms\n1) Add  2) Display  3) Remove  4) Exit\nChoice: 3\nRemoved TK7895\n1) Add  2) Display  3) Remove  4) Exit\nChoice: 4\nGood-bye!\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent each list node (the card plus `next` pointer).  \n- Logic for displaying the details of ONE specific card must be in a function called `displayCard`.  \n- The solution must be implemented with a single function besides `main()` (you may reuse `displayCard` for the whole list).  \n- Menu option 4 is the **only** way to exit; the program must terminate cleanly with `return 0;`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 53}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has a \u201cTake-a-Book, Leave-a-Book\u201d shelf that works like a tiny, ever-changing library.  \nTo keep track of which paperbacks are currently on the shelf, the student volunteers want a program that remembers the order in which books were added (so the oldest can be given away first).  \nYou will build a tiny inventory manager that keeps the titles in a **singly linked list**.\n\n## Requirements\n1. Define a singly linked list where each node stores:\n   - a unique ID (positive integer)\n   - the book title (single-line string, max 100 characters)\n2. Provide a text menu with the following options:\n   1. Add a new book (oldest to the front, newest to the back)\n   2. Display the entire shelf (one book per line, in order from oldest to newest)\n   3. Remove the oldest book (head of the list)\n   4. Exit the program (keyword `4`)\n3. After every successful operation print a short confirmation message.\n4. If the list is empty and the user tries to remove or display, print \u201cShelf is empty.\u201d\n5. All dynamic memory must be freed before the program exits.\n\n## Example Run\n```\n1. Add book\n2. Display shelf\n3. Remove oldest\n4. Exit\nChoice: 1\nEnter ID: 101\nEnter title: Dune\nBook added.\n\n1. Add book\n2. Display shelf\n3. Remove oldest\n4. Exit\nChoice: 1\nEnter ID: 102\nEnter title: Neuromancer\nBook added.\n\n1. Add book\n2. Display shelf\n3. Remove oldest\n4. Exit\nChoice: 2\n101 | Dune\n102 | Neuromancer\n\n1. Add book\n2. Display shelf\n3. Remove oldest\n4. Exit\nChoice: 3\nRemoved 101 | Dune\n\n1. Add book\n2. Display shelf\n3. Remove oldest\n4. Exit\nChoice: 4\nGoodbye!\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent each node.\n- The logic for displaying the details of ONE specific book must be in a function called `displayEntity`.\n- No global variables; use only local variables and parameters.\n- The menu option to exit the program is `4`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 54}, {"text": "# STEP 1: PROBLEM  \n## Topic: Implementing a Singly Linked List\n\n### Background Story  \nThe campus library has just digitised its catalogue of textbooks. Each book is stored as a node in a singly linked list so that new arrivals can be inserted quickly at the head of the list, while keeping memory usage low. You are asked to write a tiny demo program that librarians can run to add books and display the current shelf.\n\n### Functional Requirements  \n1. Represent a book with at least the following data:  \n   - `id` (unique positive integer)  \n   - `title` (string, no commas)  \n   - `author` (string, no commas)  \n\n2. Maintain the books in a singly linked list.\n\n3. Provide a text menu with two options (and an exit):  \n   1. Insert a new book (adds at the head of the list)  \n   2. Display all books in the order they were inserted (head \u2192 tail)  \n   3. Exit the program  \n\n4. After every insertion or display request, re-show the menu.\n\n5. Handle invalid menu choices by re-printing the menu.\n\n### Simple Example  \nInput (user responses in **bold**):\n```\n1\n101\nIntroduction to Algorithms\nCormen\n2\n3\n```\nOutput:\n```\n1) Insert book\n2) Display books\n3) Exit\nChoice: 1\nEnter id: 101\nEnter title: Introduction to Algorithms\nEnter author: Cormen\n1) Insert book\n2) Display books\n3) Exit\nChoice: 2\nID: 101, Title: Introduction to Algorithms, Author: Cormen\n1) Insert book\n2) Display books\n3) Exit\nChoice: 3\nGoodbye!\n```\n\n### CONSTRAINTS  \n- Must use a `struct` to represent the primary data entity (a book node).  \n- The logic for displaying the details of **one specific book** must be in a function called `displayBook`.  \n- The entire solution must be implemented with **only one additional function besides `main()`** (you may choose which one).  \n- If a menu is implemented (which it is), the exit option must be option number **3**.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 55}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou are helping the campus music club build a playlist manager for their Thursday-night open-mic sessions.  \nThe songs must be played in the exact order they are submitted, but the host needs the ability to drop the last submission if it is inappropriate or to review the entire list before showtime.  \nYour task is to write a tiny console app that keeps the submissions in a singly linked list and lets the host add, remove, or display songs.\n\n## Functional Requirements\n1. Represent each song with an integer ID (the submission order) and a string title.\n2. Maintain the songs in a singly linked list that always appends new songs to the **tail** (end).\n3. Implement exactly three user commands:\n   - `add <ID> \"<Title>\"` \u2013 append the song (assume ID is unique).\n   - `remove` \u2013 delete the last song in the list (print `Nothing to remove` if empty).\n   - `show` \u2013 print the full playlist, one song per line, in the format `ID: Title`.\n4. Commands are entered by the user in any order until the host types `exit`, which terminates the program.\n5. After every `add` or `remove`, print `Added` or `Removed` respectively (lower-case exactly).\n\n## Simple Example Run\n```\n> add 1 \"Blinding Lights\"\nAdded\n> add 2 \"Levitating\"\nAdded\n> show\n1: Blinding Lights\n2: Levitating\n> remove\nRemoved\n> show\n1: Blinding Lights\n> exit\n```\n\n## CONSTRAINTS\n- Must use a `struct` named `Song` to represent the primary data entity.\n- All list operations (append, delete-last, display) must be implemented in a single function `managePlaylist()`; `main()` is only allowed to handle user input and call this function.\n- The program must support the command `exit` (case-insensitive) to terminate.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 56}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just switched to a fully digital check-out system.  \nEvery time a student borrows a book, the system must record the book\u2019s unique call-number (an integer) and the student\u2019s ID (also an integer).  \nBecause the traffic is light, the head librarian has asked you to implement a **minimal, memory-efficient** system that keeps these records in the exact order they arrive, and must be able to:\n\n- add a new loan record,\n- display all current loans, and\n- delete the **oldest** loan (the one at the front of the list) when the book is returned.\n\nTo keep the code short and easy to audit, the librarian insists that **only one programmer-defined function besides `main()`** is used.\n\n---\n\n## Functional Requirements\n1. Represent each loan as a node in a **singly linked list**.\n2. Provide a **text menu** that repeats until the user chooses to exit.\n3. Menu options:\n   - `1` Add a new loan (read call-number and student ID).\n   - `2` Display every loan in order from oldest to newest (one line per loan: `call-number student-ID`).\n   - `3` Delete the oldest loan (the head node).\n   - `4` Exit the program.\n4. If the user tries to delete or display when the list is empty, print the exact message: `List is empty.`\n5. All dynamic memory must be properly freed before the program exits.\n\n---\n\n## Simple Example Run\n```\n1\n101 90001\n1\n102 90002\n2\n101 90001\n102 90002\n3\n2\n102 90002\n4\n```\n(Program ends.)\n\n---\n\n### CONSTRAINTS\n- You **must** define a `struct` to represent each loan node.  \n- The **entire solution** must be implemented with **only one programmer-defined function besides `main()`**.  \n- Menu option `4` is the **EXIT** option.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 57}, {"text": "# STEP 1: PROBLEM  \nTopic: Implementing Data Structures (e.g., Singly Linked Lists)\n\nStory  \nYou are a teaching assistant for the first\u2013year biology lab.  Every afternoon, students drop in to borrow a microscope, and the lab keeps a waiting list.  Today, the waiting list is handled electronically: each student is added at the tail of a singly linked list when they arrive, and is removed from the head when a microscope becomes free.\n\nProblem  \nWrite a small console program that records the waiting list for the biology microscopes.  The program must support the following operations:\n\n1. Add a student to the tail of the list.  \n2. Remove the student at the head of the list.  \n3. Display the entire waiting list (head \u2192 tail).  \n4. Exit the program.\n\nInput/Output  \nEach operation is selected from a menu.  The only data stored per student is a unique string (student ID).\n\n nothing else.\n\nSimple Example  \nMenu  \n1. Add student  \n2. Remove student  \n3. Display list  \n4. Exit  \nSelect: 1  \nEnter student ID: Alice  \nSelect: 1  \nEnter student ID: Bob  \nSelect: 3  \nWaiting list:  \nAlice \u2192 Bob  \nSelect: 2  \nRemoved Alice  \nSelect: 3  \nWaiting list:  \nBob \u2192\n\n### CONSTRAINTS  \n1. Represent each student as a struct Node containing a string studentID and a pointer next.  \n2. The waiting list must be a singly linked list.  \n3. The program must be implemented with exactly one function besides main(): the menu driver.  \n4. The menu must include option 4 Exit; selecting it terminates the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 58}, {"text": "# STEP 1: PROBLEM\n\n## Context\nThe campus library is digitizing its old card-catalog.  \nEach catalog card contains a book\u2019s call-number (a unique string) and title.  \nYour job is to write a tiny \"live catalog\" program that keeps these cards in **call-number order** using a **singly linked list**.  \nUsers can add a new card, remove one by call-number, or print the whole catalog.\n\n## Requirements\n1. Represent each catalog card with two fields:\n   - `callNumber` (C-string, \u2264 20 chars, unique)\n   - `title` (C-string, \u2264 100 chars)\n2. Store the cards in **ascending lexicographic order of call-number** at all times.\n3. Provide a text menu with exactly these choices:\n   1. Add card\n   2. Remove card\n   3. Show catalog\n   4. Exit\n4. Adding:\n   - Reject duplicates (print `\"Duplicate call-number.\"`)\n   - Insert in the correct sorted position without rebuilding the list.\n5. Removing:\n   - Delete by call-number; if not found print `\"Card not found.\"`\n6. Showing:\n   - Print one line per card in the exact format  \n     `call-number: title`  \n     (If the catalog is empty, print `\"Catalog is empty.\"`)\n\n## Simple Example (user input after `>`)\n```\n1\n> A123.4\n> Introduction to Algorithms\n1\n> B56\n> Operating Systems\n3\nA123.4: Introduction to Algorithms\nB56: Operating Systems\n2\n> A123.4\nCard removed.\n3\nB56: Operating Systems\n4\n```\n(Program ends)\n\n### CONSTRAINTS\n- Must use a `struct` to represent the primary data entity (a catalog card).\n- The logic for displaying the details of ONE specific card must be in a function called `displayCard`.\n- The menu option to EXIT the program is option 4.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 59}, {"text": "# STEP 1: PROBLEM\n\n## Context\nThe campus library has a tiny \u201cTake-a-Book, Leave-a-Book\u201d shelf that only holds one copy of each title.  \nTo keep track of which books are on the shelf, the librarian asks you to build a very small inventory system.  \nBecause the shelf is so small, the librarian wants to be able to insert a new book at any chosen position in the list, remove a book by title, and instantly see the current list of books in order.  \nYou decide that a singly linked list is perfect for this job.\n\n## Requirements\n1. Represent each book with a struct that stores:\n   - a unique title (string, \u2264100 chars, no spaces)  \n   - a struct pointer to the next book.\n\n2. Maintain the inventory as a singly linked list whose head is a global pointer (or returned/updated through parameters\u2014your choice).\n\n3. Provide three operations (menu driven):\n   1. Insert a new title at a 1-based position.  \n      If position \u2264 0 or greater than current length+1, print \u201cInvalid position\u201d and do nothing.  \n   2. Remove a title.  \n      If the title is not found, print \u201cTitle not found\u201d.  \n   3. Display the current list from first to last, one title per line.  \n   4. Exit the program.\n\n4. All dynamic memory (malloc/free) must be handled explicitly; no memory leaks.\n\n## Simple Example\nInput\n```\n1\nPride\n1\n2\nPrejudice\n2\n1\nPride\n3\n4\n```\nOutput\n```\nInvalid position\nPrejudice\nTitle not found\nPride\nPrejudice\n```\n(The first \u201cInvalid position\u201d appears because the second insertion tries position 2 when only one book exists.)\n\n### CONSTRAINTS\n- You must use a struct to represent the primary data entity (the book node).  \n- All list-modifying logic (insert, remove) must be implemented in a single function besides main().  \n- The menu option to EXIT the program is 4.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 60}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe city\u2019s public library is modernizing its inventory system.  Each book is identified by a **unique ISBN**, has a **title**, an **author**, and a **year of publication**.  The library wants a simple console program that lets a clerk add new books, remove books that are withdrawn, and look up a book by its ISBN.  Because the clerk will be entering and deleting books frequently, the data should be stored in a **singly linked list** that grows and shrinks dynamically.\n\n## Requirements  \n\nWrite a C (or C\u2011like) program that provides the following functionality through a text\u2011based menu:\n\n1. **Add a Book** \u2013 Prompt the user for ISBN (string, no spaces), title, author, and year, then insert the new book at the **head** of the linked list.  \n2. **Remove a Book** \u2013 Prompt for an ISBN and delete the first node whose ISBN matches. If the ISBN is not found, display a message.  \n3. **Find a Book** \u2013 Prompt for an ISBN and display all details of the matching book. If not found, display a message.  \n4. **List All Books** \u2013 Traverse the list from head to tail and print the details of every stored book in the order they appear in the list.  \n5. **Exit** \u2013 Terminate the program gracefully, freeing any allocated memory.\n\nAll input should be read from standard input, and all output written to standard output. The program should continue to display the menu after completing an operation (except when the user chooses **Exit**).\n\n## Example Input / Output  \n\n```\n===== Library Book Manager =====\n1. Add a Book\n2. Remove a Book\n3. Find a Book\n4. List All Books\n5. Exit\nChoose an option: 1\n\nEnter ISBN: 9780131103627\nEnter Title: The C Programming Language\nEnter Author: Kernighan & Ritchie\nEnter Year: 1988\nBook added successfully!\n\n===== Library Book Manager =====\n1. Add a Book\n2. Remove a Book\n3. Find a Book\n4. List All Books\n5. Exit\nChoose an option: 4\n\nCurrent books in inventory:\nISBN: 9780131103627 | Title: The C Programming Language | Author: Kernighan & Ritchie | Year: 1988\n\n===== Library Book Manager =====\n1. Add a Book\n2. Remove a Book\n3. Find a Book\n4. List All Books\n5. Exit\nChoose an option: 5\n\nGoodbye!\n```\n\n*If the user tries to remove or find a book that does not exist, the program should output:*  \n\n```\nBook with ISBN <ISBN> not found.\n```\n\n## ### CONSTRAINTS  \n\n1. **Data Representation** \u2013 The primary data entity (a book) **must be defined using a `struct`** named `BookNode` that contains the ISBN, title, author, year, and a pointer to the next node.  \n2. **Display Function** \u2013 The logic for printing the details of **one specific book** must be placed in a function with the exact prototype:  \n\n   ```c\n   void displayBook(const BookNode *node);\n   ```  \n\n3. **Memory Management** \u2013 Every node allocated with `malloc`/`new` must be freed exactly once before program termination.  \n4. **Menu Requirement** \u2013 The menu must include an explicit option to **EXIT** the program (option number 5 in the example). Selecting this option ends the loop and frees all resources.  \n\n*No additional libraries beyond the standard I/O and memory\u2011management libraries may be used.*", "model": "openai/gpt-oss-120b", "iteration": 31}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe ancient kingdom of **Algoria** maintains a **registry of heroic quests**. Each quest is recorded with a unique ID, the name of the hero who undertook it, and the number of days the quest lasted. The kingdom\u2019s archivist wants a simple console program to keep this registry up\u2011to\u2011date while the students of the Royal Academy learn how singly linked lists work.\n\n## Requirements  \nWrite a C (or C++) program that implements a **singly linked list** to store the quest records. The program must present a text\u2011based menu that allows the user to perform the following operations:\n\n1. **Add a new quest** \u2013 Prompt for the quest ID (integer), hero name (single\u2011word string, max 31 characters), and duration in days (integer). Insert the new node at the **head** of the list.  \n2. **Delete a quest by ID** \u2013 Prompt for a quest ID and remove the first node whose ID matches. If no such quest exists, display an appropriate message.  \n3. **Search and display a quest by ID** \u2013 Prompt for a quest ID and show all its fields using the required display function (see constraints). If the quest is not found, inform the user.  \n4. **Display all quests** \u2013 Traverse the list from head to tail, printing each quest on its own line.  \n5. **Exit** \u2013 Terminate the program gracefully, freeing any allocated memory.\n\nThe menu should repeat after each operation until the user chooses the **Exit** option.\n\n## Example Input / Output  \n\n```\n=== Quest Registry Menu ===\n1. Add Quest\n2. Delete Quest\n3. Search Quest\n4. List All Quests\n5. Exit\nChoose an option: 1\n\nEnter Quest ID: 101\nEnter Hero Name: Aria\nEnter Duration (days): 7\nQuest added.\n\n=== Quest Registry Menu ===\n1. Add Quest\n2. Delete Quest\n3. Search Quest\n4. List All Quests\n5. Exit\nChoose an option: 1\n\nEnter Quest ID: 202\nEnter Hero Name: Boren\nEnter Duration (days): 12\nQuest added.\n\n=== Quest Registry Menu ===\n1. Add Quest\n2. Delete Quest\n3. Search Quest\n4. List All Quests\n5. Exit\nChoose an option: 4\n\nQuest ID: 202 | Hero: Boren | Days: 12\nQuest ID: 101 | Hero: Aria  | Days: 7\n\n=== Quest Registry Menu ===\n1. Add Quest\n2. Delete Quest\n3. Search Quest\n4. List All Quests\n5. Exit\nChoose an option: 3\n\nEnter Quest ID to search: 101\nQuest ID: 101 | Hero: Aria | Days: 7\n\n=== Quest Registry Menu ===\n1. Add Quest\n2. Delete Quest\n3. Search Quest\n4. List All Quests\n5. Exit\nChoose an option: 5\n\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n- **Data Structure**: The primary entity (a quest) **must be represented with a `struct`** named `QuestNode` (or equivalent) containing at least the fields `id`, `heroName`, `duration`, and a pointer to the next node.  \n- **Display Function**: The logic for showing the details of **one specific quest** must reside in a **function called `displayQuest`** that takes a pointer to a `QuestNode` and prints the fields in the format shown in the example.  \n- **Memory Management**: All nodes allocated on the heap must be freed before the program terminates (e.g., when exiting).  \n- **Menu Requirement**: The program **must include a menu option to EXIT the program** (option\u202f5 in the example). Selecting this option ends the loop and frees any remaining list memory.  \n- **Single\u2011Responsibility Functions**: Apart from `main`, you may create additional helper functions (e.g., `addQuest`, `deleteQuest`, `searchQuest`, `listQuests`), but each should perform a clearly defined sub\u2011task.  \n\n*The problem is intended for students who have just learned how to build and manipulate singly linked lists. The specifications are deliberately straightforward to focus on correct list operations, struct usage, and basic I/O.*", "model": "openai/gpt-oss-120b", "iteration": 32}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe city\u2019s public\u2011transport authority is modernizing its bus\u2011tracking system. Each bus that is currently on the road is represented by a **BusRecord** that stores the bus\u2019s unique identifier, its current route number, and the number of passengers on board. The authority wants a simple console program that lets an operator add new buses, remove buses that have completed their routes, and query the list of active buses.  \n\nYour task is to implement this system using a **singly linked list**. The list will hold the `BusRecord` structures in the order they are entered (i.e., insertion at the tail). The operator will interact with the program through a text\u2011based menu.\n\n## Requirements  \n\n1. **Data Entity**  \n   * Define a `struct` named `BusRecord` with the following fields:  \n     - `int id` \u2013 unique bus identifier (positive integer)  \n     - `int route` \u2013 route number (positive integer)  \n     - `int passengers` \u2013 number of passengers currently on board (non\u2011negative integer)  \n\n2. **Menu\u2011driven Operations** (the program must display a menu and process the user\u2019s choice)  \n   * **1. Add a bus** \u2013 Prompt for `id`, `route`, and `passengers`; create a new node and append it to the tail of the list.  \n   * **2. Remove a bus** \u2013 Prompt for a bus `id`; locate the node with that `id` and delete it from the list. If the `id` is not found, display an appropriate message.  \n   * **3. Display all buses** \u2013 Traverse the list and print each bus\u2019s details on a separate line in the format:  \n     `Bus <id>: Route <route>, Passengers <passengers>`  \n   * **4. Display a specific bus** \u2013 Prompt for a bus `id` and invoke a dedicated function `displayBus` to print the details of that single bus in the same format as above. If the `id` does not exist, inform the user.  \n   * **5. EXIT** \u2013 Terminate the program gracefully.  \n\n3. **Memory Management**  \n   * Allocate nodes dynamically (e.g., using `malloc`/`new`).  \n   * Free memory for a node when it is removed and also free the entire list before program exit.  \n\n4. **Input Validation**  \n   * The menu choice must be an integer between 1 and 5.  \n   * Bus `id` values must be positive and unique when adding a new bus. If a duplicate `id` is entered, reject the addition with an explanatory message.  \n\n## Example Interaction  \n\n```\n=== Bus Tracking System ===\n1) Add a bus\n2) Remove a bus\n3) Display all buses\n4) Display a specific bus\n5) EXIT\nEnter choice: 1\nEnter bus id: 101\nEnter route number: 12\nEnter passenger count: 35\nBus added.\n\n=== Bus Tracking System ===\n1) Add a bus\n2) Remove a bus\n3) Display all buses\n4) Display a specific bus\n5) EXIT\nEnter choice: 1\nEnter bus id: 202\nEnter route number: 7\nEnter passenger count: 20\nBus added.\n\n=== Bus Tracking System ===\n1) Add a bus\n2) Remove a bus\n3) Display all buses\n4) Display a specific bus\n5) EXIT\nEnter choice: 3\nBus 101: Route 12, Passengers 35\nBus 202: Route 7, Passengers 20\n\n=== Bus Tracking System ===\n1) Add a bus\n2) Remove a bus\n3) Display all buses\n4) Display a specific bus\n5) EXIT\nEnter choice: 4\nEnter bus id to display: 202\nBus 202: Route 7, Passengers 20\n\n=== Bus Tracking System ===\n1) Add a bus\n2) Remove a bus\n3) Display all buses\n4) Display a specific bus\n5) EXIT\nEnter choice: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n1. **Structure Requirement** \u2013 The primary data entity must be represented with a `struct` named `BusRecord`.  \n2. **Function Requirement** \u2013 The logic that prints the details of **one** specific bus must reside in a function with the exact prototype:  \n\n   ```c\n   void displayBus(const BusRecord *bus);\n   ```\n\n   (or the equivalent in C++/Java/Python with the same name).  \n3. **Single\u2011purpose Helper Functions** \u2013 Apart from `main`, you may create additional helper functions, but each distinct operation (add, remove, display all, display one) must be encapsulated in its own function.  \n4. **Menu Exit Option** \u2013 The menu must include the option **5) EXIT** (or the keyword `EXIT`) that ends the program.  \n\n*The problem is intended for students who have just learned how to implement a singly linked list, dynamic memory allocation, and basic modular programming.*", "model": "openai/gpt-oss-120b", "iteration": 33}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe campus library is modernizing its inventory system. Each book in the collection is identified by a **call number** (an integer) and has a **title** (a short string). The library wants a simple console application that stores the books in the order they are received, allows staff to add new books, remove the oldest book, and look up a book by its call number. Because the number of books can change dynamically, the data must be kept in a **singly linked list**.\n\n## Requirements  \nWrite a program that implements the following functionality:\n\n1. **Add a book** \u2013 Prompt the user for a call number and a title, then insert the new book at the **tail** of the list (i.e., after all existing books).  \n2. **Remove the oldest book** \u2013 Delete the node at the **head** of the list and display the removed book\u2019s details. If the list is empty, print an appropriate message.  \n3. **Find a book** \u2013 Prompt for a call number, search the list, and display the title of the matching book. If the call number is not present, inform the user.  \n4. **Display all books** \u2013 Traverse the list from head to tail and print each book\u2019s call number and title in the order they were added.  \n5. **Exit** \u2013 Terminate the program gracefully.\n\nThe program should present a text\u2011based menu that repeatedly asks the user to choose one of the actions above.\n\n## Example Input / Output  \n\n```\n=== Library Book Manager ===\n1. Add a book\n2. Remove the oldest book\n3. Find a book by call number\n4. Display all books\n5. EXIT\nChoose an option: 1\n\nEnter call number: 1023\nEnter title: Introduction to Algorithms\nBook added.\n\n=== Library Book Manager ===\n1. Add a book\n2. Remove the oldest book\n3. Find a book by call number\n4. Display all books\n5. EXIT\nChoose an option: 1\n\nEnter call number: 2045\nEnter title: Data Structures in C\nBook added.\n\n=== Library Book Manager ===\n1. Add a book\n2. Remove the oldest book\n3. Find a book by call number\n4. Display all books\n5. EXIT\nChoose an option: 4\n\nCurrent collection:\n[1023] Introduction to Algorithms\n[2045] Data Structures in C\n\n=== Library Book Manager ===\n1. Add a book\n2. Remove the oldest book\n3. Find a book by call number\n4. Display all books\n5. EXIT\nChoose an option: 3\n\nEnter call number to find: 2045\nTitle: Data Structures in C\n\n=== Library Book Manager ===\n1. Add a book\n2. Remove the oldest book\n3. Find a book by call number\n4. Display all books\n5. EXIT\nChoose an option: 2\n\nRemoved book: [1023] Introduction to Algorithms\n\n=== Library Book Manager ===\n1. Add a book\n2. Remove the oldest book\n3. Find a book by call number\n4. Display all books\n5. EXIT\nChoose an option: 5\n\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n- The primary data entity **must be represented with a `struct`** named `BookNode` containing at least:\n  - `int callNumber;`\n  - `char title[101];` (titles are limited to 100 characters plus the null terminator)\n  - `struct BookNode *next;`\n- The logic for displaying the details of **ONE specific book** (used when a book is found or removed) **must be placed in a function called `displayBook(const BookNode *node)`**.\n- All list manipulation (insertion, deletion, search, traversal) should be performed in functions separate from `main()`. You may create as many helper functions as needed, but **no more than one additional function besides `main()` may be used for each distinct operation** (e.g., `addBook`, `removeHead`, `findBook`, `printAll`).\n- **If a menu is implemented (as required), the menu must include an explicit option to EXIT the program**. In the example above this is option `5`. The exit option must be clearly labeled and must cause the program to terminate without further prompts.\n\n*Note: The problem is intended for students who have just learned singly linked lists, structs, and basic modular programming.*", "model": "openai/gpt-oss-120b", "iteration": 34}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe campus library wants a tiny command\u2011line utility to keep track of the books that are currently on a single shelf.  Each book is identified by an **ISBN**, has a **title**, and a **year of publication**.  The librarian will manually add books to the shelf, remove them when they are taken off, and occasionally request a listing of all books or the details of a specific ISBN.  \n\nYour task is to implement this utility using a **singly linked list**.  The list must be built from scratch (no STL containers, no `vector`, etc.) and must reflect the order in which books are added \u2013 new books are appended to the tail of the list.\n\n## Requirements  \n\nWrite a program that provides a **menu\u2011driven** interface with the following options:\n\n1. **Add a new book** \u2013 Prompt for ISBN (string, no spaces), title (string, may contain spaces), and year (integer).  Append the new book to the end of the list.  \n2. **Remove a book** \u2013 Prompt for an ISBN.  If a node with that ISBN exists, delete it from the list and free its memory; otherwise, print \u201cBook not found.\u201d  \n3. **Display all books** \u2013 Traverse the list from head to tail and print each book on its own line in the format:  \n   `ISBN | Title | Year`  \n   If the list is empty, print \u201cNo books on the shelf.\u201d  \n4. **Search for a book by ISBN** \u2013 Prompt for an ISBN and, if found, display that single book\u2019s details using the required helper function (see Constraints). If not found, print \u201cBook not found.\u201d  \n5. **Exit** \u2013 Terminate the program gracefully.\n\nThe program should loop until the user selects the **Exit** option.\n\n## Example Interaction  \n\n```\n--- Library Shelf Manager ---\n1) Add book\n2) Remove book\n3) Display all books\n4) Search by ISBN\n5) Exit\nChoose an option: 1\nEnter ISBN: 9780131103627\nEnter title: The C Programming Language\nEnter year: 1978\nBook added.\n\n--- Library Shelf Manager ---\n1) Add book\n2) Remove book\n3) Display all books\n4) Search by ISBN\n5) Exit\nChoose an option: 1\nEnter ISBN: 9780201633610\nEnter title: Design Patterns\nEnter year: 1994\nBook added.\n\n--- Library Shelf Manager ---\n1) Add book\n2) Remove book\n3) Display all books\n4) Search by ISBN\n5) Exit\nChoose an option: 3\n9780131103627 | The C Programming Language | 1978\n9780201633610 | Design Patterns | 1994\n\n--- Library Shelf Manager ---\n1) Add book\n2) Remove book\n3) Display all books\n4) Search by ISBN\n5) Exit\nChoose an option: 4\nEnter ISBN to search: 9780201633610\n9780201633610 | Design Patterns | 1994\n\n--- Library Shelf Manager ---\n1) Add book\n2) Remove book\n3) Display all books\n4) Search by ISBN\n5) Exit\nChoose an option: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Data Representation** \u2013 The primary entity (a book) must be stored in a `struct` named `BookNode` that contains the ISBN, title, year, and a pointer to the next node.  \n* **Helper Function** \u2013 The logic for displaying the details of **ONE specific book** must reside in a function with the exact prototype:  \n  ```c\n  void displayBook(const BookNode *node);\n  ```  \n  This function should print the book in the format `ISBN | Title | Year` followed by a newline.  \n* **Menu Implementation** \u2013 The menu must include an explicit option to **EXIT** the program (option 5 in the example). Selecting this option must end the program without memory leaks.  \n* **Memory Management** \u2013 Every `malloc`/`new` (depending on language) must have a corresponding `free`/`delete` when a node is removed or when the program terminates.  \n* **Single\u2011File Requirement** \u2013 All code must reside in a single source file; you may define additional static/helper functions, but no separate compilation units.  \n\nFeel free to choose C, C++, or any language that lets you manually manage a singly linked list and satisfy the constraints above.", "model": "openai/gpt-oss-120b", "iteration": 35}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe campus library is modernizing its inventory system.  The librarian wants a simple console program that can keep track of **books** as they are added, removed, or searched.  Each book is identified by a unique integer **ISBN**, has a **title**, and a **year of publication**.  Because the library\u2019s collection is constantly changing, a **singly linked list** is an appropriate data structure: new books are appended to the end of the list, and deletions can occur anywhere in the list.\n\nYou have just finished a unit on singly linked lists.  Write a program that implements the required operations using a linked list.\n\n## Requirements  \n\nYour program must provide a **menu\u2011driven interface** with the following options (the numbers are mandatory):\n\n1. **Add a new book** \u2013 Prompt for ISBN, title, and year, then insert the new node at the **end** of the list.  \n2. **Delete a book** \u2013 Prompt for an ISBN; if a node with that ISBN exists, remove it from the list and free its memory; otherwise display \u201cBook not found.\u201d  \n3. **Search for a book** \u2013 Prompt for an ISBN; if found, display the book\u2019s details; otherwise display \u201cBook not found.\u201d  \n4. **Display all books** \u2013 Traverse the list from head to tail, printing each book on a separate line in the order they were added.  \n5. **EXIT** \u2013 Terminate the program gracefully.\n\nAdditional functional requirements:\n\n- The list must be **initially empty**.\n- ISBN values are guaranteed to be positive integers and unique for each insertion.\n- Title may contain spaces; read it as a whole line.\n- Year is a four\u2011digit integer.\n- All user prompts and messages should be clear but need not follow an exact wording beyond the required output shown in the example.\n\n## Example Input / Output  \n\n```\n--- Library Book Manager ---\n1. Add a new book\n2. Delete a book\n3. Search for a book\n4. Display all books\n5. EXIT\nChoose an option: 1\nEnter ISBN: 9780131103627\nEnter title: The C Programming Language\nEnter year: 1978\nBook added.\n\n--- Library Book Manager ---\n1. Add a new book\n2. Delete a book\n3. Search for a book\n4. Display all books\n5. EXIT\nChoose an option: 1\nEnter ISBN: 9780201616224\nEnter title: The Pragmatic Programmer\nEnter year: 1999\nBook added.\n\n--- Library Book Manager ---\n1. Add a new book\n2. Delete a book\n3. Search for a book\n4. Display all books\n5. EXIT\nChoose an option: 4\nISBN: 9780131103627 | Title: The C Programming Language | Year: 1978\nISBN: 9780201616224 | Title: The Pragmatic Programmer | Year: 1999\n\n--- Library Book Manager ---\n1. Add a new book\n2. Delete a book\n3. Search for a book\n4. Display all books\n5. EXIT\nChoose an option: 3\nEnter ISBN to search: 9780201616224\nISBN: 9780201616224 | Title: The Pragmatic Programmer | Year: 1999\n\n--- Library Book Manager ---\n1. Add a new book\n2. Delete a book\n3. Search for a book\n4. Display all books\n5. EXIT\nChoose an option: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n1. **Data Representation** \u2013 The primary data entity (a book) must be represented with a `struct` named `BookNode` (or equivalent) containing at least the fields `int isbn; char title[100]; int year; struct BookNode *next;`.  \n2. **Display Function** \u2013 The logic for showing the details of **one specific book** (used in the \u201cSearch\u201d option) must reside in a function with the exact prototype:  \n\n   ```c\n   void displayBook(const BookNode *node);\n   ```  \n\n3. **Function Count** \u2013 Apart from `int main(void)`, the entire solution may contain **only one additional user\u2011defined function** (i.e., `displayBook`). All list manipulation (add, delete, traverse, search) must be performed directly inside `main` or helper code placed inside `main`\u2019s body.  \n4. **Menu Exit Option** \u2013 The menu must include the option **5. EXIT** (or the keyword \u201cEXIT\u201d) that terminates the program. Selecting this option must end the program without memory leaks.  \n\n*Note:* The problem is deliberately restrictive to encourage careful organization of code within `main`.", "model": "openai/gpt-oss-120b", "iteration": 36}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe local **Community Wildlife Sanctuary** wants a simple console\u2011based system to keep track of the animals that are currently in its care.  Each animal has a name, species, and an integer identifier (ID).  The sanctuary staff are not programmers, so the program must be easy to use: a text menu that lets them **add**, **remove**, **search**, and **list** animals.  \n\nYou have just finished the lecture on **singly linked lists**.  Implement the required functionality using a singly linked list to store the animal records.\n\n---\n\n## Requirements  \n\n1. **Data representation**  \n   * Define a `struct` named `Animal` that stores:  \n     - `int id` \u2013 a unique identifier (positive integer)  \n     - `char name[50]` \u2013 the animal\u2019s name (no spaces)  \n     - `char species[30]` \u2013 the species name (no spaces)  \n   * The linked\u2011list node must contain an `Animal` object and a pointer to the next node.\n\n2. **Menu\u2011driven program** (displayed repeatedly until the user chooses to exit)  \n   * **1. Add a new animal** \u2013 prompt for `id`, `name`, and `species`; insert the new node at the **head** of the list.  \n   * **2. Remove an animal by ID** \u2013 prompt for an `id`; delete the first node whose `id` matches. If no such animal exists, print a suitable message.  \n   * **3. Search for an animal by name** \u2013 prompt for a `name`; traverse the list and display the details of the first matching animal (use the required display function). If not found, report it.  \n   * **4. List all animals** \u2013 traverse the list from head to tail and display each animal\u2019s details (use the required display function). If the list is empty, print \u201cNo animals recorded.\u201d  \n   * **5. EXIT** \u2013 terminate the program.  \n\n3. **Display function**  \n   * Implement a function `void displayAnimal(const Animal *a)` that prints an animal\u2019s details in the format:  \n     ```\n     ID: <id>, Name: <name>, Species: <species>\n     ```\n\n4. **Memory management**  \n   * Allocate nodes dynamically (`malloc`/`new` depending on language).  \n   * Free memory for a node when it is removed and also before program termination.\n\n5. **Input validation**  \n   * Assume the user enters data of the correct type; you do not need to handle malformed input beyond the menu choice.\n\n---\n\n## Example Interaction  \n\n```\n=== Sanctuary Animal Tracker ===\n1. Add a new animal\n2. Remove an animal by ID\n3. Search for an animal by name\n4. List all animals\n5. EXIT\nChoose an option: 1\nEnter ID: 101\nEnter name: Leo\nEnter species: Lion\nAnimal added.\n\n=== Sanctuary Animal Tracker ===\n1. Add a new animal\n2. Remove an animal by ID\n3. Search for an animal by name\n4. List all animals\n5. EXIT\nChoose an option: 1\nEnter ID: 202\nEnter name: Maya\nEnter species: Meerkat\nAnimal added.\n\n=== Sanctuary Animal Tracker ===\n1. Add a new animal\n2. Remove an animal by ID\n3. Search for an animal by name\n4. List all animals\n5. EXIT\nChoose an option: 4\nID: 202, Name: Maya, Species: Meerkat\nID: 101, Name: Leo, Species: Lion\n\n=== Sanctuary Animal Tracker ===\n1. Add a new animal\n2. Remove an animal by ID\n3. Search for an animal by name\n4. List all animals\n5. EXIT\nChoose an option: 3\nEnter name to search: Leo\nID: 101, Name: Leo, Species: Lion\n\n=== Sanctuary Animal Tracker ===\n1. Add a new animal\n2. Remove an animal by ID\n3. Search for an animal by name\n4. List all animals\n5. EXIT\nChoose an option: 2\nEnter ID to remove: 202\nAnimal removed.\n\n=== Sanctuary Animal Tracker ===\n1. Add a new animal\n2. Remove an animal by ID\n3. Search for an animal by name\n4. List all animals\n5. EXIT\nChoose an option: 5\nGoodbye!\n```\n\n---\n\n### CONSTRAINTS  \n\n* **Struct usage** \u2013 The primary data entity must be represented with a `struct` named `Animal`.  \n* **Display function** \u2013 All printing of an animal\u2019s details must be performed by a function called `displayAnimal`.  \n* **Menu requirement** \u2013 The program must present a menu as described above and **must include an explicit EXIT option (option 5)** that terminates the program.  \n* **Single\u2011responsibility functions** \u2013 Apart from `main`, you may create additional helper functions (e.g., for insertion, deletion, searching), but the only function that directly prints an animal\u2019s fields is `displayAnimal`.  \n\n*Optional language note*: The problem can be solved in C, C++, or any language that supports structs/classes and manual dynamic memory allocation. The essential constraints remain the same.", "model": "openai/gpt-oss-120b", "iteration": 37}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe city of **Algoria** is preparing for the annual **Treasure Hunt Festival**.  Contest organizers need a simple computer program to keep track of the **magical artifacts** that participants discover during the event.  Each artifact has a unique identifier, a name, and a point value.  Because the list of artifacts can grow and shrink throughout the day, a **singly linked list** is the most appropriate data structure.\n\nYou have just finished the lecture on singly linked lists and are asked to write the program that the organizers will run on a laptop at the registration desk.\n\n## Requirements  \n\nWrite a C (or C\u2011like) program that provides the following functionality through a text\u2011based menu:\n\n1. **Add a new artifact** to the **end** of the list.  \n   - Prompt the user for the artifact\u2019s **ID** (integer), **name** (single\u2011word string, up to 31 characters), and **point value** (integer).  \n2. **Remove an artifact** by its ID.  \n   - If the ID is not found, display an appropriate message.  \n3. **Display all artifacts** in the order they appear in the list, one per line, showing ID, name, and points.  \n4. **Search for an artifact** by ID and display its details.  \n   - The logic that prints the details of a single artifact **must** be placed in a function named `displayArtifact`.  \n5. **Exit** the program.  \n\nThe menu must be displayed after each operation until the user chooses to exit.\n\n## Example Input / Output  \n\n```\n=== Algoria Treasure Hunt Inventory ===\n1) Add artifact\n2) Remove artifact\n3) List all artifacts\n4) Find artifact by ID\n5) EXIT\nChoose an option: 1\nEnter artifact ID: 101\nEnter artifact name: GoldenCup\nEnter point value: 250\nArtifact added.\n\n=== Algoria Treasure Hunt Inventory ===\n1) Add artifact\n2) Remove artifact\n3) List all artifacts\n4) Find artifact by ID\n5) EXIT\nChoose an option: 1\nEnter artifact ID: 102\nEnter artifact name: SilverSword\nEnter point value: 180\nArtifact added.\n\n=== Algoria Treasure Hunt Inventory ===\n1) Add artifact\n2) Remove artifact\n3) List all artifacts\n4) Find artifact by ID\n5) EXIT\nChoose an option: 3\nCurrent artifacts:\n[101] GoldenCup \u2013 250 points\n[102] SilverSword \u2013 180 points\n\n=== Algoria Treasure Hunt Inventory ===\n1) Add artifact\n2) Remove artifact\n3) List all artifacts\n4) Find artifact by ID\n5) EXIT\nChoose an option: 4\nEnter artifact ID to search: 102\n[102] SilverSword \u2013 180 points\n\n=== Algoria Treasure Hunt Inventory ===\n1) Add artifact\n2) Remove artifact\n3) List all artifacts\n4) Find artifact by ID\n5) EXIT\nChoose an option: 5\nGood\u2011bye!\n```\n\n## ### CONSTRAINTS  \n\n- **Data Representation**: The primary entity **must** be represented by a `struct` named `Artifact` containing at least the fields `id` (int), `name` (char array of length 32), `points` (int), and a pointer to the next node.  \n- **Function Requirement**: The code that prints the details of a single artifact **must** reside in a function with the exact prototype `void displayArtifact(const Artifact *a);`.  \n- **Menu Implementation**: The program must present a textual menu as shown above and **must include** an explicit option to **EXIT** the program (option 5 in the example). Selecting this option terminates the program gracefully.  \n- **Memory Management**: All dynamically allocated nodes must be freed before program termination.  \n- **Single\u2011File Submission**: The entire solution should be contained in one source file (e.g., `main.c`). Apart from `main`, you may create additional helper functions, but the core list operations (add, remove, search, display) should each be encapsulated in their own functions.  \n\n---  \n\n*Design the program so that a student who has just completed the lecture on singly linked lists can implement it correctly, respecting all constraints.*", "model": "openai/gpt-oss-120b", "iteration": 38}, {"text": "# STEP 1: PROBLEM  \n\n**Background**  \nThe campus bookstore wants a simple console\u2011based system to keep track of the books that are currently on the shelves. Each book is identified by a unique ISBN, has a title, and a quantity indicating how many copies are available. The store manager has asked you to write a program that stores the books in a **singly linked list** and provides a small menu\u2011driven interface for common operations.\n\n**Program Requirements**  \n\n1. **Data Representation**  \n   * Define a `struct` called `BookNode` that stores:  \n     - `char isbn[20]` \u2013 the book\u2019s ISBN (no spaces).  \n     - `char title[100]` \u2013 the book\u2019s title (may contain spaces).  \n     - `int quantity` \u2013 number of copies on the shelf.  \n     - `BookNode *next` \u2013 pointer to the next node.  \n\n2. **Menu\u2011driven Interface** (the program must present a menu repeatedly until the user chooses to exit)  \n\n   | Option | Description |\n   |--------|-------------|\n   | 1 | **Add a new book** \u2013 Prompt for ISBN, title, and quantity, then insert the new node at the **end** of the list. If a book with the same ISBN already exists, increase its `quantity` by the entered amount instead of adding a new node. |\n   | 2 | **Remove a book** \u2013 Prompt for an ISBN. If the book exists, delete its node from the list and free the memory. If it does not exist, print \u201cBook not found.\u201d |\n   | 3 | **Search for a book** \u2013 Prompt for an ISBN and, if found, display its details using a function named `displayBook`. If not found, print \u201cBook not found.\u201d |\n   | 4 | **List all books** \u2013 Traverse the list and display every book\u2019s details (ISBN, title, quantity) using `displayBook`. If the list is empty, print \u201cNo books in inventory.\u201d |\n   | 5 | **EXIT** \u2013 Terminate the program. *(This option must be present as the explicit way to end the program.)* |\n\n3. **Functional Details**  \n   * All input should be read from `stdin`; all output should be written to `stdout`.  \n   * The program must **not** leak memory \u2013 every allocated node must be freed before the program terminates.  \n   * The function `void displayBook(const BookNode *node);` must be responsible for printing a single book in the format:  \n     ```\n     ISBN: <isbn>, Title: <title>, Quantity: <quantity>\n     ```\n   * The main menu loop should be implemented in `main()`; all other operations (add, remove, search, list) must be performed in separate helper functions of your choice.\n\n**Example Interaction**  \n\n```\n--- Book Inventory Menu ---\n1. Add a new book\n2. Remove a book\n3. Search for a book\n4. List all books\n5. EXIT\nEnter choice: 1\nEnter ISBN: 9780131103627\nEnter title: The C Programming Language\nEnter quantity: 3\nBook added.\n\n--- Book Inventory Menu ---\n1. Add a new book\n2. Remove a book\n3. Search for a book\n4. List all books\n5. EXIT\nEnter choice: 1\nEnter ISBN: 9780131103627\nEnter title: The C Programming Language\nEnter quantity: 2\nBook already exists; quantity updated.\n\n--- Book Inventory Menu ---\n1. Add a new book\n2. Remove a book\n3. Search for a book\n4. List all books\n5. EXIT\nEnter choice: 4\nISBN: 9780131103627, Title: The C Programming Language, Quantity: 5\n\n--- Book Inventory Menu ---\n1. Add a new book\n2. Remove a book\n3. Search for a book\n4. List all books\n5. EXIT\nEnter choice: 5\nGoodbye!\n```\n\n### CONSTRAINTS  \n\n- **Struct Requirement:** The primary data entity must be represented by a `struct` named `BookNode`.  \n- **Display Function:** The logic for displaying the details of **ONE** specific book must reside in a function called `displayBook`.  \n- **Menu Exit Option:** The menu must contain an explicit option (number\u202f5) labeled **EXIT** that terminates the program.  \n- **Memory Management:** No memory leaks are allowed; every node created with `malloc`/`new` must be freed before program termination.  \n- **Language:** The solution must be written in C (or C++ if you prefer, but the struct and function signatures must match the description above).  \n\n*Write a complete program that satisfies all of the above requirements.*", "model": "openai/gpt-oss-120b", "iteration": 39}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe city\u2019s public transportation department is modernizing its bus\u2011tracking system. Each bus is identified by a unique integer **BusID** and carries a short textual **RouteName** (e.g., \u201cDowntown\u2011Airport\u201d). The department wants a simple console program that lets an operator add, remove, and view buses in the order they are reported to the system. Because the order of arrival matters, the operator must store the buses in a **singly linked list**.\n\n## Requirements  \nWrite a C (or C++) program that implements the bus list with the following capabilities:\n\n1. **Add a bus** \u2013 Append a new bus node to the end of the list. The operator supplies the `BusID` (positive integer) and `RouteName` (a single word, max 30 characters).  \n2. **Delete a bus** \u2013 Remove the first node whose `BusID` matches a value supplied by the operator. If no such bus exists, print an informative message.  \n3. **Display all buses** \u2013 Traverse the list from head to tail, printing each bus\u2019s `BusID` and `RouteName` on its own line.  \n4. **Display a specific bus** \u2013 Given a `BusID`, locate that node and print its details using a dedicated function `displayBus`. If the bus is not found, print an appropriate message.  \n5. **Count buses** \u2013 Show the total number of buses currently stored.  \n6. **Exit** \u2013 Terminate the program gracefully.\n\nThe program should present a text\u2011based menu that repeatedly prompts the user for one of the actions above until the **Exit** option is chosen.\n\n## Example Interaction  \n\n```\n=== Bus Management System ===\n1. Add a bus\n2. Delete a bus\n3. Display all buses\n4. Display a specific bus\n5. Count buses\n6. Exit\nSelect an option: 1\nEnter BusID: 101\nEnter RouteName: DowntownAirport\n\nBus added successfully.\n\n=== Bus Management System ===\n1. Add a bus\n2. Delete a bus\n3. Display all buses\n4. Display a specific bus\n5. Count buses\n6. Exit\nSelect an option: 1\nEnter BusID: 202\nEnter RouteName: MidtownLoop\n\nBus added successfully.\n\n=== Bus Management System ===\n1. Add a bus\n2. Delete a bus\n3. Display all buses\n4. Display a specific bus\n5. Count buses\n6. Exit\nSelect an option: 3\n\nCurrent buses:\nBusID: 101, RouteName: DowntownAirport\nBusID: 202, RouteName: MidtownLoop\n\n=== Bus Management System ===\n1. Add a bus\n2. Delete a bus\n3. Display all buses\n4. Display a specific bus\n5. Count buses\n6. Exit\nSelect an option: 4\nEnter BusID to display: 202\nBusID: 202, RouteName: MidtownLoop\n\n=== Bus Management System ===\n1. Add a bus\n2. Delete a bus\n3. Display all buses\n4. Display a specific bus\n5. Count buses\n6. Exit\nSelect an option: 5\nTotal buses: 2\n\n=== Bus Management System ===\n1. Add a bus\n2. Delete a bus\n3. Display all buses\n4. Display a specific bus\n5. Count buses\n6. Exit\nSelect an option: 6\n\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n- **Data Representation**: Use a `struct` named `Bus` to represent each node. The struct must contain at least:\n  - `int busID;`\n  - `char routeName[31];` (enough space for a 30\u2011character name plus the terminating null)\n  - `struct Bus *next;`\n- **Function Requirement**: The logic for printing the details of **one** bus must reside in a function with the exact prototype:\n  ```c\n  void displayBus(const struct Bus *b);\n  ```\n- **Program Structure**: Apart from `main()`, you may create **only one additional function** (the required `displayBus`). All other list operations (add, delete, traverse, count) must be implemented directly inside `main()` or as static inline code blocks.\n- **Menu**: The program must present a menu as shown in the example, and **option 6 must be the explicit \u201cExit\u201d command** that ends the program.\n- **Memory Management**: Every node allocated with `malloc` (or `new` if using C++) must be freed appropriately when deleted or when the program terminates. No memory leaks are allowed.  \n\n---  \n\n*Deliver a complete, compilable source file that satisfies all the above constraints.*", "model": "openai/gpt-oss-120b", "iteration": 40}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe campus library is modernizing its \u201cquick\u2011checkout\u201d system.  When a patron arrives, the librarian scans the patron\u2019s ID and then repeatedly adds the titles of the books the patron wishes to borrow.  The books are stored in the order they are scanned, and the librarian can at any time:\n\n* view the current list of books,  \n* remove the most recently scanned book (e.g., if the patron changes their mind), or  \n* clear the entire list when the transaction is finished.\n\nYour task is to implement this \u201ccheckout list\u201d as a **singly linked list**.  The program must be menu\u2011driven so that the librarian can interact with it from the console.\n\n---\n\n## Requirements  \n\n1. **Data Entity**  \n   * Define a `struct` (or equivalent) named `BookNode` that stores:  \n     - `char title[101]` \u2013 the book title (maximum 100 characters, null\u2011terminated).  \n     - `BookNode *next` \u2013 pointer to the next node.  \n\n2. **Core Operations (menu options)**  \n   * **1 \u2013 Add Book** \u2013 Prompt the user for a title and insert a new node at the **tail** of the list.  \n   * **2 \u2013 Remove Last Book** \u2013 Delete the node at the tail (if the list is not empty) and display the title that was removed.  \n   * **3 \u2013 Show All Books** \u2013 Traverse the list from head to tail and print each title on its own line, preceded by its position in the list (starting at\u202f1).  \n   * **4 \u2013 Clear List** \u2013 Delete **all** nodes, freeing memory, and report how many books were removed.  \n   * **5 \u2013 EXIT** \u2013 Terminate the program gracefully (see mandatory constraint).  \n\n3. **Helper Function**  \n   * Implement a function `void displayBook(const BookNode *node);` that prints a single book title in the format `Title: <title>`.  \n   * This function **must** be used by the \u201cShow All Books\u201d and \u201cRemove Last Book\u201d options when they need to display a title.\n\n4. **Memory Management**  \n   * Every allocated node must be freed exactly once.  \n   * The program must not leak memory, even when the user exits without clearing the list.\n\n5. **User Interaction**  \n   * After completing any operation (except EXIT), the menu should be displayed again.  \n   * Input errors (e.g., selecting a non\u2011existent menu number) should be handled with an informative message and a redisplay of the menu.\n\n---\n\n## Example Input / Output  \n\n```\n--- Library Checkout System ---\n1) Add Book\n2) Remove Last Book\n3) Show All Books\n4) Clear List\n5) EXIT\nSelect an option: 1\nEnter book title: The C Programming Language\nBook added.\n\n--- Library Checkout System ---\n1) Add Book\n2) Remove Last Book\n3) Show All Books\n4) Clear List\n5) EXIT\nSelect an option: 1\nEnter book title: Introduction to Algorithms\nBook added.\n\n--- Library Checkout System ---\n1) Add Book\n2) Remove Last Book\n3) Show All Books\n4) Clear List\n5) EXIT\nSelect an option: 3\n1. Title: The C Programming Language\n2. Title: Introduction to Algorithms\n\n--- Library Checkout System ---\n1) Add Book\n2) Remove Last Book\n3) Show All Books\n4) Clear List\n5) EXIT\nSelect an option: 2\nRemoved book: Introduction to Algorithms\n\n--- Library Checkout System ---\n1) Add Book\n2) Remove Last Book\n3) Show All Books\n4) Clear List\n5) EXIT\nSelect an option: 4\nCleared 1 book(s) from the list.\n\n--- Library Checkout System ---\n1) Add Book\n2) Remove Last Book\n3) Show All Books\n4) Clear List\n5) EXIT\nSelect an option: 5\nGoodbye!\n```\n\n---\n\n### CONSTRAINTS  \n\n* **Struct Requirement** \u2013 The primary data entity must be a `struct` named `BookNode`.  \n* **Display Function** \u2013 The function `void displayBook(const BookNode *node);` must contain the logic for printing a single book\u2019s details and must be called wherever a single book title needs to be shown.  \n* **Menu Exit** \u2013 The menu must include option **5 \u2013 EXIT** (or the exact keyword \u201cEXIT\u201d) that terminates the program.  \n* **Single\u2011File Implementation** \u2013 All code must reside in a single source file; only `main()` and the required helper functions (`displayBook` and any internal list\u2011management helpers) are permitted.  \n* **No Global Variables** \u2013 All list pointers must be managed within `main()` (or passed as parameters); global variables are not allowed.  \n\n---  \n\n*Design your solution to be clear, modular, and memory\u2011safe. Good luck!*", "model": "openai/gpt-oss-120b", "iteration": 41}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe campus bookstore wants a simple command\u2011line tool to keep track of the books that are currently on the shelves. Each book is identified by a unique integer **ID**, has a **title**, and a **price** (in dollars). The store clerk will run the program each day, adding new arrivals, removing books that have been sold, and looking up information about specific titles.  \n\nYour task is to implement this tool using a **singly linked list**. The list will store the books in the order they are added (i.e., new books are appended to the tail of the list).\n\n## Program Requirements  \n\nYour program must provide a text\u2011based menu with the following options:\n\n1. **Add a new book** \u2013 Prompt for `ID`, `title`, and `price`. Append the new book to the end of the list. If a book with the same `ID` already exists, display an error and do not insert.\n2. **Remove a book by ID** \u2013 Prompt for an `ID`. Delete the node containing that `ID`. If the `ID` is not found, display an appropriate message.\n3. **Search for a book by title** \u2013 Prompt for a `title` (case\u2011insensitive exact match). If found, display the book\u2019s details using the required `displayBook` function; otherwise, report that the book does not exist.\n4. **Display all books** \u2013 Traverse the list from head to tail and display each book\u2019s details (one per line) using `displayBook`.\n5. **Exit** \u2013 Terminate the program. *(The menu must include this option as the explicit way to quit.)*\n\nAdditional functional details:\n\n- The list must be **singly linked**; you may not use arrays or library containers (e.g., `std::vector`).\n- All input validation (e.g., non\u2011negative price, unique ID) must be performed.\n- After completing any operation (except Exit), the menu should be shown again.\n\n## Example Interaction  \n\n```\n=== Bookstore Inventory Menu ===\n1. Add a new book\n2. Remove a book by ID\n3. Search for a book by title\n4. Display all books\n5. Exit\nChoose an option: 1\n\nEnter Book ID: 101\nEnter Title: Data Structures in C\nEnter Price: 59.99\nBook added successfully.\n\n=== Bookstore Inventory Menu ===\n1. Add a new book\n2. Remove a book by ID\n3. Search for a book by title\n4. Display all books\n5. Exit\nChoose an option: 1\n\nEnter Book ID: 102\nEnter Title: Algorithms Unlocked\nEnter Price: 45.00\nBook added successfully.\n\n=== Bookstore Inventory Menu ===\n1. Add a new book\n2. Remove a book by ID\n3. Search for a book by title\n4. Display all books\n5. Exit\nChoose an option: 4\n\nID: 101 | Title: Data Structures in C | Price: $59.99\nID: 102 | Title: Algorithms Unlocked   | Price: $45.00\n\n=== Bookstore Inventory Menu ===\n1. Add a new book\n2. Remove a book by ID\n3. Search for a book by title\n4. Display all books\n5. Exit\nChoose an option: 3\n\nEnter Title to search: algorithms unlocked\nID: 102 | Title: Algorithms Unlocked | Price: $45.00\n\n=== Bookstore Inventory Menu ===\n1. Add a new book\n2. Remove a book by ID\n3. Search for a book by title\n4. Display all books\n5. Exit\nChoose an option: 5\n\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n- **Data Representation**: You **must** define a `struct` (or equivalent language construct) named `BookNode` that contains the book\u2019s `ID`, `title`, `price`, and a pointer to the next node.\n- **Display Function**: The logic for printing a single book\u2019s details **must** be placed in a function with the exact signature `void displayBook(const BookNode* node);`. All menu options that show a book (search and display\u2011all) must call this function.\n- **Menu Implementation**: The program must present a menu as described above and must include an explicit option to **Exit** (option 5 in the example). Selecting this option ends the program.\n- **Single\u2011File Requirement**: The entire solution should be contained in one source file. Apart from `main`, you may create additional helper functions (e.g., for insertion, deletion, searching), but the core display logic must reside in `displayBook`.\n- **No Global Variables**: All list manipulation should be performed via pointers passed to functions; do not use global variables to store the head of the list.  \n\n*These constraints are mandatory; violating any of them will cause the solution to be considered incomplete.*", "model": "openai/gpt-oss-120b", "iteration": 42}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe city\u2019s public\u2011transport authority is modernizing its bus\u2011tracking system. Each bus on a route is identified by a unique **bus ID** and reports its **current passenger count** every few minutes. The authority wants a simple console program that stores the buses that are currently active on a given route using a **singly linked list**.  \n\nYour task is to implement this list and provide a small interactive menu so that a user (e.g., a dispatcher) can add, remove, query, and display buses while the program is running.\n\n## Requirements  \n\nWrite a C (or C++) program that:\n\n1. **Defines a `struct Bus`** containing at least:  \n   * `int id` \u2013 the unique bus identifier.  \n   * `int passengers` \u2013 number of passengers currently on board.  \n   * `struct Bus *next` \u2013 pointer to the next node in the list.  \n\n2. **Maintains a singly linked list** of all active buses. The list must be kept in the order in which buses are added (i.e., insertion at the tail).\n\n3. **Provides a text\u2011based menu** with the following options (the user selects a number):  \n   1. **Add a bus** \u2013 Prompt for `id` and `passengers`, then append a new node to the list. If a bus with the same `id` already exists, display an error and do not add it.  \n   2. **Remove a bus** \u2013 Prompt for `id`. If a bus with that `id` exists, delete its node and free the memory; otherwise, display \u201cBus not found.\u201d  \n   3. **Search for a bus** \u2013 Prompt for `id`. If found, display the bus\u2019s details; otherwise, display \u201cBus not found.\u201d  \n   4. **Display all buses** \u2013 Traverse the list and print each bus\u2019s `id` and `passengers` on a separate line. If the list is empty, print \u201cNo active buses.\u201d  \n   5. **EXIT** \u2013 Terminate the program gracefully, freeing any remaining allocated memory.  \n\n4. **Implements the following helper functions** (you may add more if you wish, but at least these must exist):  \n   * `void displayBus(const struct Bus *b);` \u2013 prints a single bus\u2019s details in the format `Bus ID: <id>, Passengers: <passengers>`.  \n   * `void addBus(struct Bus **head, int id, int passengers);`  \n   * `void removeBus(struct Bus **head, int id);`  \n   * `struct Bus* findBus(struct Bus *head, int id);`  \n   * `void displayAll(const struct Bus *head);`  \n\n5. **Handles all input errors gracefully** (e.g., non\u2011numeric input for menu choices or IDs) by prompting the user again.\n\n## Example Interaction  \n\n```\n--- Bus Tracking System ---\n1. Add a bus\n2. Remove a bus\n3. Search for a bus\n4. Display all buses\n5. EXIT\nChoose an option: 1\nEnter bus ID: 42\nEnter passenger count: 15\nBus added.\n\n--- Bus Tracking System ---\n1. Add a bus\n2. Remove a bus\n3. Search for a bus\n4. Display all buses\n5. EXIT\nChoose an option: 1\nEnter bus ID: 7\nEnter passenger count: 30\nBus added.\n\n--- Bus Tracking System ---\n1. Add a bus\n2. Remove a bus\n3. Search for a bus\n4. Display all buses\n5. EXIT\nChoose an option: 4\nBus ID: 42, Passengers: 15\nBus ID: 7, Passengers: 30\n\n--- Bus Tracking System ---\n1. Add a bus\n2. Remove a bus\n3. Search for a bus\n4. Display all buses\n5. EXIT\nChoose an option: 3\nEnter bus ID to search: 7\nBus ID: 7, Passengers: 30\n\n--- Bus Tracking System ---\n1. Add a bus\n2. Remove a bus\n3. Search for a bus\n4. Display all buses\n5. EXIT\nChoose an option: 2\nEnter bus ID to remove: 42\nBus removed.\n\n--- Bus Tracking System ---\n1. Add a bus\n2. Remove a bus\n3. Search for a bus\n4. Display all buses\n5. EXIT\nChoose an option: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Must use a `struct`** to represent each bus (as described above).  \n* The logic for displaying the details of **ONE specific bus** must reside **exclusively** in the function `displayBus`.  \n* The program **must provide a menu** and **must include an option numbered 5 (or the keyword \u201cEXIT\u201d) that terminates the program**.  \n* All dynamic memory allocated for bus nodes must be freed before the program exits.  \n* Only one additional helper function (besides `main`) is **not** allowed; you must implement at least the four functions listed in the requirements.  \n\nFeel free to add any auxiliary functions you need, but respect the constraints above. Good luck!", "model": "openai/gpt-oss-120b", "iteration": 43}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe campus library is modernizing its inventory system.  Each book in the collection is identified by a **unique ISBN**, has a **title**, and stores the **number of copies** currently available.  The library wants a simple console application that lets a librarian add new books, remove books, update the copy count, and view the details of a particular book.  Because the inventory can grow and shrink dynamically, the librarian has been instructed to use a **singly linked list** to store the books.\n\n## Requirements  \nWrite a C (or C++) program that implements the described inventory system using a singly linked list. The program must provide a **menu\u2011driven interface** with the following options:\n\n1. **Add a new book** \u2013 Prompt for ISBN (string without spaces), title (string possibly containing spaces), and initial copy count (non\u2011negative integer). Insert the new node at the **end** of the list. If a book with the same ISBN already exists, display an error and do not insert.\n2. **Remove a book** \u2013 Prompt for an ISBN. Locate the node with that ISBN, remove it from the list, and free its memory. If the ISBN is not found, display an appropriate message.\n3. **Update copy count** \u2013 Prompt for an ISBN and a new copy count. If the book exists, replace its copy count with the new value; otherwise, report that the ISBN was not found.\n4. **Display a book\u2019s details** \u2013 Prompt for an ISBN and show the ISBN, title, and copy count of that book. If the ISBN does not exist, inform the user.\n5. **List all books** \u2013 Traverse the list and print the details of every stored book in the order they were added.\n6. **EXIT** \u2013 Terminate the program gracefully, releasing all allocated memory.\n\nThe program should continue to display the menu after completing any operation until the user selects **EXIT**.\n\n## Example Input / Output  \n\n```\n=== Library Inventory Menu ===\n1) Add a new book\n2) Remove a book\n3) Update copy count\n4) Display a book\u2019s details\n5) List all books\n6) EXIT\nChoose an option: 1\nEnter ISBN: 978-0131103627\nEnter title: The C Programming Language\nEnter copy count: 4\nBook added successfully.\n\n=== Library Inventory Menu ===\n1) Add a new book\n2) Remove a book\n3) Update copy count\n4) Display a book\u2019s details\n5) List all books\n6) EXIT\nChoose an option: 1\nEnter ISBN: 978-0201616224\nEnter title: The Pragmatic Programmer\nEnter copy count: 2\nBook added successfully.\n\n=== Library Inventory Menu ===\n1) Add a new book\n2) Remove a book\n3) Update copy count\n4) Display a book\u2019s details\n5) List all books\n6) EXIT\nChoose an option: 5\n\nCurrent inventory:\nISBN: 978-0131103627 | Title: The C Programming Language | Copies: 4\nISBN: 978-0201616224 | Title: The Pragmatic Programmer   | Copies: 2\n\n=== Library Inventory Menu ===\n1) Add a new book\n2) Remove a book\n3) Update copy count\n4) Display a book\u2019s details\n5) List all books\n6) EXIT\nChoose an option: 4\nEnter ISBN to display: 978-0201616224\nISBN: 978-0201616224\nTitle: The Pragmatic Programmer\nCopies: 2\n\n=== Library Inventory Menu ===\n1) Add a new book\n2) Remove a book\n3) Update copy count\n4) Display a book\u2019s details\n5) List all books\n6) EXIT\nChoose an option: 6\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Data Representation** \u2013 The primary data entity (a book) **must be represented with a `struct`** named `BookNode` (or equivalent) that contains at least the fields `isbn`, `title`, `copies`, and a pointer to the next node.  \n* **Function Requirements** \u2013 The logic for displaying the details of **ONE specific book** (requirement #4) **must be placed in a function called `displayBook`**. This function should accept a pointer to the node to be displayed (or the ISBN to locate it) and handle all output formatting.  \n* **Modular Design** \u2013 Apart from `main()`, the solution must contain **no more than three additional functions** (e.g., `addBook`, `removeBook`, `updateCopies`, `displayBook`, `listAll`). Any extra helper functions are not permitted.  \n* **Menu Exit** \u2013 The menu must include an explicit option labeled **`6) EXIT`** (or the keyword `EXIT`) that terminates the program. Selecting this option must free all dynamically allocated memory before exiting.  \n\n*Optional (for extra credit):*  \n- Ensure that the program does not suffer from memory leaks (use tools such as Valgrind to verify).  \n- Validate that the copy count entered is a non\u2011negative integer; otherwise, prompt the user again.  ", "model": "openai/gpt-oss-120b", "iteration": 44}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe campus library is modernizing its inventory system.  The library wants a simple console\u2011based program that can store information about each book and allow the librarian to perform basic operations while the program is running.  The librarian has just been introduced to **singly linked lists**, so the solution must use a linked list to keep the collection of books in memory.\n\n## Requirements  \nWrite a C (or C++) program that implements a **singly linked list** of books.  Each book record must contain the following fields:  \n\n1. **ISBN** \u2013 a string of up to 13 characters (no spaces).  \n2. **Title** \u2013 a string of up to 50 characters (may contain spaces).  \n3. **Author** \u2013 a string of up to 30 characters (may contain spaces).  \n4. **Year** \u2013 an integer (e.g., 2023).  \n\nThe program must present a text\u2011based menu that allows the user to:\n\n1. **Add a new book** \u2013 insert the new node at the **end** of the list.  \n2. **Delete a book by ISBN** \u2013 remove the first node whose ISBN matches the supplied value.  \n3. **Search for a book by ISBN** \u2013 locate the node and display its details.  \n4. **Display all books** \u2013 traverse the list and print every stored book in the order they were added.  \n5. **Exit** \u2013 terminate the program gracefully.  \n\nAll input is read from `stdin`; all output is written to `stdout`.  The program should continue to display the menu after each operation until the user selects the Exit option.\n\n## Example  \n\n```\n=== Library Book Manager ===\n1) Add Book\n2) Delete Book\n3) Search Book\n4) Display All Books\n5) Exit\nChoose an option: 1\nEnter ISBN: 9780131103627\nEnter Title: The C Programming Language\nEnter Author: Kernighan & Ritchie\nEnter Year: 1988\nBook added successfully!\n\n=== Library Book Manager ===\n1) Add Book\n2) Delete Book\n3) Search Book\n4) Display All Books\n5) Exit\nChoose an option: 4\n--- Book List ---\nISBN: 9780131103627\nTitle: The C Programming Language\nAuthor: Kernighan & Ritchie\nYear: 1988\n--- End of List ---\n\n=== Library Book Manager ===\n1) Add Book\n2) Delete Book\n3) Search Book\n4) Display All Books\n5) Exit\nChoose an option: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Data Representation** \u2013 The primary data entity (a book) **must be defined using a `struct`** (or `class` with public members if using C++).  \n* **Display Function** \u2013 The logic for displaying the details of **ONE specific book** (used in the Search operation) **must be placed in a function named `displayBook`** that takes a pointer/reference to a book node as its only parameter.  \n* **Menu Requirement** \u2013 The menu must include an explicit option to **EXIT the program** (option `5` in the example). Selecting this option must cause the program to terminate without memory leaks.  \n* **Memory Management** \u2013 All dynamically allocated nodes must be freed appropriately when they are removed or when the program exits.  \n* **Single\u2011File Implementation** \u2013 The entire solution should be contained in one source file; only `main` and the required helper functions (`displayBook`, and any others you create) are permitted.  \n\nYour task is to design and implement this program following the specifications above.", "model": "openai/gpt-oss-120b", "iteration": 45}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe city\u2019s **Urban Wildlife Rescue** maintains a simple database of rescued animals that are waiting to be adopted.  Because the number of arrivals and adoptions changes every day, the staff wants a lightweight program that can **dynamically add** new animals, **remove** the animal that has been in the shelter the longest, and **display** information about any single animal on demand.  \n\nYou have just learned how to implement a **singly linked list** in C (or C\u2011like language).  Write a console program that models the rescue\u2019s animal list using a singly linked list.\n\n## Requirements  \n\n1. **Data Representation**  \n   - Each animal is represented by a `struct` (or equivalent) containing:  \n     - `int id` \u2013 a unique identifier (positive integer).  \n     - `char name[30]` \u2013 the animal\u2019s name (no spaces).  \n     - `char species[20]` \u2013 e.g., \u201cfox\u201d, \u201craccoon\u201d, \u201ceagle\u201d.  \n     - `int age` \u2013 age in years.  \n\n2. **Supported Operations (menu\u2011driven)**  \n   - **1. Add Animal** \u2013 Prompt the user for the fields above and insert the new node at the **tail** of the list (i.e., the newest arrival is at the end).  \n   - **2. Adopt Animal** \u2013 Remove the **head** node (the animal that has been in the shelter the longest) and display its details before deletion. If the list is empty, print an appropriate message.  \n   - **3. Display Animal by ID** \u2013 Ask for an `id`, search the list, and display that animal\u2019s details. If not found, inform the user.  \n   - **4. List All Animals** \u2013 Traverse the list from head to tail and print each animal\u2019s information on its own line. If the list is empty, state that there are no animals.  \n   - **5. EXIT** \u2013 Terminate the program.  \n\n3. **User Interaction**  \n   - After completing any operation (except EXIT), the menu should be shown again.  \n   - Input should be read from standard input; output written to standard output.  \n\n4. **Memory Management**  \n   - Dynamically allocate memory for each new node.  \n   - Free memory when a node is removed or when the program exits.  \n\n## Example Input / Output  \n\n```\n--- Urban Wildlife Rescue ---\n1. Add Animal\n2. Adopt Animal\n3. Display Animal by ID\n4. List All Animals\n5. EXIT\nChoose an option: 1\nEnter ID: 101\nEnter name: Bella\nEnter species: fox\nEnter age: 3\nAnimal added.\n\n--- Urban Wildlife Rescue ---\n1. Add Animal\n2. Adopt Animal\n3. Display Animal by ID\n4. List All Animals\n5. EXIT\nChoose an option: 1\nEnter ID: 102\nEnter name: Rocky\nEnter species: raccoon\nEnter age: 2\nAnimal added.\n\n--- Urban Wildlife Rescue ---\n1. Add Animal\n2. Adopt Animal\n3. Display Animal by ID\n4. List All Animals\n5. EXIT\nChoose an option: 4\nID: 101, Name: Bella, Species: fox, Age: 3\nID: 102, Name: Rocky, Species: raccoon, Age: 2\n\n--- Urban Wildlife Rescue ---\n1. Add Animal\n2. Adopt Animal\n3. Display Animal by ID\n4. List All Animals\n5. EXIT\nChoose an option: 2\nAdopted animal:\nID: 101, Name: Bella, Species: fox, Age: 3\n\n--- Urban Wildlife Rescue ---\n1. Add Animal\n2. Adopt Animal\n3. Display Animal by ID\n4. List All Animals\n5. EXIT\nChoose an option: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n- **Struct Requirement:** The primary data entity must be defined as a `struct` named `AnimalNode` (or equivalent) that contains the animal fields **and** a pointer to the next node.  \n- **Display Function:** The logic for printing the details of **one specific animal** (used in options 2 and 3) must reside in a function called `displayAnimal(const AnimalNode *node)`.  \n- **Menu Implementation:** The program must present a textual menu as described above and **must include a specific menu option to EXIT the program (option 5)**.  \n- **Single\u2011purpose Helper Functions:** Apart from `main()`, you may create additional helper functions (e.g., `addAnimal`, `adoptAnimal`, `findAnimal`, `listAll`, `displayAnimal`). No global variables other than the head pointer are allowed.  \n\n*Your solution should compile without warnings and behave exactly as specified.*", "model": "openai/gpt-oss-120b", "iteration": 46}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe ancient library of **Algoria** stores its scrolls in a single\u2011file chain of wooden boxes. Each box knows only the box that follows it; there is no backward link. The librarian wants a simple console program to manage this chain: adding new scrolls, removing them, and inspecting the contents of any box.  \n\nYou have just learned how to implement a **singly linked list** in C (or C\u2011like language) using `struct`s and pointer manipulation. Your task is to write a program that models the library\u2019s chain of boxes.\n\n## Requirements  \n\nYour program must support the following operations, presented to the user through a text menu:\n\n1. **Insert a new box at the end of the chain**  \n   - Prompt for the scroll\u2019s *title* (a string without spaces, max 30 characters) and its *page count* (positive integer).  \n   - Allocate a new node and attach it as the last element.\n\n2. **Delete the first box that contains a scroll with a given title**  \n   - Prompt for the title to delete.  \n   - If the title is found, remove that node and free its memory; otherwise report \u201cNot found\u201d.\n\n3. **Display the details of a specific box**  \n   - Prompt for a title.  \n   - Locate the first node whose title matches and call a function `displayEntity` to print its contents in the format:  \n     `Title: <title>, Pages: <pages>`  \n   - If the title does not exist, print \u201cNot found\u201d.\n\n4. **Print the entire chain**  \n   - Starting from the first box, print each node on its own line using the same format as above.\n\n5. **Exit the program**  \n   - Selecting this option terminates the program gracefully.\n\nThe menu must be displayed after each operation (except after exiting). All input and output should be done via `stdin`/`stdout`.\n\n## Example Input / Output  \n\n```\n--- Algoria Library Menu ---\n1) Insert box\n2) Delete box by title\n3) Display box by title\n4) Print all boxes\n5) EXIT\nChoose an option: 1\nEnter title: TheHobbit\nEnter pages: 310\nBox inserted.\n\n--- Algoria Library Menu ---\n1) Insert box\n2) Delete box by title\n3) Display box by title\n4) Print all boxes\n5) EXIT\nChoose an option: 1\nEnter title: Dune\nEnter pages: 412\nBox inserted.\n\n--- Algoria Library Menu ---\n1) Insert box\n2) Delete box by title\n3) Display box by title\n4) Print all boxes\n5) EXIT\nChoose an option: 4\nTitle: TheHobbit, Pages: 310\nTitle: Dune, Pages: 412\n\n--- Algoria Library Menu ---\n1) Insert box\n2) Delete box by title\n3) Display box by title\n4) Print all boxes\n5) EXIT\nChoose an option: 3\nEnter title to display: Dune\nTitle: Dune, Pages: 412\n\n--- Algoria Library Menu ---\n1) Insert box\n2) Delete box by title\n3) Display box by title\n4) Print all boxes\n5) EXIT\nChoose an option: 2\nEnter title to delete: TheHobbit\nBox deleted.\n\n--- Algoria Library Menu ---\n1) Insert box\n2) Delete box by title\n3) Display box by title\n4) Print all boxes\n5) EXIT\nChoose an option: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n- The primary data entity **must** be represented with a `struct` named `Box` (or equivalent) containing at least a `char title[31]`, an `int pages`, and a pointer to the next node.  \n- The logic for displaying the details of **ONE specific entity** must reside in a function exactly named `displayEntity`. Its prototype should be:  \n  ```c\n  void displayEntity(const Box *node);\n  ```  \n- Apart from `main`, you may create additional helper functions (e.g., for insertion, deletion, printing the list), but the program must **not** contain more than **five** user\u2011defined functions total (including `displayEntity`).  \n- All dynamic memory allocations must be checked for success; if `malloc` fails, print \u201cMemory allocation error\u201d and exit.  \n- The menu **must** include a distinct option to **EXIT** the program (as shown in the example, option\u202f5). Selecting this option should end the program without memory leaks.  \n\n*Write clean, well\u2011commented code that follows these constraints.*", "model": "openai/gpt-oss-120b", "iteration": 47}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe campus **Student Activities Office** maintains a simple digital register of club events.  \nEach event is identified by a unique **Event ID** (integer), has a **title** (string, up to 30 characters), and a **date** (string in the form `YYYY\u2011MM\u2011DD`).  \nBecause events are added and removed frequently, the office has decided to store them in a **singly linked list** that preserves the order in which events are entered (i.e., new events are appended to the tail of the list).\n\nYou are asked to write a small console program that lets a user manage this list through a menu\u2011driven interface.\n\n## Requirements  \nYour program must provide the following functionality:\n\n1. **Add a new event** \u2013 Prompt the user for Event ID, title, and date, then insert the event at the end of the list.  \n2. **Remove an event by ID** \u2013 Prompt for an Event ID and delete the first node whose ID matches. If the ID does not exist, display an appropriate message.  \n3. **Search for an event by ID** \u2013 Prompt for an Event ID and display the details of the matching event. If not found, inform the user.  \n4. **Display all events** \u2013 Traverse the list from head to tail and print each event\u2019s ID, title, and date on a separate line.  \n5. **Exit** \u2013 Terminate the program gracefully.\n\nAll interactions are performed through a text menu displayed after each operation.\n\n## Example Input / Output  \n\n```\n--- Student Activities Event Manager ---\n1. Add Event\n2. Remove Event\n3. Search Event\n4. List All Events\n5. Exit\nChoose an option: 1\n\nEnter Event ID: 101\nEnter Title: Hackathon\nEnter Date (YYYY-MM-DD): 2024-03-15\nEvent added.\n\n--- Student Activities Event Manager ---\n1. Add Event\n2. Remove Event\n3. Search Event\n4. List All Events\n5. Exit\nChoose an option: 1\n\nEnter Event ID: 102\nEnter Title: Poetry Night\nEnter Date (YYYY-MM-DD): 2024-04-02\nEvent added.\n\n--- Student Activities Event Manager ---\n1. Add Event\n2. Remove Event\n3. Search Event\n4. List All Events\n5. Exit\nChoose an option: 4\n\nEvent ID: 101 | Title: Hackathon   | Date: 2024-03-15\nEvent ID: 102 | Title: Poetry Night| Date: 2024-04-02\n\n--- Student Activities Event Manager ---\n1. Add Event\n2. Remove Event\n3. Search Event\n4. List All Events\n5. Exit\nChoose an option: 3\n\nEnter Event ID to search: 102\nEvent ID: 102 | Title: Poetry Night | Date: 2024-04-02\n\n--- Student Activities Event Manager ---\n1. Add Event\n2. Remove Event\n3. Search Event\n4. List All Events\n5. Exit\nChoose an option: 5\n\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n1. **Data Representation** \u2013 The primary data entity (an event) must be represented with a `struct` (or equivalent language\u2011specific record) containing at least the three fields: `id` (int), `title` (char array / string), and `date` (char array / string).  \n\n2. **Linked List Node** \u2013 The linked\u2011list node must contain the event `struct` and a pointer to the next node.  \n\n3. **Display Function** \u2013 The logic for showing the details of **one specific event** (used by the *Search* operation) must reside in a function named `displayEvent`. Its signature should accept a pointer/reference to an event and print the formatted line shown in the example.  \n\n4. **Menu Implementation** \u2013 The menu must be presented in a loop and must include a distinct option to **EXIT** the program (option number 5 in the example). Selecting this option ends the loop and terminates the program.  \n\n5. **Memory Management** \u2013 If the chosen language requires explicit memory handling (e.g., C/C++), you must allocate nodes dynamically when adding events and free the memory of removed nodes (and all remaining nodes before program termination).  \n\n6. **Single\u2011File Solution** \u2013 All code must reside in a single source file. Apart from `main`, you may create additional helper functions, but the total number of user\u2011defined functions (including `displayEvent`) must not exceed **six**.  \n\n7. **No Standard Library Containers** \u2013 You may **not** use built\u2011in list, vector, or similar container classes; the linked list must be implemented manually.  \n\nFollow these constraints closely; they are part of the grading rubric.", "model": "openai/gpt-oss-120b", "iteration": 48}, {"text": "# STEP 1: PROBLEM  \n\n**Background**  \nThe campus library wants a simple command\u2011line tool to keep track of the books that are currently on loan. Each book record contains a unique identifier, the title, and the name of the borrower. The library staff will use this tool to add new loans, remove returned books, and view the list of outstanding loans.  \n\nYour task is to implement this tool using a **singly linked list**. The list should store the loan records in the order they are entered (i.e., new records are appended to the tail of the list).  \n\n---\n\n## Requirements  \n\n1. **Data representation**  \n   * Define a `struct` named `Book` (or equivalent in your language) that stores:  \n     - `int id` \u2013 unique loan identifier  \n     - `char title[101]` \u2013 book title (max 100 characters)  \n     - `char borrower[51]` \u2013 borrower\u2019s name (max 50 characters)  \n     - `struct Book *next` \u2013 pointer to the next node  \n\n2. **Menu\u2011driven program** (the program must present a text menu and loop until the user chooses to exit)  \n   * **1. Add a new loan** \u2013 Prompt for `id`, `title`, and `borrower`; create a new node and append it to the tail of the list. If a node with the same `id` already exists, print an error and do not insert.  \n   * **2. Return a book** \u2013 Prompt for `id`; locate the node with that `id` and remove it from the list, freeing its memory. If the `id` is not found, print an appropriate message.  \n   * **3. Display all outstanding loans** \u2013 Traverse the list from head to tail and print each record on its own line in the format:  \n     `ID: <id>, Title: \"<title>\", Borrower: <borrower>`  \n   * **4. Display a specific loan** \u2013 Prompt for `id`; locate the node and display its details using a dedicated function called `displayBook`. If not found, inform the user.  \n   * **5. EXIT** \u2013 Terminate the program gracefully, freeing any remaining allocated memory.  \n\n3. **Input validation** \u2013 The program should handle non\u2011numeric menu choices gracefully and re\u2011prompt the user.  \n\n4. **Memory management** \u2013 All dynamically allocated nodes must be freed before the program ends.  \n\n---\n\n## Example Interaction  \n\n```\n=== Library Loan Tracker ===\n1. Add a new loan\n2. Return a book\n3. Display all outstanding loans\n4. Display a specific loan\n5. EXIT\nChoose an option: 1\n\nEnter loan ID: 101\nEnter book title: The C Programming Language\nEnter borrower name: Alice\nLoan added successfully.\n\n=== Library Loan Tracker ===\n1. Add a new loan\n2. Return a book\n3. Display all outstanding loans\n4. Display a specific loan\n5. EXIT\nChoose an option: 1\n\nEnter loan ID: 102\nEnter book title: Introduction to Algorithms\nEnter borrower name: Bob\nLoan added successfully.\n\n=== Library Loan Tracker ===\n1. Add a new loan\n2. Return a book\n3. Display all outstanding loans\n4. Display a specific loan\n5. EXIT\nChoose an option: 3\n\nID: 101, Title: \"The C Programming Language\", Borrower: Alice\nID: 102, Title: \"Introduction to Algorithms\", Borrower: Bob\n\n=== Library Loan Tracker ===\n1. Add a new loan\n2. Return a book\n3. Display all outstanding loans\n4. Display a specific loan\n5. EXIT\nChoose an option: 4\n\nEnter loan ID to view: 102\nID: 102, Title: \"Introduction to Algorithms\", Borrower: Bob\n\n=== Library Loan Tracker ===\n1. Add a new loan\n2. Return a book\n3. Display all outstanding loans\n4. Display a specific loan\n5. EXIT\nChoose an option: 5\n\nGoodbye!\n```\n\n---\n\n### CONSTRAINTS  \n\n* **Struct requirement** \u2013 The primary data entity must be represented by a `struct` named `Book`.  \n* **Display function** \u2013 The logic for showing the details of ONE specific loan must reside in a function with the exact prototype:  \n  ```c\n  void displayBook(const Book *b);\n  ```  \n* **Menu exit** \u2013 The menu must contain an option labelled **5. EXIT** (or the word \u201cEXIT\u201d) that terminates the program.  \n* **Single\u2011function rule** \u2013 Apart from `main()` you may create as many helper functions as needed, but the core list operations (insert, delete, traverse) must each be encapsulated in their own separate functions (e.g., `addLoan`, `removeLoan`, `printAll`, `displayBook`).  \n* **No global variables** \u2013 All list pointers must be passed to functions via parameters; do not use global variables to store the head or tail of the list.  \n\n---  \n\nImplement the program according to the above specifications.", "model": "openai/gpt-oss-120b", "iteration": 49}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe campus bookstore wants to keep a simple in\u2011memory record of the **first\u2011edition textbooks** it receives each day. Each textbook is identified by a unique ISBN, has a title, and a price. Because the store receives books continuously throughout the day, the list of books must support **insertion at the end** (the order of arrival matters) and **removal of the first book** when it is sold.  \n\nYour task is to write a console program that maintains this list using a **singly linked list**. The program will present a small menu that allows the user (the store clerk) to add new books, sell the oldest book, view the whole inventory, and look up a single book by its ISBN.\n\n## Requirements  \n\n1. **Data representation**  \n   * Define a `struct` called `Book` that stores:  \n     - `char isbn[14]` (13\u2011digit ISBN plus terminating null)  \n     - `char title[101]` (up to 100 characters)  \n     - `double price`  \n\n2. **Linked\u2011list node**  \n   * Define a `struct` called `Node` that contains a `Book` and a pointer to the next node.\n\n3. **Menu\u2011driven program** (displayed repeatedly until the user chooses to exit)  \n   * **1. Add a new textbook** \u2013 Prompt for ISBN, title, and price, then append a new node at the **tail** of the list.  \n   * **2. Sell the oldest textbook** \u2013 Remove the node at the **head** of the list and display its details. If the list is empty, print an appropriate message.  \n   * **3. Show all textbooks** \u2013 Traverse the list from head to tail, printing each book\u2019s ISBN, title, and price on its own line. If the list is empty, indicate that the inventory is empty.  \n   * **4. Find a textbook by ISBN** \u2013 Prompt for an ISBN, search the list, and if found call a function `displayBook` (see Constraint) to show its details; otherwise report \u201cBook not found\u201d.  \n   * **5. EXIT** \u2013 Terminate the program.  \n\n4. **Input validation** \u2013 The program should not crash on malformed input; if a numeric value cannot be read, ask the user to re\u2011enter it.\n\n5. **Memory management** \u2013 All dynamically allocated nodes must be freed before the program exits.\n\n## Example Interaction  \n\n```\n=== Bookstore Inventory Menu ===\n1. Add a new textbook\n2. Sell the oldest textbook\n3. Show all textbooks\n4. Find a textbook by ISBN\n5. EXIT\nEnter choice: 1\nEnter ISBN (13 digits): 9780131103627\nEnter title: The C Programming Language\nEnter price: 59.99\nTextbook added.\n\n=== Bookstore Inventory Menu ===\n1. Add a new textbook\n2. Sell the oldest textbook\n3. Show all textbooks\n4. Find a textbook by ISBN\n5. EXIT\nEnter choice: 1\nEnter ISBN (13 digits): 9780262033848\nEnter title: Introduction to Algorithms\nEnter price: 89.50\nTextbook added.\n\n=== Bookstore Inventory Menu ===\n1. Add a new textbook\n2. Sell the oldest textbook\n3. Show all textbooks\n4. Find a textbook by ISBN\n5. EXIT\nEnter choice: 3\nInventory:\nISBN: 9780131103627 | Title: The C Programming Language | Price: $59.99\nISBN: 9780262033848 | Title: Introduction to Algorithms | Price: $89.50\n\n=== Bookstore Inventory Menu ===\n1. Add a new textbook\n2. Sell the oldest textbook\n3. Show all textbooks\n4. Find a textbook by ISBN\n5. EXIT\nEnter choice: 2\nSold textbook:\nISBN: 9780131103627 | Title: The C Programming Language | Price: $59.99\n\n=== Bookstore Inventory Menu ===\n1. Add a new textbook\n2. Sell the oldest textbook\n3. Show all textbooks\n4. Find a textbook by ISBN\n5. EXIT\nEnter choice: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Struct usage** \u2013 The primary data entity must be represented with a `struct` named `Book`.  \n* **Display function** \u2013 The logic for displaying the details of **ONE** specific book must reside in a function with the exact prototype:  \n  ```c\n  void displayBook(const Book *b);\n  ```  \n* **Single\u2011purpose helper functions** \u2013 Apart from `main`, you may create additional helper functions (e.g., for insertion, deletion, searching), but the program must contain **no more than three** user\u2011defined functions besides `main` and `displayBook`.  \n* **Menu requirement** \u2013 The menu must include an explicit option **5. EXIT** that terminates the program, as shown in the example.  \n\n---  \n\nImplement the program in C (or C++) following the above specifications. The solution will be evaluated on correctness, adherence to the constraints, proper memory handling, and code clarity.", "model": "openai/gpt-oss-120b", "iteration": 50}]