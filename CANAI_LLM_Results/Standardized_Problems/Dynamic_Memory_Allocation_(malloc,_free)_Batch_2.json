[{"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired as a junior developer for **CampusConnect**, a small campus\u2011wide service that keeps a live list of active study\u2011group sessions. Each session has a **title**, a **maximum number of participants**, and the **current number of participants** that have already joined. The program must allow the user (the campus administrator) to create new sessions, join participants, display session information, and delete sessions that are no longer needed.  \n\nAll session records must be stored in **dynamic memory** because the number of sessions is not known at compile time and can change while the program runs.\n\n## Requirements  \n\nWrite a C program that implements the following functionality:\n\n1. **Create a new session**  \n   * Prompt the user for the session title (a string of up to 50 characters) and the maximum number of participants (positive integer).  \n   * Allocate a `struct Session` on the heap with `malloc`.  \n   * Initialise the current participant count to\u202f0 and add the new session to the end of a dynamically\u2011managed list.\n\n2. **Add participants to a session**  \n   * Ask the user for the session title and the number of participants to add.  \n   * If the session exists and the addition would not exceed the maximum, increment the current participant count.  \n   * If the session does not exist or the addition would overflow, print an appropriate error message.\n\n3. **Display a specific session**  \n   * Prompt for a session title.  \n   * Locate the session and print its title, maximum capacity, and current participant count.  \n   * This display logic must be placed in a function named `void displaySession(const struct Session *s);`.\n\n4. **Delete a session**  \n   * Prompt for a session title.  \n   * If the session exists, remove it from the list, free its memory with `free`, and shift remaining list elements as needed.  \n   * If the session does not exist, print an error message.\n\n5. **List all sessions**  \n   * Print a table of every session currently stored, showing title, maximum capacity, and current participants.\n\n6. **Exit**  \n   * The program must terminate cleanly, freeing any remaining allocated memory before exiting.\n\nThe program should repeatedly present a **menu** that lets the user choose one of the actions above until the \u201cExit\u201d option is selected.\n\n## Example Input / Output  \n\n```\n=== CampusConnect Menu ===\n1. Create new session\n2. Add participants\n3. Display a session\n4. Delete a session\n5. List all sessions\n6. Exit\nEnter choice: 1\nEnter session title: Algorithms Study Group\nEnter maximum participants: 12\nSession created.\n\n=== CampusConnect Menu ===\n1. Create new session\n2. Add participants\n3. Display a session\n4. Delete a session\n5. List all sessions\n6. Exit\nEnter choice: 2\nEnter session title: Algorithms Study Group\nEnter participants to add: 5\n5 participants added.\n\n=== CampusConnect Menu ===\n1. Create new session\n2. Add participants\n3. Display a session\n4. Delete a session\n5. List all sessions\n6. Exit\nEnter choice: 3\nEnter session title: Algorithms Study Group\n--- Session Details ---\nTitle: Algorithms Study Group\nMaximum participants: 12\nCurrent participants: 5\n\n=== CampusConnect Menu ===\n1. Create new session\n2. Add participants\n3. Display a session\n4. Delete a session\n5. List all sessions\n6. Exit\nEnter choice: 5\n--- All Sessions ---\nTitle                     Max   Current\nAlgorithms Study Group    12    5\n\n=== CampusConnect Menu ===\n1. Create new session\n2. Add participants\n3. Display a session\n4. Delete a session\n5. List all sessions\n6. Exit\nEnter choice: 6\nCleaning up memory... Goodbye!\n```\n\n## ### CONSTRAINTS  \n\n1. **Data structure** \u2013 The primary entity must be represented with a `struct Session` containing at least the fields `char title[51]; int maxParticipants; int currentParticipants;`.  \n\n2. **Display function** \u2013 The logic that prints the details of a single session must be encapsulated in a function named `void displaySession(const struct Session *s);`.  \n\n3. **Dynamic allocation** \u2013 All sessions must be allocated with `malloc` (or `calloc`) and released with `free`. No static or global arrays of fixed size may be used to store the sessions.  \n\n4. **Menu requirement** \u2013 The program must present a menu as shown in the example and **must include an explicit \u201cExit\u201d option (choice\u202f6)** that terminates the program.  \n\n5. **Memory safety** \u2013 Before the program ends, every block of memory obtained via `malloc`/`calloc` must be freed exactly once.  \n\nFeel free to add any helper functions you deem necessary, but the above constraints must be satisfied.", "model": "openai/gpt-oss-120b", "iteration": 81}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired by the **City Library** to write a small C program that keeps track of the books currently borrowed by patrons. The library does not have a database; instead, it stores the information only while the program is running. Because the number of active loans changes constantly, you must allocate and release memory dynamically using `malloc` and `free`.  \n\nEach loan (a **BorrowRecord**) contains:  \n\n* the patron\u2019s name (a string, up to 50 characters),  \n* the title of the book (a string, up to 100 characters),  \n* the number of days the book is borrowed (an integer).  \n\nThe program should allow the librarian to add new loans, remove a loan when a book is returned, and display the details of a specific loan.\n\n---\n\n## Requirements  \n\nYour program must implement the following functionality:\n\n1. **Add a new loan**  \n   * Prompt the user for the patron\u2019s name, book title, and number of days.  \n   * Dynamically allocate a `BorrowRecord` and store the entered data.  \n   * Store the pointer in a dynamically\u2011growing array (you may re\u2011allocate the array each time a new record is added).\n\n2. **Return a loan (remove a record)**  \n   * Ask the user for the patron\u2019s name and the book title.  \n   * Search the array for a matching record (both fields must match exactly).  \n   * If found, free the memory used by that `BorrowRecord`, remove its pointer from the array, and shrink the array accordingly.  \n   * If not found, print \u201cRecord not found.\u201d\n\n3. **Display a specific loan**  \n   * Ask the user for the patron\u2019s name and the book title.  \n   * Locate the matching record and call a function `displayRecord` (see constraints) to print the three fields in a readable format.  \n   * If the record does not exist, print \u201cRecord not found.\u201d\n\n4. **List all active loans**  \n   * Iterate over the array and print every stored loan using `displayRecord`.\n\n5. **Exit**  \n   * Before terminating, free **all** memory that was allocated (both the individual `BorrowRecord`s and the array that holds their pointers).\n\nThe program should present a simple text menu that repeatedly asks the user to choose an option until the *Exit* option is selected.\n\n---\n\n## Example Interaction  \n\n```\n=== Library Loan Manager ===\n1. Add a new loan\n2. Return a loan\n3. Display a loan\n4. List all loans\n5. Exit\nChoose an option: 1\n\nPatron name: Alice Johnson\nBook title : The C Programming Language\nDays borrowed: 14\nLoan added successfully.\n\n=== Library Loan Manager ===\n1. Add a new loan\n2. Return a loan\n3. Display a loan\n4. List all loans\n5. Exit\nChoose an option: 4\n\n--- Active Loans ---\nPatron: Alice Johnson\nBook  : The C Programming Language\nDays  : 14\n--------------------\n\n=== Library Loan Manager ===\n1. Add a new loan\n2. Return a loan\n3. Display a loan\n4. List all loans\n5. Exit\nChoose an option: 5\n\nGoodbye!\n```\n\n---\n\n## ### CONSTRAINTS  \n\n* **Struct Requirement** \u2013 The primary data entity must be represented with a `struct` named `BorrowRecord`.  \n* **Display Function** \u2013 The logic for printing the details of a single loan must be placed in a function with the exact prototype:  \n\n  ```c\n  void displayRecord(const BorrowRecord *rec);\n  ```\n\n* **Menu Requirement** \u2013 The program must present a menu as shown in the example.  \n  * The menu must include an explicit option to **EXIT** the program (option number 5 in the example). Selecting this option terminates the loop and triggers the final cleanup.  \n\n* **Dynamic Allocation Only** \u2013 All storage for loan records and the array of pointers must be obtained with `malloc`/`calloc`/`realloc` and released with `free`. No static or global arrays of fixed size are allowed for storing the records.  \n\n* **Single\u2011File Implementation** \u2013 All code must reside in one source file (`.c`). Apart from `main`, you may create additional helper functions, but the only required extra function is `displayRecord`.  \n\n* **Error Handling** \u2013 If any `malloc`/`realloc` call fails, the program should print an error message and exit gracefully, freeing any memory that was already allocated.  ", "model": "openai/gpt-oss-120b", "iteration": 82}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired to write a tiny \u201cpersonal library\u201d manager for a small community reading club.  \nThe club wants a console program that can keep track of the books currently owned by the club.  \nBecause the number of books is not known in advance and can change while the program runs, the\ndata for each book must be allocated dynamically on the heap using `malloc` (or `calloc`) and released\nwith `free` when the book is removed or when the program terminates.\n\n## Requirements  \n\nWrite a C program that provides the following functionality through a simple text\u2011based menu:\n\n1. **Add a new book**  \n   * Prompt the user for the book\u2019s **ISBN** (a positive integer), **title** (a single line, up to 100 characters), and **author** (a single line, up to 100 characters).  \n   * Dynamically allocate a `struct Book` to store the information and insert it into an internal list.  \n   * If a book with the same ISBN already exists, print an error message and do **not** add a duplicate.\n\n2. **Delete a book**  \n   * Prompt for an ISBN.  \n   * Locate the matching book, remove it from the list, and free the memory that was allocated for it.  \n   * If the ISBN is not found, print a suitable message.\n\n3. **Display details of ONE specific book**  \n   * Prompt for an ISBN.  \n   * Locate the book and **call a function named `displayBook`** to print its details in the format:  \n     ```\n     ISBN: <isbn>\n     Title: <title>\n     Author: <author>\n     ```  \n   * If the ISBN does not exist, print a suitable message.\n\n4. **List all books**  \n   * Print the details of every book currently stored, using `displayBook` for each entry.  \n   * If the list is empty, print \u201cNo books in the library.\u201d\n\n5. **Exit**  \n   * Choose the menu option to terminate the program.  \n   * Before exiting, free **all** memory that was allocated for books.\n\nThe program should continue to display the menu after each operation until the user selects the\nexit option.\n\n## Example Interaction  \n\n```\n=== Library Manager ===\n1. Add a book\n2. Delete a book\n3. Show a book\n4. List all books\n0. Exit\nEnter choice: 1\nEnter ISBN: 9780131103627\nEnter title: The C Programming Language\nEnter author: Kernighan & Ritchie\nBook added.\n\n=== Library Manager ===\n1. Add a book\n2. Delete a book\n3. Show a book\n4. List all books\n0. Exit\nEnter choice: 1\nEnter ISBN: 9780201633610\nEnter title: Design Patterns\nEnter author: Gamma et al.\nBook added.\n\n=== Library Manager ===\n1. Add a book\n2. Delete a book\n3. Show a book\n4. List all books\n0. Exit\nEnter choice: 3\nEnter ISBN to display: 9780131103627\nISBN: 9780131103627\nTitle: The C Programming Language\nAuthor: Kernighan & Ritchie\n\n=== Library Manager ===\n1. Add a book\n2. Delete a book\n3. Show a book\n4. List all books\n0. Exit\nEnter choice: 4\nISBN: 9780131103627\nTitle: The C Programming Language\nAuthor: Kernighan & Ritchie\n\nISBN: 9780201633610\nTitle: Design Patterns\nAuthor: Gamma et al.\n\n=== Library Manager ===\n1. Add a book\n2. Delete a book\n3. Show a book\n4. List all books\n0. Exit\nEnter choice: 0\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Data structure** \u2013 The primary entity must be represented by a `struct` named `Book` containing at least the fields `int isbn; char title[101]; char author[101];` and a pointer to the next `Book` (i.e., a singly\u2011linked list).  \n* **Dynamic allocation** \u2013 Every time a new book is added, allocate memory with `malloc`/`calloc`.  \n  Every removal must free the exact block that was allocated for that book.  \n* **Function requirement** \u2013 The logic that prints the details of a single book **must** be placed in a function with the exact prototype:  \n\n  ```c\n  void displayBook(const struct Book *b);\n  ```  \n\n* **Menu** \u2013 The program must present a menu as shown above and **must** include the option `0` (or the word `EXIT`) that terminates the program. Selecting this option must cause the program to free all remaining allocated memory before exiting.  \n\n* **Single\u2011source file** \u2013 The entire solution should be written in one `.c` file; you may define helper functions, but the `main` function must contain the menu loop.  \n\n* **No global variables** \u2013 All data structures should be created and manipulated via pointers passed to functions; avoid using global variables for the book list.  \n\n---  \n\n*Note to students*: Focus on correct use of `malloc`, `free`, pointer manipulation, and keeping the program free of memory leaks. Use tools such as `valgrind` (or your IDE\u2019s memory\u2011checking facilities) to verify that every allocated block is released.", "model": "openai/gpt-oss-120b", "iteration": 83}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe city museum is digitizing its collection of artifacts. Each artifact has a name, a year of origin, and a short description. The museum\u2019s software must be able to **create**, **store**, **display**, and **remove** artifacts while the program is running. Because the number of artifacts is not known ahead of time, the program must allocate memory dynamically using `malloc`/`calloc` and release it with `free` when an artifact is deleted or when the program terminates.\n\n## Requirements  \n\nWrite a C program that implements a simple **menu\u2011driven** artifact manager. The program must support the following operations:\n\n1. **Add a new artifact**  \n   - Prompt the user for the artifact\u2019s *name* (string, max 50 characters), *year* (integer), and *description* (string, max 200 characters).  \n   - Allocate memory for a new `struct Artifact` and store the entered data.  \n   - Append the new artifact to the end of the current collection.\n\n2. **Delete an artifact**  \n   - Prompt the user for the *index* (1\u2011based) of the artifact to delete.  \n   - Remove the artifact from the collection, free its memory, and shift any following artifacts so that indices remain contiguous.  \n   - If the index is invalid, display an error message and return to the menu.\n\n3. **Display a specific artifact**  \n   - Prompt the user for the *index* (1\u2011based) of the artifact to view.  \n   - Call a function `displayArtifact` (see constraints) that prints the artifact\u2019s details in a readable format.  \n   - If the index is invalid, display an error message.\n\n4. **List all artifacts**  \n   - Print a numbered list of all stored artifacts, showing only the *index* and *name* for each entry.  \n   - If the collection is empty, print \u201cNo artifacts stored.\u201d\n\n5. **Exit the program**  \n   - Before terminating, free **all** dynamically allocated memory.  \n   - The menu must contain a clearly labeled option (e.g., `0. Exit`) that ends the program.\n\nThe menu should be displayed after each operation until the user chooses to exit.\n\n## Example Input / Output  \n\n```\n=== Museum Artifact Manager ===\n1. Add artifact\n2. Delete artifact\n3. Display artifact\n4. List all artifacts\n0. Exit\nChoose an option: 1\n\nEnter name (max 50 chars): Golden Mask\nEnter year of origin: 1325\nEnter description (max 200 chars): A ceremonial mask made of gold, discovered in the Andes.\n\nArtifact added successfully!\n\n=== Museum Artifact Manager ===\n1. Add artifact\n2. Delete artifact\n3. Display artifact\n4. List all artifacts\n0. Exit\nChoose an option: 4\n\nCurrent artifacts:\n1. Golden Mask\n\n=== Museum Artifact Manager ===\n1. Add artifact\n2. Delete artifact\n3. Display artifact\n4. List all artifacts\n0. Exit\nChoose an option: 3\n\nEnter artifact index to display: 1\n\n--- Artifact #1 ---\nName       : Golden Mask\nYear       : 1325\nDescription: A ceremonial mask made of gold, discovered in the Andes.\n--------------------\n\n=== Museum Artifact Manager ===\n1. Add artifact\n2. Delete artifact\n3. Display artifact\n4. List all artifacts\n0. Exit\nChoose an option: 0\n\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n1. **Data Structure** \u2013 The primary entity must be represented by a `struct Artifact` containing at least the following members:  \n   ```c\n   char name[51];        // 50 chars + terminating null\n   int  year;\n   char description[201]; // 200 chars + terminating null\n   ```\n2. **Dynamic Allocation** \u2013 Every artifact must be allocated on the heap using `malloc` (or `calloc`). No static or global arrays of artifacts are allowed.\n3. **Display Function** \u2013 The logic for printing the details of a single artifact **must** reside in a function with the exact prototype:  \n   ```c\n   void displayArtifact(const struct Artifact *a, int index);\n   ```\n4. **Memory Management** \u2013 All memory obtained with `malloc`/`calloc` must be released with `free` before the program exits, and also when an artifact is deleted.\n5. **Menu Requirement** \u2013 The program must present a menu as shown in the example and **must** include an explicit option to **EXIT** the program (option `0` in the example). Selecting this option terminates the loop and ends the program after freeing memory.\n6. **Single\u2011File Implementation** \u2013 The entire solution must be written in a single source file (`.c`). Apart from `main`, you may define additional helper functions, but the core menu handling should remain in `main`.  \n\n*Note: The problem is intended for students who have just learned `malloc`, `free`, structs, and basic I/O. No advanced data structures (linked lists, etc.) are required; a simple dynamically\u2011resized array (reallocating as needed) is sufficient.*", "model": "openai/gpt-oss-120b", "iteration": 84}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired to write a small \u201cpersonal library\u201d manager for a university student who wants to keep track of the books he/she owns. The program must store each book\u2019s information dynamically because the number of books is not known at compile\u2011time and can change while the program runs (books can be added or removed).  \n\n## Requirements  \nWrite a C program that allows the user to manage a collection of books using **dynamic memory allocation** (`malloc`, `realloc`, `free`). The program must provide a **menu\u2011driven interface** with the following options:\n\n1. **Add a new book** \u2013 Prompt the user for the book\u2019s title (string, up to 100 characters), author (string, up to 100 characters), and number of pages (positive integer). Allocate memory for the new book and store it in the collection.  \n2. **Remove a book** \u2013 Ask for the **index** (starting at 1) of the book to delete. Remove the book from the collection, free its memory, and shift the remaining entries so that there are no gaps.  \n3. **List all books** \u2013 Display the index, title, author, and page count for every book currently stored.  \n4. **Display details of a specific book** \u2013 Ask for the index of a book and show its full information. The logic for this operation **must be placed in a function called `displayBook`**.  \n5. **Exit** \u2013 Terminate the program, freeing any memory that is still allocated. (The menu option to exit must be clearly numbered, e.g., `0. Exit`.)\n\n### Functional Details\n- The collection should be stored as a **dynamic array of `struct Book`**. The array may grow or shrink as books are added or removed, using `realloc` as needed.  \n- Input validation: if the user selects an invalid menu option or provides an out\u2011of\u2011range index, display an error message and re\u2011show the menu.  \n- When the program terminates (option \u201cExit\u201d), all memory that was allocated for books **must be freed**.  \n\n## Example Interaction  \n\n```\n=== Personal Library Manager ===\n1. Add a new book\n2. Remove a book\n3. List all books\n4. Display a specific book\n0. Exit\nChoose an option: 1\n\nEnter title: The C Programming Language\nEnter author: Kernighan & Ritchie\nEnter number of pages: 274\nBook added successfully!\n\n=== Personal Library Manager ===\n1. Add a new book\n2. Remove a book\n3. List all books\n4. Display a specific book\n0. Exit\nChoose an option: 3\n\nCurrent books:\n1) Title: The C Programming Language | Author: Kernighan & Ritchie | Pages: 274\n\n=== Personal Library Manager ===\n1. Add a new book\n2. Remove a book\n3. List all books\n4. Display a specific book\n0. Exit\nChoose an option: 4\n\nEnter book index to display: 1\n--- Book Details ---\nTitle : The C Programming Language\nAuthor: Kernighan & Ritchie\nPages : 274\n--------------------\n\n=== Personal Library Manager ===\n1. Add a new book\n2. Remove a book\n3. List all books\n4. Display a specific book\n0. Exit\nChoose an option: 0\n\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n- **Struct Requirement** \u2013 The primary data entity must be defined as  \n\n  ```c\n  typedef struct {\n      char title[101];\n      char author[101];\n      int  pages;\n  } Book;\n  ```\n\n- **Function Requirement** \u2013 The logic for displaying the details of ONE specific book **must be implemented in a function named** `void displayBook(const Book *b);`. No other function may perform this exact task.  \n\n- **Menu Exit Requirement** \u2013 The menu must contain an option explicitly labeled (e.g., `0. Exit`) that terminates the program. Selecting this option must cause the program to free all allocated memory before exiting.  \n\n- **Dynamic Allocation Only** \u2013 All storage for books must be obtained with `malloc`/`realloc` and released with `free`. No static or global arrays of books are allowed.  \n\n- **Single Source File** \u2013 The entire solution must be placed in a single `.c` file (aside from standard library headers).  \n\n- **No Memory Leaks** \u2013 The program will be tested with tools such as Valgrind; any leaked memory will result in a failed submission.  \n\n---  \n\nWrite the program fulfilling the above specifications. Good luck!", "model": "openai/gpt-oss-120b", "iteration": 85}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired by **Eco\u2011Logistics**, a small company that ships reusable containers across a city. Each container is tracked by three pieces of information:  \n\n* **ID** \u2013 a positive integer that uniquely identifies the container.  \n* **Weight** \u2013 the current load in kilograms (a `float`).  \n* **Destination** \u2013 a short string (max 30 characters) describing the delivery address.  \n\nThe company\u2019s software must be able to add new containers, remove containers that have been delivered, and display information about a particular container on demand. Because the number of active containers changes at runtime, the program must allocate and free memory dynamically.\n\n## Program Requirements  \n\n1. **Data Representation**  \n   * Define a `struct Container` that holds the three fields described above.  \n\n2. **Dynamic Storage**  \n   * Maintain a dynamic array (or linked list) of `Container` objects.  \n   * The array must grow when a new container is added (using `malloc`/`realloc`) and shrink when a container is removed (using `free`).  \n\n3. **Menu\u2011Driven Interface** (the program must present a text menu to the user)  \n   * **1 \u2013 Add a container**  \n     * Prompt for ID, weight, and destination.  \n     * Insert the new container at the end of the dynamic collection.  \n   * **2 \u2013 Remove a container**  \n     * Prompt for an ID.  \n     * If a container with that ID exists, delete it and free its memory; otherwise, print \u201cContainer not found.\u201d  \n   * **3 \u2013 Display a container**  \n     * Prompt for an ID.  \n     * If found, call a function `displayContainer` (see constraints) to print the container\u2019s details; otherwise, print \u201cContainer not found.\u201d  \n   * **4 \u2013 List all containers**  \n     * Print the ID, weight, and destination of every stored container, one per line.  \n   * **0 \u2013 Exit**  \n     * Terminate the program after releasing all allocated memory.  \n\n4. **Input Validation**  \n   * IDs are unique; if the user tries to add a container with an existing ID, print \u201cID already in use.\u201d and do not add it.  \n\n5. **Memory Management**  \n   * No memory leaks: every allocation must eventually be freed before program termination.  \n\n## Example Interaction  \n\n```\n=== Eco\u2011Logistics Container Manager ===\n1) Add a container\n2) Remove a container\n3) Display a container\n4) List all containers\n0) Exit\nChoice: 1\nEnter ID: 101\nEnter weight (kg): 12.5\nEnter destination: 12 Oak St.\nContainer added.\n\n1) Add a container\n2) Remove a container\n3) Display a container\n4) List all containers\n0) Exit\nChoice: 1\nEnter ID: 202\nEnter weight (kg): 8.0\nEnter destination: 45 Pine Ave.\nContainer added.\n\n1) Add a container\n2) Remove a container\n3) Display a container\n4) List all containers\n0) Exit\nChoice: 3\nEnter ID to display: 101\n--- Container 101 ---\nWeight: 12.5 kg\nDestination: 12 Oak St.\n\n1) Add a container\n2) Remove a container\n3) Display a container\n4) List all containers\n0) Exit\nChoice: 4\nID   Weight   Destination\n101  12.5     12 Oak St.\n202  8.0      45 Pine Ave.\n\n1) Add a container\n2) Remove a container\n3) Display a container\n4) List all containers\n0) Exit\nChoice: 0\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Struct Requirement** \u2013 The primary data entity **must** be represented by a `struct Container`.  \n* **Display Function** \u2013 The logic for showing the details of a **single** container **must** be placed in a function with the exact prototype:  \n\n  ```c\n  void displayContainer(const struct Container *c);\n  ```  \n\n* **Menu Exit Option** \u2013 The menu **must** contain an option numbered **0** (or the keyword `EXIT`) that cleanly terminates the program.  \n* **Single\u2011File Implementation** \u2013 Apart from `main`, you may define additional helper functions, but the entire solution must reside in one source file.  \n* **Dynamic Allocation Only** \u2013 You are **not** allowed to use static or global arrays to store the containers; all storage must come from `malloc`/`realloc` and be released with `free`.  \n\n---  \n\n*Write a C program that satisfies the above specifications.*", "model": "openai/gpt-oss-120b", "iteration": 86}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired as a software engineer for **PixelPet**, a startup that creates simple \u201cvirtual pet\u201d toys that run on tiny embedded systems. Each pet has a name, an age (in days), and a happiness level (0\u2011100). Because the device has very limited RAM, pets must be created and destroyed dynamically as the user interacts with the system.  \n\nYour task is to write a C program that lets the user **add**, **remove**, **list**, and **view details** of pets using dynamic memory allocation (`malloc` / `free`). The program must store each pet in a dynamically allocated `struct` and keep a list of pointers to those structs.\n\n## Requirements  \n\n1. **Data structure**  \n   * Define a `struct Pet` containing:  \n     - `char *name` \u2013 a dynamically allocated string (maximum length 50 characters).  \n     - `int age` \u2013 age in days.  \n     - `int happiness` \u2013 value from 0 to 100.  \n\n2. **Menu\u2011driven interface** (displayed repeatedly until the user chooses to exit)  \n   * **1. Add a new pet** \u2013 Prompt for name, age, and happiness; allocate memory for a new `Pet` and store its pointer in the list.  \n   * **2. Remove a pet** \u2013 Prompt for the pet\u2019s name; locate the matching pet, free its `name` string, free the `Pet` struct, and remove its pointer from the list. If the pet does not exist, print an error message.  \n   * **3. List all pets** \u2013 Print each pet\u2019s name on a separate line. If no pets exist, print \u201cNo pets available.\u201d  \n   * **4. Show pet details** \u2013 Prompt for a pet\u2019s name and display its age and happiness in the format shown in the example. Use a separate function named `displayPet` for this output. If the pet is not found, print an error message.  \n   * **5. EXIT** \u2013 Terminate the program gracefully, freeing any remaining allocated memory.  \n\n3. **Dynamic list management**  \n   * The list of pet pointers must be stored in a dynamically allocated array that grows as needed (you may reallocate with `realloc`).  \n   * Keep track of the current number of pets and the allocated capacity.  \n\n4. **Input validation**  \n   * Age must be a non\u2011negative integer.  \n   * Happiness must be an integer between 0 and 100 inclusive.  \n   * If the user enters invalid data, display a brief error message and return to the menu.  \n\n5. **Program termination**  \n   * Before exiting, ensure that **all** memory allocated for pet names, pet structs, and the pointer array is freed.  \n\n## Example Interaction  \n\n```\n--- PixelPet Management ---\n1) Add a new pet\n2) Remove a pet\n3) List all pets\n4) Show pet details\n5) EXIT\nEnter choice: 1\nEnter pet name: Fluffy\nEnter age (days): 12\nEnter happiness (0-100): 85\nPet added successfully.\n\n--- PixelPet Management ---\n1) Add a new pet\n2) Remove a pet\n3) List all pets\n4) Show pet details\n5) EXIT\nEnter choice: 1\nEnter pet name: Bubbles\nEnter age (days): 5\nEnter happiness (0-100): 60\nPet added successfully.\n\n--- PixelPet Management ---\n1) Add a new pet\n2) Remove a pet\n3) List all pets\n4) Show pet details\n5) EXIT\nEnter choice: 3\nCurrent pets:\nFluffy\nBubbles\n\n--- PixelPet Management ---\n1) Add a new pet\n2) Remove a pet\n3) List all pets\n4) Show pet details\n5) EXIT\nEnter choice: 4\nEnter pet name to view: Fluffy\nPet Details:\nName: Fluffy\nAge: 12 days\nHappiness: 85\n\n--- PixelPet Management ---\n1) Add a new pet\n2) Remove a pet\n3) List all pets\n4) Show pet details\n5) EXIT\nEnter choice: 2\nEnter pet name to remove: Bubbles\nPet removed.\n\n--- PixelPet Management ---\n1) Add a new pet\n2) Remove a pet\n3) List all pets\n4) Show pet details\n5) EXIT\nEnter choice: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n1. **Struct usage** \u2013 The primary data entity **must** be represented by a `struct Pet` as described.  \n2. **Function requirement** \u2013 The logic that displays the details of a single pet **must** be implemented in a function with the exact prototype:  \n\n   ```c\n   void displayPet(const struct Pet *p);\n   ```  \n\n3. **Dynamic allocation only** \u2013 All memory for pet names, pet structs, and the pointer array must be obtained with `malloc`, `calloc`, or `realloc`. No static or global arrays of fixed size are allowed.  \n4. **Menu exit option** \u2013 The menu must contain an explicit option labeled **5) EXIT** (or the keyword `EXIT`) that terminates the program. Selecting this option must trigger the clean\u2011up of all allocated memory before the program ends.  \n\n*Optional hint for students:* consider keeping a variable `size_t capacity` and double it whenever the pointer array is full.  \n\n---  \n\n*Your solution will be evaluated on correctness of dynamic memory handling, adherence to the constraints, and proper freeing of all resources.*", "model": "openai/gpt-oss-120b", "iteration": 87}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired by a small wildlife\u2011conservation NGO to develop a simple C program that keeps track of rescued **turtles** awaiting release back into the wild. Each turtle has a unique tag number, its species name, and the number of days it has been in the care facility. The NGO\u2019s field volunteers will enter data for an arbitrary number of turtles during a single run of the program. Because the number of turtles is not known in advance, you must allocate memory dynamically.\n\n## Requirements  \n\nYour program must:\n\n1. **Store each turtle\u2019s data** in a dynamically allocated array of structures (use `malloc`/`realloc` as needed).  \n2. **Provide a text\u2011based menu** with the following options:  \n   1. **Add a new turtle** \u2013 Prompt the user for tag number (int), species (string \u2264 30 characters), and days in care (int). Append the new record to the dynamic array.  \n   2. **List all turtles** \u2013 Print a table showing all stored turtles in the order they were entered.  \n   3. **Search by tag** \u2013 Prompt for a tag number and display the matching turtle\u2019s details (or a \u201cnot found\u201d message).  \n   4. **Remove a turtle** \u2013 Prompt for a tag number, delete that turtle from the array, and shrink the allocated memory accordingly.  \n   5. **Exit** \u2013 Clean up all allocated memory and terminate the program.  \n\n3. All input should be read from `stdin`; all output should be written to `stdout`.  \n4. The program must **not leak memory**: every block obtained with `malloc`/`realloc` must eventually be released with `free`.  \n\n## Example Interaction  \n\n```\n=== Turtle Rescue Tracker ===\n1) Add a new turtle\n2) List all turtles\n3) Search by tag\n4) Remove a turtle\n5) Exit\nChoose an option: 1\nEnter tag number: 101\nEnter species (max 30 chars): Loggerhead\nEnter days in care: 12\nTurtle added.\n\n1) Add a new turtle\n2) List all turtles\n3) Search by tag\n4) Remove a turtle\n5) Exit\nChoose an option: 1\nEnter tag number: 202\nEnter species (max 30 chars): Green\nEnter days in care: 7\nTurtle added.\n\n1) Add a new turtle\n2) List all turtles\n3) Search by tag\n4) Remove a turtle\n5) Exit\nChoose an option: 2\nTag   Species          Days\n101   Loggerhead       12\n202   Green            7\n\n1) Add a new turtle\n2) List all turtles\n3) Search by tag\n4) Remove a turtle\n5) Exit\nChoose an option: 3\nEnter tag number to search: 202\nTag: 202, Species: Green, Days in care: 7\n\n1) Add a new turtle\n2) List all turtles\n3) Search by tag\n4) Remove a turtle\n5) Exit\nChoose an option: 4\nEnter tag number to remove: 101\nTurtle removed.\n\n1) Add a new turtle\n2) List all turtles\n3) Search by tag\n4) Remove a turtle\n5) Exit\nChoose an option: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Struct usage** \u2013 The primary data entity must be represented by a `struct` named `Turtle` containing at least the fields `int tag; char species[31]; int days;`.  \n* **Function decomposition** \u2013  \n  * The logic that **displays the details of ONE specific turtle** (used by the \u201cSearch by tag\u201d option) **must be placed in a function called `displayTurtle`** with prototype `void displayTurtle(const Turtle *t);`.  \n  * All other menu actions may be implemented in additional helper functions, but the program must contain **no more than three user\u2011defined functions besides `main`**.  \n* **Dynamic array management** \u2013 Use `malloc` for the initial allocation and `realloc` when expanding or shrinking the array. Do **not** use a fixed\u2011size array.  \n* **Menu exit requirement** \u2013 The menu must include an option explicitly labeled \u201c5) Exit\u201d (or the word `EXIT`) that terminates the program after freeing all allocated memory.  \n\nThese constraints are mandatory; solutions that violate any of them will be considered incomplete.", "model": "openai/gpt-oss-120b", "iteration": 88}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired to write a tiny \u201cstudent\u2011record manager\u201d for a university\u2019s registration office.  \nThe office keeps a **dynamic** list of students that can grow and shrink while the program runs.  \nEach student is represented by a `struct` that holds the student's **ID number**, **full name**, **age**, and **GPA**.  \n\nYour task is to write a menu\u2011driven C program that lets the user add new students, view a particular student\u2019s data, delete a student, and list all stored students. All memory for student records must be obtained with `malloc` (or `calloc`) and released with `free` when a record is removed or when the program terminates.\n\n## Requirements  \n\n1. **Data structure**  \n   * Define a `struct Student` containing:  \n     ```c\n     int    id;          // unique positive identifier\n     char  *name;        // dynamically allocated string (max 100 characters)\n     int    age;\n     float  gpa;\n     ```  \n   * The `name` field itself must be allocated dynamically (e.g., with `malloc`).\n\n2. **Menu** (displayed repeatedly until the user chooses to exit)  \n\n   | Option | Description |\n   |--------|-------------|\n   | 1      | **Add a new student** \u2013 ask for ID, name, age, GPA; allocate memory for the struct and for the name string, then store the pointer in the list. |\n   | 2      | **Display a student** \u2013 ask for an ID and print all fields of the matching student. If the ID does not exist, print an appropriate message. |\n   | 3      | **Delete a student** \u2013 ask for an ID, free the memory for that student (including the name string), and remove the pointer from the list. |\n   | 4      | **List all students** \u2013 print the data of every stored student in the order they were added. |\n   | 5      | **Exit** \u2013 free **all** remaining allocated memory and terminate the program. *(This option **must** be present.)* |\n\n3. **Dynamic list management**  \n   * The program must not assume a fixed maximum number of students.  \n   * Use a dynamically allocated array of `Student *` (e.g., start with capacity 2 and `realloc` as needed) to store the pointers to each student record.  \n\n4. **Functions**  \n   * Implement a function `void displayStudent(const Student *s);` that prints a single student\u2019s information in a readable format. This function must be used by menu options 2 and 4.  \n   * All other logic may reside in `main` or additional helper functions, but **no other function may directly perform printing of a student\u2019s fields** (the printing must go through `displayStudent`).  \n\n5. **Input validation**  \n   * IDs must be positive integers and unique; if the user tries to add a student with an existing ID, print an error and discard the input.  \n   * Age must be a positive integer; GPA must be a floating\u2011point number between `0.0` and `4.0`. If any value is invalid, request the input again.  \n\n6. **Memory safety**  \n   * Every block obtained with `malloc`/`calloc`/`realloc` must eventually be released with `free`.  \n   * The program must not leak memory when the user selects \u201cExit\u201d.  \n\n## Example Interaction  \n\n```\n=== Student Record Manager ===\n1) Add a new student\n2) Display a student\n3) Delete a student\n4) List all students\n5) Exit\nChoose an option: 1\n\nEnter ID: 101\nEnter name: Alice Johnson\nEnter age: 20\nEnter GPA: 3.7\nStudent added successfully.\n\n=== Student Record Manager ===\n1) Add a new student\n2) Display a student\n3) Delete a student\n4) List all students\n5) Exit\nChoose an option: 1\n\nEnter ID: 102\nEnter name: Bob Smith\nEnter age: 22\nEnter GPA: 3.2\nStudent added successfully.\n\n=== Student Record Manager ===\n1) Add a new student\n2) Display a student\n3) Delete a student\n4) List all students\n5) Exit\nChoose an option: 2\n\nEnter ID to display: 101\n--- Student 101 ---\nName : Alice Johnson\nAge  : 20\nGPA  : 3.70\n\n=== Student Record Manager ===\n1) Add a new student\n2) Display a student\n3) Delete a student\n4) List all students\n5) Exit\nChoose an option: 4\n\n--- All Students ---\n--- Student 101 ---\nName : Alice Johnson\nAge  : 20\nGPA  : 3.70\n--- Student 102 ---\nName : Bob Smith\nAge  : 22\nGPA  : 3.20\n\n=== Student Record Manager ===\n1) Add a new student\n2) Display a student\n3) Delete a student\n4) List all students\n5) Exit\nChoose an option: 3\n\nEnter ID to delete: 101\nStudent 101 deleted.\n\n=== Student Record Manager ===\n1) Add a new student\n2) Display a student\n3) Delete a student\n4) List all students\n5) Exit\nChoose an option: 5\nGoodbye!\n```\n\n*(The exact wording of prompts is not important, only the overall flow and required functionality.)*\n\n---\n\n### CONSTRAINTS  \n\n1. **Struct usage** \u2013 The primary data entity must be a `struct Student` as described.  \n2. **Display function** \u2013 The function `void displayStudent(const Student *s);` must be used for any output of a single student\u2019s details.  \n3. **Menu requirement** \u2013 The program must present a menu and **must** include an explicit \u201cExit\u201d option (option\u202f5 in the example). Selecting this option must free all allocated memory before terminating.  \n4. **Dynamic allocation only** \u2013 No static arrays of fixed size may be used to store the student records; the list must grow/shrink with `malloc`/`realloc`/`free`.  \n\n*Feel free to add any minor helper functions you need, but the above constraints are mandatory.*", "model": "openai/gpt-oss-120b", "iteration": 89}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired to write a small \u201cStudent Registry\u201d program for the campus IT department. The registry must keep track of an arbitrary number of students entered during a single execution of the program. Because the number of students is not known in advance, you must allocate and release memory dynamically using `malloc` and `free`.  \n\n## Requirements  \n1. **Data representation**  \n   * Define a `struct Student` that stores:  \n     - an integer `id` (unique identifier)  \n     - a string `name` (maximum 50 characters)  \n     - a floating\u2011point `gpa`  \n\n2. **Menu\u2011driven interface** (the program must present a menu repeatedly until the user chooses to exit)  \n   * **1. Add a student** \u2013 Prompt for `id`, `name`, and `gpa`. Allocate a new `Student` object with `malloc` and store it in a dynamically\u2011grown array (or linked list).  \n   * **2. Remove a student** \u2013 Prompt for an `id`. Locate the matching student, remove it from the collection, and `free` its memory. If the `id` does not exist, print an appropriate message.  \n   * **3. Display a student** \u2013 Prompt for an `id`. Locate the student and display all of its fields using a dedicated function (see Constraints). If the `id` is not found, inform the user.  \n   * **4. List all students** \u2013 Print the details of every student currently stored, in the order they were added.  \n   * **5. EXIT** \u2013 Terminate the program. Before exiting, free any memory that remains allocated.  \n\n3. **Input validation** \u2013 The program should handle non\u2011numeric input for menu choices gracefully (you may assume the user enters valid data for `id`, `name`, and `gpa`).  \n\n4. **Memory management** \u2013 No memory leak is allowed. Every block obtained with `malloc` must be released exactly once.  \n\n## Example Interaction  \n\n```\n=== Student Registry ===\n1) Add a student\n2) Remove a student\n3) Display a student\n4) List all students\n5) EXIT\nChoose an option: 1\nEnter ID: 101\nEnter name: Alice\nEnter GPA: 3.8\nStudent added.\n\n=== Student Registry ===\n1) Add a student\n2) Remove a student\n3) Display a student\n4) List all students\n5) EXIT\nChoose an option: 1\nEnter ID: 102\nEnter name: Bob\nEnter GPA: 3.5\nStudent added.\n\n=== Student Registry ===\n1) Add a student\n2) Remove a student\n3) Display a student\n4) List all students\n5) EXIT\nChoose an option: 4\nID: 101, Name: Alice, GPA: 3.80\nID: 102, Name: Bob, GPA: 3.50\n\n=== Student Registry ===\n1) Add a student\n2) Remove a student\n3) Display a student\n4) List all students\n5) EXIT\nChoose an option: 3\nEnter ID to display: 101\nID: 101, Name: Alice, GPA: 3.80\n\n=== Student Registry ===\n1) Add a student\n2) Remove a student\n3) Display a student\n4) List all students\n5) EXIT\nChoose an option: 2\nEnter ID to remove: 102\nStudent removed.\n\n=== Student Registry ===\n1) Add a student\n2) Remove a student\n3) Display a student\n4) List all students\n5) EXIT\nChoose an option: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n- **Struct usage**: The primary data entity must be represented by a `struct Student`.  \n- **Display function**: The logic for showing the details of **one** specific student must be placed in a function named `void displayStudent(const struct Student *s);`.  \n- **Menu requirement**: The menu must contain an explicit option numbered **5** (or the keyword `EXIT`) that terminates the program.  \n- **Memory discipline**: Every `malloc` call must have a matching `free`. The program must not leak memory, even when the user exits without removing all students.  \n\n*Note: You may implement the collection as a dynamic array that is resized with `realloc`, or as a singly\u2011linked list; either approach is acceptable as long as dynamic allocation (`malloc`/`realloc`) and deallocation (`free`) are used correctly.*", "model": "openai/gpt-oss-120b", "iteration": 90}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired to write a small utility for the campus \u201cLost\u2011and\u2011Found\u201d office.  Items that are turned in are recorded in a computer system so that owners can later retrieve them.  Each item has a **type** (e.g., \u201cWallet\u201d, \u201cBackpack\u201d, \u201cPhone\u201d), a **description** (a short text entered by the staff member), and the **room number** where it was found.  \n\nThe office wants a simple console program that lets a user **add**, **list**, **search**, and **remove** items while the program is running.  Because the number of items is not known in advance, the program must allocate memory dynamically using `malloc`/`free`.\n\n## Requirements  \n\n1. Define a `struct Item` that holds the three fields mentioned above (`type`, `description`, `room`).  \n2. The program must maintain a **dynamic array** (i.e., a pointer that can be re\u2011allocated) of `Item` objects.  \n3. Implement a **menu\u2011driven** interface with the following options (the user enters the number shown):  \n   1. **Add a new item** \u2013 Prompt for type, description, and room; store the new item at the end of the array (grow the array with `realloc`).  \n   2. **List all items** \u2013 Print every stored item, one per line, showing its index (starting at\u202f0) and all fields.  \n   3. **Search by room** \u2013 Prompt for a room number and display all items that were found in that room.  \n   4. **Remove an item** \u2013 Prompt for the index of the item to delete; remove it by shifting later elements left and shrinking the array with `realloc`.  \n   5. **EXIT** \u2013 Terminate the program (must be option\u202f5).  \n\n4. All memory allocated for the array (and any strings inside the struct, if you allocate them separately) must be released before the program exits.  \n\n## Example Input / Output  \n\n```\n=== Lost\u2011and\u2011Found Management ===\n1) Add a new item\n2) List all items\n3) Search by room\n4) Remove an item\n5) EXIT\nChoose an option: 1\nEnter item type: Phone\nEnter description: Black iPhone 12, cracked screen\nEnter room number: 210\n\nItem added successfully.\n\n=== Lost\u2011and\u2011Found Management ===\n1) Add a new item\n2) List all items\n3) Search by room\n4) Remove an item\n5) EXIT\nChoose an option: 1\nEnter item type: Wallet\nEnter description: Brown leather, contains ID and cash\nEnter room number: 210\n\nItem added successfully.\n\n=== Lost\u2011and\u2011Found Management ===\n1) Add a new item\n2) List all items\n3) Search by room\n4) Remove an item\n5) EXIT\nChoose an option: 2\n\n[0] Type: Phone   Room: 210   Description: Black iPhone 12, cracked screen\n[1] Type: Wallet  Room: 210   Description: Brown leather, contains ID and cash\n\n=== Lost\u2011and\u2011Found Management ===\n1) Add a new item\n2) List all items\n3) Search by room\n4) Remove an item\n5) EXIT\nChoose an option: 3\nEnter room number to search: 210\n\n[0] Type: Phone   Description: Black iPhone 12, cracked screen\n[1] Type: Wallet  Description: Brown leather, contains ID and cash\n\n=== Lost\u2011and\u2011Found Management ===\n1) Add a new item\n2) List all items\n3) Search by room\n4) Remove an item\n5) EXIT\nChoose an option: 4\nEnter index of item to remove: 0\n\nItem removed.\n\n=== Lost\u2011and\u2011Found Management ===\n1) Add a new item\n2) List all items\n3) Search by room\n4) Remove an item\n5) EXIT\nChoose an option: 2\n\n[0] Type: Wallet  Room: 210   Description: Brown leather, contains ID and cash\n\n=== Lost\u2011and\u2011Found Management ===\n1) Add a new item\n2) List all items\n3) Search by room\n4) Remove an item\n5) EXIT\nChoose an option: 5\n\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Struct Requirement** \u2013 The primary data entity must be represented by a `struct Item`.  \n* **Function Requirement** \u2013 The logic for displaying the details of **one specific item** must be placed in a function named `void displayItem(const struct Item *p);`. This function should be used by both the \u201cList all items\u201d and the \u201cSearch by room\u201d options.  \n* **Menu Exit** \u2013 The menu must contain the explicit option **5) EXIT** (or the keyword `EXIT`) that terminates the program.  \n* **Dynamic Allocation Only** \u2013 The array of items must be created with `malloc`/`realloc` and freed with `free`. No static or fixed\u2011size arrays are allowed.  \n* **Single\u2011File Implementation** \u2013 All code must reside in a single source file (e.g., `lost_and_found.c`). Apart from `main`, you may create additional helper functions, but the only required extra function is `displayItem`.  \n\n---  \n\n*Feel free to add any harmless user\u2011interface niceties (such as clearing the screen or pausing), as long as the core requirements and constraints above are satisfied.*", "model": "openai/gpt-oss-120b", "iteration": 91}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired as the software developer for **\u201cCampus Caf\u00e9\u201d**, a small coffee shop on a university campus.  \nThe caf\u00e9 wants a simple command\u2011line inventory system to keep track of the drinks it sells during the day.  \nEach drink has a name, a price (in dollars, to two decimal places), and the quantity currently in stock.  \n\nBecause the number of different drinks can change from day to day (new seasonal drinks may be added, old ones removed), the program must allocate memory dynamically for the list of drinks.\n\n## Requirements  \n\nWrite a **menu\u2011driven** C program that allows the user to manage the drink inventory. The program must support the following operations:\n\n1. **Add a new drink**  \n   - Prompt for the drink\u2019s name (a string of up to 30 characters, no spaces), price, and initial quantity.  \n   - Allocate memory for the new drink and store it in the dynamic array, expanding the array as necessary with `realloc`.  \n\n2. **Remove a drink**  \n   - Prompt for the name of the drink to delete.  \n   - If the drink exists, remove it from the array, free the memory associated with that drink, and shrink the array with `realloc`.  \n   - If the drink does not exist, display an appropriate message.  \n\n3. **Update the quantity of a drink**  \n   - Prompt for the drink\u2019s name and the amount to add (positive integer) or subtract (negative integer).  \n   - Adjust the quantity accordingly; the quantity must never become negative.  \n   - If the drink is not found, display an appropriate message.  \n\n4. **Display a drink\u2019s details**  \n   - Prompt for the drink\u2019s name.  \n   - Show the name, price, and current quantity of that drink.  \n   - The logic for displaying a single drink must be placed in a function called `displayEntity`.  \n\n5. **List all drinks**  \n   - Print a table containing the name, price, and quantity of every drink currently stored.  \n\n6. **Exit**  \n   - Terminate the program, freeing **all** dynamically allocated memory before exiting.  \n\nThe menu must be displayed after each operation and must contain a clearly labeled option to **EXIT** the program (e.g., \u201c0 \u2013 Exit\u201d).\n\n## Example Interaction  \n\n```\n=== Campus Caf\u00e9 Inventory ===\n1) Add a new drink\n2) Remove a drink\n3) Update drink quantity\n4) Display a drink\n5) List all drinks\n0) Exit\nChoose an option: 1\nEnter drink name: Latte\nEnter price: 3.50\nEnter quantity: 10\nDrink added.\n\n=== Campus Caf\u00e9 Inventory ===\n1) Add a new drink\n2) Remove a drink\n3) Update drink quantity\n4) Display a drink\n5) List all drinks\n0) Exit\nChoose an option: 1\nEnter drink name: Espresso\nEnter price: 2.25\nEnter quantity: 5\nDrink added.\n\n=== Campus Caf\u00e9 Inventory ===\n1) Add a new drink\n2) Remove a drink\n3) Update drink quantity\n4) Display a drink\n5) List all drinks\n0) Exit\nChoose an option: 4\nEnter drink name to display: Latte\n--- Drink Details ---\nName    : Latte\nPrice   : $3.50\nQuantity: 10\n\n=== Campus Caf\u00e9 Inventory ===\n1) Add a new drink\n2) Remove a drink\n3) Update drink quantity\n4) Display a drink\n5) List all drinks\n0) Exit\nChoose an option: 5\n--- All Drinks ---\nName       Price   Quantity\nLatte      3.50    10\nEspresso   2.25    5\n\n=== Campus Caf\u00e9 Inventory ===\n1) Add a new drink\n2) Remove a drink\n3) Update drink quantity\n4) Display a drink\n5) List all drinks\n0) Exit\nChoose an option: 0\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Struct Requirement** \u2013 The primary data entity (a drink) must be represented by a `struct` named `Drink` containing at least the fields `name`, `price`, and `quantity`.  \n* **Function Requirement** \u2013 The code that prints the details of a single drink **must** be placed in a function with the exact prototype:  \n\n  ```c\n  void displayEntity(const Drink *d);\n  ```  \n\n* **Dynamic Allocation** \u2013 The array that holds the pointers to `Drink` objects must be allocated with `malloc`/`realloc` and each individual `Drink` must also be allocated with `malloc`. No static (fixed\u2011size) arrays are allowed for storing the drinks.  \n* **Memory Management** \u2013 Every call to `malloc`/`realloc` must have a matching `free` before the program terminates.  \n* **Menu Exit Option** \u2013 The menu must include an explicit option to exit the program (e.g., option `0 \u2013 Exit`). Selecting this option must cause the program to free all allocated memory and then terminate.  \n\n*Optional (for extra credit):*  \n- Validate all numeric input (price must be non\u2011negative, quantity must be an integer).  \n- Keep the drink list sorted alphabetically after each insertion.  ", "model": "openai/gpt-oss-120b", "iteration": 92}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired to write a tiny command\u2011line \u201cpersonal library\u201d program for a university reading club. The club members will add information about the books they own, query the collection, and remove books when they are donated away. Because the number of books is not known in advance and can change while the program runs, you must allocate and free memory dynamically using `malloc` and `free`.\n\n## Requirements  \n\nWrite a C program that implements a **menu\u2011driven** interface with the following options (the user selects an option by typing its number and pressing **Enter**):\n\n1. **Add a new book** \u2013 Prompt the user for the book\u2019s ISBN (string, up to 13 characters), title (string, up to 100 characters), and number of pages (positive integer). Allocate a new `struct Book` on the heap and store the data.  \n2. **List all books** \u2013 Print the details of every book currently stored, in the order they were added.  \n3. **Find a book by ISBN** \u2013 Prompt for an ISBN, search the collection, and display the matching book\u2019s details (or a \u201cnot found\u201d message).  \n4. **Remove a book by ISBN** \u2013 Prompt for an ISBN, locate the book, free its memory, and remove it from the list so that subsequent listings no longer show it. If the ISBN is not present, display an appropriate message.  \n5. **Exit** \u2013 Terminate the program, freeing any remaining allocated memory.\n\nThe program should continue to display the menu after completing any option except **Exit**.\n\n## Example Input / Output  \n\n```\n=== Personal Library Menu ===\n1) Add a new book\n2) List all books\n3) Find a book by ISBN\n4) Remove a book by ISBN\n5) Exit\nSelect an option: 1\n\nEnter ISBN (max 13 chars): 9780131103627\nEnter title: The C Programming Language\nEnter number of pages: 274\nBook added successfully!\n\n=== Personal Library Menu ===\n1) Add a new book\n2) List all books\n3) Find a book by ISBN\n4) Remove a book by ISBN\n5) Exit\nSelect an option: 2\n\n--- Book List ---\nISBN: 9780131103627\nTitle: The C Programming Language\nPages: 274\n--- End of List ---\n\n=== Personal Library Menu ===\n1) Add a new book\n2) List all books\n3) Find a book by ISBN\n4) Remove a book by ISBN\n5) Exit\nSelect an option: 5\n\nGoodbye!\n```\n\n(Any reasonable formatting of the output is acceptable as long as the required information is present.)\n\n## ### CONSTRAINTS  \n\n1. **Struct Requirement** \u2013 The primary data entity must be represented by a `struct Book` containing at least the following members:  \n   ```c\n   typedef struct Book {\n       char isbn[14];      // space for 13 characters + null terminator\n       char title[101];    // space for 100 characters + null terminator\n       int  pages;\n       struct Book *next; // pointer for linked\u2011list chaining\n   } Book;\n   ```\n2. **Function Requirement** \u2013 The logic that prints the details of **exactly one** `Book` must be placed in a function with the exact prototype:  \n   ```c\n   void displayBook(const Book *b);\n   ```\n   This function may be called from other parts of the program (e.g., when listing all books or showing a search result).  \n3. **Memory Management** \u2013 Every `malloc` call must have a corresponding `free` when a book is removed or when the program exits. No memory leaks are permitted.  \n4. **Menu Requirement** \u2013 The menu must include an option to **EXIT** the program; it must be clearly identified as option **5** (or the keyword \u201cexit\u201d) and must cause the program to terminate after freeing all allocated memory.  \n\n*No additional libraries beyond `<stdio.h>`, `<stdlib.h>`, and `<string.h>` may be used.*  \n\n---  \n\n**Your task** is to design the problem statement above; you do **not** need to provide a solution. The problem should be clear enough for a student who has just learned about `malloc`, `free`, and basic struct handling to implement.", "model": "openai/gpt-oss-120b", "iteration": 93}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired to write a small \u201cinventory\u201d program for a local hobby\u2011shop that sells model kits.  \nEach model kit has a **name**, a **price**, and a **quantity in stock**.  \nThe shop owner wants to be able to add new kits, remove kits that are discontinued, and view the details of a single kit on demand.  \nBecause the number of different kits changes over time, the program must allocate memory dynamically for each kit as it is entered.\n\n## Requirements  \nWrite a C program that fulfills the following functional specifications:\n\n1. **Data Representation**  \n   * Define a `struct Kit` that stores the name (a string of up to 50 characters), price (a `double`), and quantity (an `int`).  \n\n2. **Menu\u2011driven Interface** (the program must present a text menu repeatedly until the user chooses to exit)  \n   * **1 \u2013 Add a new kit**  \n     * Prompt the user for the name, price, and quantity.  \n     * Allocate memory for a new `struct Kit` using `malloc` and store the entered data.  \n     * Store the pointer in a dynamic array that grows as needed (you may re\u2011allocate the array with `realloc`).  \n   * **2 \u2013 Delete a kit**  \n     * Prompt for the name of the kit to delete.  \n     * Search the dynamic array for a kit with that exact name.  \n     * If found, free the memory for that `struct Kit`, remove the pointer from the array, and shrink the array accordingly.  \n     * If not found, print \u201cKit not found.\u201d  \n   * **3 \u2013 Display a kit**  \n     * Prompt for the name of the kit to display.  \n     * Locate the kit and call a function `displayKit` (see Constraints) to print its details in the format shown in the example.  \n     * If the kit does not exist, print \u201cKit not found.\u201d  \n   * **4 \u2013 List all kits**  \n     * Iterate over the dynamic array and print the details of every kit, one per line.  \n   * **5 \u2013 EXIT**  \n     * Terminate the program after freeing **all** allocated memory.  \n\n3. **Input Validation**  \n   * The program should handle non\u2011numeric input for price and quantity gracefully (you may assume the user follows the prompts).  \n\n4. **Memory Management**  \n   * Every `malloc`/`realloc` must have a matching `free`.  \n   * No memory leaks should remain when the program exits.\n\n## Example Interaction  \n\n```\n=== Model Kit Inventory ===\n1) Add a new kit\n2) Delete a kit\n3) Display a kit\n4) List all kits\n5) EXIT\nChoose an option: 1\nEnter kit name: Starfighter\nEnter price: 34.99\nEnter quantity: 12\nKit added.\n\n=== Model Kit Inventory ===\n1) Add a new kit\n2) Delete a kit\n3) Display a kit\n4) List all kits\n5) EXIT\nChoose an option: 1\nEnter kit name: Space Rover\nEnter price: 27.50\nEnter quantity: 5\nKit added.\n\n=== Model Kit Inventory ===\n1) Add a new kit\n2) Delete a kit\n3) Display a kit\n4) List all kits\n5) EXIT\nChoose an option: 3\nEnter kit name to display: Starfighter\nName: Starfighter, Price: $34.99, Quantity: 12\n\n=== Model Kit Inventory ===\n1) Add a new kit\n2) Delete a kit\n3) Display a kit\n4) List all kits\n5) EXIT\nChoose an option: 4\nName: Starfighter, Price: $34.99, Quantity: 12\nName: Space Rover, Price: $27.50, Quantity: 5\n\n=== Model Kit Inventory ===\n1) Add a new kit\n2) Delete a kit\n3) Display a kit\n4) List all kits\n5) EXIT\nChoose an option: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n1. **Struct Usage** \u2013 The primary data entity must be represented by a `struct Kit`.  \n2. **Display Function** \u2013 The logic for printing the details of a single kit must be placed in a function with the exact prototype:  \n\n   ```c\n   void displayKit(const struct Kit *k);\n   ```  \n\n3. **Menu Requirement** \u2013 The program must present a menu as described above and **must include option 5 (or the keyword EXIT) to terminate the program**.  \n4. **Single\u2011source File** \u2013 All code must reside in a single `.c` file; you may define additional helper functions, but the `main` function must orchestrate the menu loop.  \n5. **Dynamic Array Management** \u2013 You must manage the collection of kit pointers with a dynamically allocated array (using `malloc`/`realloc`). Static arrays or fixed\u2011size limits are not allowed.  \n\n*Feel free to add any auxiliary helper functions you need, but respect the constraints above.*", "model": "openai/gpt-oss-120b", "iteration": 94}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired by the **Campus Event Planning Office** to write a small utility that keeps track of **event volunteers**.  \nEach volunteer has a name (up to 30 characters) and the number of hours they have pledged to work.  \nThe office does not know in advance how many volunteers will sign up, so the program must allocate memory dynamically as volunteers are added and release it when they are removed.\n\n## Requirements  \n\nWrite a C program that provides a **menu\u2011driven interface** to manage the volunteer list. The program must support the following operations:\n\n1. **Add a volunteer**  \n   - Prompt the user for the volunteer\u2019s name and pledged hours.  \n   - Dynamically allocate (or re\u2011allocate) space to store the new volunteer record.  \n\n2. **Remove a volunteer**  \n   - Prompt for the volunteer\u2019s name.  \n   - If a volunteer with that name exists, remove the record, shrink the allocated array accordingly, and free the memory that is no longer needed.  \n   - If the name is not found, display an appropriate message.  \n\n3. **Display all volunteers**  \n   - List every stored volunteer in the order they were added, showing the name and pledged hours.  \n\n4. **Display a specific volunteer**  \n   - Prompt for a name and, if found, display that volunteer\u2019s details.  \n   - The logic for this operation must be placed in a function named `displayVolunteer`.  \n\n5. **Exit**  \n   - Terminate the program, freeing all allocated memory.  \n\nThe menu must be displayed after each completed operation until the user chooses to exit.\n\n## Example Input / Output  \n\n```\n=== Volunteer Management Menu ===\n1) Add volunteer\n2) Remove volunteer\n3) Display all volunteers\n4) Display a specific volunteer\n5) Exit\nEnter choice: 1\nEnter name: Alice\nEnter pledged hours: 12\n\nVolunteer added.\n\n=== Volunteer Management Menu ===\n1) Add volunteer\n2) Remove volunteer\n3) Display all volunteers\n4) Display a specific volunteer\n5) Exit\nEnter choice: 1\nEnter name: Bob\nEnter pledged hours: 8\n\nVolunteer added.\n\n=== Volunteer Management Menu ===\n1) Add volunteer\n2) Remove volunteer\n3) Display all volunteers\n4) Display a specific volunteer\n5) Exit\nEnter choice: 3\n\nCurrent volunteers:\n1. Alice \u2013 12 hours\n2. Bob \u2013 8 hours\n\n=== Volunteer Management Menu ===\n1) Add volunteer\n2) Remove volunteer\n3) Display all volunteers\n4) Display a specific volunteer\n5) Exit\nEnter choice: 4\nEnter name to view: Bob\n\nVolunteer details:\nName: Bob\nHours pledged: 8\n\n=== Volunteer Management Menu ===\n1) Add volunteer\n2) Remove volunteer\n3) Display all volunteers\n4) Display a specific volunteer\n5) Exit\nEnter choice: 5\n\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Struct usage** \u2013 The primary data entity must be represented with a `struct` named `Volunteer` containing at least the fields `char name[31];` and `int hours;`.  \n* **Dynamic allocation** \u2013 Use `malloc`, `realloc`, and `free` to manage the array of `Volunteer` records. No fixed\u2011size arrays are allowed.  \n* **Function requirement** \u2013 The logic for displaying the details of ONE specific volunteer must be implemented in a function with the exact prototype:  \n  ```c\n  void displayVolunteer(const Volunteer *v);\n  ```  \n* **Menu exit option** \u2013 The menu must include an option (clearly numbered or keyworded) that allows the user to exit the program; choosing this option must free all allocated memory before terminating.  \n\nYour solution should compile with a standard C compiler (e.g., `gcc -std=c11`).", "model": "openai/gpt-oss-120b", "iteration": 95}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired to write a small utility for a **community garden**. The garden keeps a list of *plot reservations*. Each reservation stores the gardener\u2019s name, the size of the plot (in square meters), and the number of weeks the plot will be used. The garden manager wants a simple command\u2011line program that can add new reservations, remove an existing reservation, and display the details of any reservation on demand. Because the number of reservations is not known in advance and can change while the program runs, you must allocate and free memory dynamically.\n\n## Requirements  \n\n1. **Data Structure**  \n   * Define a `struct Reservation` that contains:  \n     - `char *name` \u2013 a dynamically allocated string for the gardener\u2019s name (max length 100 characters).  \n     - `int size` \u2013 plot size in square meters.  \n     - `int weeks` \u2013 number of weeks the reservation lasts.  \n   * Store each reservation in a dynamically allocated node of a singly\u2011linked list.\n\n2. **Program Functionality**  \n   The program must present a **menu** with the following options (the user selects by entering the number):  \n   1. **Add a reservation** \u2013 Prompt for name, size, and weeks, allocate memory for a new `Reservation`, and insert it at the end of the list.  \n   2. **Remove a reservation** \u2013 Prompt for the gardener\u2019s name, locate the first node whose `name` matches exactly, remove it from the list, and free all associated memory. If no such reservation exists, print an informative message.  \n   3. **Display a reservation** \u2013 Prompt for the gardener\u2019s name and call a function `displayReservation` (see Constraints) to print the reservation\u2019s details. If the name is not found, print an informative message.  \n   4. **List all reservations** \u2013 Traverse the list and print each reservation\u2019s details in the order they were added.  \n   5. **EXIT** \u2013 Terminate the program after freeing all allocated memory.  \n\n3. **User Interaction**  \n   - After completing any operation (except EXIT), the menu should be shown again.  \n   - Input validation is not required beyond what is described; you may assume the user enters data of the correct type.\n\n4. **Memory Management**  \n   - Every `malloc`/`calloc`/`realloc` must have a matching `free`.  \n   - When a reservation is removed or the program exits, all memory belonging to that reservation (including the name string) must be released.\n\n## Example Input / Output  \n\n```\n=== Garden Plot Reservation System ===\n1) Add a reservation\n2) Remove a reservation\n3) Display a reservation\n4) List all reservations\n5) EXIT\nSelect an option: 1\n\nEnter gardener's name: Alice\nEnter plot size (m^2): 12\nEnter number of weeks: 8\nReservation added.\n\n=== Garden Plot Reservation System ===\n1) Add a reservation\n2) Remove a reservation\n3) Display a reservation\n4) List all reservations\n5) EXIT\nSelect an option: 1\n\nEnter gardener's name: Bob\nEnter plot size (m^2): 20\nEnter number of weeks: 4\nReservation added.\n\n=== Garden Plot Reservation System ===\n1) Add a reservation\n2) Remove a reservation\n3) Display a reservation\n4) List all reservations\n5) EXIT\nSelect an option: 3\n\nEnter gardener's name to display: Alice\nReservation for Alice:\n  Plot size: 12 m^2\n  Duration : 8 weeks\n\n=== Garden Plot Reservation System ===\n1) Add a reservation\n2) Remove a reservation\n3) Display a reservation\n4) List all reservations\n5) EXIT\nSelect an option: 4\n\nAll reservations:\n1) Alice \u2013 12 m^2, 8 weeks\n2) Bob   \u2013 20 m^2, 4 weeks\n\n=== Garden Plot Reservation System ===\n1) Add a reservation\n2) Remove a reservation\n3) Display a reservation\n4) List all reservations\n5) EXIT\nSelect an option: 5\n\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n1. **Struct Requirement** \u2013 The primary data entity must be represented with a `struct Reservation` as described.  \n2. **Display Function** \u2013 The logic for showing the details of a single reservation must be placed in a function with the exact prototype:  \n\n   ```c\n   void displayReservation(const struct Reservation *r);\n   ```\n\n3. **Menu Exit Option** \u2013 The menu must contain an option labelled **EXIT** (option number 5 in the example) that terminates the program. Selecting this option must first free **all** dynamically allocated memory.  \n\n4. **Single\u2011File Implementation** \u2013 Apart from `main`, you may define additional helper functions, but the entire solution must be contained in a single source file (e.g., `garden.c`).  \n\n5. **Standard Library Only** \u2013 Use only the C standard library (`stdio.h`, `stdlib.h`, `string.h`, etc.). No third\u2011party libraries are allowed.  ", "model": "openai/gpt-oss-120b", "iteration": 96}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired by the campus IT department to write a small utility that keeps track of **temporary study\u2011group sessions** for a single course.  \nEach session is created at run\u2011time, stores a few pieces of information, and can be removed when the group finishes.  \nBecause the number of sessions is not known in advance, the program must allocate and free memory dynamically using `malloc` and `free`.\n\n## Program Requirements  \n\n1. **Data representation**  \n   * Define a `struct Session` that contains:  \n     - an integer `id` (unique identifier, assigned sequentially starting from\u202f1)  \n     - a string `topic` (maximum 50 characters)  \n     - an integer `participants` (number of students in the group)  \n\n2. **Menu\u2011driven interface** (the program must present a text menu after each operation)  \n   * **1 \u2013 Add a new session**  \n     - Prompt the user for `topic` and `participants`.  \n     - Allocate memory for a new `struct Session`, fill the fields, assign the next `id`, and store the pointer in a dynamic array that grows as needed.  \n   * **2 \u2013 List all sessions**  \n     - Print a table showing `id`, `topic`, and `participants` for every session currently stored.  \n   * **3 \u2013 Display a session**  \n     - Ask for a session `id` and call a function `displaySession` (see constraints) to print the details of that single session.  \n   * **4 \u2013 Delete a session**  \n     - Ask for a session `id`. Remove the corresponding `struct Session` from the dynamic array, free its memory, and shift the remaining pointers so that the array stays compact.  \n   * **5 \u2013 EXIT**  \n     - Terminate the program after freeing **all** remaining allocated memory.  \n\n3. The program must continue to show the menu until the user selects the **EXIT** option.\n\n## Example Interaction  \n\n```\n=== Study\u2011Group Manager ===\n1) Add a new session\n2) List all sessions\n3) Display a session\n4) Delete a session\n5) EXIT\nChoose an option: 1\nEnter topic: Operating Systems Review\nEnter number of participants: 4\nSession added with id 1.\n\n=== Study\u2011Group Manager ===\n1) Add a new session\n2) List all sessions\n3) Display a session\n4) Delete a session\n5) EXIT\nChoose an option: 1\nEnter topic: Compiler Design Basics\nEnter number of participants: 3\nSession added with id 2.\n\n=== Study\u2011Group Manager ===\n1) Add a new session\n2) List all sessions\n3) Display a session\n4) Delete a session\n5) EXIT\nChoose an option: 2\nID   Topic                     Participants\n1    Operating Systems Review  4\n2    Compiler Design Basics    3\n\n=== Study\u2011Group Manager ===\n1) Add a new session\n2) List all sessions\n3) Display a session\n4) Delete a session\n5) EXIT\nChoose an option: 3\nEnter session id to display: 2\n--- Session 2 ---\nTopic: Compiler Design Basics\nParticipants: 3\n\n=== Study\u2011Group Manager ===\n1) Add a new session\n2) List all sessions\n3) Display a session\n4) Delete a session\n5) EXIT\nChoose an option: 5\nCleaning up\u2026 All memory freed. Goodbye!\n```\n\n## ### CONSTRAINTS  \n\n1. **Struct usage** \u2013 The primary data entity must be represented with a `struct Session`.  \n2. **Display function** \u2013 The logic for showing the details of a **single** session must reside in a function with the exact prototype:  \n\n   ```c\n   void displaySession(const struct Session *s);\n   ```  \n\n3. **Dynamic array management** \u2013 The collection of session pointers must be stored in a dynamically allocated array that grows (e.g., using `realloc`) when new sessions are added and shrinks when sessions are removed.  \n4. **Memory safety** \u2013 Every `malloc`/`realloc` must have a corresponding `free`. No memory leaks are allowed; all allocated memory must be released before program termination.  \n5. **Menu requirement** \u2013 The menu must include an explicit option **5 \u2013 EXIT** (or the word \u201cEXIT\u201d) that ends the program. Selecting this option must trigger the cleanup described above.  \n\n*Note:* Use only the standard C library (`stdio.h`, `stdlib.h`, `string.h`). Do **not** use global variables; all data structures should be managed through pointers passed between functions.", "model": "openai/gpt-oss-120b", "iteration": 97}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired by the **Campus Bookstore** to write a small C program that keeps track of the books currently on loan to students.  \nEach loan record contains the student\u2019s ID, the title of the book, and the number of days the book is borrowed for.  \nThe bookstore wants a simple console application that can add new loan records, remove a record when a book is returned, and display the details of a particular loan.  \n\nBecause the number of active loans changes over the semester, the program must allocate memory dynamically for each record and release it when the record is removed.\n\n## Requirements  \n\nWrite a C program that fulfills the following functionality:\n\n1. **Data representation**  \n   * Define a `struct Loan` that stores:  \n     - `int studentID;`  \n     - `char *title;`   (dynamically allocated string)  \n     - `int days;`  \n\n2. **Menu\u2011driven interface** (the program must present a text menu and repeat until the user chooses to exit)  \n   * **1 \u2013 Add a new loan**  \n     - Prompt for `studentID`, the book `title` (a line of text up to 100 characters), and `days`.  \n     - Allocate a new `struct Loan` with `malloc`.  \n     - Allocate just\u2011enough memory for the title string, copy it, and store the pointer in the struct.  \n     - Insert the new loan at the end of a dynamically\u2011grown array (or linked list) of loans.  \n   * **2 \u2013 Return a loan (remove)**  \n     - Prompt for a `studentID`.  \n     - Search for the first loan with that `studentID`.  \n     - If found, free the memory used for the title string and the `struct Loan` itself, then remove it from the collection, shifting remaining elements if you use an array.  \n     - If not found, print \u201cLoan not found.\u201d  \n   * **3 \u2013 Display a loan**  \n     - Prompt for a `studentID`.  \n     - Locate the loan with that `studentID` and call a function `displayLoan` (see Constraint) to print its contents in the format shown in the example.  \n     - If the loan does not exist, print \u201cLoan not found.\u201d  \n   * **4 \u2013 List all loans**  \n     - Iterate over the collection and print each loan using `displayLoan`.  \n   * **0 \u2013 Exit**  \n     - Terminate the program after freeing **all** dynamically allocated memory.  \n\n3. **Error handling**  \n   * If any `malloc` call fails, print \u201cMemory allocation failed.\u201d and exit the program.  \n\n4. **Program termination**  \n   * Before exiting (via the menu option), ensure that every block of memory obtained with `malloc`/`calloc`/`realloc` is released with `free`.\n\n## Example Input / Output  \n\n```\n--- Campus Bookstore Loan System ---\n1. Add a new loan\n2. Return a loan\n3. Display a loan\n4. List all loans\n0. Exit\nChoose an option: 1\n\nEnter student ID: 12345\nEnter book title: Introduction to Algorithms\nEnter number of days: 14\nLoan added.\n\n--- Campus Bookstore Loan System ---\n1. Add a new loan\n2. Return a loan\n3. Display a loan\n4. List all loans\n0. Exit\nChoose an option: 1\n\nEnter student ID: 67890\nEnter book title: Clean Code\nEnter number of days: 7\nLoan added.\n\n--- Campus Bookstore Loan System ---\n1. Add a new loan\n2. Return a loan\n3. Display a loan\n4. List all loans\n0. Exit\nChoose an option: 3\n\nEnter student ID to display: 12345\nStudent ID: 12345\nTitle     : Introduction to Algorithms\nDays      : 14\n\n--- Campus Bookstore Loan System ---\n1. Add a new loan\n2. Return a loan\n3. Display a loan\n4. List all loans\n0. Exit\nChoose an option: 4\n\nStudent ID: 12345\nTitle     : Introduction to Algorithms\nDays      : 14\n\nStudent ID: 67890\nTitle     : Clean Code\nDays      : 7\n\n--- Campus Bookstore Loan System ---\n1. Add a new loan\n2. Return a loan\n3. Display a loan\n4. List all loans\n0. Exit\nChoose an option: 0\n\nAll memory freed. Goodbye!\n```\n\n## ### CONSTRAINTS  \n\n1. **Struct usage** \u2013 The primary data entity must be represented by a `struct Loan` as described above.  \n2. **Display function** \u2013 The logic for printing the details of a single loan must be placed in a function with the exact prototype:  \n\n   ```c\n   void displayLoan(const struct Loan *loan);\n   ```  \n\n3. **Single additional function** \u2013 Apart from `main` and `displayLoan`, you may create helper functions **only if** they are used for memory management (e.g., `createLoan`, `freeLoan`). No other functionality should be placed in extra functions.  \n4. **Menu requirement** \u2013 The program must provide a menu and **must** include an explicit option `0` (or the word \u201cEXIT\u201d) that terminates the program, as shown in the example.  \n5. **Dynamic allocation** \u2013 All loan records and their title strings must be allocated with `malloc` (or `calloc`/`realloc`). No static or global arrays of fixed size are allowed for storing the loans.  \n\n*Note: The problem is deliberately open to either an array that is resized with `realloc` or a linked\u2011list implementation; both satisfy the constraints as long as the above rules are respected.*", "model": "openai/gpt-oss-120b", "iteration": 98}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired as a junior developer for **\u201cPixelPet\u201d,** a simple console\u2011based virtual\u2011pet game. Each pet has a name, an age (in days), and a \u201chunger level\u201d that ranges from 0 (full) to 10 (starving). The game must allow the user to create any number of pets while the program runs, inspect a single pet\u2019s details, feed a pet (decrease its hunger level), and finally release all pets before exiting.\n\nThe focus of this assignment is to practice **dynamic memory allocation** with `malloc` and `free`. All pets must be stored on the heap, and the program must correctly clean up every allocation before terminating.\n\n## Program Requirements  \n\n1. **Data Representation**  \n   * Define a `struct Pet` that contains:  \n     - `char *name;`   (dynamically allocated string)  \n     - `int age;`  \n     - `int hunger;`  \n\n2. **Menu\u2011driven Interface** (displayed repeatedly until the user chooses to quit)  \n   * **1. Add a new pet** \u2013 Prompt for the pet\u2019s name (single word, up to 31 characters) and its age.  \n     - Allocate memory for a new `Pet`.  \n     - Allocate exactly enough memory to store the entered name (including the terminating `'\\0'`).  \n     - Initialise `hunger` to `5`.  \n   * **2. List all pets** \u2013 Print each pet\u2019s index (starting at 0) and name.  \n   * **3. Show pet details** \u2013 Ask for a pet index, then call a function `displayPet` that prints the pet\u2019s name, age, and hunger level.  \n   * **4. Feed a pet** \u2013 Ask for a pet index, then decrease its `hunger` by 1 (minimum 0).  \n   * **5. Remove a pet** \u2013 Ask for a pet index, free the memory for that pet\u2019s name and the `Pet` structure itself, and shift the remaining pets in the array so that indices stay contiguous.  \n   * **6. EXIT** \u2013 Terminate the program after freeing **all** remaining allocated memory.  \n\n3. **Dynamic Storage of the Pet List**  \n   * The collection of pets must be stored in a dynamically allocated array of pointers (`Pet **petList`).  \n   * When a new pet is added, the array should be resized with `realloc` to accommodate the extra pointer.  \n   * When a pet is removed, shrink the array accordingly.\n\n4. **Error Handling**  \n   * If the user enters an invalid index, print an informative message and return to the menu.  \n   * If any `malloc`/`realloc` call fails, print an error and exit gracefully after freeing any memory already obtained.\n\n5. **Program Termination**  \n   * Before exiting (whether via the menu or an error), ensure that every block of memory allocated with `malloc`/`realloc` is released with `free`.\n\n## Example Interaction  \n\n```\n--- PixelPet ---\n1) Add a new pet\n2) List all pets\n3) Show pet details\n4) Feed a pet\n5) Remove a pet\n6) EXIT\nChoose an option: 1\nEnter pet name: Fluffy\nEnter pet age (days): 12\nPet added.\n\n--- PixelPet ---\n1) Add a new pet\n2) List all pets\n3) Show pet details\n4) Feed a pet\n5) Remove a pet\n6) EXIT\nChoose an option: 2\n[0] Fluffy\n\n--- PixelPet ---\n1) Add a new pet\n2) List all pets\n3) Show pet details\n4) Feed a pet\n5) Remove a pet\n6) EXIT\nChoose an option: 3\nEnter pet index: 0\nName   : Fluffy\nAge    : 12 days\nHunger : 5\n\n--- PixelPet ---\n1) Add a new pet\n2) List all pets\n3) Show pet details\n4) Feed a pet\n5) Remove a pet\n6) EXIT\nChoose an option: 4\nEnter pet index to feed: 0\nFluffy has been fed. Hunger is now 4.\n\n--- PixelPet ---\n1) Add a new pet\n2) List all pets\n3) Show pet details\n4) Feed a pet\n5) Remove a pet\n6) EXIT\nChoose an option: 6\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Struct Requirement** \u2013 The primary data entity must be represented with a `struct Pet` as described above.  \n* **Display Function** \u2013 The logic for displaying the details of ONE specific pet **must** be placed in a function with the exact prototype:  \n  ```c\n  void displayPet(const struct Pet *p);\n  ```  \n* **Menu Exit Option** \u2013 The menu must include a distinct option labelled **\u201c6) EXIT\u201d** (or the exact keyword `EXIT`) that terminates the program.  \n* **Memory Management** \u2013 Every allocation performed with `malloc`, `calloc`, or `realloc` must have a matching `free` before program termination. No memory leaks are allowed.  \n* **Single\u2011source File** \u2013 The entire solution should be written in one `.c` file and may contain only `main` plus the required helper functions (e.g., `displayPet`). No additional libraries beyond `<stdio.h>`, `<stdlib.h>`, and `<string.h>` may be used.  \n\n---  \n\n*Write a program that satisfies all the requirements above, demonstrating correct use of dynamic memory allocation, pointer arithmetic, and proper resource cleanup.*", "model": "openai/gpt-oss-120b", "iteration": 99}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nA small wildlife sanctuary maintains a list of rescued animals that are adopted out to families.  Each animal record contains the animal\u2019s **ID number**, **species name**, **age in months**, and a **short description** entered by the caretaker.  The sanctuary\u2019s computer system must be able to add new animals, remove animals that have been adopted, and display the information of a particular animal on demand.  \n\nBecause the number of rescued animals changes over time, the program must allocate memory dynamically for each animal record and release it when the record is deleted.\n\n## Requirements  \n\nWrite a C program that implements the following functionality:\n\n1. **Add an animal** \u2013 Prompt the user for the animal\u2019s ID (integer), species (string, max 30 characters), age (integer), and description (string, max 100 characters).  \n   - Dynamically allocate a `struct Animal` to store this information using `malloc`.  \n   - Store a pointer to the newly created struct in an array that can grow as needed (you may also use a linked list if you prefer).  \n\n2. **Remove an animal** \u2013 Prompt the user for an animal ID.  \n   - Search for the animal with that ID.  \n   - If found, free the memory occupied by that animal\u2019s struct and remove its pointer from the collection.  \n   - If not found, display an appropriate message.  \n\n3. **Display an animal** \u2013 Prompt the user for an animal ID.  \n   - Locate the animal and print all its fields in a readable format.  \n   - The printing logic must be placed in a function named `displayAnimal`.  \n\n4. **List all animals** \u2013 Print a summary line for every animal currently stored (ID and species only).  \n\n5. **Exit** \u2013 Terminate the program, freeing any memory that remains allocated.  \n\nThe program should repeatedly present a menu that allows the user to choose one of the actions above until the \u201cExit\u201d option is selected.\n\n## Example Interaction  \n\n```\n=== Sanctuary Animal Tracker ===\n1. Add animal\n2. Remove animal\n3. Display animal\n4. List all animals\n5. Exit\nChoose an option: 1\n\nEnter ID: 101\nEnter species: Red Panda\nEnter age (months): 18\nEnter description: Small, shy, loves climbing.\nAnimal added.\n\n=== Sanctuary Animal Tracker ===\n1. Add animal\n2. Remove animal\n3. Display animal\n4. List all animals\n5. Exit\nChoose an option: 1\n\nEnter ID: 202\nEnter species: African Grey Parrot\nEnter age (months): 36\nEnter description: Very talkative, enjoys puzzles.\nAnimal added.\n\n=== Sanctuary Animal Tracker ===\n1. Add animal\n2. Remove animal\n3. Display animal\n4. List all animals\n5. Exit\nChoose an option: 4\n\nCurrent animals:\nID: 101   Species: Red Panda\nID: 202   Species: African Grey Parrot\n\n=== Sanctuary Animal Tracker ===\n1. Add animal\n2. Remove animal\n3. Display animal\n4. List all animals\n5. Exit\nChoose an option: 3\n\nEnter ID to display: 101\n--- Animal Details ---\nID: 101\nSpecies: Red Panda\nAge (months): 18\nDescription: Small, shy, loves climbing.\n\n=== Sanctuary Animal Tracker ===\n1. Add animal\n2. Remove animal\n3. Display animal\n4. List all animals\n5. Exit\nChoose an option: 5\n\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n1. **Data structure** \u2013 The primary entity must be represented by a `struct` named `Animal` containing at least the fields `id`, `species`, `age`, and `description`.  \n\n2. **Dynamic allocation** \u2013 Every `Animal` instance must be created with `malloc` (or `calloc`) and released with `free` when the animal is removed or when the program exits.  \n\n3. **Display function** \u2013 The logic that prints the full details of a single animal must be encapsulated in a function with the exact prototype:  \n\n   ```c\n   void displayAnimal(const struct Animal *a);\n   ```  \n\n4. **Menu requirement** \u2013 The program must present a textual menu as shown in the example.  \n   - The menu must include an explicit option to **EXIT** the program (option number 5 in the example).  \n\n5. **Memory safety** \u2013 No memory leaks are permitted. All allocated memory must be freed before the program terminates.  \n\n6. **Standard library only** \u2013 Use only the C standard library (`stdio.h`, `stdlib.h`, `string.h`, etc.). No third\u2011party libraries.  \n\nFeel free to choose an array that resizes with `realloc` or a singly\u2011linked list to store the pointers to `Animal` structs; either approach satisfies the requirements as long as the dynamic allocation rules are obeyed.", "model": "openai/gpt-oss-120b", "iteration": 100}, {"text": "# STEP 1: PROBLEM\n\n## Context\nYou are helping the campus library manage its collection of e-books.  \nEach e-book record contains a title (\u226460 chars), an author (\u226440 chars), and a file-size in MB (positive double).  \nAll records are stored in memory only while the program is running.  \nThe librarian should be able to add new books, delete a book by its zero-based index, list every book, or safely quit.\n\n## Functional Requirements\n1. The program keeps an expandable array of e-book records in dynamic memory.\n2. Provide a simple text menu:\n   ```\n   1) Add book\n   2) Delete book\n   3) List books\n   4) Exit\n   ```\n3. \u201cAdd book\u201d reads title, author, and size; appends the record; reallocates memory as needed.\n4. \u201cDelete book\u201d reads an integer index; if valid, removes that book and shrinks the array; otherwise print \u201cInvalid index.\u201d\n5. \u201cList books\u201d prints every book in the order stored, one per line, in the exact format:\n   ```\n   <index>. \"<title>\" by <author> (<size> MB)\n   ```\n   If no books exist, print \u201cCollection empty.\u201d\n6. On \u201cExit\u201d the program frees all heap memory and terminates.\n\n## Simple Example Run\n```\n1) Add book\n2) Delete book\n3) List books\n4) Exit\nChoice: 1\nTitle: C Traps and Pitfalls\nAuthor: Andrew Koenig\nSize: 1.2\nBook added.\n\nChoice: 1\nTitle: The C Programming Language\nAuthor: Kernighan & Ritchie\nSize: 2.3\nBook added.\n\nChoice: 3\n0. \"C Traps and Pitfalls\" by Andrew Koenig (1.2 MB)\n1. \"The C Programming Language\" by Kernighan & Ritchie (2.3 MB)\n\nChoice: 2\nIndex to delete: 0\nBook deleted.\n\nChoice: 3\n0. \"The C Programming Language\" by Kernighan & Ritchie (2.3 MB)\n\nChoice: 4\nGood-bye.\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent one e-book record.\n- The logic that prints a single book must live in a function called `displayBook`.\n- Only two functions are allowed: `main` and `displayBook`.\n- Menu option 4 is the required EXIT keyword.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 31}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just started a \u201cLate-Night Laptop Lending\u201d program.  \nStudents can borrow a laptop for up to 4 hours, but only while supplies last.  \nYou have been asked to write a tiny console app that keeps track of which laptops are currently checked-out and which are available.  \nAll data must live only in dynamic memory (`malloc`/`free`) while the program runs; when the program ends, the list disappears.\n\n## Functional Requirements\n1. Start with an empty inventory (no laptops).\n2. Support the following commands (menu-driven):\n   - `1` Add a new laptop to the pool (enter ID and battery %).\n   - `2` Check-out a laptop by ID (only if it is not already checked-out).\n   - `3` Return a laptop by ID (mark it available again).\n   - `4` Show the full current inventory (ID, battery, status).\n   - `5` Completely remove a laptop from the pool (free its memory).\n   - `6` EXIT the program and free all remaining memory.\n3. After every command, re-display the menu.\n4. If an operation is illegal (e.g., duplicate ID, check-out of non-existent laptop), print a short error message and continue.\n\n## Simple Example Run\n```\n=== Laptop Lending ===\n1) Add laptop\n2) Check-out\n3) Return\n4) Show inventory\n5) Remove laptop\n6) EXIT\nChoice: 1\nEnter laptop ID: 101\nBattery %: 85\nLaptop added.\n\nChoice: 2\nEnter laptop ID to check-out: 101\nLaptop 101 checked out.\n\nChoice: 4\nID: 101 | Battery: 85% | Status: OUT\n\nChoice: 6\nGood-bye.\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent each laptop.\n- All laptop structs must be stored in a linked list that is built with `malloc`.\n- Every `malloc` must eventually be matched by a `free` (no leaks).\n- The only functions allowed besides `main()` are:\n  - `void displayInventory(struct Laptop *head)` \u2013 prints the list.\n  - `void freeAll(struct Laptop *head)` \u2013 frees every node.\n- Menu option `6` must be the only way to exit the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 32}, {"text": "# STEP 1: PROBLEM\n\n## Story\nProfessor Byte has just opened the campus **USB Memory Bank**.  \nStudents can deposit (\"check-in\") any number of USB sticks, each with a unique ID and a capacity in GB.  \nThey can also withdraw (\"check-out\") a stick by giving its ID.  \nBecause the bank never knows how many sticks will arrive, it must store them in dynamically-allocated memory.  \nYour task is to write the program that acts as the bank\u2019s front-desk clerk.\n\n## Program Requirements\n1. Keep track of every USB stick currently in the bank.  \n2. Support three operations (presented in a menu that repeats until the user chooses to quit):\n   - 1  Check-in a new stick  \n     \u2013 Ask for an ID string (max 15 chars, no spaces) and capacity (positive integer \u2264 1024 GB).  \n     \u2013 Reject duplicate IDs.  \n   - 2  Check-out a stick  \n     \u2013 Ask for the ID; remove it and free its memory; if the ID is not found, say so.  \n   - 3  List all sticks currently in the bank (ID and capacity)  \n   - 4  Exit the program  \n3. Use dynamic memory allocation (`malloc`/`free`) for every stick.  \n4. After every operation (except Exit) re-display the menu.\n\n## Example Run\n```\nUSB Memory Bank\n1 Check-in  2 Check-out  3 List  4 Exit\nChoice: 1\nID: blue32\nCapacity (GB): 64\nStick blue32 checked in.\n\n1 Check-in  2 Check-out  3 List  4 Exit\nChoice: 1\nID: red11\nCapacity (GB): 128\nStick red11 checked in.\n\n1 Check-in  2 Check-out  3 List  4 Exit\nChoice: 3\nblue32 64GB\nred11 128GB\n\n1 Check-in  2 Check-out  3 List  4 Exit\nChoice: 2\nID: blue32\nStick blue32 checked out.\n\n1 Check-in  2 Check-out  3 List  4 Exit\nChoice: 4\nGood-bye!\n```\n\n### CONSTRAINTS\n- You must use a `struct` to represent each USB stick.  \n- All stick data must be stored in dynamically-allocated memory; no fixed-size arrays.  \n- The logic that prints the details of ONE stick must be placed in a function called `displayStick`.  \n- The entire solution must be implemented with only one additional function besides `main` (you may still use `displayStick`).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 33}, {"text": "# STEP 1: PROBLEM\n\n## Story\nYou are helping the campus library move from a card-catalog to a tiny digital archive.  \nThe head librarian asks for a console program that can store (and later discard) book records in **heap memory only**.  \nNo global arrays are allowed; every record must be created with `malloc` and released with `free`.\n\n## Requirements\n1. The user can repeatedly choose one of four actions from a menu:\n   - 1) Add a new book  \n   - 2) Delete the most recently added book (LIFO)  \n   - 3) Show the current catalog (print every book, one per line)  \n   - 4) Exit (the program must free every remaining record before termination)\n\n2. Each book stores:\n   - a unique integer id (auto-incremented, starting at 1)\n   - title (max 80 characters, no spaces)\n   - year of publication (positive integer)\n\n3. After every command the menu must re-appear until the user chooses Exit.\n\n4. If the catalog is empty, deletion or display must print:  \n   `Catalog is empty.`\n\n## Simple Example Run\n```\n1) Add\n2) Delete-last\n3) Show\n4) Exit\nChoice: 1\nTitle: KandR\nYear: 1988\n1) Add\n2) Delete-last\n3) Show\n4) Exit\nChoice: 1\nTitle: DragonBook\nYear: 1986\n1) Add\n2) Delete-last\n3) Show\n4) Exit\nChoice: 3\n1 KandR 1988\n2 DragonBook 1986\n1) Add\n2) Delete-last\n3) Show\n4) Exit\nChoice: 2\n1) Add\n2) Delete-last\n3) Show\n4) Exit\nChoice: 4\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent a book.\n- All book records must live in dynamically allocated memory (`malloc`/`free`).\n- Logic that prints a single book must be placed in a function called `displayBook`.\n- The only functions allowed besides `main` are `displayBook` and any helper functions you need for memory management.\n- Menu option 4 is the **only** valid way to exit; the program must free every remaining book before terminating.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 34}, {"text": "# STEP 1: PROBLEM\n\n## Context\nYou are helping the campus library build a tiny, self-service kiosk that keeps track of which books are currently on the shelf.  \nBecause the kiosk only runs while a patron is using it, the list of books must be built on-the-fly with dynamic memory.  \nWhen the patron is done, the list is freed and the program exits, releasing all memory back to the system.\n\n## Requirements\n1. The program starts with an empty collection (no books).\n2. The program repeatedly shows this menu:\n\n   ```\n   1 Add a book\n   2 List all books\n   3 Remove a book by ISBN\n   4 Exit\n   ```\n\n3. \u201cAdd a book\u201d reads from stdin: title (may contain spaces), author (may contain spaces), and a positive integer ISBN.  \n   The book is appended to the current collection.\n4. \u201cList all books\u201d prints every book in the order added, one per line, in the exact format:\n\n   ```\n   ISBN: 1234567890 | Title: Alice in Wonderland | Author: Lewis Carroll\n   ```\n\n   (If the collection is empty, print nothing.)\n5. \u201cRemove a book by ISBN\u201d reads an integer ISBN.  \n   Only the first matching book is removed; memory for that book is freed.  \n   If no book matches, do nothing.\n6. The program must not leak memory: every malloc\u2019d block must be freed before the program ends.\n\n## Simple Example\nInput\n```\n1\nAlice in Wonderland\nLewis Carroll\n1234567890\n1\nThe Hobbit\nJ. R. R. Tolkien\n1234567891\n2\n3\n1234567890\n2\n4\n```\n\nOutput\n```\nISBN: 1234567890 | Title: Alice in Wonderland | Author: Lewis Carroll\nISBN: 1234567891 | Title: The Hobbit | Author: J. R. R. Tolkien\nISBN: 1234567891 | Title: The Hobbit | Author: J. R. R. Tolkien\n```\n\n### CONSTRAINTS\n- Must use a struct to represent a Book.\n- Logic for displaying the details of ONE specific book must be in a function called `displayBook`.\n- The solution must be implemented with a single function besides `main()` (you may declare other helper functions, but only one additional function may contain substantial logic; `displayBook` counts as that one).\n- Menu option 4 is the EXIT keyword.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 35}, {"text": "# STEP 1: PROBLEM\n\n## Topic  \nDynamic Memory Allocation (malloc, free)\n\n## Background Story  \nThe campus library has just opened a new \u201cTech-Loan\u201d desk that lets students borrow electronic gadgets (e.g., tablets, VR headsets, drones).  \nYou are asked to write a quick, light-weight console program to keep track of which gadgets are currently checked-out.  \nAll data must live only while the program is running (no files), so you will use dynamic memory.\n\n## Functional Requirements  \n1. The program starts with an empty list of gadgets.  \n2. It repeatedly shows a menu:  \n   1) Add a gadget  \n   2) Return (delete) a gadget by ID  \n   3) List all gadgets  \n   4) EXIT  \n3. Adding a gadget allocates a new structure, stores its data, and appends it to the list.  \n4. Returning a gadget finds the gadget with the given ID, removes it from the list, frees its memory, and compacts the list.  \n5. Listing displays one line per gadget in the order they were added.  \n6. After every operation the menu re-appears until the user chooses EXIT (option 4).\n\n## Input/Output Example  \n(\u201c> \u201d is the prompt; user input is in italics)\n\n```\n1) Add\n2) Return\n3) List\n4) EXIT\n> *1*\nEnter gadget ID: *T123*\nEnter gadget name: *Tablet Pro*\nEnter borrower name: *Alice*\n1) Add\n2) Return\n3) List\n4) EXIT\n> *1*\nEnter gadget ID: *V007*\nEnter gadget name: *VR Headset*\nEnter borrower name: *Bob*\n1) Add\n2) Return\n3) List\n4) EXIT\n> *3*\nT123 Tablet Pro Alice\nV007 VR Headset Bob\n1) Add\n2) Return\n3) List\n4) EXIT\n> *2*\nEnter gadget ID to return: *T123*\nGadget T123 returned.\n1) Add\n2) Return\n3) List\n4) EXIT\n> *4*\nGood-bye!\n```\n\n## CONSTRAINTS  \n- Must use a `struct` to represent the primary data entity (a gadget).  \n- The list must be maintained as a dynamically-allocated array of pointers (`struct gadget **list`).  \n- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.  \n- The only functions allowed are `main` and `displayEntity`; no other helper functions.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 36}, {"text": "# STEP 1: PROBLEM  \n**Memory Mailbox**  \n\nA local post office has hired you to write a small program that keeps track of physical mailboxes currently in storage. Each mailbox is represented only by a 32-byte description string (e.g., \u201crusty red mailbox on post\u201d). The warehouse can add or remove mailboxes at runtime, so you must store the descriptions in heap memory using `malloc` and `free`.  \n\nYour program must provide a console menu with the following options:  \n1. Add a mailbox  \n2. Remove a mailbox  \n3. List all mailboxes  \n4. Exit (free all remaining mailboxes and quit)  \n\nThe program starts with an empty warehouse (no mailboxes).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 37}, {"text": "# STEP 1: PROBLEM\n\n## Background Story  \nThe university library is modernizing its old card-catalog system. You have been hired to write a tiny proof-of-concept that keeps the catalogue only in memory while the program is running. All data must be allocated dynamically with `malloc`/`free`, because the final embedded device will have no standard C++ containers available.\n\n## Functional Requirements  \n1. The program stores exactly three pieces of information for each book:  \n   - an integer id (unique inside the catalogue)  \n   - the title (\u226480 printable characters)  \n   - the author (\u226480 printable characters)  \n2. The catalogue is initially empty.  \n3. The user must be able to perform the following operations through a simple text menu:  \n   1) Add a new book  \n   2) List all books (one per line: id, title, author)  \n   3) Remove a book given its id  \n   4) EXIT the program  \n4. Every dynamically created structure must be released before the program terminates (no memory leaks).  \n5. If the user tries to add a book with an id that already exists, print `\"Duplicate id\"` and do nothing else; otherwise print `\"Book added\"`.  \n6. If the user tries to remove a non-existing id, print `\"Not found\"`; otherwise print `\"Book removed\"`.\n\n## Simple Example Run  \n(Everything after \u201c> \u201d is user input.)\n\n```\n1\n> 17\n> The C Programming Language\n> Kernighan & Ritchie\nBook added\n1\n> 42\n> Dynamic Memory For Dummies\n> Malloc Mallory\nBook added\n2\n17, The C Programming Language, Kernighan & Ritchie\n42, Dynamic Memory For Dummies, Malloc Mallory\n3\n> 17\nBook removed\n4\n```\n\nProgram terminates and Valgrind reports: `All heap blocks were freed -- no leaks are possible`.\n\n### CONSTRAINTS  \n- Must use a single `struct` called `Book` to represent the primary data entity.  \n- Logic for displaying the details of ONE specific book must be in a function called `displayBook`.  \n- The program must be implemented with exactly one function besides `main()` (i.e. `displayBook` is the only additional function).  \n- If a menu is implemented, option 4 must be the EXIT option.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 38}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)\n\nContext  \nYou are writing a tiny guest-book for the console.  \nThe user can add, list, and delete guest records.  \nEach record is just a name (\u2264 30 characters) and a message (\u2264 100 characters).\n\nRequirements  \n1. Store all records in dynamically allocated memory.  \n2. The program must support three commands:  \n   - ADD followed by a name and a message \u2192 store one record  \n   - LIST \u2192 print every stored record  \n   - EXIT \u2192 free memory and terminate  \n3. After each ADD the program must allocate a new struct and append it to the collection.  \n4. After LIST the program must print every stored record.  \n5. After EXIT the program must free all allocated memory and exit cleanly.\n\nExample  \nInput  \nADD Alice Hello  \nADD Bob Hello  \nLIST  \nEXIT  \n\nOutput  \nName: Alice Message: Hello  \nName: Bob Message:", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 39}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus bookstore is running a \u201cStudent-Authored Titles\u201d promotion.  \nAuthors (students) may add their books to a shared catalogue and later remove them if they change their minds.  \nBecause the number of books is unknown in advance, the catalogue must grow and shrink at run-time using dynamic memory allocation.\n\n## Precise Functional Requirements\n1. Represent each book with a struct that stores:\n   - a unique integer id (positive, supplied by the user)\n   - the book\u2019s title (one word, \u226430 chars)\n   - the author\u2019s name (one word, \u226430 chars)\n2. Maintain the collection as a dynamically-allocated array of pointers to these structs.\n3. Provide an interactive menu with the following choices:\n   1. Add a new book\n   2. Remove a book by id\n   3. Display catalogue (print id, title, author for every book)\n   4. Exit (this choice must be numbered 4)\n4. Adding must:\n   - check that the id is not already present\n   - allocate a new struct and resize the array with realloc\n5. Removing must:\n   - find the book, free its struct, compact the array, and realloc to shrink it\n   - print \u201cBook <id> removed.\u201d or \u201cBook <id> not found.\u201d\n6. Display must be implemented in a function called `displayEntity` that receives one struct pointer and prints its data on a single line in the format:\n   ```\n   [<id>] \"<title>\" by <author>\n   ```\n7. After every successful add or remove, print the current number of books in the catalogue.\n8. On Exit, free all remaining memory and print \u201cGood-bye!\u201d\n\n## Simple Example Run\n```\n===== Student Book Catalogue =====\n1. Add book\n2. Remove book\n3. Display catalogue\n4. Exit\nChoice: 1\nEnter id title author: 42 Algorithms Alice\nAdded. Total books: 1\nChoice: 1\nEnter id title author: 7 Poems Bob\nAdded. Total books: 2\nChoice: 3\n[42] \"Algorithms\" by Alice\n[7] \"Poems\" by Bob\nChoice: 2\nEnter id to remove: 42\nBook 42 removed. Total books: 1\nChoice: 4\nGood-bye!\n```\n\n### CONSTRAINTS\n- You must use a struct to represent each book entity.\n- The logic that prints the details of a single book must be placed in a function called `displayEntity` which receives a pointer to that struct.\n- The only functions allowed are `main` and `displayEntity`.\n- Menu option 4 is the required EXIT choice.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 40}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library is digitising its small \u201cReference-Only\u201d book shelf.  \nEach book is so fragile that it cannot be moved; instead, every student request is answered by *creating a temporary digital bookmark* that records the student\u2019s name and the page they want to revisit.  \nThe librarian has hired you to write a short-lived tool that keeps track of these bookmarks in memory while the program is running and releases the memory when the student leaves the terminal.\n\n## Functional Requirements\n1. The program starts with an initially empty collection of bookmarks.\n2. It repeatedly presents a menu with the following options:\n   1. Add a bookmark (student\u2019s name \u226430 chars, page number \u22651)  \n   2. Delete the *last* bookmark that was added (LIFO)  \n   3. Display *all* current bookmarks in the order they were added  \n   4. Exit (this option must be numbered 4)\n3. After every successful operation (add or delete) the program must print the total number of bookmarks currently stored.\n4. If the user tries to delete when no bookmarks exist, print \u201cStack-empty\u201d and redisplay the menu.\n5. Before the program terminates it must free every allocated structure.\n\n## Example Session (user input after prompt \u203a)\n```\n1. Add bookmark\n2. Delete last bookmark\n3. Show all\n4. Exit\nChoice \u203a 1\nStudent name \u203a Alice\nPage \u203a 77\nTotal bookmarks: 1\n\n1. Add bookmark\n2. Delete last bookmark\n3. Show all\n4. Exit\nChoice \u203a 1\nStudent name \u203a Bob\nPage \u203a 42\nTotal bookmarks: 2\n\n1. Add bookmark\n2. Delete last bookmark\n3. Show all\n4. Exit\nChoice \u203a 3\n1. Alice, page 77\n2. Bob, page 42\n\n1. Add bookmark\n2. Delete last bookmark\n3. Show all\n4. Exit\nChoice \u203a 2\nRemoved Bob, page 42\nTotal bookmarks: 1\n\n1. Add bookmark\n2. Delete last bookmark\n3. Show all\n4. Exit\nChoice \u203a 4\nGood-bye!\n```\n\n### CONSTRAINTS\n- You must use a `struct` called `Bookmark` to represent one bookmarked request.\n- The logic that prints the details of a *single* bookmark must be placed in a function called `displayBookmark(const struct Bookmark *b)`.\n- You may implement only **one** additional function besides `main()` (you may still use library functions such as `malloc`, `free`, `printf`, etc.).\n- Menu option 4 is the only valid way to exit the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 41}, {"text": "# STEP 1: PROBLEM\n\n## Context\nYou are helping the campus library build a tiny, self-service kiosk that keeps track of who is currently reading which book.  \nBecause the kiosk has very little permanent storage, the list of \u201cwho-has-which-book\u201d must live only in RAM while the program is running.  \nAll records must therefore be created, updated, and destroyed with explicit dynamic memory calls (`malloc`, `free`).\n\n## Functional Requirements\n1. The program starts with an empty list.\n2. It repeatedly presents a menu:\n   ```\n   1. Register new loan\n   2. Return book (remove record)\n   3. Show all active loans\n   4. Exit\n   ```\n3. **Register new loan**  \n   - Read a reader name (single word, \u226430 chars), an ISBN string (\u226420 chars), and a title string (\u226450 chars).  \n   - Dynamically create one record, add it to the list.\n4. **Return book**  \n   - Read an ISBN.  \n   - Remove the corresponding record and free its memory; print `Not found` if the ISBN is absent.\n5. **Show all active loans**  \n   - Print every record on one line in this exact format:  \n     ```\n     Reader: <name>, ISBN: <isbn>, Title: <title>\n     ```\n   - Print `No active loans` when the list is empty.\n6. **Exit**  \n   - Free any remaining memory and terminate.\n\n## Example Run\n```\n1. Register new loan\n2. Return book\n3. Show all active loans\n4. Exit\nChoice: 1\nReader: Alice\nISBN: 9780131103627\nTitle: The C Programming Language\nChoice: 1\nReader: Bob\nISBN: 9780201633610\nTitle: Design Patterns\nChoice: 3\nReader: Alice, ISBN: 9780131103627, Title: The C Programming Language\nReader: Bob, ISBN: 9780201633610, Title: Design Patterns\nChoice: 2\nISBN: 9780131103627\nChoice: 3\nReader: Bob, ISBN: 9780201633610, Title: Design Patterns\nChoice: 4\n<program ends>\n```\n\n### CONSTRAINTS\n- You must store each loan in a `struct Loan` allocated with `malloc`.  \n- All list manipulation (insert, delete, traverse) must use explicit pointer logic; you may not use global arrays.  \n- The only additional function besides `main()` must be `displayLoan(struct Loan* node)`, which prints one record in the required format.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 42}, {"text": "# STEP 1: PROBLEM\n\nYou are helping a tiny library automate its book-tracking system.  \nThe librarian can add new books, remove old ones, and list every book currently stored.  \nEach book has a unique (positive) ID, a title (no spaces, \u226430 chars), and the number of copies on the shelf.  \nAll data must be kept only in dynamic memory (i.e., you must use malloc/realloc and free; no global arrays).\n\nProgram behaviour\n1. The program starts with an empty collection.\n2. It repeatedly shows a menu:\n   1. Add book\n   2. Remove book\n   3. List books\n   0. Exit  \u2190 mandatory exit option\n3. \u201cAdd book\u201d asks for ID, title, copies. If the ID is already taken the request is ignored.\n4. \u201cRemove book\u201d asks for an ID; if it exists the book is erased and its memory freed.\n5. \u201cList books\u201d prints every book on a single line in the order they were added:\n   ID title copies\n6. After every command (except Exit) the menu re-appears. Choosing 0 ends the program and frees every remaining allocation.\n\nExample run (user input after >)\n1\n>101 C_Programming 4\n2\n>101\n3\n101 C_Programming 4\n0\n\n### CONSTRAINTS\n- You must store each book in a struct Book { int id; char title[31]; int copies; };  \n- You must keep the collection as a dynamically-sized array of struct Book * (i.e., struct Book **library).  \n- The logic that prints the details of ONE specific book must be in a function void displayBook(const struct Book *b).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 43}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou are helping the campus \u201cRideShare\u201d office manage their fleet of electric scooters.  \nEach scooter stores only three pieces of information: an integer ID (1\u20139999), its current battery percentage (0\u2013100), and whether it is currently rented (1 = yes, 0 = no).  \nBecause the fleet size changes every semester, the office wants a program that stores the scooters in dynamic memory and lets the user add, remove, and display scooters on demand.\n\n## Functional Requirements\n1. The program must keep all scooters in dynamically allocated memory (i.e., use `malloc`/`realloc`/`free`; no statically sized arrays).\n2. When the program starts it has **zero** scooters.\n3. The user is presented with a menu:\n    1. Add a new scooter  \n    2. Remove a scooter by ID  \n    3. Display all scooters  \n    4. Exit  \n   (Choosing option 4 must cleanly free all allocated memory and terminate the program.)\n4. Adding a scooter:\n   - Prompt for ID, battery, rented status.  \n   - Reject duplicate IDs (print `ID already exists.` and leave memory unchanged).  \n   - Dynamically expand the collection to hold the new scooter.\n5. Removing a scooter:\n   - Prompt for an ID.  \n   - If the ID exists, delete that scooter and shrink the dynamic memory; otherwise print `ID not found.`\n6. Displaying scooters:\n   - Print one line per scooter in the format `ID: <id>, Battery: <bat>%, Rented: <Yes/No>`  \n   - If the fleet is empty, print `Fleet empty.`\n\n## Simple Example Run\n```\n1. Add a new scooter\n2. Remove a scooter\n3. Display all scooters\n4. Exit\nChoice: 1\nEnter ID: 101\nEnter battery: 85\nIs rented (1=yes, 0=no): 0\nScooter added.\n\nChoice: 1\nEnter ID: 202\nEnter battery: 42\nIs rented (1=yes, 0=no): 1\nScooter added.\n\nChoice: 3\nID: 101, Battery: 85%, Rented: No\nID: 202, Battery: 42%, Rented: Yes\n\nChoice: 2\nEnter ID to remove: 101\nScooter removed.\n\nChoice: 3\nID: 202, Battery: 42%, Rented: Yes\n\nChoice: 4\nGoodbye.\n```\n\n### CONSTRAINTS\n- You must define a `struct Scooter` to represent a single scooter.\n- The logic that prints the details of exactly one scooter must be placed in a function called `displayScooter(const struct Scooter *s)`.\n- The entire solution must be implemented with only two functions: `main()` and `displayScooter()`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 44}, {"text": "# STEP 1: PROBLEM\n\n## Context\nYou have been hired by the campus bookstore to write a tiny inventory system that keeps track of how many copies of each textbook are in stock. The program must store the records in dynamic memory (heap) so that the array can grow or shrink while the program is running. All memory you allocate with malloc must later be released with free before the program ends.\n\n## Functional Requirements\n1. The program starts by asking how many different titles will be entered initially (\u22650).\n2. For each title it reads: ISBN (long), title (one\u2013line string, max 80 chars), quantity (int).\n3. After the initial load the program shows a menu with four choices:\n   - 1 \u2013 Add a new book (append to the current list)\n   - 2 \u2013 Update quantity of an existing book (search by ISBN)\n   - 3 \u2013 Display complete inventory (one line per book)\n   - 4 \u2013 Exit (must free all heap memory and terminate)\n4. Every dynamic array expansion must use realloc; no fixed upper limits are allowed.\n\n## Example Session (user input in italics)\n```\nHow many initial titles? *2*\nISBN: *9780131103627*\nTitle: *The C Programming Language*\nQuantity: *2*\nISBN: *9780134190440*\nTitle: *Computer Systems: A Programmer's Perspective*\nQuantity: *5*\n\nMenu\n1 Add\n2 Update\n3 Display\n4 Exit\nChoice: *3*\n9780131103627 \"The C Programming Language\" 2\n9780134190440 \"Computer Systems: A Programmer's Perspective\" 5\nChoice: *1*\nISBN: *9780201616224*\nTitle: *Effective C++*\nQuantity: *4*\nChoice: *3*\n9780131103627 \"The C Programming Language\" 2\n9780134190440 \"Computer Systems: A Programmer's Perspective\" 5\n9780201616224 \"Effective C++\" 4\nChoice: *4*\nGood-bye.\n```\n\n## CONSTRAINTS\n- You must define and use a struct Book that contains the three fields.\n- All list operations (add, update, display) must be implemented in a single function called manageInventory; main is only allowed to call this one function after the initial load.\n- Option 4 must be the explicit EXIT keyword.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 45}, {"text": "# STEP 1: PROBLEM\n## Background Story\nThe campus library has just opened a \u201cTech-Loan\u201d corner where students can borrow small electronic gadgets (Arduino kits, power banks, cables, etc.). To keep track of what is currently on loan, you are asked to write a tiny inventory system that only remembers the gadgets that are **checked-out**.  All data must live in dynamic memory; when the program ends the list disappears (that is fine).\n\n## Program Requirements\n1. On startup the list is empty.\n2. Repeatedly show a menu:\n   ```\n   1. Check-out gadget\n   2. Return gadget\n   3. Show current loans\n   4. Exit\n   ```\n3. \u201cCheck-out gadget\u201d asks for:\n   - student ID (positive integer)\n   - gadget name (single word, \u226430 chars)\n   - estimated return day (1-31)\n   The new loan is appended to the list.  \n   (Do **not** worry about duplicates; every call creates a new record.)\n4. \u201cReturn gadget\u201d asks for a student ID.  \n   - If the student has **any** loan, remove the **first** one found (free its memory) and print:\n     ```\n     <gadget name> returned by student <student ID>\n     ```\n   - If the student has no loans, print:\n     ```\n     No loan found for student <student ID>\n     ```\n5. \u201cShow current loans\u201d prints one line per record in the order they were added:\n   ```\n   Student 12345: power-bank (due day 15)\n   Student 14022: cable (due day 20)\n   ```\n   If the list is empty, print:\n   ```\n   No gadgets currently on loan\n   ```\n6. After every menu action (except Exit) re-display the menu.\n7. Choose menu option 4 to terminate the program gracefully (free all remaining memory before exit).\n\n## Simple Example Run\n```\n1. Check-out gadget\n2. Return gadget\n3. Show current loans\n4. Exit\nChoice: 1\nStudent ID: 12345\nGadget name: power-bank\nReturn day: 15\n1. Check-out gadget\n2. Return gadget\n3. Show current loans\n4. Exit\nChoice: 3\nStudent 12345: power-bank (due day 15)\n1. Check-out gadget\n2. Return gadget\n3. Show current loans\n4. Exit\nChoice: 2\nStudent ID: 12345\npower-bank returned by student 12345\n1. Check-out gadget\n2. Return gadget\n3. Show current loans\n4. Exit\nChoice: 3\nNo gadgets currently on loan\n1. Check-out gadget\n2. Return gadget\n3. Show current loans\n4. Exit\nChoice: 4\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent one loan record.\n- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.\n- The solution must be implemented with a single function besides `main()` (you may add `displayEntity` and still satisfy this).\n- Must include a specific menu option to EXIT the program: choose `4` to exit.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 46}, {"text": "# STEP 1: PROBLEM\n\n**Background Story**  \nYou are helping a small-town library computerise its book-loan records.  \nEach book is stored as a dynamic record containing its title and the number of free copies.  \nReaders can borrow or return copies, and the librarian can add new titles to the catalogue.  \nWhen the librarian chooses to shut the program, every dynamically allocated record must be released.\n\n**Program Requirements**  \n1. Maintain a catalogue of books (title + available-copy count).  \n2. Provide a simple text menu with the following options:  \n   1. Add new book title (initial copies \u2265 1)  \n   2. Borrow a copy (decrease count by 1, refuse if none left)  \n   3. Return a copy (increase count by 1)  \n   4. Show entire catalogue (title and current copies)  \n   5. Exit (free all memory and terminate)  \n3. The catalogue must grow on demand; do not pre-allocate a fixed-size array.  \n4. Duplicate titles are not allowed; when \u201cadding\u201d a title that already exists, just increase its copy count instead of creating a second record.\n\n**Example Session**  \nInput:\n```\n1\nPride and Prejudice\n3\n1\n1984\n5\n2\n1984\n2\n1984\n4\n5\n```\n\nOutput:\n```\nCatalogue:\n1984 - 4 copies\n```\n\n### CONSTRAINTS\n- You must represent each book with a struct that contains at least title (string) and copies (int).  \n- All dynamic allocation must be done with malloc; every malloc must have a matching free before the program exits.  \n- The menu option to EXIT the program is option 5.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 47}, {"text": "# STEP 1: PROBLEM\n\nYou have just volunteered to help the campus library digitise its old card-catalogue.  \nEach book card contains: title (\u226480 chars), author (\u226450 chars), and year of publication.  \nYour task is to write a tiny, interactive catalogue program that keeps these cards in dynamic memory only while the program is running.  \nThe librarian should be able to add new cards, list every card, delete a card by position, and cleanly exit.\n\n## Functional Requirements\n1. On start-up the program holds **zero** cards; all storage must be obtained with `malloc`/`realloc`.\n2. The program presents a menu:\n   1) Add a new card  \n   2) List all cards  \n   3) Delete a card by index (1-based)  \n   4) Exit  \n3. Adding a card must `realloc` the internal array to hold one more `struct Card`.\n4. Deleting a card must shift later elements left and `realloc` the array one element smaller; freeing unused memory is mandatory.\n5. After every operation the menu re-appears; choosing option 4 must free **all** remaining memory and terminate gracefully with the message `Good-bye!`\n\n## Simple Example Session\n```\n1) Add\n2) List\n3) Delete\n4) Exit\nChoice: 1\nTitle: The C Programming Language\nAuthor: Kernighan & Ritchie\nYear: 1978\n\n1) Add\n2) List\n3) Delete\n4) Exit\nChoice: 2\n#1 \"The C Programming Language\" by Kernighan & Ritchie (1978)\n\n1) Add\n2) List\n3) Delete\n4) Exit\nChoice: 4\nGood-bye!\n```\n\n### CONSTRAINTS\n- You must represent each card with a `struct Card`.\n- You must implement the operation \u201cdisplay details of ONE specific card\u201d inside a function called `displayCard`.\n- The solution must be implemented with **a single function besides `main()`** (i.e. only `main` and `displayCard`).\n- Menu option `4` is the required EXIT keyword.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 48}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)\n\nBackground  \nThe university library is digitising its card catalogue.  \nEach card contains a title, author and year.  \nAll cards are stored in a single \u201cdrawer\u201d that can grow or shrink on demand.\n\nTask  \nWrite a program that sim this drawer using dynamic memory.  \nThe user can add, list or remove cards.  \nAll cards reside in one contiguous block allocated with malloc.\n\nRequirements  \n1. Represent one card as a struct Card { \u2026 }.  \n2. Keep the entire drawer in one pointer: struct * drawer = malloc(\u2026).  \n3. When the user adds a card, realloc the drawer to size+1.  \n4. When the user lists, print every card.  \n5. When the user deletes, shift the remaining cards and realloc to size\u20131.  \n6. Provide a menu: 1=add, 2=list, 3=delete, 0=exit.  \n7. free everything before exit.\n\nExample  \nInput  \n1  \n1984 Orwell 1949  \n1  \nAnimal Farm Orwell 1945  \n2  \n3 1984  \n2  \n0  \n\nOutput  \n1 1984 Orwell 1949  \n2 Animal Farm Orwell 1945  \n1 1984 Orwell 1949  \n2 Animal Farm Orwell 1945  \n1 Animal Farm Orwell 1945  \n\n### CONSTRAINTS  \n- Must use a struct Card to represent one entity.  \n- Must use malloc/realloc/free only for the drawer.  \n- Must include a menu option 0 to EXIT.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 49}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)\n\n### BACKGROUND  \nYou are the sole librarian of a tiny, one-room public library that has just gone digital. Every book is now represented only by its title and nothing else. When a patron walks in, they hand you a title and you either add it to the collection or remove it. The collection starts empty and you must store every title in dynamically allocated memory.\n\n### TASK  \nWrite a program that keeps the live collection of titles in memory while the librarian is working. At any moment the librarian must be able to:  \n1. Add a title (malloc)  \n2. Remove a title (free)  \n3. List every title currently present  \n4. Exit the program  \n\nThe program must start with an empty collection and finish by freeing every byte it ever allocated.\n\n### INPUT/OUTPUT  \nEach command is a single line:\n\n```\nadd <title>  \nremove <title>  \nlist  \nexit  \n```\n\nExample session:\n\n```\nadd Moby Dick  \nadd Les Mis\u00e9rables  \nlist  \nMoby Dick  \nLes Mis\u00e9rables  \nremove Moby Dick  \nlist  \nLes Mis\u00e9rables  \nexit  \n```\n\n### CONSTRAINTS  \n- Must use a struct to represent the primary data entity.  \n- Must use malloc to add and free to remove.  \n- Must include a specific menu option to EXIT the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 50}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)\n\nA small campus library has just acquired its first computer and wants a tiny digital\u2010only checkout system.  \nThe librarian will type a list of ISBNs (as 13-digit strings) into the terminal.  \nWhen the librarian finishes, the program must print the exact same list back out, one ISBN per line, and then free every byte it allocated.\n\n### CONSTRAINTS  \n1. You may NOT store any data statically; everything must live on the heap.  \n2. You may NOT use any global variables.  \n3. You may NOT use any arrays (no `[]` anywhere).  \n4. You may NOT use any libraries besides `<stdio.h>`, `<stdlib.h>`, and `<string.h>`.  \n5. You must use a single function besides `main()`.  \n6. You must use `malloc` and `free` only.  \n\n### INPUT  \nThe first line is a single integer `n` (0 \u2264 n \u2264 100).  \nThe next `n` lines are 13-digit ISBN strings (no spaces).\n\n### OUTPUT  \nThe exact same `n` lines, one ISBN per line, in the same order.\n\n### EXAMPLE  \nInput  \n3  \n9781234567890  \n9791234567890  \n9781234567890  \n\nOutput  \n9781234567890  \n9791234567890  \n9781234567890", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 51}, {"text": "# STEP 1: PROBLEM\n\n## Context\nThe campus library has replaced its old card-catalog with a tiny, memory-constrained computer that can only keep one \u201cbookshelf\u201d in RAM at a time.  \nEach shelf holds up to 100 books, but the exact number is not known until run-time.  \nYour task is to write a console program that lets the librarian:\n\n1. Create a new shelf (allocate just enough memory for the books that will be placed on it).\n2. Fill the shelf with book titles (stop early if the librarian types \u201cEND\u201d).\n3. List every book currently on the shelf.\n4. Discard the entire shelf (free its memory) and exit.\n\n## Functional Requirements\n1. Ask the librarian how many books will be placed on the shelf (`n`, 1 \u2264 n \u2264 100).\n2. Dynamically allocate an array of exactly `n` book titles (each title \u2264 80 characters).\n3. Read up to `n` titles from stdin; stop reading if the librarian types the sentinel word `END`.  If fewer than `n` titles are entered, shrink the array to the actual number of titles entered.\n4. Print the list of titles in the order they were entered, one per line.\n5. After printing, release all dynamically allocated memory and terminate.\n\n## Simple Example\nInput\n```\n5\nThe C Programming Language\nEND\n```\nOutput\n```\nShelf contents:\nThe C Programming Language\n```\n(Only one title was typed before the sentinel, so memory for 1 book is used and then freed.)\n\n### CONSTRAINTS\n- Must use a single `struct` named `Shelf` that contains a pointer to the dynamic array of titles and an integer `count` of how many books are currently stored.\n- All allocation and re-allocation must be done with `malloc`/`realloc`; no variable-length arrays.\n- The logic for printing the shelf must be in a function `void displayShelf(const struct Shelf *s)`.\n- The program must offer a menu with two options:  \n  1. Create and fill shelf  \n  2. Exit (choose 2 to terminate)", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 52}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just digitised its old card catalogue.  \nEach card contains a book\u2019s title, author, and year of publication.  \nYour task is to write a tiny \u201cdigital catalogue\u201d program that can:\n\n- add new cards (allocate them dynamically),\n- list every card currently in memory,\n- delete a card by its running index,\n- free all cards and exit.\n\nThe librarian will interact with the program through a simple text menu.\n\n## Functional Requirements\n1. On startup the catalogue is empty.\n2. Menu options (cycle until the user chooses to quit):\n   1) Add Card\n   2) List Cards\n   3) Delete Card\n   4) Exit\n3. \u201cAdd Card\u201d reads title, author, and year from stdin (see example).\n4. \u201cList Cards\u201d prints every card in insertion order, numbering them 0,1,2\u2026\n5. \u201cDelete Card\u201d reads an integer index; if valid, frees that card and compacts the array of pointers so there are no gaps.\n6. After each command the menu re-appears.\n7. Choosing \u201cExit\u201d must free every remaining card before terminating.\n\n## Simple Input/Output Example\n```\n1\nThe Pragmatic Programmer\nAndrew Hunt\n1999\n1\nClean Code\nRobert C. Martin\n2008\n2\n0) \"The Pragmatic Programmer\" by Andrew Hunt (1999)\n1) \"Clean Code\" by Robert C. Martin (2008)\n3\n0\n2\n0) \"Clean Code\" by Robert C. Martin (2008)\n4\n```\n(program exits)\n\n### CONSTRAINTS\n- You must store cards in a dynamically-resizing array (`Card **catalogue`).\n- Each card must be represented by a `struct Card`.\n- The logic that prints a single card must live in a function `void displayCard(const struct Card *c)`.\n- The only functions besides `main()` allowed are: `displayCard`, `addCard`, `listCards`, `deleteCard`, and `freeAll`.\n- Menu option 4 is the required EXIT keyword.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 53}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just opened a \u201cTech-Loan\u201d counter where students can borrow small electronic items (calculators, phone chargers, etc.).  \nEach item is stored in a sealed box labeled with an ID, a description, and the number of units currently available.  \nTo keep the inventory flexible, the librarian has asked you to write a tiny C program that stores the catalog in dynamic memory and lets her add new items on-the-fly.\n\n## Functional Requirements\n1. At start-up the program knows **no items**; everything is entered at run-time.\n2. The user can repeatedly:\n   - Add a new item (ID, description, quantity).  \n   - Show the entire catalog.  \n   - Exit.\n3. All items must be stored in a dynamically-allocated array that grows by exactly one `struct` each time the user adds an item.\n4. When the user chooses **Exit**, the program must:\n   - Print every item once more (identical to \u201cShow catalog\u201d).  \n   - Release every byte of dynamically-allocated memory.  \n   - Terminate gracefully.\n\n## Example Session (user input in `[]`)\n```\n===== MENU =====\n1. Add item\n2. Show catalog\n3. Exit\nChoice: [1]\nEnter item ID: [PWRBANK-07]\nEnter description: [10 000 mAh power bank]\nEnter quantity: [12]\n\n===== MENU =====\n1. Add item\n2. Show catalog\n3. Exit\nChoice: [1]\nEnter item ID: [CALC-TI30]\nEnter description: [Scientific calculator TI-30]\nEnter quantity: [5]\n\n===== MENU =====\n1. Add item\n2. Show catalog\n3. Exit\nChoice: [2]\nCatalog:\nPWRBANK-07 | 10 000 mAh power bank | 12\nCALC-TI30 | Scientific calculator TI-30 | 5\n\n===== MENU =====\n1. Add item\n2. Show catalog\n3. Exit\nChoice: [3]\nFinal catalog:\nPWRBANK-07 | 10 000 mAh power bank | 12\nCALC-TI30 | Scientific calculator TI-30 | 5\n<program ends>\n```\n\n### CONSTRAINTS\n- You must define a `struct` named `Item` that contains at least: `char id[32]`, `char desc[64]`, `int qty`.  \n- You may implement **only one** additional function besides `main()`; that function must be named `displayItem` and must print a single `Item` in the exact format shown in the example.  \n- The menu option to exit the program is **3**.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 54}, {"text": "# STEP 1: PROBLEM\n\n**Background Story**  \nThe campus library has just upgraded to an electronic checkout system.  \nEach book is represented by its title, author, and a unique integer ID.  \nYou are asked to write a tiny \u201ccheckout manager\u201d that allows the librarian to add new books, list every book currently in memory, and delete a book by ID. All data must be stored in dynamically allocated structures so that the collection can grow and shrink at runtime.\n\n**Program Requirements**  \n1. On startup the program contains zero books.  \n2. Present a menu with four options:  \n   1. Add a new book  \n   2. List all books (ID, title, author)  \n   3. Delete book by ID  \n   4. Exit  \n3. \u201cAdd\u201d must prompt for title (\u226480 chars), author (\u226450 chars), and automatically assign the next free ID (start at 1).  \n4. \u201cList\u201d must print the books in the order they were added; if the collection is empty, print \u201cNo books.\u201d  \n5. \u201cDelete\u201d must free the memory of the chosen book and compact the internal array so there are no gaps.  \n6. Choosing \u201cExit\u201d must free every remaining book before terminating.\n\n**Simple Example Run**  \n```\n1. Add book\n2. List books\n3. Delete book\n4. Exit\nChoice: 1\nTitle: The C Programming Language\nAuthor: Kernighan & Ritchie\nBook added with ID 1.\n\nChoice: 1\nTitle: Introduction to Algorithms\nAuthor: Cormen\nBook added with ID 2.\n\nChoice: 2\nID: 1, Title: The C Programming Language, Author: Kernighan & Ritchie\nID: 2, Title: Introduction to Algorithms, Author: Cormen\n\nChoice: 3\nEnter ID to delete: 1\nBook deleted.\n\nChoice: 2\nID: 2, Title: Introduction to Algorithms, Author: Cormen\n\nChoice: 4\nGood-bye.\n```\n\n### CONSTRAINTS  \n- The primary data entity must be represented by a `struct Book`.  \n- All books must be stored in a single dynamically allocated array that grows/shrinks with `realloc`.  \n- Logic for displaying the details of ONE specific book must be in a function called `displayBook`.  \n- The solution must be implemented with only two functions besides `main`: `displayBook` and one other helper of your choice.  \n- Menu option 4 is the required EXIT keyword.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 55}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just upgraded its old card-catalogue to a tiny C program running on the librarian\u2019s PC.  \nEvery time a student returns a book, the librarian types the book\u2019s ID and the day it is returned.  \nYour task is to keep track of these returns in memory (using dynamic allocation) and to let the librarian:\n- add a return record,\n- list all current records, and\n- delete (free) a record once the book is placed back on the shelf.\n\n## Program Requirements\n1. The program must display a simple text menu:\n   1. Add return record  \n   2. List all returns  \n   3. Remove a return  \n   4. Exit  \n2. \u201cAdd\u201d allocates one new record, stores the book ID (positive integer) and return day (1-31), and keeps it in a linked list.  \n3. \u201cList\u201d prints every record in the order they were added, one per line:  \n   `ID=<id> Day=<day>`  \n4. \u201cRemove\u201d reads an ID; if that ID exists, the corresponding node is freed and removed from the list.  \n5. After each command the menu re-appears until the user chooses Exit.  \n6. No global variables; use dynamic memory (malloc/free) for every node.  \n7. Before exiting, free every remaining node.\n\n## Simple Example Run\n```\n1\n101 12\n1\n102 15\n2\nID=101 Day=12\nID=102 Day=15\n3\n101\n2\nID=102 Day=15\n4\n```\n(Program ends.)\n\n### CONSTRAINTS\n- You must store each return in a struct called `ReturnRecord`.  \n- All list operations (add, remove, list) must be implemented in a **single** function called `listOps` besides `main()`.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 56}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just switched to a fully digital check-out system.  \nEvery time a student borrows a book, a \u201cloan record\u201d must be created on-the-fly.  \nBecause the number of daily loans is unknown in advance, you must manage the records in dynamic memory.  \nAt closing time the librarian wants to see a summary of every open loan and then free all memory before the program quits.\n\n## Functional Requirements\n1. Store an arbitrary number of loan records.\n2. Each record contains: student ID (positive int), book ID (string of up to 20 chars), daysBorrowed (int).\n3. Provide an interactive menu with at least these options:\n   - 1 Add a new loan (allocate one record)\n   - 2 Display all current loans\n   - 3 Return (delete) a loan by student ID\n   - 0 Exit the program\n4. After the user chooses \u201cExit\u201d, the program must release every allocated byte and then terminate.\n\n## Simple Example Run\n```\n=== Digital Loan Manager ===\n1 Add loan\n2 List loans\n3 Return loan\n0 Exit\nChoice: 1\nStudent ID: 101\nBook ID: C_Prog_Lang\nDays borrowed: 7\nLoan added.\n\nChoice: 1\nStudent ID: 202\nBook ID: Algo_Design\nDays borrowed: 14\n\nChoice: 2\nLoan 0: Student 101, Book C_Prog_Lang, 7 days\nLoan 1: Student 202, Book Algo_Design, 14 days\n\nChoice: 3\nStudent ID to return: 101\nLoan removed.\n\nChoice: 0\nReleasing memory\u2026 Good-bye!\n```\n\n### CONSTRAINTS\n- You must represent one loan with a `struct` called `Loan`.\n- All loans must be kept in a dynamically resizing 1-D array (use `malloc`/`realloc`).\n- Logic that prints the details of a **single** loan must be encapsulated in a function named `displayLoan`.\n- The only functions allowed besides `main()` are `displayLoan` and any memory-management helpers you need.\n- Menu option `0` must immediately exit the program after freeing memory.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 57}, {"text": "# STEP 1: PROBLEM\n\n## Background\nA small library wants a tiny, self-contained program to keep track of the books that are currently on a single display table.  \nEach book has a title (\u2264 80 characters), an author (\u2264 50 characters), and a year of publication.  \nThe head librarian will enter new books one-by-one until she types \u201cEND\u201d as the title.  \nAfter all books are entered, the program must print the full list in the order they were typed.\n\n## Functional Requirements\n1. The program starts with an empty collection.\n2. Repeatedly read:\n   - Title (stop if the user enters exactly \u201cEND\u201d)\n   - Author\n   - Year\n3. Store every book in dynamically allocated memory (you may NOT use a fixed-size array).\n4. After the sentinel \u201cEND\u201d is entered, print every book on its own line in the exact format:\n   ```\n   Title by Author (Year)\n   ```\n5. Before terminating, free every byte of dynamically allocated memory.\n\n## Simple Example\nInput\n```\nThe Pragmatic Programmer\nAndrew Hunt\n1999\nClean Code\nRobert C. Martin\n2008\nEND\n```\nOutput\n```\nThe Pragmatic Programmer by Andrew Hunt (1999)\nClean Code by Robert C. Martin (2008)\n```\n\n### CONSTRAINTS\n- You must define a single `struct` called `Book` that represents one book.\n- All dynamic allocations must be done with `malloc`; every `malloc`ed block must be `free`d exactly once.\n- The only functions allowed besides `main` are:\n  - `struct Book *createBook(const char *title, const char *author, int year);`  \n  - `void printBook(const struct Book *b);`  \n  - `void freeBook(struct Book *b);`  \n- You may NOT use global variables; keep all data inside `main` or pass it through parameters.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 58}, {"text": "# STEP 1: PROBLEM  \n## Background Story  \nYou are helping the campus library build a tiny \u201cbook-tracker\u201d for its new mini-collection of e-textbooks.  \nEach time a student downloads a copy of a book, the program must create a new record in memory (hint: malloc).  \nWhen the student returns the copy, the record must be released (hint: free).  \nAll records must be kept in a single chained list; no global arrays are allowed.\n\n## Functional Requirements  \n1. The program must present a menu with these exact options:  \n   1) Add a new book download  \n   2) Return (delete) a book  \n   3) Show all active downloads  \n   4) Exit  \n2. \u201cAdd\u201d must prompt for: ISBN (string of at most 12 chars), title (string of at most 30 chars), and student ID (integer).  \n3. \u201cReturn\u201d must prompt for the same ISBN and remove the matching record; if no match, print \u201cISBN not found.\u201d  \n4. \u201cShow all\u201d must print one line per active record with ISBN, title, and student ID separated by spaces.  \n5. All dynamic memory must be released before the program terminates.\n\n## Simple Example Run  \n```\n1\n123456789012\nAlgorithms\n101\n3\n123456789012 Algorithms 101\n2\n123456789012\n4\n```\n(The program exits without leaks.)\n\n### CONSTRAINTS  \n- You must use a struct called `Book` to represent each record.  \n- All list operations must be performed inside a single function besides `main()`.  \n- Menu option 4 is EXIT and must terminate the program cleanly.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 59}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou are helping a local animal shelter manage its foster-home records.  \nEach foster home can temporarily house several cats.  The shelter keeps only the homes that are currently in use, so the list must grow and shrink dynamically as homes are added or removed.\n\n## Requirements\nWrite a program that keeps a dynamic array of foster-home records.  \nEach record contains:\n- a unique positive integer ID (used as the key)\n- the caregiver\u2019s last name (\u226430 characters, no spaces)\n- the number of cats currently housed there\n\nThe program must support the following commands in a loop:\n1. Add a new foster home (allocate space, store the data, expand the array if needed).  \n2. Remove a foster home given its ID (free its memory and compact the array).  \n3. Show the current list of homes (ID, last name, cat count).  \n4. Exit the program and release **all** remaining dynamically allocated memory.\n\nThe array itself must be dynamically allocated and resized with `realloc`.  \nNo global variables are allowed; carry any necessary state through pointers.\n\n## Simple Example\nInput\n```\n1 101 Smith 3\n1 102 Lee 1\n3\n2 101\n3\n4\n```\nOutput\n```\nID: 101 Last: Smith Cats: 3\nID: 102 Last: Lee Cats: 1\nID: 102 Last: Lee Cats: 1\n```\n(Program terminates after the final `4`.)\n\n### CONSTRAINTS\n- Represent each foster home with a `struct FosterHome`.  \n- The logic that prints a **single** home must be in a function `void displayHome(const struct FosterHome *home)`.  \n- The only functions allowed besides `main()` are `displayHome`, plus at most one helper function for resizing the array.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 60}, {"text": "# STEP 1: PROBLEM\n\n## Topic: Dynamic Memory Allocation (malloc, free)\n\n### Context\nYou are helping a small-town library computerise its catalogue. The librarian can only add or remove books one at a time, but the program must remember every title currently on the shelf. The titles are stored only in memory, not in files, and you must not waste space for books that do not exist.\n\n### Requirements\nWrite a program that:\n\n1. keeps an expandable list of book titles currently in the library;\n2. lets the librarian:\n   - add one new title;\n   - remove one title;\n   - list every title currently stored;\n   - exit the program;\n3. stores each title as a dynamically allocated string;\n4. frees every string before the program ends.\n\n### Example session\n```\n1 add\n2 remove\n3 list\n4 exit\nChoice: 1\nEnter title: The Hobbit\nChoice: 1\nEnter title: Dune\nChoice: 3\nCurrent titles:\nThe Hobbit\nDune\nChoice: 2\nEnter title: The Hobbit\nChoice: 3\nCurrent titles:\nDune\nChoice: 1\nEnter title: The Hobbit\nChoice: 4\nGoodbye.\n```\n\n### CONSTRAINTS\n- Must use a single struct to represent the catalogue.\n- Must implement only one function besides main().\n- Must free all allocated memory before exit.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 1}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library has just opened a \u201cTech-Loan\u201d kiosk where students can borrow small electronic items (phone chargers, ear buds, calculators, etc.).  \nEach item is tagged with a unique ID and a loan period in days.  \nYou have volunteered to write the tiny inventory system that keeps track of what is currently checked out.  \nAll data must live in dynamically-allocated memory so that the kiosk can run for weeks without rebooting.\n\n## Functional Requirements\n1. On start-up the program has an empty inventory.\n2. The program repeatedly shows a menu:\n   1) Add a new item  \n   2) Delete an item by ID  \n   3) Display all items  \n   4) Exit\n3. \u201cAdd\u201d reads an ID (positive int) and loan period (positive int, in days).  \n   - If the ID already exists, print \u201cID already exists.\u201d and do nothing.  \n   - Otherwise store the new item in dynamically-allocated memory.\n4. \u201cDelete\u201d reads an ID.  \n   - If the ID exists, free its memory and remove it.  \n   - Otherwise print \u201cID not found.\u201d\n5. \u201cDisplay\u201d prints one line per item in the order they were added:  \n   ID:<id>, Loan:<days> days\n6. \u201cExit\u201d frees all remaining memory and terminates the program.\n\n## Simple Example Run\n```\n1) Add\n2) Delete\n3) Display\n4) Exit\nChoice: 1\nEnter ID: 101\nEnter loan days: 7\n1) Add\n2) Delete\n3) Display\n4) Exit\nChoice: 1\nEnter ID: 102\nEnter loan days: 3\n1) Add\n2) Delete\n3) Display\n4) Exit\nChoice: 3\nID:101, Loan:7 days\nID:102, Loan:3 days\n1) Add\n2) Delete\n3) Display\n4) Exit\nChoice: 2\nEnter ID: 101\n1) Add\n2) Delete\n3) Display\n4) Exit\nChoice: 3\nID:102, Loan:3 days\n1) Add\n2) Delete\n3) Display\n4) Exit\nChoice: 4\n```\n\n### CONSTRAINTS\n- Must use a struct to represent each item.  \n- All items must be stored in a singly-linked list of dynamically allocated nodes.  \n- The only functions besides main() are:  \n  \u2013 void displayEntity(const struct Item *item)  \n  \u2013 struct Node *deleteByID(struct Node *head, int id)  \n- Menu option 4 is the only way to exit; typing 4 must free every remaining node before terminating.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 2}, {"text": "# STEP 1: PROBLEM  \n**Topic:** Dynamic Memory Allocation (malloc, free)\n\n## Background Story  \nThe campus library has just switched to a fully digital check-out system.  \nEvery time a student borrows a book, a new record must be created on-the-fly and stored until the book is returned.  \nYour task is to write a tiny, self-contained \u201cDigital Check-Out\u201d program that keeps these records in dynamic memory and frees them as soon as the book is returned.\n\n## Functional Requirements  \n1. The program starts with an empty collection (no books checked out).  \n2. It repeatedly presents a menu:  \n   1. Check-out book  \n   2. Return book  \n   3. Show all currently checked-out books  \n   4. Exit program  \n3. **Check-out book:**  \n   - Prompt for title (\u226450 characters) and student ID (positive integer).  \n   - Dynamically allocate one structure to store the pair.  \n   - Append it to an in-memory array of pointers (also dynamically allocated).  \n4. **Return book:**  \n   - Prompt for the title.  \n   - Remove the corresponding record, free its memory, and compact the array.  \n   - If the title is not found, print \u201cBook not found.\u201d  \n5. **Show all:** print title and student ID, one per line.  \n6. **Exit:** free every remaining record before termination.\n\n## Simple Example Session (user input after `>`)  \n```\n1\n> Quantum Gravity\n> 12345\n1\n> Advanced C\n> 67890\n3\nQuantum Gravity 12345\nAdvanced C 67890\n2\n> Quantum Gravity\n3\nAdvanced C 67890\n4\n```\n(Program ends.)\n\n### CONSTRAINTS  \n- The primary data entity must be a `struct Book`.  \n- All dynamic allocations must use `malloc`/`realloc`/`free`; no global arrays.  \n- Logic that prints the details of ONE specific book must be in a function `void displayBook(const struct Book *b)`.  \n- The solution must be implemented with a single function besides `main()`.  \n- Menu option 4 is the only way to exit; the program must free all remaining memory before terminating.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 3}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)  \n\nBackground  \nA tiny convenience store has just bought a second-hand cash register that can only run console programs. The owner wants a simple stock-control program that keeps a list of products in memory while the program is running. Each product has a name, a price and a quantity. The list must grow and shrink on demand; no fixed-size arrays are allowed.  \n\nRequirements  \n1. The program must start with an empty list (pointer initially NULL).  \n2. It must support:  \n   1) add a new product (malloc)  \n   2) delete a product (free)  \n   3) list all products  \n3. Every add or delete must update the list correctly and never leak memory.  \n4. The program must terminate only when the user chooses the EXIT option.  \n\nExample  \nInput  \n```\n1\nApple 2.50 30\n1\nBanana 1.20 40\n2\nApple\n3\n0\n```\n\nOutput  \n```\nApple 2.50 30\nBanana 1.20 40\n```\n\n### CONSTRAINTS  \n- Must use a struct to represent the product.  \n- Must use a single function besides main() (e.g. displayEntity).  \n- Must include a menu option 0 to EXIT the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 4}, {"text": "# STEP 1: PROBLEM  \n**Topic:** Dynamic Memory Allocation (malloc, free)  \n\n### Background Story  \nA university residence-hall manager keeps track of which rooms are occupied.  \nAt the start of the term the manager only knows the total number of rooms; no names are stored yet.  \nDuring check-in day students arrive one-by-one, give their name, and are assigned the lowest-numbered free room.  \nIf a student wants to check out, the manager deletes that record so the room becomes free again.  \nYou will write a tiny \u201cfront-desk\u201d program that lets the manager type simple commands to: record a check-in, record a check-out, list the current occupants, or exit.\n\n### Functional Requirements  \n1. On start-up read one integer N (1 \u2264 N \u2264 100 000) \u2013 the total number of rooms.  \n2. Then repeatedly read a single-line command until the EXIT command is given.  \n   Commands are:  \n   - `CHECKIN name` \u2013 allocate the lowest free room for this student.  \n     - Print `OK <name> <room>` on success.  \n     - If every room is full print `FULL`.  \n   - `CHECKOUT name` \u2013 delete that student.  \n     - Print `OK` if the name was found and removed.  \n     - Print `NOTFOUND` if the name does not exist.  \n   - `LIST` \u2013 print every occupied room in ascending room-number order, one per line: `<room> <name>`.  \n     - If no rooms are occupied print `EMPTY`.  \n   - `EXIT` \u2013 free all dynamically allocated memory and terminate.  \n\n### Simple Example  \n**Input**  \n```\n5\nCHECKIN Alice\nCHECKIN Bob\nCHECKOUT Alice\nLIST\nCHECKIN Carol\nLIST\nEXIT\n```\n\n**Output**  \n```\nOK Alice 1\nOK Bob 2\nOK\nEMPTY\nOK Carol 1\n1 Carol\n2 Bob\n```\n\n### CONSTRAINTS  \n- You must store each occupant in a dynamically allocated `struct` that contains at least the student\u2019s name (C-string) and room number.  \n- You must keep an array of *pointers* to these structs; the array itself must be dynamically allocated with `malloc` and released with `free`.  \n- You may **not** use `realloc`; the array size is fixed after the first input.  \n- The logic that prints the details of a single occupant must be placed in a function `void displayEntity(const struct Student *s)`.  \n- The only functions allowed besides `main` are `displayEntity` and, if you wish, string-duplication helper(s).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 5}, {"text": "# STEP 1: PROBLEM  \n**Story**  \nThe town of Byteville has just opened its first public library. You are the volunteer programmer who must write the tiny \u201ccheckout register\u201d that keeps track of which books are on the shelves. Because the library may buy more books at any time, the list must grow and shrink while the program is running, so you will use dynamic memory (`malloc`, `free`).\n\n**What the program must do**  \n1. Maintain a catalogue of up to 1000 books.  \n2. Each book has:  \n   - a unique integer ID (1 \u2026 1000)  \n   - a title string (\u2264 40 characters, no spaces)  \n   - an integer quantity (how many physical copies are on the shelf)  \n3. Offer the user a menu with the following four choices:  \n   1. Add a new book (or increase quantity if ID already exists).  \n   2. Remove one copy of a book (if quantity reaches 0 the entry is deleted and its memory freed).  \n   3. Display the full catalogue sorted by ID (ascending).  \n   4. EXIT the program (free all remaining memory before quitting).  \n4. After every operation print the updated total number of distinct titles stored.\n\n**Simple example**  \nInput  \n```\n1 101 C_Programming 5\n1 102 Algorithms 3\n3\n2 101\n3\n4\n```  \nOutput  \n```\nTotal titles: 1\nTotal titles: 2\nID 101 C_Programming 5\nID 102 Algorithms 3\nTotal titles: 2\nID 101 C_Programming 4\nID 102 Algorithms 3\nTotal titles: 2\nGood-bye!\n```\n\n### CONSTRAINTS  \n- You must store each book in a dynamically allocated `struct Book`.  \n- All catalogue operations (add, remove, display) must be performed through a **single user-defined function** besides `main()`.  \n- Menu option **4** is the only way to EXIT; the program must free every remaining `struct Book` before terminating.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 6}, {"text": "# STEP 1: PROBLEM\n\n## Background\nYou are helping the campus library manage its small collection of daily-use laptops.  \nEach laptop is identified by a unique integer ID, its brand name, and whether it is currently checked out.  \nBecause the collection grows or shrinks during the semester, you must store the records in dynamically allocated memory and free them before the program ends.\n\n## Requirements\n1. Represent one laptop with a `struct` containing:\n   - `int id` (unique, positive)\n   - `char *brand` (dynamically allocated string)\n   - `int isCheckedOut` (0 = available, 1 = checked-out)\n\n2. Provide an interactive menu with the following options:\n   - `1` Add a new laptop\n   - `2` Display all laptops\n   - `3` Check-out a laptop (by ID)\n   - `4` Return a laptop (by ID)\n   - `5` Remove a laptop record (by ID)\n   - `6` Exit the program\n\n3. For options 2\u20135, if the requested ID does not exist, print `Laptop <id> not found.`\n\n4. Before the program terminates, free **every** dynamically allocated object (both structs and their brand strings).\n\n5. You may assume no more than 100 laptops will ever exist simultaneously.\n\n## Simple Example Run\n```\n=== Laptop Manager ===\n1 Add laptop\n2 Display all\n3 Check-out\n4 Return\n5 Remove\n6 Exit\nChoice: 1\nEnter ID: 101\nEnter brand: DellXPS\nAdded laptop 101.\n\nChoice: 1\nEnter ID: 102\nEnter brand: MacAir\nAdded laptop 102.\n\nChoice: 3\nEnter ID: 101\nLaptop 101 checked out.\n\nChoice: 2\nID  Brand     Status\n101 DellXPS   OUT\n102 MacAir    IN\n\nChoice: 6\nGood-bye!\n```\n\n### CONSTRAINTS\n- You **must** use a `struct` to represent a laptop.\n- The logic that prints the details of **one** laptop must be placed in a function called `displayEntity`.\n- The solution must be implemented with **only one** additional function besides `main()` (i.e., `displayEntity` is that function; all other code resides in `main`).\n- Menu option `6` is the required EXIT keyword.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 7}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou are helping the university library\u2019s \u201cBook-Tracker\u201d project.  \nEvery time a student checks out a book, the librarian types the book\u2019s ISBN (a 13-digit string) and the student\u2019s ID number (an int).  \nAll check-outs must be kept until the librarian explicitly deletes them; the data must therefore be stored in dynamically allocated memory so that it can grow and shrink while the program is running.\n\n## Program Requirements\n1. The program must repeatedly show a menu:\n   1. Add a new check-out  \n   2. Delete the oldest check-out (FIFO)  \n   3. List all current check-outs  \n   4. Exit  \n2. \u201cAdd\u201d must read an ISBN (13 chars, no spaces) and a student ID, store them in dynamically allocated memory, and append the record to the list.  \n3. \u201cDelete\u201d must free the memory of the oldest check-out; if none exist, print \u201cNothing to delete.\u201d  \n4. \u201cList\u201d must print every check-out in order, one per line:  \n   ISBN studentID  \n5. \u201cExit\u201d must free all remaining memory and quit.\n\n## Simple Example\nInput (user choices and data):\n1  \n9780131103627 12345  \n1  \n9780136097042 67890  \n3  \n2  \n3  \n4  \n\nCorresponding output:\n1. Add  \n2. Delete oldest  \n3. List  \n4. Exit  \nChoice: ISBN: Student ID:  \n1. Add  \n2. Delete oldest  \n3. List  \n4. Exit  \nChoice: ISBN: Student ID:  \n1. Add  \n2. Delete oldest  \n3. List  \n4. Exit  \nChoice: 9780131103627 12345  \n9780136097042 67890  \n1. Add  \n2. Delete oldest  \n3. List  \n4. Exit  \nChoice: Deleted oldest check-out.  \n1. Add  \n2. Delete oldest  \n3. List  \n4. Exit  \nChoice: 9780136097042 67890  \n\n### CONSTRAINTS\n- Must use a struct to represent one check-out record.  \n- The logic for displaying a single record must be in a function called displayEntity.  \n- The entire solution must be implemented with only one additional function besides main().", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 8}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou have just been hired as the \u201cMemory Librarian\u201d for the city of Heapville.  \nCitizens can donate books (titles only) to the library at any time, but because shelf space is precious, every donated book must be stored in dynamically-allocated memory.  \nWhen a citizen is done reading, they may return a book by giving its title; the librarian then frees the memory so it can be reused.  \nYour job is to write the program that keeps track of which books are currently checked in.\n\n## Functional Requirements\n1. The program starts with an empty collection.\n2. Repeatedly present the user with a menu:\n   1) Donate book  \n   2) Return book  \n   3) List all books currently in the library  \n   4) Exit\n3. Donating a book:\n   - Read one line (may contain spaces) that is the book\u2019s title.  \n   - Dynamically allocate exactly enough bytes to store the title plus the terminating '\\0'.  \n   - Store the pointer in your collection.  \n   - If the title is already present, print \u201cBook already donated.\u201d and do **not** allocate anything.\n4. Returning a book:\n   - Read one line (the title).  \n   - If the title exists, free its memory and remove it from the collection.  \n   - If the title is not found, print \u201cNo such book in the library.\u201d\n5. Listing books:\n   - Print every title currently stored, one per line, in the order they were donated.  \n   - If the library is empty, print \u201cLibrary is empty.\u201d\n6. After every command (except Exit), re-display the menu.\n\n## Simple Example Run\n(Underlined text is user input)\n\n1) Donate book  \n2) Return book  \n3) List all books  \n4) Exit  \nChoice: 1  \nTitle: The C Programming Language  \n1) Donate book  \n2) Return book  \n3) List all books  \n4) Exit  \nChoice: 1  \nTitle: Dynamic Memory for Dummies  \n1) Donate book  \n2) Return book  \n3) List all books  \n4) Exit  \nChoice: 3  \nThe C Programming Language  \nDynamic Memory for Dummies  \n1) Donate book  \n2) Return book  \n3) List all books  \n4) Exit  \nChoice: 2  \nTitle: The C Programming Language  \n1) Donate book  \n2) Return book  \n3) List all books  \n4) Exit  \nChoice: 3  \nDynamic Memory for Dummies  \n1) Donate book  \n2) Return book  \n3) List all books  \n4) Exit  \nChoice: 4  \n\n### CONSTRAINTS\n- You must use a single `struct` named `Book` to represent each book; the struct must contain *only* a dynamically-allocated C-string (`char *title`).  \n- All allocation (`malloc`) and deallocation (`free`) must be performed explicitly; you may not use global arrays or fixed-size buffers for the titles.  \n- The logic that prints the details of **one** specific book must be in a function called `displayBook()`.  \n- You may implement additional helper functions, but the core book-handling logic must reside in **one** additional function besides `main()` (i.e., `displayBook()` counts toward this limit; any others are forbidden).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 9}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nThe campus library is experimenting with a tiny \u201cbook\u2010tracker\u201d for its new study\u2010room shelves.  \nEach shelf can hold at most `N` books, but the librarian does **not** know `N` in advance.  \nStudents keep donating books, so the shelf must grow on demand.  \nYour task is to write a C program that simulates this shelf: it starts empty, grows with `malloc`/`realloc`, and shrinks when books are removed (using `free`).\n\n## Functional Requirements\n1. The program starts by asking for the **initial capacity** of the shelf (a positive integer).\n2. It then repeatedly presents a menu:\n   ```\n   1. Add book\n   2. Remove last book\n   3. List shelf\n   0. EXIT\n   ```\n3. **Add book**: Prompt for a single\u2010word title (\u226430 chars).  \n   - If the shelf is full, double its capacity with `realloc`.  \n   - Insert the title at the next free slot.\n4. **Remove last book**: Delete the last title (do nothing if shelf is empty).  \n   - If after removal the **used** portion is \u226425 % of the current capacity **and** the capacity is > 4, shrink the array to half its current size (never < 4).  \n   - `free` the old block after a successful shrink.\n5. **List shelf**: Print the current titles, one per line, preceded by `1)` `2)` \u2026  \n   - Print `(empty)` if none.\n6. On choosing `0` (EXIT), release **all** dynamically allocated memory and terminate gracefully.\n\n## Example Run\n```\nInitial capacity> 2\n1. Add book\n2. Remove last book\n3. List shelf\n0. EXIT\nChoice> 1\nTitle> Alice\nChoice> 1\nTitle> Bob\nChoice> 3\n1) Alice\n2) Bob\nChoice> 1\nTitle> Carol\nChoice> 3\n1) Alice\n2) Bob\n3) Carol\nChoice> 2\nChoice> 3\n1) Alice\n2) Bob\nChoice> 0\n```\n(Program frees memory and exits.)\n\n### CONSTRAINTS\n- You must represent the shelf with a `struct Shelf` that contains at least:  \n  `char **titles`, `size_t used`, `size_t capacity`.\n- Implement exactly one additional function besides `main()`:  \n  `void displayShelf(const struct Shelf *s);`  \n  This function prints the list exactly as required for menu option 3.\n- No global variables except possibly for constants.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 10}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)  \n\nBackground  \nA tiny campus library owns exactly 100 physical books.  At the start of term every book is either \u201cAvailable\u201d or \u201cBorrowed\u201d.  The librarian wants a small terminal program that records only two things for each book:  \n1. its unique 1-based index (1 \u2026 100)  \n2. its status (Available / Borrowed).  \n\nThe program must keep this information entirely in RAM, never store anything on disk, and never use fixed-size arrays.  You must allocate / re-allocate / free memory as the user inserts or deletes records.\n\nFunctional Requirements  \n1. Provide a console menu:  \n   1. Add a book  \n   2. Delete a book  \n   3. List all books  \n   4. Exit  \n2. \u201cAdd\u201d allocates memory for one new book and stores its index and status.  \n3. \u201cDelete\u201d frees the memory of the book with the given index.  \n4. \u201cList\u201d prints every book index and its status, one per line.  \n5. After every command the menu re-appears.  \n6. No global variables, no fixed arrays, no memory leaks.  \n\nInput / Output Example  \n( > is user input)  \n> 1  \n> 3  \n1 Available  \n2 Borrowed  \n3 Available  \n> 4  \n\n### CONSTRAINTS  \n- You must represent a book with a struct Book { int index; char status; }.  \n- All books must be stored in a dynamically allocated linked list.  \n- You must provide a single function void displayBook(Book *b) that prints one book.  \n- You must implement only one additional function besides main().", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 11}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou are helping the campus \u201cLost & Found\u201d office computerize its logbook.  \nEvery item that is turned in gets an ID number, a short description, and the contact e-mail of the person who found it.  \nBecause the number of items changes constantly, the office wants a small C program that keeps the list in dynamic memory and lets the clerk add or delete entries during the day.  \nAt closing time the clerk will print the complete list and exit the program.\n\n## Functional Requirements\n1. On start-up the program holds **zero** items and displays a simple text menu:\n    ```\n    1. Add new item\n    2. Remove an item (by ID)\n    3. Show all items\n    4. Exit\n    ```\n2. Choosing \u201cAdd\u201d prompts for:\n    - ID (positive integer, unique in the current list)\n    - description (single line, \u226480 characters)\n    - finder\u2019s e-mail (single line, \u226440 characters)  \n    The program stores this new item in dynamically allocated memory.\n3. Choosing \u201cRemove\u201d prompts for an ID.  \n    If the ID exists, the corresponding memory is freed and the item disappears; otherwise print `ID not found.`\n4. Choosing \u201cShow all\u201d prints every item, one per line, in the order they were added:\n    ```\n    ID: 102   Desc: Black umbrella   Found-by: alice@univ.edu\n    ID: 105   Desc: Blue water bottle Found-by: bob@univ.edu\n    ```\n    If the list is empty, print `No items.`\n5. Choosing \u201cExit\u201d (option 4) frees all remaining dynamic memory and terminates the program.\n6. All dynamic allocations must use `malloc`/`realloc`/`free`; no global arrays are allowed.\n\n## Example Session (user input after prompt)\n```\n1. Add new item\n2. Remove an item\n3. Show all items\n4. Exit\nChoice: 1\nEnter ID: 102\nDescription: Black umbrella\nE-mail: alice@univ.edu\n1. Add new item\n2. Remove an item\n3. Show all items\n4. Exit\nChoice: 3\nID: 102   Desc: Black umbrella   Found-by: alice@univ.edu\n1. Add new item\n2. Remove an item\n3. Show all items\n4. Exit\nChoice: 4\n```\n(program ends)\n\n### CONSTRAINTS\n- You must define a `struct` to represent one lost-and-found item.  \n- All list operations (add, remove, show) must be implemented in **one** user-defined function besides `main()`; `main()` itself should only handle the menu loop and call that helper function with appropriate arguments.  \n- Menu option **4** is the required EXIT keyword.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 12}, {"text": "# STEP 1: PROBLEM  \n**Topic:** Dynamic Memory Allocation (malloc, free)  \n\n**Background Story**  \nThe campus library is replacing its old card\u2010catalog with a tiny digital system for storing book records.  \nYou volunteer to write a demo program that keeps an *expandable* collection of books in **heap memory**.  \nEach book has a unique accession number, title, and author.  \nThe librarian must be able to add books, list all of them, delete a book by accession number, and quit.\n\n**Precise Functional Requirements**  \n1. On startup the program holds **zero** books.  \n2. Present a simple numbered menu:  \n   1) Add Book  \n   2) List Books  \n   3) Delete Book  \n   4) Exit  \n3. Choosing **1** prompts for:  \n   - accession number (positive int, unique)  \n   - title (single\u2010line string \u226480 chars)  \n   - author (single\u2010line string \u226450 chars)  \n   Then dynamically allocate a new book record and append it to the collection.  \n4. Choosing **2** prints every book in the order added, one per line:  \n   `<AccNo> \u2014 <Title> by <Author>`  \n   (If none exist, print \u201cCollection empty.\u201d)  \n5. Choosing **3** prompts for an accession number.  \n   - If it exists, free its memory, shrink the collection logically, and print \u201cDeleted.\u201d  \n   - Otherwise print \u201cNot found.\u201d  \n6. Choosing **4** frees *all* remaining heap blocks and terminates with \u201cGood-bye.\u201d  \n7. After any operation, re-display the menu unless the user chose 4.  \n\n**Simple Example Run**  \n( user input after `>` )  \n\n```\n1) Add Book\n2) List Books\n3) Delete Book\n4) Exit\n> 1\nAccession number> 1001\nTitle> The C Programming Language\nAuthor> Kernighan & Ritchie\n1) Add Book\n2) List Books\n3) Delete Book\n4) Exit\n> 2\n1001 \u2014 The C Programming Language by Kernighan & Ritchie\n1) Add Book\n2) List Books\n3) Delete Book\n4) Exit\n> 4\nGood-bye.\n```\n\n### CONSTRAINTS  \n- You **must** define a `struct Book` to represent each book entity.  \n- You **must** store the collection as a dynamically\u2010allocated *array* of pointers to `struct Book` (i.e., `struct Book **library`).  \n- The only functions besides `main()` allowed are:  \n  \u2013 `void displayLibrary(struct Book **lib, int count)`  \n  \u2013 `void freeLibrary(struct Book **lib, int count)`  \n- Menu option **4** is the *sole* way to exit; typing 4 must free every allocated block before termination.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 13}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)  \n\nStory  \nYou are helping a tiny village library that still checks books out by hand.  \nEvery afternoon the librarian types the day\u2019s new titles into your program.  \nYour program must store the list in memory only while it is running; the librarian will NOT save anything to disk.  \nWhen the librarian closes the program every byte must be freed again.\n\nTask  \nWrite a small console program that:\n\n1. keeps a list of books  \n2. lets the librarian add one book at a time  \n3. prints the whole catalogue on request  \n4. exits when finished and frees every malloc\u2019ed byte\n\nInput / Output  \nEach line is either  \n   add <title>  \nor  \n   list  \n\nExample  \nadd Alice in Wonderland  \nadd Through the Looking-Glass  \nlist  \nAlice in Wonderland  \nThrough the Looking-Glass  \nadd  \nlist  \nAlice in Wonderland  \nThrough the Looking-Glass  \nexit  \n\nConstraints  \n- Must use a struct to represent a book.  \n- Must use malloc/free; no global arrays.  \n- Must display one book via displayEntity().  \n- Must implement only one function besides main().", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 14}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)\n\nBackground  \nA tiny campus library has just donated its old card-catalogue to the CS department. Each drawer is full of blank 3 \u00d7 5 index cards. You are to write a console program that lets the librarian create an arbitrary number of \u201cdrawers\u201d (dynamic arrays) of cards on the fly. The only fields stored on each card are an integer card\u2010ID and a 3-character string title (title fits exactly on the card). The program must keep track of how many cards are currently in each drawer and must be able to add, delete, or list cards.\n\nRequirements  \n1. The program must start with an empty library (no drawers).  \n2. The user can type commands:  \n   - `add <card-ID> <3-char-title>` \u2013 add a new card  \n   - `list` \u2013 print every card currently stored  \n   - `exit` \u2013 quit and free everything  \n3. The program must allocate exactly the space needed for each card (no fixed arrays).  \n4. No global variables allowed.\n\nExample  \nInput  \n```\nadd 107 cat  \nadd 105 dog  \nlist  \nexit\n```\nOutput  \n```\n107 cat  \n105 dog\n```\n\n### CONSTRAINTS  \n- Must use a `struct` to represent a single card.  \n- Must implement a function `displayEntity(int cardID, char title[3])` that prints one card.  \n- Must implement only one function besides `main()` (displayEntity).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 15}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)\n\nYou are the owner of a tiny student library that keeps every book on a single shelf.  \nWhen a student brings a new book, you place it on the first free slot you find.  \nWhen a student returns a book, you erase its title and mark the slot as empty.  \nAll memory must be managed manually with malloc and free.\n\nWrite a program that simulates this shelf.\n\n### CONSTRAINTS  \n1. Must use a struct Book { char title[50]; } to represent one slot.  \n2. Must use a single function besides main(): void displayEntity(int index).  \n3. Must implement a menu with options 0-3 and option 0 must EXIT the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 16}, {"text": "# STEP 1: PROBLEM\n\n**Background Story**  \nThe campus library just bought a crate of second-hand books.  \nEach book has three attributes: title (\u226450 chars), author (\u226430 chars), and year of publication (int).  \nBecause the librarian does not know how many books are inside the crate, your program must keep the records in dynamically-allocated memory (malloc) and be able to release that memory (free) when the user closes the program.\n\n**Required Behaviour**  \n1. The program starts with an empty catalogue.  \n2. A simple text menu repeats until the user chooses to exit:  \n   1. Add a new book (read title, author, and year).  \n   2. List all books in the order they were added.  \n   3. Remove the last added book (LIFO discard).  \n   4. Exit.  \n3. After every operation the menu is re-displayed.  \n4. On exit, every dynamically-allocated byte must be freed.\n\n**Simple Example Run**  \n(\u201c>\u201d is the prompt, user input is shown after the number)\n\n```\n1. Add book\n2. List books\n3. Remove last book\n4. Exit\n> 1\nTitle: The Pragmatic Programmer\nAuthor: Hunt & Thomas\nYear: 1999\n1. Add book\n2. List books\n3. Remove last book\n4. Exit\n> 1\nTitle: Clean Code\nAuthor: Robert C. Martin\nYear: 2008\n1. Add book\n2. List books\n3. Remove last book\n4. Exit\n> 2\n1. The Pragmatic Programmer, Hunt & Thomas, 1999\n2. Clean Code, Robert C. Martin, 2008\n1. Add book\n2. List books\n3. Remove last book\n4. Exit\n> 3\nRemoved Clean Code\n1. Add book\n2. List books\n3. Remove last book\n4. Exit\n> 4\nGood-bye!\n```\n\n### CONSTRAINTS\n- Must use a struct to represent a single book entity.  \n- Logic for displaying the details of ONE specific book must be in a function called `displayBook`.  \n- The solution must be implemented with a single function besides `main()`.  \n- Menu option 4 is EXIT.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 17}, {"text": "# STEP 1: PROBLEM  \n**Topic: Dynamic Memory Allocation (malloc, free)**  \n\n**Story**  \nYou are running a tiny pop-up coffee cart that only sells one item: a \u201ccup\u201d whose size is measured in millilitres. Customers can place an order (`add`), cancel an order (`remove`), or see what is currently in the cart (`list`). Every order is stored in a dynamically-allocated array that grows and shrinks as needed.\n\n**Task**  \nWrite a console program that keeps an expandable array of orders, each order being a single integer (millilitres). The program must respond to three commands:  \n\n- `add <mL>` \u2192 append one order to the cart  \n- `remove` \u2192 delete the last order (LIFO)  \n- `list` \u2192 print the current cart contents  \n\nThe cart starts empty. Every `add` must enlarge the array by one element; every `remove` must shrink it by one element. The array must be built entirely with `malloc`/`realloc` and released with `free`.\n\n**Example**  \nInput  \n```\nadd 200\nadd 150\nremove\nadd 100\nlist\n```\nOutput  \n```\n200 100\n```\n\n### CONSTRAINTS  \n1. Must use a single `struct` to represent the entire cart (e.g. `struct Cart`).  \n2. Must implement exactly one helper function besides `main()`: `displayEntity` prints the millilitres of one order.  \n3. No menu; commands are typed directly.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 18}, {"text": "# STEP 1: PROBLEM\n\n## Story\nThe tiny town of Stackville has just opened a public library.  \nTo keep track of its book collection, the head librarian has hired you to write a console program that stores book records in **dynamic memory**.  \nEach book has a unique ID (positive integer), a title, and the number of copies on the shelf.  \nAll records must be kept only while the program is running; nothing is saved to disk.\n\n## Functional Requirements\n1. The program must start with an empty collection (i.e. no books are pre-loaded).  \n2. The user is shown a menu with four options:  \n   1. Add a new book  \n   2. Remove a book by ID  \n   3. List every book currently stored  \n   4. Exit  \n3. \u201cAdd\u201d must prompt for ID, title, and copies, then store the new record in dynamically allocated memory.  \n4. \u201cRemove\u201d must release the memory occupied by the chosen book.  \n5. \u201cList\u201d must print ID, title, and copies for every book in the order they were added.  \n6. The program must free **all** remaining memory before terminating.  \n7. Handle invalid menu choices gracefully by re-printing the menu.\n\n## Example Session (user input in bold)\n```\n=== Stackville Library ===\n1. Add book\n2. Remove book\n3. List books\n4. Exit\nChoice: **1**\nEnter ID: **101**\nEnter title: **The C Programming Language**\nEnter copies: **3**\nBook added.\n\n1. Add book\n2. Remove book\n3. List books\n4. Exit\nChoice: **3**\nID: 101, Title: The C Programming Language, Copies: 3\n\n1. Add book\n2. Remove book\n3. List books\n4. Exit\nChoice: **4**\nGood-bye!\n```\n\n### CONSTRAINTS\n- You must define a `struct Book` to represent the primary data entity.  \n- Add and Remove must be handled by a single helper function  \n  `void updateCollection(struct Book **collection, int *size, int choice)`;  \n  no other functions besides `main()` are allowed.  \n- The EXIT option is number **4** and must be clearly listed in the menu.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 19}, {"text": "# STEP 1: PROBLEM\n\n## Context\nA small public library has just received a donation of old computers and wants to catalogue them while they are being refurbished. Each computer is identified by a unique integer ID, the year it was built, and the amount of RAM (in GB). The librarian needs a simple console program that can add a new computer, show the current catalogue, or exit. Because the number of computers is unknown at compile time, you must allocate and free memory dynamically.\n\n## Requirements\n1. The program must keep all computer records in dynamic memory.\n2. The program must provide a text menu with the following options:\n   - 1) Add Computer\n   - 2) Show Catalogue\n   - 3) Exit\n3. Choosing \u201cAdd Computer\u201d prompts the user for ID, year, and RAM, then stores the information.\n4. Choosing \u201cShow Catalogue\u201d prints every stored computer in the order they were added, one per line, with the format:\n   ```\n   ID=123 Year=2015 RAM=8GB\n   ```\n   If no computers exist, print \u201cNo computers in catalogue.\u201d\n5. Choosing \u201cExit\u201d frees all dynamically allocated memory and terminates the program.\n6. Handle invalid menu choices with the message \u201cInvalid option.\u201d and re-display the menu.\n\n## Example Run\n```\n1) Add Computer\n2) Show Catalogue\n3) Exit\nChoice: 1\nEnter ID: 101\nEnter year: 2019\nEnter RAM (GB): 16\n\n1) Add Computer\n2) Show Catalogue\n3) Exit\nChoice: 2\nID=101 Year=2019 RAM=16GB\n\n1) Add Computer\n2) Show Catalogue\n3) Exit\nChoice: 3\n```\n\n### CONSTRAINTS\n- You must define a struct named `Computer` to represent each computer.\n- All computer structs must be stored in a dynamically resizing array allocated with `malloc`/`realloc` and freed with `free`.\n- Only two functions are allowed: `main` and `addComputer`.\n- The menu option to exit the program is 3.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 20}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)\n\nYou have just been hired as the night-shift manager of a tiny, 24-hour underground parking garage.  \nThe garage contains exactly 100 parking spaces, numbered 1 \u2026 100.  \nEach space is either free or occupied by a single car.  \nWhen a car arrives, the driver types a 4-digit year (e.g. 2023) and a 1 \u2026 100 space number.  \nWhen a car leaves, the system must erase that space and reclaim its memory.\n\nYour job is to write a small C program that keeps an in-memory record of which spaces are occupied and by which year.  \nThe parking lot never grows beyond 100 spaces, so you must store only the occupied spaces and nothing else.\n\nRequirements  \n1. Represent one occupied space as a struct { int year; }.  \n2. Use malloc to allocate one struct when a car arrives, and free to de-allocate when it leaves.  \n3. Implement a single function void displayEntity(int space) that prints  \n   \u201cSpace 42 occupied by car from 2023.\u201d  \n   or  \n   \u201cSpace 42 is free.\u201d  \n4. main() must only call displayEntity; no other functions allowed.\n\nSimple Example  \nInput  \n1 42 2023  \n1 42 2023  \n2 42  \n3  \n\nOutput  \nSpace 42 occupied by car from 2023.  \nSpace 42 is free.  \n\n### CONSTRAINTS  \n- The solution must be implemented with exactly one function besides main().  \n- Must use a struct to represent the primary data entity.  \n- Menu option 3 is EXIT the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 21}, {"text": "# STEP 1: PROBLEM  \n\u201cMemory-Mart\u201d is a tiny convenience store that keeps its entire stock in the heap rather than on shelves. Every night the owner dynamically records what has just arrived and every morning throws away what has not been sold. Your job is to model this nightly inventory with nothing more than malloc, free and simple console I/O.\n\n### Specification  \nThe program must:  \n1. Keep a linked list of structs describing one product (name, quantity, price).  \n2. Present a menu:  \n   1. Add new product  \n   2. Delete product by name  \n   3. Display all products  \n   4. EXIT  \n3. After each \u201cAdd\u201d the user enters: name, quantity, price.  \n4. After each \u201cDelete\u201d the user enters a name; if it exists, remove the node and free its heap memory.  \n5. Display must print every product in the list.  \n6. EXIT immediately ends the program.\n\n### Example Session  \n(typed exactly as the student would see it)  \n1  \napple 10 1.50  \n1  \nbanana 5 0.75  \n3  \napple 10 1.50  \nbanana 5 0.75  \n2  \nbanana  \n3  \napple 10 1.50  \n4  \n\u2192 program ends\n\n### CONSTRAINTS  \n- Must include a menu option 4 to EXIT.  \n- Use a struct to represent one product.  \n- Logic for displaying the entire list must be in a function called displayList.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 22}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou have just been hired as the \u201cMemory Keeper\u201d for the campus library.  \nInstead of shelves, the library stores its electronic books (e-books) in dynamically allocated memory.  \nEvery time a new e-book is donated, you must allocate space for its metadata (title, author, file-size in KiB).  \nWhen an e-book is withdrawn, you must reclaim that memory.  \nYour job is to write a tiny, menu-driven console program that lets student volunteers add, list, and withdraw e-books while correctly using malloc and free.\n\n## Functional Requirements\n1. The program starts with an empty collection of e-books.\n2. Implement a menu with the following choices:\n   1) Add e-book\n   2) List all e-books\n   3) Withdraw e-book (by array index, 0-based)\n   4) Exit program (keyword `4`)\n3. \u201cAdd e-book\u201d reads title (\u226430 chars, no spaces), author (\u226430 chars, no spaces), and file-size (positive integer).  \n   Dynamically allocate one struct for the new e-book and append its pointer to a dynamically allocated array of pointers.\n4. \u201cList all e-books\u201d prints every e-book in insertion order, showing index, title, author, and size.  \n   If the collection is empty, print `Collection empty.`\n5. \u201cWithdraw e-book\u201d removes the e-book at the given index, frees its memory, compacts the pointer array, and updates counters.  \n   If the index is invalid, print `Invalid index.`\n6. On Exit, free every remaining allocated object (no memory leaks).\n\n## Example Input/Output\n```\n=== E-Book Memory Keeper ===\n1) Add e-book\n2) List e-books\n3) Withdraw e-book\n4) Exit\nChoice: 1\nTitle: C_Programming\nAuthor: King\nSize: 2048\nChoice: 1\nTitle: Python_Crash\nAuthor: Matthes\nSize: 1536\nChoice: 2\n0: C_Programming by King (2048 KiB)\n1: Python_Crash by Matthes (1536 KiB)\nChoice: 3\nIndex to withdraw: 0\nChoice: 2\n0: Python_Crash by Matthes (1536 KiB)\nChoice: 4\nGoodbye!\n```\n\n### CONSTRAINTS\n- Must use a `struct` to represent each e-book.\n- The logic for listing a single e-book must be in a function called `displayEntity`.\n- The only functions allowed are `main` and `displayEntity`.\n- Menu option 4 must exit the program.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 23}, {"text": "# STEP 1: PROBLEM  \nDynamic Memory Allocation (malloc, free) \u2013 \u201cLibrary\u2010of\u2010Everything\u201d\n\nBackground  \nImagine a tiny public library that has only ONE shelf.  Every book is identified by its title (a single word, no spaces, \u2264 30 characters).  When a new book arrives the librarian places it on the shelf; when a book is borrowed the librarian removes it from the shelf and frees the memory.  The librarian never keeps more than one copy of any title.\n\nTask  \nWrite a program that simulates this ultra\u2010minimal library.  The program must keep the shelf in dynamic memory and must be able to:  \n1. Add a new book (malloc).  \n2. Borrow a book (free).  \n3. Print the current shelf.  \n\nRequirements  \n1. The shelf is represented as a dynamically allocated array of strings (titles).  \n2. The program must add and remove books only by malloc/free.  \n3. The program must print the current shelf.  \n4. The program must exit when the user chooses EXIT.\n\nExample  \nInput  \n```\n1 add Harry  \n1 add Potter  \n1 add  \n2 borrow Harry  \n3 shelf  \n4 exit  \n```\nOutput  \n```\nCurrent shelf:  \nPotter  \n```\n\n### CONSTRAINTS  \n1. Must use a struct to represent the library.  \n2. Logic for displaying the details of ONE specific entity must be in a function called displayEntity.  \n3. The solution must be implemented with a single function besides main().", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 24}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou are helping the campus library move from paper cards to a tiny digital index.  \nThey only care about one thing right now: keeping track of how many copies of each book are currently on the shelf.  \nBecause the librarian is never sure how many titles will be entered on a given day, the list must grow on demand.\n\n## Requirements\n1. The program starts with an empty list of books.\n2. It repeatedly asks the user to choose one of the following actions:\n   1. Add a new book title (allocate space, store the title string and an initial copy-count).\n   2. Increase the copy-count of an existing title by 1.\n   3. Decrease the copy-count of an existing title by 1 (never let it go below 0).\n   4. Display the current list of all titles and their copy-counts.\n   5. Exit the program (and free every malloc\u2019d block before termination).\n3. All dynamically allocated memory must be released before the program ends.\n4. Assume titles are unique; case-sensitive matching is fine.\n\n## Simple Example of Expected Input/Output\n```\n1\nIntroduction to Algorithms\n3\n1\nOperating Systems\n2\n2\nOperating Systems\n4\n5\n```\nOutput (after the last command):\n```\nIntroduction to Algorithms : 3\nOperating Systems        : 3\n```\nProgram terminates cleanly.\n\n### CONSTRAINTS\n- Every book must be represented by a `struct Book` containing at least the fields `title` (char *) and `copies` (int).\n- All dynamic allocation must be done with `malloc`/`realloc`; every block must be freed before the program exits.\n- Logic that prints the details of ONE specific book must be placed in a separate function called `displayBook`.\n- The menu option to exit the program is number 5.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 25}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)\n\nBackground  \nA small library wants to keep track of the books that are currently on the shelf. Each book has a title (\u226430 characters) and an integer ID. The librarian will type commands into a console program that must keep an up-to-date list of books, storing the data only in dynamically allocated memory.\n\nRequirements  \n1. Implement a tiny \u201cshelf\u201d that can grow or shrink at run-time.  \n2. The program must support three commands:  \n   - `add <title> <id>` \u2013 append a new book to the shelf.  \n   - `remove <id>` \u2013 delete the book with the given ID (if it exists).  \n   - `exit` \u2013 free everything and terminate.  \n3. After every command the program prints the current list of books in order of insertion (one per line: `<id> <title>`).  \n4. All data must be stored in dynamically allocated memory; no fixed-size arrays.\n\nSimple Example  \nInput  \n```\nadd Moby_Dick 42  \nadd Hamlet 17  \nremove 42  \nexit  \n```\nOutput  \n```\n42 Moby_Dick  \n17 Hamlet  \n```\nInput  \n```\nremove 99  \nexit  \n```\nOutput  \n```\n```\n\n### CONSTRAINTS  \n- Must use a struct to represent a book.  \n- Must use a single function besides main().  \n- Must free all memory before exiting.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 26}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)\n\nStory  \nA small campus library has just bought a handful of identical books each week.  \nYou are the volunteer who records how many identical copies arrived that week and stores the week\u2019s data in a simple catalogue.  \nEach week you also decide whether to keep the catalogue or throw it away.\n\nPrecise Requirements  \n1. Allocate space for one week\u2019s worth of identical books at a time.  \n2. Keep a list of weeks that are still in the catalogue.  \n3. Free any week that is removed from the catalogue.  \n4. At the end, free everything that is still in the catalogue.\n\nInput/Output  \nEach line is either  \n   + <week> <copies>  \nor  \n   \u2212 <week>  \n\n+ means \u201cadd week to catalogue\u201d (allocate)  \n\u2212 means \u201cremove week from catalogue\u201d (free)  \n\nExample  \nInput  \n+ 1 5  \n+ 2 4  \n\u2212 2  \n+ 3 6  \n\nOutput  \n1 5  \n3 6  \n\n### CONSTRAINTS  \n1. A single struct must represent a week.  \n2. The catalogue must be an array of pointers to these structs.  \n3. You may not use any STL containers.  \n4. You must use malloc and free only.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 27}, {"text": "# STEP 1: PROBLEM  \nTopic: Dynamic Memory Allocation (malloc, free)\n\nBackground  \nA tiny library has just hired you to automate their catalogue.  \nEach book is described by three strings: title, author, and ISBN.  \nThe librarian will type the details of any number of books (until she decides to stop).  \nYour program must store these books in memory and print them back in the same order.\n\nRequirements  \n1. Allocate space for each book dynamically (malloc).  \n2. Store all books in a contiguous block (array).  \n3. When the librarian finishes, print the list in the order received.  \n4. Free all allocated memory before the program ends.\n\nExample  \nInput  \nHow many books? 2  \nBook 1:  \nTitle: The Catcher  \nAuthor: John  \nISBN: 001  \nBook 2:  \nTitle: The Catcher  \nAuthor: Jane  \nISBN: 002  \n\nOutput  \nBook 1  \nTitle: The Catcher  \nAuthor: John  \nISBN: 001  \nBook 2  \nTitle: The Catcher  \nAuthor: Jane  \nISBN: 002  \n\n### CONSTRAINTS  \n- Must use a struct Book.  \n- Must allocate space for each book dynamically.  \n- Must print each book in the order received.  \n- Must free all allocated memory.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 28}, {"text": "# STEP 1: PROBLEM\n\n## Context\nYou have just joined the university\u2019s \u201cRetro Game Preservation Club.\u201d  \nThe club keeps a small, hand-curated collection of classic 8-bit games.  \nEach game is stored as a cartridge that has only three fields:  \n- a unique ID number (int)  \n- the year it was released (int)  \n- the number of hours the club has logged playing it (double)\n\nBecause the collection grows and shrinks as new donations arrive and old ones are traded away, the club needs a tiny inventory manager that uses dynamic memory allocation (`malloc`, `free`) to store the cartridges. No static arrays are allowed.\n\n## Requirements\n1. On startup the collection is empty.\n2. The program repeatedly offers a menu:\n   1) Add a new cartridge  \n   2) Remove a cartridge by ID  \n   3) Show every cartridge (one per line: ID, year, hours)  \n   4) EXIT  \n3. After every successful operation the menu re-appears.  \n4. All cartridge data must live in dynamically allocated memory.  \n5. When the user chooses EXIT every allocated byte must be released.\n\n## Simple Example Run\n```\n=== Retro Cartridge Manager ===\n1) Add cartridge\n2) Remove cartridge\n3) List cartridges\n4) EXIT\nChoice: 1\nEnter ID: 101\nEnter year: 1985\nEnter hours played: 12.5\nCartridge added.\n\n1) Add cartridge\n2) Remove cartridge\n3) List cartridges\n4) EXIT\nChoice: 3\nID: 101  Year: 1985  Hours: 12.50\n\n1) Add cartridge\n2) Remove cartridge\n3) List cartridges\n4) EXIT\nChoice: 4\nGood-bye!\n```\n\n### CONSTRAINTS\n- You must represent each cartridge with a `struct` named `Cartridge`.  \n- The only functions besides `main()` you may write are:  \n  \u2013 `void displayCartridge(const struct Cartridge *c)` which prints one cartridge in the exact format shown above.  \n  \u2013 Any helper you need for memory management (but no other \u201clogic\u201d functions).", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 29}, {"text": "# STEP 1: PROBLEM\n\n## Background Story\nYou are helping the campus library build a tiny, self-service kiosk that lets students register the books they are donating.  \nBecause the number of donations is unknown in advance, the program must keep the registry in dynamically-allocated memory.  \nEach book is recorded only once; if the same ISBN appears again the kiosk simply ignores the duplicate.\n\n## Functional Requirements\n1. On startup the registry is empty.\n2. The program repeatedly shows a menu:\n   1) Add a donated book  \n   2) List all donated books  \n   3) Remove a book by ISBN  \n   4) Exit\n3. Adding a book stores:\n   - title (single string, \u226480 characters)  \n   - author (single string, \u226450 characters)  \n   - ISBN  (13-digit string, no spaces)  \n   - year  (positive integer)  \n   Duplicate ISBNs must be rejected with the message \u201cBook already registered.\u201d\n4. Listing prints the books in the order they were added, one line per book with a single space between fields:\n   `title author ISBN year`\n5. Removing deletes the first book with the given ISBN and compacts the array.  \n   If no such ISBN exists, print \u201cBook not found.\u201d\n6. Before terminating, all dynamically allocated memory must be released.\n\n## Example Session (user input after \">\")\n```\n1) Add  2) List  3) Remove  4) Exit\n> 1\nTitle: Clean Code\nAuthor: Robert C. Martin\nISBN: 9780132350884\nYear: 2008\nBook added.\n\n1) Add  2) List  3) Remove  4) Exit\n> 1\nTitle: Clean Code\nAuthor: Robert C. Martin\nISBN: 9780132350884\nYear: 2008\nBook already registered.\n\n1) Add  2) List  3) Remove  4) Exit\n> 2\nClean Code Robert C. Martin 9780132350884 2008\n\n1) Add  2) List  3) Remove  4) Exit\n> 3\nISBN: 9780132350884\nBook removed.\n\n1) Add  2) List  3) Remove  4) Exit\n> 2\n(nothing printed \u2013 registry is empty)\n\n1) Add  2) List  3) Remove  4) Exit\n> 4\nGoodbye.\n```\n\n### CONSTRAINTS\n- A single `struct` must represent a book.\n- All book data must be kept in one dynamically-allocated array of `struct`.\n- The only functions allowed besides `main()` are:\n  - `addBook(...)`\n  - `listBooks(...)`\n  - `removeBook(...)`\n  - `freeRegistry(...)`\n- Menu option 4 is the only way to exit; typing 4 must terminate the program cleanly.", "model": "moonshotai/kimi-k2-instruct-0905", "iteration": 30}, {"text": "# STEP 1: PROBLEM\nYou are a librarian tasked with managing a collection of books in a library. The library's catalog system needs to be updated to efficiently store and manage book information. The system should utilize dynamic memory allocation to store book details.\n\n## BACKGROUND\nThe library has a diverse collection of books, and the catalog system needs to store information such as the book's title, author, publication year, and genre. The system should allow users to add new books, display all books, and search for specific books by title or author.\n\n## REQUIREMENTS\nThe program should have the following functionality:\n1. Add a new book to the catalog.\n2. Display all books in the catalog.\n3. Search for a book by title or author.\n4. Remove a book from the catalog.\n\n## EXAMPLE INPUT/OUTPUT\nExample Input:\n```\nAdd a new book:\nTitle: \"To Kill a Mockingbird\"\nAuthor: \"Harper Lee\"\nPublication Year: 1960\nGenre: \"Fiction\"\n\nDisplay all books:\nTitle: \"To Kill a Mockingbird\", Author: \"Harper Lee\", Publication Year: 1960, Genre: \"Fiction\"\n\nSearch for a book by title: \"To Kill a Mockingbird\"\nTitle: \"To Kill a Mockingbird\", Author: \"Harper Lee\", Publication Year: 1960, Genre: \"Fiction\"\n\nRemove a book:\nTitle: \"To Kill a Mockingbird\"\nBook removed successfully.\n```\n\n### CONSTRAINTS\n1. The solution must use a `struct` to represent a book, containing fields for title, author, publication year, and genre.\n2. The logic for displaying the details of all books must be in a function called `displayCatalog`.\n3. The program must include a menu with the following options:\n   - Option 1: Add a new book\n   - Option 2: Display all books\n   - Option 3: Search for a book\n   - Option 4: Remove a book\n   - Option 5: EXIT the program\n   The menu should be displayed repeatedly until the user chooses to EXIT the program by selecting Option 5.\n\nNote: The program should handle memory allocation and deallocation properly to avoid memory leaks.", "model": "llama-3.3-70b-versatile", "iteration": 16}, {"text": "# STEP 1: PROBLEM\nYou are the manager of a library, and you want to create a simple program to manage the books in your library. The library has a limited amount of memory to store information about the books, so you will use dynamic memory allocation to store the book details.\n\nThe program should allow you to add, remove, and display books in the library. Each book has a title, author, and publication year.\n\n### REQUIREMENTS\n1. The program should allow the user to add a new book to the library.\n2. The program should allow the user to remove a book from the library by its title.\n3. The program should allow the user to display all the books in the library.\n4. The program should allow the user to display the details of a specific book by its title.\n\n### EXAMPLE\nIf the user adds the following books:\n- Title: \"Book1\", Author: \"Author1\", Year: 2000\n- Title: \"Book2\", Author: \"Author2\", Year: 2001\n- Title: \"Book3\", Author: \"Author3\", Year: 2002\n\nThe program should display:\n- When displaying all books: \n  - \"Book1\" by Author1 (2000)\n  - \"Book2\" by Author2 (2001)\n  - \"Book3\" by Author3 (2002)\n- When displaying a specific book (e.g., \"Book2\"): \n  - \"Book2\" by Author2 (2001)\n\n### CONSTRAINTS\n- Must use a 'struct' to represent a book.\n- Logic for displaying the details of all books must be in a function called 'displayAllBooks'.\n- Logic for displaying the details of a specific book must be in a function called 'displayBook'.\n- The solution must be implemented with a menu-driven program.\n- The program must have the following menu options:\n  1. Add a book\n  2. Remove a book\n  3. Display all books\n  4. Display a specific book\n  5. EXIT (to exit the program)\n- If a menu is implemented, the program must include a specific menu option to EXIT the program, which is option 5.", "model": "llama-3.3-70b-versatile", "iteration": 17}, {"text": "# STEP 1: PROBLEM\nIn a small library, the librarian wants to manage the books using a computer program. The librarian needs to store the title, author, and publication year of each book. Since the number of books is not fixed, the program should dynamically allocate memory for each book. The program should also allow the librarian to add, remove, and display books.\n\n### BACKGROUND\nThe librarian has a collection of books and wants to use a computer program to manage the collection. The program should store the title, author, and publication year of each book.\n\n### REQUIREMENTS\nThe program should have the following functionality:\n1. Dynamically allocate memory for each book.\n2. Allow the librarian to add a new book to the collection.\n3. Allow the librarian to remove a book from the collection.\n4. Allow the librarian to display all books in the collection.\n5. Allow the librarian to display the details of a specific book.\n\n### EXAMPLE\nExample Input:\n```\nAdd a book: Title - \"Book1\", Author - \"Author1\", Year - 2020\nAdd a book: Title - \"Book2\", Author - \"Author2\", Year - 2021\nDisplay all books:\nBook1 by Author1 (2020)\nBook2 by Author2 (2021)\nRemove a book: Title - \"Book1\"\nDisplay all books:\nBook2 by Author2 (2021)\n```\nExample Output:\n```\nBook added successfully!\nBook added successfully!\nBook1 by Author1 (2020)\nBook2 by Author2 (2021)\nBook removed successfully!\nBook2 by Author2 (2021)\n```\n\n### CONSTRAINTS\n* Must use a `struct` to represent a book.\n* Logic for displaying the details of all books must be in a function called `displayAllBooks`.\n* Logic for displaying the details of a specific book must be in a function called `displayBook`.\n* The solution must be implemented with two functions besides `main()`: `addBook` and `removeBook`.\n* The program must have a menu with the following options:\n\t1. Add a book\n\t2. Remove a book\n\t3. Display all books\n\t4. Display a specific book\n\t5. EXIT the program\n* The program must free the dynamically allocated memory when a book is removed or when the program exits.\n\nNote: The `EXIT` option should be clearly stated as option 5. When the user chooses option 5, the program should free all dynamically allocated memory and exit.", "model": "llama-3.3-70b-versatile", "iteration": 18}, {"text": "# STEP 1: PROBLEM\nYou are the manager of a library, and you want to create a system to manage the books in your library. You want to store the title, author, and year of publication for each book. Since the number of books is not fixed, you will use dynamic memory allocation to store the books.\n\nThe program should allow users to add, remove, and display books. When a user adds a book, the program should allocate memory for the new book and store its details. When a user removes a book, the program should free the memory allocated for that book.\n\n### REQUIREMENTS\n1. The program should allow users to add books with their title, author, and year of publication.\n2. The program should allow users to remove books by their title.\n3. The program should allow users to display all the books in the library.\n4. The program should display a menu with options to add, remove, display books, and exit the program.\n\n### EXAMPLE\nIf the user adds two books: \"Book1\" by \"Author1\" published in 2020, and \"Book2\" by \"Author2\" published in 2021, and then displays all books, the output should be:\n```\nTitle: Book1\nAuthor: Author1\nYear: 2020\nTitle: Book2\nAuthor: Author2\nYear: 2021\n```\nIf the user then removes \"Book1\" and displays all books again, the output should be:\n```\nTitle: Book2\nAuthor: Author2\nYear: 2021\n```\n\n### CONSTRAINTS\n1. Must use a `struct` to represent a book with its title, author, and year of publication.\n2. Logic for displaying the details of all books must be in a function called `displayBooks`.\n3. The solution must be implemented with a single function besides `main()` to handle the menu and user input, called `handleMenu`.\n4. If a menu is implemented, it must include a specific menu option to EXIT the program, which is option 4.\n\n### MENU CONSTRAINTS\nIf a menu is implemented, it should have the following options:\n1. Add a book\n2. Remove a book\n3. Display all books\n4. EXIT the program (by selecting option 4)", "model": "llama-3.3-70b-versatile", "iteration": 19}, {"text": "# STEP 1: PROBLEM\nIn a library management system, books are the primary entities that need to be managed. The system should allow users to add, delete, and display book details. The details of each book include the title, author, and publication year. Since the number of books is not fixed and can vary dynamically, dynamic memory allocation using `malloc` and `free` should be utilized.\n\nThe system should provide a simple menu-driven interface for users to interact with the library management system. The requirements for the system's functionality are as follows:\n1. Initialize an empty library.\n2. Allow users to add new books to the library.\n3. Allow users to delete a book by its title.\n4. Display all books in the library.\n5. Display the details of a specific book by its title.\n\n### CONSTRAINTS\n- Must use a `struct` to represent a book, containing fields for title, author, and publication year.\n- The logic for displaying the details of all books must be in a function called `displayAllBooks`.\n- The logic for adding a new book must be in a function called `addBook`.\n- The solution must include a menu with the following options:\n  1. Add a new book\n  2. Delete a book\n  3. Display all books\n  4. Display a specific book\n  5. EXIT the program\n- The program must handle memory allocation and deallocation properly to avoid memory leaks.\n\n### EXAMPLE\nExample Input/Output:\n```\nMenu:\n1. Add a new book\n2. Delete a book\n3. Display all books\n4. Display a specific book\n5. EXIT\n\nChoose an option: 1\nEnter title: Harry Potter\nEnter author: J.K. Rowling\nEnter publication year: 1997\n\nChoose an option: 3\nTitle: Harry Potter, Author: J.K. Rowling, Year: 1997\n\nChoose an option: 5\n```\nNote: The above example illustrates a simple interaction with the system. The actual implementation should handle user inputs, validate data, and manage memory efficiently.", "model": "llama-3.3-70b-versatile", "iteration": 20}, {"text": "# STEP 1: PROBLEM\nYou are the administrator of a university's student records system. The system needs to store information about each student, including their name, student ID, and GPA. Since the number of students is not fixed and can change dynamically, you want to use dynamic memory allocation to store the student records. \n\nThe program should allow users to add, remove, and display student records. When adding a student record, the program should prompt the user for the student's name, ID, and GPA. When removing a student record, the program should prompt the user for the student's ID. When displaying student records, the program should display all the records or a specific record based on the user's choice.\n\n### REQUIREMENTS\n1. The program should have a menu-driven interface to add, remove, and display student records.\n2. The program should use dynamic memory allocation to store student records.\n3. The program should handle memory deallocation when removing a student record.\n4. The program should validate user input for student ID and GPA.\n\n### EXAMPLE\nIf the user chooses to add a student record with name \"John Doe\", ID \"12345\", and GPA \"3.5\", the program should store this information and display a confirmation message. If the user chooses to display all student records, the program should display the name, ID, and GPA of each student.\n\nExample Input/Output:\n```\nMenu:\n1. Add Student Record\n2. Remove Student Record\n3. Display All Student Records\n4. Display Specific Student Record\n5. EXIT\n\nChoose an option: 1\nEnter student name: John Doe\nEnter student ID: 12345\nEnter student GPA: 3.5\nStudent record added successfully.\n\nChoose an option: 3\nStudent Records:\nName: John Doe, ID: 12345, GPA: 3.5\n\nChoose an option: 5\nExiting the program...\n```\n\n### CONSTRAINTS\n1. Must use a `struct` to represent the student record.\n2. Logic for displaying the details of one specific student record must be in a function called `displayStudent`.\n3. The program must use dynamic memory allocation to store student records.\n4. If a menu is implemented, the program must include a specific menu option to EXIT the program, which is option 5.\n\nNote: The `struct` should have fields for student name, ID, and GPA. The `displayStudent` function should take a pointer to the student record as an argument and display the details of the student. The program should handle memory deallocation when removing a student record to prevent memory leaks.", "model": "llama-3.3-70b-versatile", "iteration": 21}, {"text": "# STEP 1: PROBLEM\nYou are a librarian tasked with managing the inventory of books in a library. The library has a limited budget and can only store a certain number of books at a time. You need to create a program to manage the book inventory, allowing you to add, remove, and display books.\n\n**Background Story:**\nThe library has a unique system where each book is represented by its title, author, and publication year. The librarian wants to be able to add new books to the inventory, remove books that are no longer needed, and display the details of all the books in the inventory.\n\n**Requirements:**\n1. The program must be able to dynamically allocate memory for each book.\n2. The program must allow the user to add a new book to the inventory.\n3. The program must allow the user to remove a book from the inventory by its title.\n4. The program must display the details of all the books in the inventory.\n5. The program must handle memory deallocation when a book is removed from the inventory.\n\n**Example Input/Output:**\n```\nMenu:\n1. Add Book\n2. Remove Book\n3. Display Books\n4. Exit\n\nChoose an option: 1\nEnter book title: Harry Potter\nEnter book author: J.K. Rowling\nEnter book publication year: 1997\n\nChoose an option: 3\nBook 1:\nTitle: Harry Potter\nAuthor: J.K. Rowling\nPublication Year: 1997\n\nChoose an option: 2\nEnter book title to remove: Harry Potter\n\nChoose an option: 3\nNo books in inventory.\n\nChoose an option: 4\nExiting program...\n```\n\n### CONSTRAINTS\n* The solution must be implemented using a `struct` to represent each book.\n* The logic for displaying the details of all books must be in a function called `displayBooks`.\n* The program must have a menu with the following options:\n\t+ 1: Add Book\n\t+ 2: Remove Book\n\t+ 3: Display Books\n\t+ 4: Exit\n* The program must exit when the user chooses option 4 (Exit).\n* The program must use `malloc` and `free` for dynamic memory allocation and deallocation.", "model": "llama-3.3-70b-versatile", "iteration": 22}, {"text": "# STEP 1: PROBLEM\nYou are the manager of a library that lends books to its members. To efficiently manage the books and their corresponding borrowers, you decide to create a program that utilizes dynamic memory allocation. The program will store information about the books and their borrowers, and perform operations to add, remove, and display this information.\n\nThe library has a collection of books with unique IDs, titles, authors, and the names of the borrowers. The program should be able to handle the following operations:\n1. Add a new book to the collection, along with its details (ID, title, author, and borrower).\n2. Remove a book from the collection by its ID.\n3. Display the details of all the books in the collection.\n4. Display the details of a specific book by its ID.\n\n### CONSTRAINTS\n- The program must use a `struct` to represent a book, which includes the ID, title, author, and borrower.\n- The logic for displaying the details of all books must be in a function called `displayAllBooks`.\n- The logic for displaying the details of one specific book must be in a function called `displayBook`.\n- The solution must be implemented with at least two functions besides `main()`.\n- If a menu is implemented, it must include the following options:\n  - Option 1: Add a new book\n  - Option 2: Remove a book\n  - Option 3: Display all books\n  - Option 4: Display a specific book\n  - Option 5: EXIT the program\n  To exit the program, the user must select Option 5.\n\n### EXAMPLE\nExample Input:\n```\n1. Add a new book with ID: 1, title: \"Book1\", author: \"Author1\", borrower: \"Borrower1\"\n2. Add a new book with ID: 2, title: \"Book2\", author: \"Author2\", borrower: \"Borrower2\"\n3. Display all books\n```\nExample Output:\n```\nBook 1:\nID: 1\nTitle: Book1\nAuthor: Author1\nBorrower: Borrower1\n\nBook 2:\nID: 2\nTitle: Book2\nAuthor: Author2\nBorrower: Borrower2\n```\nThis program will help the library to efficiently manage its collection of books and borrowers, and provide a simple and user-friendly interface for the library manager to perform various operations.", "model": "llama-3.3-70b-versatile", "iteration": 23}, {"text": "# STEP 1: PROBLEM\nYou are the manager of a library that lends books to its members. The library has a collection of books, and each book has a title, author, and status (available or borrowed). The library wants to create a system to manage its book collection using dynamic memory allocation.\n\nThe system should allow the librarian to add new books, remove existing books, display all books, and search for a specific book by title or author.\n\n### REQUIREMENTS\n1. The system should store the book collection in a dynamically allocated array of structures, where each structure represents a book with its title, author, and status.\n2. The system should have the following functionalities:\n   - Add a new book to the collection\n   - Remove a book from the collection\n   - Display all books in the collection\n   - Search for a book by title or author\n3. The system should handle memory allocation and deallocation properly to avoid memory leaks.\n\n### EXAMPLE\nInput:\n```\nAdd book: \"Harry Potter\" by \"J.K. Rowling\"\nAdd book: \"The Lord of the Rings\" by \"J.R.R. Tolkien\"\nDisplay all books\nSearch for book by title: \"Harry Potter\"\nRemove book: \"The Lord of the Rings\"\nDisplay all books\n```\nOutput:\n```\nBook 1: \"Harry Potter\" by \"J.K. Rowling\" (available)\nBook 2: \"The Lord of the Rings\" by \"J.R.R. Tolkien\" (available)\nBook found: \"Harry Potter\" by \"J.K. Rowling\" (available)\nBook removed: \"The Lord of the Rings\"\nBook 1: \"Harry Potter\" by \"J.K. Rowling\" (available)\n```\n\n### CONSTRAINTS\n- The solution must be implemented using a `struct` to represent a book.\n- The logic for displaying the details of all books must be in a function called `displayBooks`.\n- The solution must include a menu with the following options:\n  1. Add a new book\n  2. Remove a book\n  3. Display all books\n  4. Search for a book\n  5. EXIT (to exit the program)\n- The menu option to exit the program is option 5 (EXIT). \n\nNote: The program should handle invalid inputs and memory allocation errors properly.", "model": "llama-3.3-70b-versatile", "iteration": 24}, {"text": "# STEP 1: PROBLEM\nIn a university setting, the management wants to keep track of the books in its library using a dynamic memory allocation system. The system should be able to add, remove, and display books. Each book has a unique ID, title, author, and publication year.\n\nThe program should be designed to manage the library's book collection efficiently. The following requirements must be met:\n1. The program should allow users to add a new book to the collection.\n2. The program should allow users to remove a book from the collection by its ID.\n3. The program should allow users to display all the books in the collection.\n4. The program should allow users to search for a book by its ID and display its details.\n\n### CONSTRAINTS\n- Must use a 'struct' to represent a book.\n- Logic for displaying the details of ONE specific book must be in a function called 'displayBook'.\n- The solution must be implemented with a single function besides main() to handle all the menu options.\n- If a menu is implemented, it must include a specific menu option to EXIT the program, which should be option 5.\n\n### EXAMPLE INPUT/OUTPUT\nExample Input:\n```\n1. Add a new book\nEnter book ID: 1\nEnter book title: Introduction to CS\nEnter book author: John Doe\nEnter publication year: 2020\n\n2. Add a new book\nEnter book ID: 2\nEnter book title: Data Structures\nEnter book author: Jane Smith\nEnter publication year: 2019\n\n3. Display all books\nBook ID: 1, Title: Introduction to CS, Author: John Doe, Year: 2020\nBook ID: 2, Title: Data Structures, Author: Jane Smith, Year: 2019\n\n4. Search for a book by ID\nEnter book ID: 1\nBook ID: 1, Title: Introduction to CS, Author: John Doe, Year: 2020\n\n5. Exit\n```\nExample Output:\n```\nMenu:\n1. Add a new book\n2. Remove a book\n3. Display all books\n4. Search for a book by ID\n5. Exit\n\nChoose an option: \n```", "model": "llama-3.3-70b-versatile", "iteration": 25}, {"text": "# STEP 1: PROBLEM\nYou are the manager of a library that lends books to its members. To keep track of the books and their borrowers, you need to develop a program that utilizes dynamic memory allocation. The program should store information about each book, including its title, author, and borrower's name (if the book is borrowed).\n\n## BACKGROUND\nThe library has a collection of books, and each book can be borrowed by a member. When a book is borrowed, the program should record the borrower's name. If a book is returned, the borrower's name should be removed from the record.\n\n## REQUIREMENTS\nThe program's functionality should include the following:\n1. Add a new book to the collection with its title, author, and initially, no borrower.\n2. Borrow a book by specifying the book's title and the borrower's name.\n3. Return a book by specifying the book's title.\n4. Display all books in the collection, including their titles, authors, and borrowers (if any).\n5. Display the details of a specific book by its title.\n\n## EXAMPLE INPUT/OUTPUT\nExample input:\n- Add book: \"Introduction to CS\" by \"John Doe\"\n- Borrow book: \"Introduction to CS\" by \"Jane Smith\"\n- Return book: \"Introduction to CS\"\n- Display all books\n- Display book: \"Introduction to CS\"\n\nExample output:\n- After adding the book: \"Book added successfully: Introduction to CS by John Doe\"\n- After borrowing the book: \"Book borrowed successfully: Introduction to CS by Jane Smith\"\n- After returning the book: \"Book returned successfully: Introduction to CS\"\n- Display all books: A list of all books with their titles, authors, and borrowers (if any).\n- Display book: Details of the specified book, including title, author, and borrower (if any).\n\n### CONSTRAINTS\n- The solution must be implemented using a `struct` to represent a book, which includes the title, author, and borrower's name.\n- The logic for displaying the details of one specific book must be in a function called `displayBook`.\n- The program must include a menu with the following options:\n  1. Add a new book\n  2. Borrow a book\n  3. Return a book\n  4. Display all books\n  5. Display a specific book\n  6. EXIT (to exit the program)\n- The program must use dynamic memory allocation (`malloc`, `free`) to manage the collection of books.\n\nNote: The program should handle memory allocation and deallocation properly to avoid memory leaks.", "model": "llama-3.3-70b-versatile", "iteration": 26}, {"text": "# STEP 1: PROBLEM\nYou are the manager of a library that lends books to its members. The library has a collection of books, and you want to create a program to manage the catalog. The program should allow you to add, remove, and display the details of books in the catalog.\n\nThe background story is that the library has just started, and you need to create a system to manage the books. You have decided to use dynamic memory allocation to store the book details, as the number of books can vary.\n\nHere are the requirements for the program's functionality:\n1. The program should allow you to add a new book to the catalog. Each book has a title, author, and publication year.\n2. The program should allow you to remove a book from the catalog by its title.\n3. The program should allow you to display the details of all books in the catalog.\n4. The program should allow you to search for a book by its title and display its details.\n\nHere is a simple example of expected Input/Output:\n```\nMenu:\n1. Add a book\n2. Remove a book\n3. Display all books\n4. Search for a book\n5. Exit\n\nChoose an option: 1\nEnter book title: Harry Potter\nEnter book author: J.K. Rowling\nEnter book publication year: 1997\n\nChoose an option: 3\nTitle: Harry Potter, Author: J.K. Rowling, Year: 1997\n\nChoose an option: 5\nExiting the program...\n```\n\n### CONSTRAINTS\n- Must use a 'struct' to represent a book.\n- Logic for displaying the details of all books must be in a function called 'displayAllBooks'.\n- Logic for adding a new book must be in a function called 'addBook'.\n- The program must include a menu with the following options:\n  1. Add a book\n  2. Remove a book\n  3. Display all books\n  4. Search for a book\n  5. Exit\n- The program must exit when the user chooses option 5.\n- The solution must be implemented using dynamic memory allocation (malloc, free) to store the book details.", "model": "llama-3.3-70b-versatile", "iteration": 27}, {"text": "# STEP 1: PROBLEM\nIn a university setting, the management wants to create a simple system to manage the details of its faculty members. The system should be able to dynamically allocate memory for each faculty member and store their details such as name, age, department, and years of experience. The system should also be able to display the details of all faculty members and free the allocated memory when the program terminates.\n\nThe background story is that the university has a growing number of faculty members, and the management wants a system that can efficiently store and manage their details without wasting memory.\n\nThe program's functionality requirements are as follows:\n1. The program should dynamically allocate memory for each faculty member using malloc.\n2. The program should store the details of each faculty member, including name, age, department, and years of experience.\n3. The program should display the details of all faculty members.\n4. The program should free the allocated memory when the program terminates.\n\nHere is a simple example of expected input/output:\n```\nEnter the number of faculty members: 2\nEnter name: John Doe\nEnter age: 30\nEnter department: Computer Science\nEnter years of experience: 5\nEnter name: Jane Doe\nEnter age: 25\nEnter department: Mathematics\nEnter years of experience: 3\nFaculty Member 1:\nName: John Doe\nAge: 30\nDepartment: Computer Science\nYears of Experience: 5\nFaculty Member 2:\nName: Jane Doe\nAge: 25\nDepartment: Mathematics\nYears of Experience: 3\n```\n\n### CONSTRAINTS\n- The solution must be implemented using a struct to represent the faculty member.\n- The logic for displaying the details of all faculty members must be in a function called `displayFaculty`.\n- The solution must include a menu with the following options:\n  1. Add Faculty Member\n  2. Display Faculty Members\n  3. Exit\n- The program must exit when the user selects the \"Exit\" option (option 3).\n- The program must free the allocated memory when the program terminates.", "model": "llama-3.3-70b-versatile", "iteration": 28}, {"text": "# STEP 1: PROBLEM\nIn a small library, books are stored on shelves. Each book has a unique title, author, and publication year. The librarian wants a program to manage the library's book collection. The program should allow the librarian to add, remove, and display books. Since the number of books is dynamic, the program will use dynamic memory allocation to store the book collection.\n\nThe program's functionality should include:\n1. Adding a new book to the collection: The librarian will input the title, author, and publication year of the new book.\n2. Removing a book from the collection: The librarian will input the title of the book to be removed.\n3. Displaying all books in the collection: The program will display the title, author, and publication year of each book.\n4. Displaying a specific book's details: The librarian will input the title of the book, and the program will display its details.\n\n### EXAMPLE\nIf the librarian adds two books: \"Book1\" by \"Author1\" published in 2020, and \"Book2\" by \"Author2\" published in 2021, the program should display the following when the librarian chooses to display all books:\n```\nBook1 by Author1 (2020)\nBook2 by Author2 (2021)\n```\nIf the librarian chooses to display the details of \"Book1\", the program should display:\n```\nBook1 by Author1 (2020)\n```\n\n### CONSTRAINTS\n- Must use a 'struct' to represent a book.\n- The logic for displaying the details of one specific book must be in a function called 'displayBook'.\n- The solution must include a menu with the following options:\n  1. Add a book\n  2. Remove a book\n  3. Display all books\n  4. Display a specific book's details\n  5. EXIT (to exit the program)\n- The menu option to EXIT the program is option 5. \n\nNote: The program should handle cases where the librarian tries to remove or display a book that does not exist in the collection. In such cases, the program should display an error message.", "model": "llama-3.3-70b-versatile", "iteration": 29}, {"text": "# STEP 1: PROBLEM\nYou are a librarian tasked with managing a collection of books in a library. The library wants to keep track of the books using a dynamic memory allocation system. The system should allow the librarian to add, remove, and display books.\n\nBackground:\nThe library has a large collection of books, and the number of books can vary. The librarian needs a system that can dynamically allocate memory to store the book details.\n\nRequirements:\n1. The program should allow the librarian to add a new book to the collection.\n2. The program should allow the librarian to remove a book from the collection.\n3. The program should allow the librarian to display all the books in the collection.\n4. The program should allow the librarian to search for a specific book by its title.\n\nExample Input/Output:\n```\nMenu:\n1. Add Book\n2. Remove Book\n3. Display Books\n4. Search Book\n5. Exit\n\nChoose an option: 1\nEnter book title: Harry Potter\nEnter book author: J.K. Rowling\n\nChoose an option: 3\nBook 1:\nTitle: Harry Potter\nAuthor: J.K. Rowling\n\nChoose an option: 4\nEnter book title to search: Harry Potter\nBook found:\nTitle: Harry Potter\nAuthor: J.K. Rowling\n```\n\n### CONSTRAINTS\n1. Must use a `struct` to represent the book entity with fields for `title`, `author`, and `next` (a pointer to the next book in the collection).\n2. The solution must be implemented with a single linked list.\n3. The `addBook` function should dynamically allocate memory for the new book and add it to the end of the linked list.\n4. The `removeBook` function should free the memory allocated for the book being removed.\n5. The logic for displaying the details of all books must be in a function called `displayBooks`.\n6. The program must include a menu with options to add, remove, display, search, and exit the program.\n7. The menu option to exit the program must be option 5, labeled as \"Exit\".\n\n### ADDITIONAL CONSTRAINTS IF MENU IS IMPLEMENTED\n- The program must include a specific menu option to exit the program, which is option 5, labeled as \"Exit\". When this option is chosen, the program should free all the dynamically allocated memory and exit.", "model": "llama-3.3-70b-versatile", "iteration": 30}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe city museum is modernising its catalogue system.  Each exhibit is described by a **name**, the **year** it was created, and its **estimated monetary value**.  The museum wants a small console program that can store an arbitrary number of exhibits while the program runs, allow the curator to add new entries, view the whole list, look up a single exhibit, and finally release all memory before the program ends.\n\nYou have just learned how to allocate and release memory with `malloc`/`free`, and how to bundle related data in a `struct`.  Write the required program using those tools.\n\n## Requirements  \n\n1. Define a `struct Exhibit` that contains:  \n   * `char *name` \u2013 a dynamically allocated string (maximum length 100 characters).  \n   * `int year` \u2013 the year the artifact was created.  \n   * `double value` \u2013 estimated monetary value in dollars.  \n\n2. When the program starts, it should present the user with a **menu** that repeats until the user chooses to exit. The menu must contain the following options (the numbers are mandatory):  \n\n   1. **Add a new exhibit** \u2013 Prompt for the name, year, and value, allocate a new `Exhibit`, and store it in a dynamically\u2011allocated array that grows as needed.  \n   2. **List all exhibits** \u2013 Print the index (starting at 0) and all fields of every stored exhibit.  \n   3. **Display a specific exhibit** \u2013 Ask for an index, then call a function `displayEntity` to print that exhibit\u2019s details.  \n   4. **Delete an exhibit** \u2013 Ask for an index, free the memory used for that exhibit\u2019s name, shift the remaining elements left, and shrink the array accordingly.  \n   5. **Exit** \u2013 Free **all** memory allocated for the array and for every exhibit\u2019s name, then terminate the program.  \n\n3. The program must **never leak memory**: every block obtained with `malloc` (or `realloc`) must be released with `free` before the program ends or when an exhibit is deleted.\n\n4. Input validation is not required beyond ensuring the entered index is within the current range of stored exhibits.\n\n## Example Interaction  \n\n```\n=== Museum Exhibit Manager ===\n1) Add a new exhibit\n2) List all exhibits\n3) Display a specific exhibit\n4) Delete an exhibit\n5) Exit\nChoose an option: 1\nEnter exhibit name: Ancient Vase\nEnter year created: 1845\nEnter estimated value: 1250.75\nExhibit added.\n\n1) Add a new exhibit\n2) List all exhibits\n3) Display a specific exhibit\n4) Delete an exhibit\n5) Exit\nChoose an option: 1\nEnter exhibit name: Bronze Sword\nEnter year created: 1020\nEnter estimated value: 3400.00\nExhibit added.\n\n1) Add a new exhibit\n2) List all exhibits\n3) Display a specific exhibit\n4) Delete an exhibit\n5) Exit\nChoose an option: 2\n[0] Name: Ancient Vase, Year: 1845, Value: $1250.75\n[1] Name: Bronze Sword, Year: 1020, Value: $3400.00\n\n1) Add a new exhibit\n2) List all exhibits\n3) Display a specific exhibit\n4) Delete an exhibit\n5) Exit\nChoose an option: 3\nEnter exhibit index: 1\n--- Exhibit Details ---\nName : Bronze Sword\nYear : 1020\nValue: $3400.00\n\n1) Add a new exhibit\n2) List all exhibits\n3) Display a specific exhibit\n4) Delete an exhibit\n5) Exit\nChoose an option: 4\nEnter exhibit index to delete: 0\nExhibit deleted.\n\n1) Add a new exhibit\n2) List all exhibits\n3) Display a specific exhibit\n4) Delete an exhibit\n5) Exit\nChoose an option: 2\n[0] Name: Bronze Sword, Year: 1020, Value: $3400.00\n\n1) Add a new exhibit\n2) List all exhibits\n3) Display a specific exhibit\n4) Delete an exhibit\n5) Exit\nChoose an option: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Struct Requirement** \u2013 The primary data entity must be a `struct Exhibit` as described above.  \n* **Function Requirement** \u2013 The logic for displaying the details of ONE specific exhibit must be placed in a function named `void displayEntity(const struct Exhibit *e);`.  \n* **Menu Requirement** \u2013 The program must present a textual menu that includes a distinct option to **EXIT** the program (option\u202f5 in the example).  \n* **Memory Management** \u2013 All memory allocated with `malloc`/`realloc` must be released with `free` before the program terminates, and also when an exhibit is removed.  \n* **Single\u2011File Implementation** \u2013 Apart from `main`, you may create additional helper functions, but the overall solution should be contained in a single source file.  \n\nWrite the program in C, adhering to the above specifications.", "model": "openai/gpt-oss-120b", "iteration": 31}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired to write a tiny \u201clibrary\u2011catalog\u201d program for a small community library.  \nEach book in the catalog is described by three pieces of information:\n\n* **ISBN** \u2013 a 13\u2011digit number (store as a string to keep leading zeros).  \n* **Title** \u2013 up to 100 characters.  \n* **Year** \u2013 the year of publication (integer).  \n\nThe library wants a command\u2011line, menu\u2011driven application that can add books, remove books, and display information about a single book on demand. Because the number of books is not known beforehand, you must allocate memory dynamically for each book record and for the list that holds the pointers to those records.\n\n## Requirements  \n\nWrite a C program that satisfies the following functional specifications:\n\n1. **Menu** \u2013 When the program starts, display a menu with the options:  \n   1. Add a new book  \n   2. Delete a book by ISBN  \n   3. Show details of a book by ISBN  \n   4. List all books (in the order they were added)  \n   5. EXIT  \n\n   The user selects an option by entering the corresponding number.\n\n2. **Add a new book**  \n   * Prompt the user for ISBN, Title, and Year.  \n   * Allocate a `struct Book` dynamically (`malloc`).  \n   * Store the data in the newly allocated structure.  \n   * Store the pointer to this structure in a dynamically\u2011sized array (you may use a simple array that you `realloc` each time a book is added).  \n\n3. **Delete a book by ISBN**  \n   * Search the array for a book whose ISBN matches the user\u2011supplied ISBN.  \n   * If found, free the memory that holds that `struct Book`.  \n   * Remove the pointer from the array, shifting later elements forward, and shrink the array with `realloc`.  \n   * If the ISBN is not present, print an informative message.\n\n4. **Show details of a book by ISBN**  \n   * Locate the book with the given ISBN.  \n   * If found, call a function `displayBook` (see constraints) to print the book\u2019s data.  \n   * If not found, print an appropriate message.\n\n5. **List all books**  \n   * Iterate over the array and call `displayBook` for each stored book.\n\n6. **EXIT**  \n   * Before terminating, free every dynamically allocated `struct Book` and the array that holds the pointers.\n\n## Example Interaction  \n\n```\n=== Library Catalog ===\n1. Add a new book\n2. Delete a book by ISBN\n3. Show details of a book by ISBN\n4. List all books\n5. EXIT\nEnter choice: 1\nEnter ISBN: 9780131103627\nEnter Title: The C Programming Language\nEnter Year: 1978\nBook added.\n\n=== Library Catalog ===\n1. Add a new book\n2. Delete a book by ISBN\n3. Show details of a book by ISBN\n4. List all books\n5. EXIT\nEnter choice: 1\nEnter ISBN: 9780262033848\nEnter Title: Introduction to Algorithms\nEnter Year: 2009\nBook added.\n\n=== Library Catalog ===\n1. Add a new book\n2. Delete a book by ISBN\n3. Show details of a book by ISBN\n4. List all books\n5. EXIT\nEnter choice: 4\nISBN: 9780131103627 | Title: The C Programming Language | Year: 1978\nISBN: 9780262033848 | Title: Introduction to Algorithms | Year: 2009\n\n=== Library Catalog ===\n1. Add a new book\n2. Delete a book by ISBN\n3. Show details of a book by ISBN\n4. List all books\n5. EXIT\nEnter choice: 3\nEnter ISBN to display: 9780131103627\nISBN: 9780131103627 | Title: The C Programming Language | Year: 1978\n\n=== Library Catalog ===\n1. Add a new book\n2. Delete a book by ISBN\n3. Show details of a book by ISBN\n4. List all books\n5. EXIT\nEnter choice: 5\nGood\u2011bye!\n```\n\n## ### CONSTRAINTS  \n\n* **Struct requirement** \u2013 The primary data entity must be represented by a `struct` named `Book` containing the fields `char isbn[14];`, `char title[101];`, and `int year;`.  \n\n* **Display function** \u2013 The logic for printing the details of **ONE** book must reside in a function with the exact prototype:  \n\n  ```c\n  void displayBook(const struct Book *b);\n  ```  \n\n* **Memory management** \u2013 Every call to `malloc`/`realloc` must have a matching `free` before program termination. No memory leaks are permitted.  \n\n* **Menu exit option** \u2013 The menu must include the option **5. EXIT** (as shown above). Selecting this option must cause the program to free all allocated memory and then terminate.  \n\n* **Single\u2011source file** \u2013 The entire solution must be placed in one `.c` file and compile with a standard C compiler (C99 or later).  \n\n* **Error handling** \u2013 The program should handle invalid menu choices and failed allocations gracefully, printing an error message and returning to the menu.  ", "model": "openai/gpt-oss-120b", "iteration": 32}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired to write a small \u201cstudent registry\u201d utility for the campus computer lab.  \nThe lab\u2019s computer must keep track of an arbitrary number of students that are entered during a single execution of the program. Because the number of students is not known beforehand, you must allocate and free memory dynamically using `malloc` and `free`.  \n\n## Requirements  \n\nWrite a C program that implements the following functionality:\n\n1. **Menu\u2011driven interface** (displayed repeatedly until the user chooses to exit):\n   * `1` \u2013 **Add a student**  \n        * Prompt for the student\u2019s **ID** (integer), **name** (string without spaces, max 30 characters), and **GPA** (float).  \n        * Allocate a new `struct Student` on the heap, store the data, and insert it at the end of the current list.\n   * `2` \u2013 **Display a student**  \n        * Prompt for a student **ID**.  \n        * Search the list; if the student exists, call the function `displayEntity` to print the student\u2019s details (see below).  \n        * If the ID is not found, print `Student not found.`  \n   * `3` \u2013 **Remove a student**  \n        * Prompt for a student **ID**.  \n        * If the student exists, remove it from the list and `free` the associated memory.  \n        * If the ID is not found, print `Student not found.`  \n   * `4` \u2013 **List all students**  \n        * Print the details of every student currently stored, in the order they were added.  \n   * `5` \u2013 **Exit**  \n        * Terminate the program after freeing **all** dynamically allocated memory.  \n\n2. The program must **not** impose any fixed limit on the number of students; it should grow the list only as needed.\n\n3. All allocated memory must be released before the program terminates (including when a student is removed).\n\n4. The program should be robust against invalid menu choices (print `Invalid option.` and redisplay the menu).\n\n## Example Interaction  \n\n```\n=== Student Registry ===\n1) Add student\n2) Display student\n3) Remove student\n4) List all students\n5) Exit\nChoose an option: 1\nEnter ID: 101\nEnter name: Alice\nEnter GPA: 3.7\nStudent added.\n\n=== Student Registry ===\n1) Add student\n2) Display student\n3) Remove student\n4) List all students\n5) Exit\nChoose an option: 1\nEnter ID: 202\nEnter name: Bob\nEnter GPA: 3.2\nStudent added.\n\n=== Student Registry ===\n1) Add student\n2) Display student\n3) Remove student\n4) List all students\n5) Exit\nChoose an option: 2\nEnter ID to display: 101\n--- Student Details ---\nID   : 101\nName : Alice\nGPA  : 3.70\n\n=== Student Registry ===\n1) Add student\n2) Display student\n3) Remove student\n4) List all students\n5) Exit\nChoose an option: 4\n--- All Students ---\nID   : 101  Name : Alice  GPA : 3.70\nID   : 202  Name : Bob    GPA : 3.20\n\n=== Student Registry ===\n1) Add student\n2) Display student\n3) Remove student\n4) List all students\n5) Exit\nChoose an option: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n* **Struct Requirement** \u2013 The primary data entity must be represented by a `struct Student` containing at least the fields `int id; char name[31]; float gpa;`.  \n* **Display Function** \u2013 The logic for printing the details of a single student must reside in a function with the exact prototype:  \n\n  ```c\n  void displayEntity(const struct Student *s);\n  ```  \n\n* **Memory Management** \u2013 Use only `malloc` (or `calloc`) and `free` for dynamic allocation; do **not** use global/static arrays to store the students.  \n* **Menu Exit Option** \u2013 The menu must include an explicit option `5` (or the keyword `EXIT`) that terminates the program, satisfying the mandatory exit\u2011option constraint.  \n\n*Optional (for extra credit):* Implement the list as a singly\u2011linked list; however, any dynamic container that respects the above constraints is acceptable.  ", "model": "openai/gpt-oss-120b", "iteration": 33}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nYou have been hired to write a tiny \u201cstudent registry\u201d for the campus computer\u2011lab. The lab technician will run the program each day to add new students, remove students who have left, and view the details of a particular student. Because the number of students changes at run\u2011time, you must allocate and free memory dynamically.\n\n## Program Requirements  \n\n1. **Data Representation**  \n   - Define a `struct Student` that stores:  \n     - an integer `id` (unique identifier)  \n     - a string `name` (maximum 30 characters)  \n     - a floating\u2011point `gpa`  \n\n2. **Menu\u2011driven Interface** (the program must present a menu repeatedly until the user chooses to exit)  \n   - **1. Add a student** \u2013 Prompt for `id`, `name`, and `gpa`. Allocate memory for a new `Student` and store it in a dynamically\u2011grown array (or linked list).  \n   - **2. Remove a student** \u2013 Prompt for an `id`. Locate the matching `Student`, free its memory, and shrink the collection accordingly. If the `id` does not exist, print an appropriate message.  \n   - **3. Display a student** \u2013 Prompt for an `id`. Locate the matching `Student` and call a function `displayStudent` (see Constraint) to print its details in the format shown below. If the `id` does not exist, print an appropriate message.  \n   - **4. List all students** \u2013 Print the details of every stored student, one per line, in the order they were added.  \n   - **5. EXIT** \u2013 Terminate the program, freeing any remaining allocated memory.  \n\n3. **Input / Output**  \n   - All interaction is via standard input and output.  \n   - The program should be robust to invalid menu choices (print \u201cInvalid option, try again.\u201d and re\u2011display the menu).  \n\n### Example Interaction  \n\n```\n--- Student Registry ---\n1) Add a student\n2) Remove a student\n3) Display a student\n4) List all students\n5) EXIT\nChoose an option: 1\nEnter ID: 101\nEnter name: Alice\nEnter GPA: 3.8\nStudent added.\n\n--- Student Registry ---\n1) Add a student\n2) Remove a student\n3) Display a student\n4) List all students\n5) EXIT\nChoose an option: 1\nEnter ID: 102\nEnter name: Bob\nEnter GPA: 3.2\nStudent added.\n\n--- Student Registry ---\n1) Add a student\n2) Remove a student\n3) Display a student\n4) List all students\n5) EXIT\nChoose an option: 3\nEnter ID to display: 101\nID: 101, Name: Alice, GPA: 3.80\n\n--- Student Registry ---\n1) Add a student\n2) Remove a student\n3) Display a student\n4) List all students\n5) EXIT\nChoose an option: 4\nID: 101, Name: Alice, GPA: 3.80\nID: 102, Name: Bob, GPA: 3.20\n\n--- Student Registry ---\n1) Add a student\n2) Remove a student\n3) Display a student\n4) List all students\n5) EXIT\nChoose an option: 5\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n- **Struct Requirement** \u2013 The primary data entity must be represented with a `struct Student`.  \n- **Display Function** \u2013 The logic for printing the details of a single student must reside in a function with the exact prototype:  \n\n  ```c\n  void displayStudent(const struct Student *s);\n  ```  \n\n- **Dynamic Allocation Only** \u2013 All `Student` objects must be created with `malloc` (or `calloc`) and released with `free`. No static or global arrays of fixed size may be used to store the students.  \n- **Menu Exit Option** \u2013 The menu must contain an explicit option labeled **5) EXIT** (or the keyword \u201cEXIT\u201d) that ends the program after freeing any remaining allocated memory.  \n\n*Optional:* You may implement the collection as a dynamically resized array (using `realloc`) or as a singly\u2011linked list; either approach satisfies the dynamic\u2011memory requirement.", "model": "openai/gpt-oss-120b", "iteration": 34}, {"text": "# STEP 1: PROBLEM  \n\n## Background  \nThe university library is modernizing its catalogue system. Each book record must be stored in dynamically allocated memory because the number of books is not known at compile\u2011time and can change while the program runs (books may be added or removed). Your task is to write a small console application that lets a librarian add new books, list all books, search for a book by its ISBN, and delete a book. All book information must be kept in a singly\u2011linked list that you build yourself using `malloc` and `free`.\n\n## Requirements  \n\n1. **Data Representation**  \n   *Define a `struct Book` that contains the following fields:*  \n   - `char title[101]` \u2013 title of the book (maximum 100 characters).  \n   - `char author[51]` \u2013 author name (maximum 50 characters).  \n   - `char isbn[14]` \u2013 ISBN\u201113 string (13 characters + terminating null).  \n   - `int copies` \u2013 number of copies available.  \n   - `struct Book *next` \u2013 pointer to the next book in the list.  \n\n2. **Menu\u2011driven Interface** (the program must present a menu repeatedly until the user chooses to exit)  \n   1. **Add a new book** \u2013 Prompt for title, author, ISBN, and number of copies; allocate a new `Book` node with `malloc` and insert it at the end of the list.  \n   2. **List all books** \u2013 Traverse the list and print each book\u2019s details on a separate line.  \n   3. **Search by ISBN** \u2013 Ask for an ISBN, locate the matching node, and display its details using a dedicated function `displayBook`. If the ISBN is not found, print \u201cBook not found.\u201d  \n   4. **Delete a book** \u2013 Ask for an ISBN, locate the node, remove it from the list, free its memory, and confirm deletion. If the ISBN does not exist, print \u201cBook not found.\u201d  \n   5. **Exit** \u2013 Terminate the program, freeing any remaining allocated memory.  \n\n3. **Input Validation**  \n   - The program should not crash on malformed input; if a numeric entry is invalid, re\u2011prompt the user.  \n   - ISBN strings must be exactly 13 characters long (you may assume the user follows this rule).  \n\n4. **Memory Management**  \n   - Every `malloc` must have a corresponding `free`.  \n   - Before exiting, the program must free all nodes that are still allocated.  \n\n## Example Interaction  \n\n```\n=== Library Catalogue ===\n1. Add a new book\n2. List all books\n3. Search by ISBN\n4. Delete a book\n5. Exit\nChoose an option: 1\n\nEnter title: The C Programming Language\nEnter author: Kernighan & Ritchie\nEnter ISBN (13 chars): 9780131103627\nEnter number of copies: 3\nBook added successfully!\n\n=== Library Catalogue ===\n1. Add a new book\n2. List all books\n3. Search by ISBN\n4. Delete a book\n5. Exit\nChoose an option: 2\n\nTitle: The C Programming Language | Author: Kernighan & Ritchie | ISBN: 9780131103627 | Copies: 3\n\n=== Library Catalogue ===\n1. Add a new book\n2. List all books\n3. Search by ISBN\n4. Delete a book\n5. Exit\nChoose an option: 3\n\nEnter ISBN to search: 9780131103627\nTitle: The C Programming Language\nAuthor: Kernighan & Ritchie\nISBN: 9780131103627\nCopies: 3\n\n=== Library Catalogue ===\n1. Add a new book\n2. List all books\n3. Search by ISBN\n4. Delete a book\n5. Exit\nChoose an option: 5\n\nGoodbye!\n```\n\n## ### CONSTRAINTS  \n\n- **Struct Requirement** \u2013 The primary data entity must be represented by a `struct Book` as described above.  \n- **Function Requirement** \u2013 The logic for displaying the details of a single book must be placed in a function with the exact prototype:  \n\n  ```c\n  void displayBook(const struct Book *b);\n  ```  \n\n- **Menu Requirement** \u2013 The menu must include an explicit option to **EXIT** the program (option number 5 in the example). Selecting this option must cause the program to terminate after freeing all allocated memory.  \n\n- **Dynamic Allocation Only** \u2013 No static or global arrays may be used to store the books; all nodes must be obtained with `malloc` and released with `free`.  \n\n- **Single\u2011File Implementation** \u2013 The entire solution must be contained in a single `.c` source file.  \n\n- **Standard Library Only** \u2013 You may only use headers from the C standard library (`<stdio.h>`, `<stdlib.h>`, `<string.h>`, etc.). No third\u2011party libraries are allowed.  ", "model": "openai/gpt-oss-120b", "iteration": 35}]