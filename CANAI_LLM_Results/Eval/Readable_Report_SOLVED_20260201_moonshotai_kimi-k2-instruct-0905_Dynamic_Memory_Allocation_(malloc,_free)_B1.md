# C Education Standardized Research Report: Dynamic Memory Allocation (malloc, free)
**Solver Model:** moonshotai/kimi-k2-instruct-0905 | **Date:** 20260201 | **Batch:** 1

---

## Iteration 1 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The university library is digitizing its card-catalogue.  
Your task is to write a tiny, throw-away program that lets the librarian type in book records one-by-one.  
Each record is kept only while the program is running; when the librarian chooses to exit, every record must be released and the program must terminate cleanly.

## Functional Requirements
1. The program repeatedly shows a menu:
   1) Add a new book  
   2) List all books  
   3) Delete the last added book (LIFO)  
   4) Exit  
2. “Add” prompts for: title (≤80 chars), author (≤50 chars), year (integer).  
3. “List” prints every book currently stored, in the order they were added.  
4. “Delete” removes the most recently added book and frees its memory.  
5. Choosing “Exit” (menu option 4) frees every remaining book and ends the program.

## Example Session
```
1) Add  2) List  3) Delete-last  4) Exit
Choice: 1
Title: The C Programming Language
Author: Kernighan & Ritchie
Year: 1978
Book added.

1) Add  2) List  3) Delete-last  4) Exit
Choice: 2
1. The C Programming Language - Kernighan & Ritchie (1978)

1) Add  2) List  3) Delete-last  4) Exit
Choice: 3
Last book removed.

1) Add  2) List  3) Delete-last  4) Exit
Choice: 4
Good-bye.
```

### CONSTRAINTS
- You must use a single struct to represent a book.  
- All dynamic allocations (malloc) and de-allocations (free) must be explicit—no memory leaks.  
- The only additional function allowed besides main() is displayBook(struct Book *b), which prints a single book in the format shown in the example.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 *  Card-catalogue digitiser – memory-safe, leak-free
 *  Compile:  gcc -std=c11 -Wall -Wextra -pedantic catalog.c -o catalog
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*--------------------------------  Data model  ------------------------------*/
typedef struct Book {
    char  title[81];   /* +1 for NUL terminator */
    char  author[51];
    int   year;
} Book;

/*--------------------------------  Prototype  -------------------------------*/
void displayBook(const Book *b);   /* required by spec */

/*--------------------------------  Helpers  -------------------------------*/
static void clearInputLine(void)
/* discard the rest of the current input line (up to and including '\n') */
{
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF)
        ;
}

/*--------------------------------  main  ------------------------------------*/
int main(void)
{
    Book *library = NULL;   /* dynamic array of Books */
    size_t capacity = 0;    /* allocated slots */
    size_t count    = 0;    /* currently used slots */

    while (1) {
        /*---------------- print menu ----------------*/
        puts("1) Add  2) List  3) Delete-last  4) Exit");

        /*---------------- read choice ---------------*/
        printf("Choice: ");
        int choice;
        if (scanf("%d", &choice) != 1) {      /* non-numeric input */
            clearInputLine();
            puts("Invalid choice.");
            continue;
        }
        clearInputLine();                     /* remove trailing '\n' */

        /*---------------- dispatch ------------------*/
        if (choice == 1) {                    /* ---------- ADD ---------- */
            /* ensure capacity */
            if (count == capacity) {          /* need more space */
                size_t newCap = capacity == 0 ? 4 : capacity * 2;
                Book *tmp = realloc(library, newCap * sizeof *tmp);
                if (!tmp) {                     /* allocation failure */
                    perror("realloc");
                    goto cleanup;
                }
                library  = tmp;
                capacity = newCap;
            }

            Book *b = &library[count];          /* where the new book goes */
            printf("Title: ");
            if (!fgets(b->title, sizeof b->title, stdin)) {
                puts("Input error.");
                continue;
            }
            b->title[strcspn(b->title, "\n")] = '\0'; /* chomp newline */

            printf("Author: ");
            if (!fgets(b->author, sizeof b->author, stdin)) {
                puts("Input error.");
                continue;
            }
            b->author[strcspn(b->author, "\n")] = '\0';

            printf("Year: ");
            if (scanf("%d", &b->year) != 1) {
                clearInputLine();
                puts("Invalid year.");
                continue;
            }
            clearInputLine();

            ++count;
            puts("Book added.");
        }

        else if (choice == 2) {               /* ---------- LIST --------- */
            if (count == 0)
                puts("No books stored.");
            else
                for (size_t i = 0; i < count; ++i) {
                    printf("%zu. ", i + 1);
                    displayBook(&library[i]);
                }
        }

        else if (choice == 3) {               /* -------- DELETE --------- */
            if (count == 0) {
                puts("Nothing to remove.");
            } else {
                --count;                        /* LIFO removal */
                puts("Last book removed.");
            }
        }

        else if (choice == 4) {              /* ---------- EXIT ---------- */
            break;
        }

        else {                                 /* unknown option */
            puts("Invalid choice.");
        }
    }

cleanup:                                       /* release everything */
    free(library);
    puts("Good-bye.");
    return 0;
}

/*------------------------------  displayBook  ------------------------------*/
void displayBook(const Book *b)
{
    printf("%s - %s (%d)\n", b->title, b->author, b->year);
}
```

Key points addressed:
- Single `struct Book` holds the three fields with fixed-width buffers (no dynamic strings).  
- All heap allocations occur through `realloc`; failure is handled gracefully.  
- Memory is freed exactly once, either at normal exit or after a catastrophic allocation failure.  
- The only extra function besides `main()` is the mandated `displayBook`.

### STEP_3
# STEP 3: EXPLANATION

## 1. Why dynamic memory?
The problem forbids hard-coding “at most N books”, so the program must grow the catalogue on demand.  
The natural tool is a resizable array implemented with `malloc`/`realloc` and cleaned up with `free`.

## 2. The three bookkeeping variables
```
Book *library   → start of the array (NULL at first)
size_t capacity → how many Book slots are currently allocated
size_t count    → how many slots are in use (logical length)
```
These three variables live on the stack of `main` but **point to** and **describe** the heap block that really stores the data.

## 3. Growing the array (choice 1)
When `count == capacity` the array is full, so before inserting we:

a) Compute a new capacity – here we double (`capacity*2`). Doubling is a textbook trade-off:  
· amortised O(1) time per insertion  
· keeps the array reasonably tight (no huge over-allocation)  

b) Ask the runtime for a bigger block, re-using the old content:
```c
Book *tmp = realloc(library, newCap * sizeof *tmp);
```
- `realloc` either:
  – enlarges the current block in place, or  
  – allocates a new bigger block, copies the old bytes, and frees the old block.  
Either way, the call returns the base address of the block that now holds the data.

**Always assign the result to a temporary pointer.**  
If allocation fails `realloc` returns `NULL` and the original block is untouched; assigning directly to `library` would lose the only reference to the still-valid memory — a leak.

c) If the request succeeded, update `library` and `capacity`; if not we bail out with `perror` and jump to the `cleanup:` label.

## 4. Adding a book
After we have room we simply fill the next unused slot (`&library[count]`).  
`fgets` protects us from overrunning the fixed character buffers; `strcspn` strips the trailing new-line.  
Increment `count`; the book is logically “owned” by the array.

## 5. Deleting the last book (LIFO, choice 3)
With an array, “remove last” is just `count--`; we do **not** call `free` on the book itself because the storage is part of the same block that holds the whole array.  
The slot is now available for the next insertion (it will be overwritten, never freed individually).

## 6. Listing (choice 2)
We walk from `0 … count-1` and call `displayBook` for every element. The function receives a **const pointer** to a Book and simply prints; no memory management here.

## 7. Exiting cleanly (choice 4 and error path)
Because we never allocated the individual Book structs separately, we have exactly **one** heap block to release – the one pointed to by `library`.  
`free(library)` returns the whole array to the runtime.  
After `free` we set no pointer to the released memory; luckily the program ends immediately, so no dangling references survive.

## 8. What about memory leaks?
A leak happens if you:
- lose the last pointer to an allocated block (`realloc` failure case handled).  
- forget to `free` reachable blocks (our only block is freed on every exit path via `cleanup:`).

Because we never allocate more than one contiguous object, the bookkeeping is trivial and the code is leak-free by construction.

## 9. Relation to malloc/free basics
`malloc` gives you raw bytes – you must remember both “where” and “how many” yourself.  
`realloc` is `malloc` + copy + free rolled into one, but failure rules are the same.  
With an array pattern the “how many” is `capacity * sizeof(ElementType)`, and the “where” is your base pointer (`library`).

## 10. Take-away pattern
Whenever you need a growable sequence:
1. Keep three stack variables: pointer, capacity, count.  
2. Before inserting, check fullness → grow with `realloc`.  
3. Keep the actual elements inside the big block (value semantics) unless you have a reason to point to them separately.  
4. On shutdown, `free` the single block; the runtime recycles every element inside it.

This is exactly what the C++ vector or Java ArrayList do under the hood—only here we do it manually.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge)**  
Think of the catalogue as a pile of index cards that can grow taller whenever the librarian adds another book.  
What simple, real-world container always lets you add to the top and remove from the top without fuss?

**Hint 2 (key feature spotlight)**  
Remember that the program has to keep the list while it is running but throw everything away when it ends.  
C lets you ask the computer for extra space at any moment, and to give it back when you are done—look for the trio of tools whose names start with “alloc” and end with “free”.

**Hint 3 (structure starter)**  
Sketch a loop that:  
1. prints four menu choices,  
2. reads the librarian’s pick,  
3. uses a three-way branch (one branch for each non-exit choice).  
For the “add” branch, begin by making sure your current array has room; if it doesn’t, ask for a bigger block before you store the new book.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: allocating, growing with `realloc`, and freeing a single contiguous block
- Safe handling of allocation failure to prevent memory leaks and crashes
- Value semantics inside a dynamically resized array
- Maintaining logical length vs. allocated capacity, the classic “vector” pattern
- Fixed-size character buffers and using `fgets`/`strcspn` to avoid buffer overruns
- LIFO deletion logic without per-element allocation
- Clean program shutdown: one `free` call releases an entire data set
- Consolidated design: only one user-defined function besides `main`, yet fully functional

### STEP_6
# STEP 6: TEST CASES

TC-1 “Happy path” – add two books, list them, delete-last, list again, exit.  
TC-2 “Empty list” – choose List on an empty catalogue, then Exit.  
TC-3 “Invalid menu choice” – type 9, then 0, then the correct Add, then Exit.  
TC-4 “Delete on empty” – choose Delete-last when nothing exists, then Exit.  
TC-5 “Garbage year” – Add a book, type “nineteen” for year, retry with 1950, list, exit.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\nThe Pragmatic Programmer\nHunt & Thomas\n1999\n1\nClean Code\nRobert C. Martin\n2008\n2\n3\n2\n4",
      "expected_keyword": "Hunt & Thomas"
    },
    {
      "input": "2\n4",
      "expected_keyword": "No books stored"
    },
    {
      "input": "9\n0\n1\nC Programming Language\nKernighan & Ritchie\n1978\n4",
      "expected_keyword": "Invalid choice"
    },
    {
      "input": "3\n4",
      "expected_keyword": "Nothing to remove"
    },
    {
      "input": "1\nIntroduction to Algorithms\nCormen\nnineteen\n1950\n2\n4",
      "expected_keyword": "Invalid year"
    }
  ]
}
```

---

## Iteration 2 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  
**Topic:** Dynamic Memory Allocation (malloc, free)  

## Background  
The university library has bought a huge box of index cards for a “mini‐catalogue.”  
Instead of throwing the cards away, the librarian wants you to digitize them.  
Each card contains exactly three strings: title, author, and ISBN.  
Because the librarian does not know how many cards will be in the box, your program must allocate exactly the amount of memory needed, no more, no less.

## Functional Requirements  
1. The program starts by asking for the number of cards (n).  
2. Allocate a contiguous block of memory for n cards.  
3. For each card, read the title, author, and ISBN (all single‐line strings, max 100 chars each).  
4. Implement a menu loop with the following options:  
   1) Display all cards  
   2) Search for a card by ISBN  
   3) Exit  
5. Option 1 prints every card, one per line, in the order stored.  
6. Option 2 reads an ISBN. If a card with that ISBN exists, print its details; otherwise print “ISBN not found.”  
7. Option 3 frees all memory and terminates the program with “Good‐bye!”  
8. If the user enters an invalid menu choice, print “Invalid choice.” and re‐show the menu.

## Example Session (user input in bold)  
```
How many cards? 2
Card 1
  Title: Clean Code
  Author: Robert C. Martin
  ISBN: 9780132350884
Card 2
  Title: The C Programming Language
  Author: Kernighan & Ritchie
  ISBN: 9780131103627

Menu:
1) Display all
2) Search by ISBN
3) Exit
Choice: 2
Enter ISBN: 9780132350884
Title: Clean Code, Author: Robert C. Martin, ISBN: 9780132350884

Menu:
1) Display all
2) Search by ISBN
3) Exit
Choice: 1
1. Clean Code | Robert C. Martin | 9780132350884
2. The C Programming Language | Kernighan & Ritchie | 9780131103627

Menu:
1) Display all
2) Search by ISBN
3) Exit
Choice: 3
Good-bye!
```

### CONSTRAINTS  
- Must use a single `struct` to represent a single card.  
- Must allocate the array of cards with one call to `malloc` and free it with one call to `free`.  
- The logic for displaying the details of ONE specific card must be in a function called `displayCard`.  
- The only functions allowed besides `main` are `displayCard` and any helper functions strictly necessary for the menu loop.  
- Menu option **3** is the only way to exit the program; typing **3** must free memory and terminate.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * digitize_cards.c
 *
 * Digitizes the library’s index-card catalogue.
 * Each card = title, author, ISBN (all strings ≤ 100 characters).
 * Memory is allocated *once* for the requested number of cards.
 *
 * Compile: gcc -std=c11 -Wall -Wextra -pedantic digitize_cards.c -o digitize_cards
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LEN 100           /* max characters per string field */

/* ---------- DATA STRUCTURE ---------- */
typedef struct {
    char title[MAX_LEN + 1];
    char author[MAX_LEN + 1];
    char isbn[MAX_LEN + 1];
} Card;

/* ---------- FUNCTION PROTOTYPES ---------- */
void displayCard(const Card *c, size_t idx);   /* print one card */
void freeResources(Card *arr);                 /* simple wrapper to free */

/* ---------- MAIN ---------- */
int main(void)
{
    size_t nCards;
    printf("How many cards? ");
    if (scanf("%zu%*c", &nCards) != 1) {       /* %*c consumes trailing newline */
        fprintf(stderr, "Input error.\n");
        return 1;
    }

    /* Allocate *one* contiguous block for nCards structs */
    Card *catalogue = malloc(nCards * sizeof *catalogue);
    if (!catalogue) {
        perror("malloc");
        return 1;
    }

    /* Read each card */
    for (size_t i = 0; i < nCards; ++i) {
        printf("Card %zu\n", i + 1);

        printf("  Title: ");
        if (!fgets(catalogue[i].title, sizeof catalogue[i].title, stdin)) {
            fprintf(stderr, "Input error.\n");
            freeResources(catalogue);
            return 1;
        }
        catalogue[i].title[strcspn(catalogue[i].title, "\n")] = '\0';

        printf("  Author: ");
        if (!fgets(catalogue[i].author, sizeof catalogue[i].author, stdin)) {
            fprintf(stderr, "Input error.\n");
            freeResources(catalogue);
            return 1;
        }
        catalogue[i].author[strcspn(catalogue[i].author, "\n")] = '\0';

        printf("  ISBN: ");
        if (!fgets(catalogue[i].isbn, sizeof catalogue[i].isbn, stdin)) {
            fprintf(stderr, "Input error.\n");
            freeResources(catalogue);
            return 1;
        }
        catalogue[i].isbn[strcspn(catalogue[i].isbn, "\n")] = '\0';
    }

    /* ---------- MENU LOOP ---------- */
    for (;;) {
        puts("\nMenu:");
        puts("1) Display all");
        puts("2) Search by ISBN");
        puts("3) Exit");

        printf("Choice: ");
        int choice;
        if (scanf("%d%*c", &choice) != 1) {
            fprintf(stderr, "Input error.\n");
            continue;
        }

        if (choice == 3) {
            freeResources(catalogue);
            puts("Good-bye!");
            return 0;
        }

        if (choice == 1) {
            for (size_t i = 0; i < nCards; ++i)
                displayCard(&catalogue[i], i + 1);
        }
        else if (choice == 2) {
            char query[MAX_LEN + 1];
            printf("Enter ISBN: ");
            if (!fgets(query, sizeof query, stdin)) {
                fprintf(stderr, "Input error.\n");
                continue;
            }
            query[strcspn(query, "\n")] = '\0';

            int found = 0;
            for (size_t i = 0; i < nCards; ++i) {
                if (strcmp(catalogue[i].isbn, query) == 0) {
                    displayCard(&catalogue[i], 0); /* idx 0 → no prefix number printed */
                    found = 1;
                    break;
                }
            }
            if (!found) puts("ISBN not found.");
        }
        else {
            puts("Invalid choice.");
        }
    }
}

/* ---------- FUNCTION DEFINITIONS ---------- */

/* Display a single card.
 * If idx > 0, prefix the output with “idx. ”; otherwise print without prefix.
 */
void displayCard(const Card *c, size_t idx)
{
    if (idx)
        printf("%zu. ", idx);
    printf("%s | %s | %s\n", c->title, c->author, c->isbn);
}

/* Free the catalogue array; for symmetry and future expansion. */
void freeResources(Card *arr)
{
    free(arr);
}
```

### STEP_3
# STEP 3: EXPLANATION

0.  Why dynamic memory at all?
    The librarian does **not** know in advance how many index cards will be in the box.  
    If we declare a fixed-size array such as  
        Card catalogue[1000];  
    we either waste memory (most slots empty) or run out of space (more than 1000 cards).  
    Dynamic memory lets us wait until run-time, ask the user for *n*, then obtain **exactly** *n* slots—no more, no less.

1.  What does malloc really give us?
    malloc() returns the **address** of a *contiguous* chunk of raw bytes large enough to hold the requested objects.  
    In our code:

        Card *catalogue = malloc(nCards * sizeof *catalogue);

    — sizeof *catalogue is the size of **one** Card structure.  
    — The product is the total number of bytes needed for *nCards* structures.  
    — The result is a pointer to the **first** Card; the rest live in memory right behind it, so we can use normal array indexing:

        catalogue[i]               // the i-th structure

    **Key safety rule**: malloc can fail (returns NULL). We always check this and immediately free any previously allocated resources before aborting.

2.  Why only one malloc / one free?
    The specification insists on a *single* allocation and a *single* de-allocation.  
    This keeps the program simple and guarantees that all Cards sit next to each other in memory, improving cache locality and avoiding fragmentation.  
    When the user finally chooses menu item 3 we execute:

        free(catalogue);

    and the entire block goes back to the heap.

3.  Strings inside the struct—where do they live?
    Notice the struct definition:

        typedef struct {
            char title  [101];
            char author [101];
            char isbn   [101];
        } Card;

    The character arrays are **inside** the structure; they are *not* pointers.  
    Therefore every Card carries its own 101-byte buffers. No secondary malloc() is necessary, and no secondary free() is necessary. One struct = one self-contained unit.

4.  Reading strings safely
    We never use scanf("%s") for strings because it stops at the first blank space and can overflow the buffer.  
    Instead we use fgets(), which:

    - reads **up to** N-1 characters including spaces,  
    - stops at the first newline,  
    - always NUL-terminates the buffer.

    After fgets() we shave off the trailing newline with:

        buffer[strcspn(buffer, "\n")] = '\0';

    so later strcmp() works correctly.

5.  The menu loop and separation of concerns
    The specification forces us to keep a single helper function: displayCard().  
    By isolating the “pretty printing” in one place we achieve:

    — re-use (used both for “display all” and for the search hit),  
    — consistency (same formatting everywhere),  
    — future-proofing (one change fixes all output).

    All other logic (input, search, decision making) remains in main(); this respects the “only two extra functions” rule while still being readable.

6.  Searching by ISBN
    We perform a **linear scan** over the catalogue array.  
    For each Card we compare the user-supplied ISBN string with the stored one using strcmp().  
    As soon as we find a match we print that Card and break.  
    If the loop finishes without finding anything we print “ISBN not found.”  
    For the tiny data sizes implied by a box of index cards, O(n) search is perfectly adequate and avoids the complexity of hashing or sorting.

7.  Clean termination
    The program is *only* allowed to exit through menu option 3.  
    When the user selects it we:

    — call free() to release the heap block,  
    — print “Good-bye!”,  
    — return 0 to the operating system.

    This guarantees **zero** memory leaks (valgrind will report “no leaks are possible”).  
    Any earlier error path (malloc failure, input failure) also calls freeResources() before exiting.

8.  Putting it together
    Follow this mental checklist whenever you use dynamic memory:

    1. Compute how many bytes you need.  
    2. malloc(); test result == NULL.  
    3. Use the memory (array or pointer arithmetic).  
    4. Make **sure** every exit path eventually free()s the block.  
    5. Do not reference the memory after free() (dangling pointer).

    Keep these habits and you will avoid leaks, crashes, and valgrind headaches.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge):**  
Think of the box of cards as a collection whose size you only learn at runtime.  
Ask yourself: “What kind of memory can grow or shrink to match an exact user-supplied count, unlike a fixed array declared in the source file?”

**Hint 2 (focus on a key C feature):**  
Look for the standard-library facility that lets you reserve a contiguous chunk of bytes whose address you receive in a pointer.  
Remember that once you have that pointer, you can treat it exactly like an array whose length is the number of cards the user typed.

**Hint 3 (logic structure):**  
Start by reading the integer *n*, then allocate space for *n* structures that each contain three fixed-size character buffers.  
After you verify the allocation succeeded, you can safely loop *n* times to fill those structures with title, author, and ISBN strings—no secondary allocation needed.

### STEP_5
# STEP 5: SUMMARY

- Dynamic allocation with malloc/free: requesting exactly the needed bytes at run-time and releasing them once.  
- Struct layout for grouped data: embedding fixed-size char buffers inside a struct to avoid secondary allocations.  
- Safe string input: using fgets and removing the trailing newline to prevent buffer overflow.  
- Array-style access through a pointer: treating a malloc’d block as a contiguous array.  
- Single-allocation/single-free discipline: satisfying the requirement of one malloc paired with one free.  
- Menu-driven control flow: looping until the user explicitly chooses exit, with input validation.  
- Linear search over an array of structures: comparing strings with strcmp to locate a matching ISBN.  
- Separation of concerns: isolating print logic in a helper function while keeping main responsible for overall control.

### STEP_6
# STEP 6: TEST CASES

1.  **Normal happy-path**  
    Two valid cards are entered, the user displays all, searches for the first ISBN, then exits.  
    Expected: both cards listed in order; search finds the correct card; clean exit.

2.  **Single-card boundary**  
    Only one card is entered and then displayed.  
    Expected: output lists exactly one card; no crashes; memory freed on exit.

3.  **Zero cards (edge)**  
    User enters 0 cards.  
    Expected: program immediately drops to menu; display-all prints nothing; searching prints “ISBN not found”; exit still frees the (zero-byte) allocation.

4.  **Invalid menu choice (error handling)**  
    After entering two cards the user types menu choices 7, −1, 2, then 3.  
    Expected: first two choices print “Invalid choice.”; third choice performs search; final choice exits cleanly.

5.  **Search miss (error handling)**  
    Two cards stored. User searches for an ISBN that does not exist, then exits.  
    Expected: “ISBN not found.” displayed; no memory leak on exit.

```json
{
  "exit_command": "3",
  "test_suite": [
    {
      "input": "2\nClean Code\nRobert C. Martin\n9780132350884\nThe C Programming Language\nKernighan & Ritchie\n9780131103627\n1\n2\n9780132350884\n3",
      "expected_keyword": "Clean Code"
    },
    {
      "input": "1\nTest Title\nTest Author\n1234567890123\n1\n3",
      "expected_keyword": "Test Title"
    },
    {
      "input": "0\n1\n2\n123\n3",
      "expected_keyword": "ISBN not found"
    },
    {
      "input": "2\nA\nB\n1\nC\nD\n2\n7\n-1\n2\n1\n3",
      "expected_keyword": "Invalid choice"
    },
    {
      "input": "2\nTitle1\nAuthor1\n111\nTitle2\nAuthor2\n222\n2\n999\n3",
      "expected_keyword": "ISBN not found"
    }
  ]
}
```

---

## Iteration 3 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story  
The campus library has just gone “fine-free,” but they still need a way to keep track of who has which book.  
You volunteer to write a tiny, memory-only checkout system that starts empty, grows as books are checked out, and shrinks as they are returned.  
All data must live on the heap so the program can run for the entire semester without ever knowing in advance how many books will pass through.

## Functional Requirements  
1. Represent a book with:  
   - 13-digit ISBN (string, exactly 13 chars + null terminator)  
   - Title (dynamically allocated string of any length)  
   - Borrower’s student ID (unsigned int)  
2. Store every *currently* checked-out book in a single, contiguous, dynamically allocated array.  
3. Provide a menu-driven interface:  
   1. Check-out (add) a book  
   2. Return (remove) a book by ISBN  
   3. List all checked-out books  
   4. Exit  
4. After every add or remove operation, the array must be resized *exactly* to the current number of books (no slack, no fragmentation).  
5. If the user tries to remove a non-existent ISBN, print `Not found.` and leave the array unchanged.  
6. On exit, free every byte of heap memory (array and every title string).

## Simple Example Session  
(user input shown after `>`)

```
1
>9781234567890
>The C Programming Language
>12345
2
>9781234567890
1
>9781111111111
>Python Crash Course
>12345
3
4
```

Expected Output

```
1
Title: The C Programming Language, ISBN: 9781234567890, Student: 12345
Title: Python Crash Course, ISBN: 9781111111111, Student: 12345
Good-bye!
```

### CONSTRAINTS  
- Must use a `struct` to represent the primary data entity (a Book).  
- Logic for displaying the details of ONE specific Book must be in a function called `displayBook`.  
- The solution must be implemented with a single function besides `main()` (you may add `displayBook`; everything else lives in that one helper).  
- Menu option 4 is the EXIT keyword.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Checkout System – "fine-free" edition
 *
 * This program keeps an in-memory list of every book that is currently
 * checked out of the campus library.  All data live on the heap and are
 * resized *exactly* to the current number of books after every
 * add/remove operation.  The code is written in ISO C11.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ISBN_LEN 14 /* 13 digits + '\0' */

/* ---------- DATA STRUCTURE ---------- */
typedef struct {
    char  isbn[ISBN_LEN]; /* fixed-length field */
    char *title;          /* variable-length title on the heap */
    unsigned int studentID;
} Book;

/* ---------- PROTOTYPES ---------- */
/* Display one Book (required by the spec) */
static void displayBook(const Book *b);

/*
 * The single helper demanded by the spec.
 * It does everything except displaying a Book and main-menu I/O.
 *   op     – 1 for add, 2 for remove
 *   shelf  – pointer to the dynamic array
 *   count  – pointer to the number of books in that array
 * Returns the new array pointer (may change after realloc)
 */
static Book *manageShelf(Book *shelf, unsigned int *count, int op);

/* ---------- MAIN ---------- */
int main(void)
{
    Book *shelf = NULL;       /* dynamic, contiguous array */
    unsigned int count = 0;   /* how many books are checked out */

    for (;;) {
        int choice;
        /* menu prompt */
        if (scanf("%d", &choice) != 1) break; /* EOF or bad input  */

        switch (choice) {
        case 1: /* check-out (add) */
            shelf = manageShelf(shelf, &count, 1);
            break;
        case 2: /* return (remove) */
            shelf = manageShelf(shelf, &count, 2);
            break;
        case 3: /* list */
            for (unsigned int i = 0; i < count; ++i) {
                displayBook(&shelf[i]);
            }
            break;
        case 4: /* exit */
            goto cleanup;
        }
    }

cleanup:
    /* release every byte on the heap before leaving */
    for (unsigned int i = 0; i < count; ++i) {
        free(shelf[i].title);
    }
    free(shelf);
    puts("Good-bye!");
    return 0;
}

/* ---------- FUNCTION DEFINITIONS ---------- */

static void displayBook(const Book *b)
{
    printf("Title: %s, ISBN: %s, Student: %u\n",
           b->title, b->isbn, b->studentID);
}

static Book *manageShelf(Book *shelf, unsigned int *count, int op)
{
    if (op == 1) { /* ------- ADD ------- */
        char isbn[ISBN_LEN];
        char titleBuf[256]; /* temporary buffer large enough */
        unsigned int id;

        /* read the three fields */
        scanf(" %13s", isbn);  /* 13-digit ISBN, skip leading whites */
        getchar();             /* consume the newline left by scanf */
        if (!fgets(titleBuf, sizeof titleBuf, stdin)) {
            fprintf(stderr, "Input error\n");
            return shelf;
        }
        titleBuf[strcspn(titleBuf, "\n")] = '\0'; /* strip newline */
        scanf("%u", &id);

        /* duplicate the title onto the heap (malloc check inside) */
        char *titleCopy = malloc(strlen(titleBuf) + 1);
        if (!titleCopy) {
            perror("malloc title");
            exit(EXIT_FAILURE);
        }

        strcpy(titleCopy, titleBuf);

        /* expand the array exactly to count+1 */
        Book *tmp = realloc(shelf, (*count + 1) * sizeof *tmp);
        if (!tmp) {
            perror("realloc add");
            free(titleCopy);   /* partial clean-up */
            exit(EXIT_FAILURE);
        }
        shelf = tmp;

        /* fill the new slot */
        Book *slot = &shelf[*count];
        strcpy(slot->isbn, isbn);
        slot->title    = titleCopy;
        slot->studentID = id;

        ++(*count);
    }
    else if (op == 2) { /* ------- REMOVE ------- */
        char target[ISBN_LEN];
        scanf(" %13s", target);

        /* locate the book */
        unsigned int idx = 0;
        while (idx < *count && strcmp(shelf[idx].isbn, target) != 0)
            ++idx;

        if (idx == *count) {   /* not found case */
            puts("Not found.");
            return shelf;
        }

        /* free the title that lives on the heap */
        free(shelf[idx].title);

        /* compact the array (order not required) */
        shelf[idx] = shelf[*count - 1];

        --(*count);

        /* shrink the allocation *exactly* to the new number of books */
        Book *tmp = realloc(shelf, (*count) * sizeof *tmp);
        /* realloc shrinking is guaranteed not to fail; but we check anyway */
        if (*count && !tmp) {
            perror("realloc shrink");
            exit(EXIT_FAILURE);
        }
        shelf = tmp; /* may be NULL if count became 0 */
    }
    return shelf;
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic-memory problems often feel scary because nothing "automatically" cleans-up after you once the program leaves a block.  
This walk-through focuses on **why** we allocate, resize, and free exactly when we do.

---

### 1. The Big Picture
Think of the library shelf as a **vector** (array) that can grow or shrink every time a patron checks-out or returns a book.  
- The shelf starts empty (`count == 0` and `shelf == NULL`).  
- When the first book arrives we allocate space for 1 Book.  
- After each add or remove we resize so that the allocated bytes on the heap are exactly `count × sizeof(Book)`.  
  – "No slack" is the specification's way of saying "don't waste memory; realloc to exact size".

---

### 2. Struct Book
```c
typedef struct {
    char  isbn[14];       /* fixed 13-digit field */
    char *title;          /* pointer to string on heap */
    unsigned int studentID;
} Book;
```
The string title has **unbounded length**, so we ask the OS for new bytes on demand and keep only a pointer inside Book.  
All other fields are small enough to live directly in the struct (called "store by value").

---

### 3. Reading Input Safely
- ISBN is fixed width; we read 13 chars and a '\0'.  
- Title may contain spaces; therefore we read an entire LINE with fgets (NOT scanf("%s")).  
After that newline lives in the buffer. We trim it with  
  `titleBuf[strcspn(titleBuf, "\n")] = '\0'`  
strcspn is safer than strcat/strcpy+strlen games; it scans once and gives the length until newline.

Once we have the user title we malloc/strdup.  
We cannot assign titleBuf directly; that array's lifetime ends when manageShelf returns. We need fresh memory that survives the call:

```c
char *titleCopy = malloc(strlen(titleBuf)+1);
```
We always check malloc.

---

### 4. Realloc: The Heart of "Dynamic Contiguous Array"
When we realloc, three things may happen internally:
- The block might stay where it is and just get bigger (cheap).  
- The OS may copy everything to a new, larger address (we get a fresh pointer; old pointer becomes invalid after that single assignment `shelf = tmp`).  
- If realloc fails we get NULL; the original block is still valid. That is why we use a temporary variable (tmp) and only overwrite `shelf` after success.

A common rookie error is writing:
```
shelf = realloc(shelf, newBytes);      // BAD if realloc fails
```
If realloc returns NULL you have just overwritten the ONLY pointer to the original memory, leaking the old block.  
So the pattern is:
```c
tmp = realloc(old, newBytes);
if(!tmp) { perror("..."); exit(EXIT_FAILURE); }
old = tmp;
```

Shrinking works the same, except the OS is allowed to do nothing or to move the block to a smaller chunk. Because the spec demands "exactly as many bytes as currently used books" we shrink even when removing one book.

---

### 5. Removing a Book
Arrays do not allow holes. Two common choices:
a) shift everything left after the deleted index, or  
b) overwrite slot-to-delete with the **last** element, then shorten.

We chose (b) because it is O(1) and no order is required. After that compaction we realloc again: this time to `(*)count × sizeof(Book)`. `count` is now smaller so bytes are freed back to the OS.

Edge case: if the searched-for ISBN is absent we print `Not found.` and do not touch either the counter or the allocation; therefore the user can retry without corrupting state.

---

### 6. Free'ing (Releasing) Memory
The compiler does not know that `char *title` inside each Book points to heap memory; only **your code** can return those titles to the OS.  
At program exit we loop over every occupied slot of the array and:

```c
free(shelf[i].title);     // free each individual string
```

After that we free the array itself:

```c
free(shelf);
```

If you skip these two steps you have two kinds of leaks:
- "still reachable" leak: the array is reachable from a global/static pointer (here: `shelf`), so Valgrind may call it "still reachable".  
- "definitely lost" leak: the numerous title strings are not reachable anymore, wasting bytes inside the running process and making Valgrind complain.

---

### 7. Why Only One Helper Function?
The spec explicitly says:  
"everything else lives in that one helper".  
manageShelf therefore doubles as a tiny service layer:  
- it accepts the shelf, the count pointer, and the operation code,  
- returns the (possibly new) shelf pointer,  
- keeps the main loop oblivious to reallocation details.

Separation of concerns:
- UI lives in main (menu, `scanf`).  
- Data-manipulation lives in one well-tested function.  
- Display details live in a dedicated `displayBook`.

---

### 8. Takeaway Ideas
1. Dynamic memory lets you fit data whose size is known only at run-time.  
2. Always pair malloc/calloc/realloc with free.  
3. When the only pointer you own might be invalidated, stash new pointer in a temporary; verify success; only then overwrite the main pointer.  
4. realloc can both grow and shrink; use it to keep an array's footprint exactly as large as needed.  
5. Structs that embed pointers create a "two-level" ownership graph; you must free the secondary level (titles) before freeing the top level (shelf array).

Master these habits once, and you will find later C++ std::vector, Rust Vec, or Python list resize operations suddenly feel trivial—because you already understand what those libraries quietly do for you under the hood.

### STEP_4
# STEP 4: HINTS

**Hint 1 (Conceptual)**  
Think of the library shelf as a line of chairs that can appear or disappear whenever a book is checked out or returned.  You don’t reserve a huge room up front—just add or remove one chair at a time, keeping the row **exactly** as long as the number of people (books) currently sitting.

**Hint 2 (Focus)**  
Every time that row of chairs needs to get bigger or smaller, you’ll need the memory manager to change the size of the single block you’re using for the row.  Which standard C library routine lets you resize an already-allocated block, copying the old contents for you when necessary?

**Hint 3 (First Steps)**  
Start by declaring a struct to hold one book’s fixed-length ID and a pointer for its variable-length title.  Then, inside your main loop, for option 1 (add) begin with these steps:  
1. Read the three pieces of data the user types.  
2. Allocate brand-new space for the title string only, and copy the text there.  
3. Enlarge the sole array of structs by exactly one element before writing the new book into the freshly extended slot.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management with malloc, realloc, and free  
- Resizing a single contiguous array to an exact size (no slack)  
- Managing memory containing both fixed-size fields and variable-length strings  
- Correctly checking allocation failures to prevent leaks and crashes  
- Structuring a program with pointer ownership and proper cleanup paths  
- Separating data-modification logic from user-interface code within the given function limit

### STEP_6
# STEP 6: TEST CASES
1. Common add-then-remove  
   - Add a single book, list it, remove it, list again.  
   - Expected: listing after removal shows nothing, no leaks.

2. Edge case – empty shelf  
   - Immediately list all books and attempt to remove a non-existent ISBN.  
   - Expected: list produces no lines, removal prints “Not found.”

3. Sequence stressing exact sizing  
   - Add three books, remove the middle one, add a fourth, remove two more.  
   - Expected: after every operation the heap footprint matches the current count (checked externally with Valgrind or similar).

4. Invalid removal (ISBN never issued)  
   - Add two books; try to remove an ISBN that was never entered.  
   - Expected: “Not found.”, array unchanged, both books remain.

5. Zero-strings handling (blank title)  
   - Add a book whose title is only a newline (empty after trimming).  
   - Expected: program stores a non-NULL zero-length string and continues normally.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\n9780000000001\nClean Code\n98765\n3\n2\n9780000000001\n3\n4",
      "expected_keyword": "Clean Code"
    },
    {
      "input": "3\n2\n1234567890123\n4",
      "expected_keyword": "Not found"
    },
    {
      "input": "1\n9781111111111\nBook A\n10001\n1\n9782222222222\nBook B\n10002\n1\n9783333333333\nBook C\n10003\n2\n9782222222222\n1\n9784444444444\nBook D\n11111\n2\n9781111111111\n2\n9783333333333\n3\n4",
      "expected_keyword": "Book D"
    },
    {
      "input": "1\n9791234567890\nNonexistent Test\n20000\n1\n9790000000000\nSecond Real\n20000\n2\n9799999999999\n3\n4",
      "expected_keyword": "Not found"
    },
    {
      "input": "1\n9780000000000\n\n20000\n3\n4",
      "expected_keyword": "9780000000000"
    }
  ]
}
```

---

## Iteration 4 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The campus library has just gone “digital-only” for its CD collection.  
Staff members are typing the titles into a simple terminal program, but they have no idea how many discs will arrive.  
Your job is to write a tiny inventory tool that grows the list as each CD is scanned and shrinks it when a CD is withdrawn.

## Requirements
1. The program starts with an empty list of CDs.
2. The user repeatedly chooses one of three actions:
   - `1` – Add a new CD  
     *Prompt for:* title (≤30 characters), artist (≤30 characters), and an integer year.  
     *Store the data in dynamically allocated memory* and append it to the list.
   - `2` – Remove a CD by its exact title (case-sensitive).  
     If the title is found, free its memory and compact the list; otherwise print `CD not found.`
   - `3` – List all CDs in the order they were added.  
     Format: `Title — Artist (year)`
   - `0` – Exit the program (free all remaining memory before terminating).
3. Handle an arbitrary number of CDs; do not declare a fixed-size array.
4. After every command, re-display the menu unless the user chose `0`.

## Simple Example Run
```
1
Title: Nevermind
Artist: Nirvana
Year: 1991
1
Title: Back in Black
Artist: AC/DC
Year: 1980
3
Nevermind — Nirvana (1991)
Back in Black — AC/DC (1980)
2
Title to remove: Nevermind
3
Back in Black — AC/DC (1980)
0
```
(Program ends; all memory freed.)

### CONSTRAINTS
- Must use a `struct` to represent one CD.
- All dynamic allocation must be done with `malloc`; every successful `malloc` must eventually be matched by `free`.
- Logic for displaying the details of ONE specific CD must be in a function called `displayCD`.
- The entire solution must be implemented with **only one** additional function besides `main()` (you may choose any name for that function).
- Menu option `0` must be the EXIT option.

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * CD inventory tool for the campus library.
 * Implements a grow/shrink list with dynamic memory only.
 * Only two functions are defined: main() and displayCD().
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STR 31          /* 30 chars + '\0' */

/* ---------- Data structure ---------- */
typedef struct {
    char  title[MAX_STR];
    char  artist[MAX_STR];
    int   year;
} CD;

/* ---------- Single additional function ---------- */
static void displayCD(const CD *cd)
{
    /* Display one CD in the required format */
    printf("%s — %s (%d)\n", cd->title, cd->artist, cd->year);
}

/* ---------- Entry point ---------- */
int main(void)
{
    CD  *collection = NULL; /* dynamic array of CDs               */
    size_t count   = 0;   /* how many CDs are currently stored  */
    size_t capacity = 0;  /* how many the array can hold        */
    int choice;

    for (;;) {
        /* ---- menu ---- */
        printf("1. Add CD\n2. Remove CD\n3. List CDs\n0. Exit\n");

        if (scanf("%d", &choice) != 1) {          /* malformed input  */
            fprintf(stderr, "Invalid input.\n");
            return 1;
        }
        int c;
        while ((c = getchar()) != '\n' && c != EOF) /* flush rest of line */
            ;

        if (choice == 0) {                        /* EXIT requested */
            break;
        }
        else if (choice == 1) {                    /* ADD */
            /* Ensure we have room */
            if (count == capacity) {
                size_t newCap = capacity ? capacity * 2 : 4;
                CD *tmp = realloc(collection, newCap * sizeof *tmp);
                if (!tmp) {
                    perror("realloc");
                    goto cleanup;
                }
                collection = tmp;
                capacity   = newCap;
            }

            /* Read the data */
            CD newCD;
            printf("Title: ");
            if (!fgets(newCD.title, MAX_STR, stdin)) goto cleanup;
            newCD.title[strcspn(newCD.title, "\n")] = '\0';

            printf("Artist: ");
            if (!fgets(newCD.artist, MAX_STR, stdin)) goto cleanup;
            newCD.artist[strcspn(newCD.artist, "\n")] = '\0';

            printf("Year: ");
            if (scanf("%d", &newCD.year) != 1) {
                fprintf(stderr, "Invalid year.\n");
                goto cleanup;
            }
            while ((c = getchar()) != '\n' && c != EOF) /* flush */
                ;

            collection[count++] = newCD;
        }
        else if (choice == 2) {                    /* REMOVE */
            char title[MAX_STR];
            printf("Title to remove: ");
            if (!fgets(title, MAX_STR, stdin)) goto cleanup;
            title[strcspn(title, "\n")] = '\0';

            int found = 0;
            for (size_t i = 0; i < count; ++i) {
                if (strcmp(collection[i].title, title) == 0) {
                    /* Shift everything after i left by one */
                    memmove(&collection[i], &collection[i+1],
                            (count - i - 1) * sizeof *collection);
                    --count;
                    found = 1;
                    break;
                }
            }
            if (!found) printf("CD not found.\n");
        }
        else if (choice == 3) {                    /* LIST */
            for (size_t i = 0; i < count; ++i)
                displayCD(&collection[i]);
        }
        else {                                       /* Unknown option */
            printf("Unknown option.\n");
        }
    }

cleanup:
    /* Free all remaining memory before termination */
    free(collection);
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

## 1. What “dynamic” really means  
- In the problem we are **not allowed** to declare  
  `CD cds[1000];` because we do not know how many discs will arrive.  
- Instead we keep a **pointer** (`CD *collection`) that can aim at **any
  amount of memory we allocate at run-time**.  
- The size of that memory block is controlled by two variables:
  - `count` – how many CDs we currently store.  
  - `capacity` – how many we *could* store before the next allocation.

Think of it like a classroom:  
- `capacity` is the number of chairs we rented.  
- `count` is the number of students currently sitting.  
If a new student arrives and all chairs are taken, we rent **twice as many
chairs** (`capacity *= 2`) and move everyone to the bigger room
(`realloc`).

## 2. Why we need `malloc`/`realloc` and how we avoid leaks  
- Every successful call to `malloc`, `calloc`, or `realloc` gives us a
  **ticket** to memory we must later **hand back** with `free`.  
- If we forget, the operating system cannot reuse that memory until our
  program ends – a **memory leak**.  
- Our rule of thumb: **one `free` for every successful allocation**.  
  In this program we have only one allocation path (`realloc`), so we
  have only one `free` at the end (`cleanup:` label).

## 3. Step-by-step life-cycle of the array

### a) Start-up  
```c
CD *collection = NULL;
size_t count = 0, capacity = 0;
```
`collection` is `NULL`, so we own **zero bytes**.

### b) First insert (Add CD)  
`count == capacity` (both 0) triggers the growth branch:
```c
size_t newCap = capacity ? capacity*2 : 4;
collection = realloc(collection, newCap * sizeof *collection);
```
- `realloc(NULL, size)` behaves exactly like `malloc(size)`, so the first
  call is safe.  
- We choose an initial capacity of 4 CDs – arbitrary but small.  
- We always store the **return value in a temporary pointer**; if
  `realloc` fails we can still recover without losing the old block.

### c) Subsequent inserts  
While `count < capacity` we simply copy the new CD into
`collection[count++]`.  
When the array becomes full again we double the capacity (`capacity *=
2`). Doubling keeps the cost of copying low (amortized O(1)).

### d) Removal  
- We search by exact title (**case sensitive**) using `strcmp`.  
- When found, we **remove in place** with `memmove`:
  ```c
  memmove(&collection[i], &collection[i+1],
          (count - i - 1) * sizeof *collection);
  ```
  This overwrites the deleted slot and shifts everything left.  
  We do **not** shrink the array; it stays at its current capacity
  (a production program might `realloc` downward when `count <
  capacity/4`, but the problem does not require it).

### e) Program end  
Exiting with menu option `0` jumps to the `cleanup:` label:
```c
free(collection);
```
Because `free(NULL)` is legal and does nothing, this is safe even if
the user exits immediately.

## 4. Why we flush the input line with `getchar`  
After `scanf("%d", …)` the newline remains in the input buffer. If we
immediately call `fgets` to read a string, `fgets` would see that leftover
newline and stop reading. The little `while ((c = getchar()) != '\n' &&
c != EOF);` loop **consumes the rest of the line** so the next `fgets`
starts fresh.

## 5. Encapsulating the print-out in `displayCD`  
The problem forces us to keep the **details of how to show one CD** in
a separate function:
```c
void displayCD(const CD *cd);
```
Using a `const` pointer guarantees the function **cannot accidentally
modify** the CD while printing.

## 6. Summary of dynamic-memory rules illustrated here
- Always check the result of `malloc`/`realloc`; on failure clean up
  resources and exit gracefully.  
- Keep a temporary pointer when calling `realloc`; only overwrite the live
  pointer after you know the call succeeded.  
- Match every allocation with exactly one `free`.  
- Growing by a constant factor (2×) gives amortized constant-time
  expansion.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge)**  
Think of the collection as a stretchy container: it starts empty and must grow whenever new items arrive and shrink when one leaves.  
Focus on how you can keep a reference to that container without ever fixing its size in advance.

**Hint 2 (key feature focus)**  
To let the container expand or contract while the program is running, you’ll need to ask the system for fresh blocks of memory and, when necessary, give the old, unneeded pieces back.  
Investigate which standard library tools let you request variable amounts of memory and later release it.

**Hint 3 (first concrete step)**  
Begin by declaring a single variable that can point to your first memory block, and two counters—one for how many CDs are currently stored, another for how much space you’ve reserved.  
When the stored count catches up to the reserved count, allocate a new, larger block, move the existing data into it, and update your pointer and counters accordingly.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory management: requesting, resizing, and releasing blocks with `malloc`/`realloc`/`free`
- Amortized constant-time array growth by doubling capacity
- Struct usage to group heterogeneous data (title, artist, year)
- Pointer arithmetic and `memmove` for in-place deletion and compaction
- Input-handling discipline: flushing newlines after `scanf` before `fgets`
- Single-function encapsulation (`displayCD`) for modularity within the one-extra-function limit
- Resource safety: check every allocation and guarantee a matching `free` on all exit paths

### STEP_6
# STEP 6: TEST CASES

1. **Happy path – add two CDs, list, remove one, list again**  
   Sequence adds *Nevermind* and *Back in Black*, lists both, removes *Nevermind*, lists the survivor.

2. **Empty list list**  
   Choose “List” immediately; program prints nothing and re-displays the menu.

3. **Remove from empty list**  
   Attempt to delete a CD when none exist; program prints `CD not found.`

4. **Invalid menu option**  
   Type `7` at the prompt; program prints `Unknown option.` and redisplays the menu.

5. **Long title truncation and year overflow**  
   Enter a title longer than 30 characters and a non-numeric year; program silently truncates the string and rejects the year input (behavior depends on implementation details, but the test verifies robustness).

```json
{
  "exit_command": "0",
  "test_suite": [
    {"input": "1\nNevermind\nNirvana\n1991\n1\nBack in Black\nAC/DC\n1980\n3\n2\nNevermind\n3\n0", "expected_keyword": "Back in Black"},
    {"input": "3\n0", "expected_keyword": ""},
    {"input": "2\nImaginaryCD\n0", "expected_keyword": "CD not found"},
    {"input": "7\n0", "expected_keyword": "Unknown option"},
    {"input": "1\nThisTitleIsMuchMuchMuchMuchMuchLongerThanAllowed\nArtist\nNotAYear\n1\nShortTitle\nArtist\n2020\n0", "expected_keyword": "ShortTitle"}
  ]
}
```

---

## Iteration 5 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Context
The campus library is testing a new self–service kiosk that lets students borrow books without staff help.  
Every time a student borrows a book, the kiosk must remember the book’s title, the student’s ID, and the due‐date.  
Because the number of simultaneous checkouts is unpredictable, the system must store this data in dynamically-allocated memory.

## Requirements
Write a C program that behaves like the kiosk’s back-end.  
The program must:

1. Keep an expandable array of pointers (`Book **catalog`) that point to individually allocated `Book` structures.
2. Support two commands entered by the user:
   - `add <title> <student_id> <days>`  
     Allocate a new `Book`, store the title, student ID, and a due-date computed as “today + days”, append its address to the catalog, and print the catalog index at which it was stored.
   - `return <catalog_index>`  
     Free the `Book` at that index, set its pointer to `NULL`, and print `Returned`.  
     If the index is invalid or the slot is already empty, print `Invalid`.
3. Stop accepting commands when the user types `exit`.
4. Just before terminating, print the total number of books currently checked-out (non-NULL entries).

## Example Session
```
Input
add C_Programming 12345 14
add Data_Structures 12345 7
return 0
exit

Output
0
1
Returned
1
```

## Explanation
- First `add` stores the book at catalog[0] and prints `0`.  
- Second `add` stores the next book at catalog[1] and prints `1`.  
- `return 0` frees catalog[0] and prints `Returned`.  
- `exit` prints the final count of outstanding books: `1`.

### CONSTRAINTS
- You must represent a book with a `struct Book` containing at least `char *title`, `int student_id`, and `int due_days`.
- All dynamic allocations (`malloc`) must be matched by exactly one `free`.  
- The logic that displays the final count must reside in a function `void showOutstanding(Book **catalog, int size)`.  
- The only functions allowed besides `main()` are `showOutstanding` and any helper you need for string duplication.  
- If you implement an interactive menu, option `3` must be “Exit the program”.

### STEP_2
```c
/*  STEP 2: SOLUTION
 *  Self-service library kiosk – dynamic catalog management
 *  ------------------------------------------------------
 *  The program keeps a resizable array (catalog) of dynamically allocated
 *  Book pointers.  It supports two commands:
 *      add   <title> <id> <days>
 *      return <index>
 *  and prints the final number of outstanding books on exit.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

/* Book descriptor ---------------------------------------------------------*/
typedef struct {
    char *title;       /* dynamically copied title string */
    int  student_id;   /* borrower id */
    int  due_days;     /* days from “today” when book is due */
} Book;

/* Function prototypes -----------------------------------------------------*/
static char *xstrdup(const char *s);       /* helper: strdup with OOM check */
static int   getToken(const char **p);   /* helper: tokeniser for “add”   */
void   showOutstanding(Book **catalog, int size);  /* required by spec */

/* Global state ------------------------------------------------------------*/
static Book **catalog    = NULL;   /* expandable array */
static int   catalogCap  = 0;     /* physical size    */
static int   catalogUsed = 0;     /* logical  size    */

int main(void)
{
    char  line[1024];

    puts("Self-service kiosk ready.  Commands: add, return, exit");

    /* REPL ----------------------------------------------------------------*/
    while (printf("> "), fflush(stdout), fgets(line, sizeof line, stdin)) {

        /* Remove trailing newline */
        char *nl = strchr(line, '\n');
        if (nl) *nl = '\0';

        /* Tokenise first word */
        const char *p   = line;
        int cmd = getToken(&p);                 /* tokenises command */

        /* 1) EXIT ----------------------------------------------------------*/
        if (cmd == 'e') break;                  /* “exit” */

        /* 2) ADD -----------------------------------------------------------*/
        if (cmd == 'a') {                       /* “add” */
            /* Parse arguments */
            int student_id, days;
            const char *titleStart = p;         /* title starts at p */
            while (*p && !isspace((unsigned char)*p)) p++; /* skip title */
            if (*p) *p++ = '\0';                /* NUL-terminate title copy */

            if (sscanf(p, "%d %d", &student_id, &days) != 2) {
                puts("Invalid");                /* malformed add */
                continue;
            }

            /* Grow catalog array if needed (doubling strategy) */
            if (catalogUsed == catalogCap) {
                int newCap = catalogCap ? catalogCap * 2 : 4;
                Book **bigger = realloc(catalog, newCap * sizeof *bigger);
                if (!bigger) {
                    perror("realloc");          /* OOM: terminate immediately */
                    exit(EXIT_FAILURE);
                }
                catalogCap = newCap;
                catalog    = bigger;
            }

            /* Allocate new book */
            Book *b = malloc(sizeof *b);
            if (!b) { perror("malloc"); exit(EXIT_FAILURE); }
            b->title       = xstrdup(titleStart);  /* will exit() on OOM */
            b->student_id  = student_id;
            b->due_days    = days;

            catalog[catalogUsed++] = b;
            printf("%d\n", catalogUsed - 1);       /* print storage index */
            continue;
        }

        /* 3) RETURN --------------------------------------------------------*/
        if (cmd == 'r') {                       /* “return” */
            int idx;
            if (sscanf(p, "%d", &idx) != 1) {
                puts("Invalid");
                continue;
            }
            if (idx < 0 || idx >= catalogUsed || catalog[idx] == NULL) {
                puts("Invalid");
            } else {
                free(catalog[idx]->title);
                free(catalog[idx]);
                catalog[idx] = NULL;
                puts("Returned");
            }
            continue;
        }

        /* Unknown command -------------------------------------------------*/
        puts("Invalid");
    }

    /* Cleanup and final report -------------------------------------------*/
    int outstanding = 0;
    for (int i = 0; i < catalogUsed; ++i)
        if (catalog[i]) outstanding++;

    showOutstanding(catalog, catalogUsed);

    /* Free all outstanding books and the catalog array itself ------------*/
    for (int i = 0; i < catalogUsed; ++i) {
        if (catalog[i]) {
            free(catalog[i]->title);
            free(catalog[i]);
        }
    }
    free(catalog);
    return 0;
}

/* -------------------------------------------------------------------------
 * Prints the number of non-NULL entries currently in the catalog
 * (required by the problem statement).
 * ---------------------------------------------------------------------- */
void showOutstanding(Book **catalog, int size)
{
    int c = 0;
    for (int i = 0; i < size; ++i)
        if (catalog[i]) ++c;
    printf("%d\n", c);
}

/* -------------------------------------------------------------------------
 * Helper: strdup with OOM checking
 * ---------------------------------------------------------------------- */
static char *xstrdup(const char *s)
{
    char *d = strdup(s);
    if (!d) { perror("strdup"); exit(EXIT_FAILURE); }
    return d;
}

/* -------------------------------------------------------------------------
 * Helper: extract first token (command) into lower-case first char
 * Returns 'a' for add, 'r' for return, 'e' for exit, 0 otherwise.
 * Advances *p past the token.
 * ---------------------------------------------------------------------- */
static int getToken(const char **p)
{
    while (isspace((unsigned char)**p)) (*p)++;
    if (!**p) return 0;

    switch (tolower((unsigned char)**p))) {
        case 'a': *p += 3; return 'a';   /* add */
        case 'r': *p += 6; return 'r';    /* return */
        case 'e': *p += 4; return 'e';    /* exit */
        default:  return 0;
    }
}
```

### STEP_3
# STEP 3: EXPLANATION  
*(aimed at a student who already knows basic C syntax but is uneasy with malloc/free)*

---

## 0. Big Picture
We have to remember an **unknown** number of book-checkouts at run-time.  
Because we do **not** know that number when we start the program, we cannot do:

```c
Book catalog[100];   /* fixed size */
```

Instead we keep a **chain** of individually allocated `Book` objects and hold them through an **expandable array of pointers** (`Book **catalog`).  
All operations (adding, returning, cleaning-up) are nothing more than **three classic malloc/free patterns**:

1. **Single-object allocation:** one call to `malloc(sizeof(Book))`  
2. **String duplication inside the object:** `strdup` so each book owns its title  
3. **Array-growth via `realloc`**: double the pointer-array when full

If you understand these three patterns you will recognise them in virtually every "dynamic container" you ever write in C.

---

## 1. Why a pointer-to-pointer (`Book **catalog`)?
`catalog` itself **is not** an array of books; it is an array of **addresses of books**.  
That extra level of indirection gives two advantages:

- We can grow the array (only the array of *pointers* is moved by `realloc`) without touching the already existing `Book` objects
- `return`-ing a book becomes **O(1)**: just `free()` the object and set its slot to `NULL`.  The slot remains in place, but is now empty

The price is visual complexity: you must remember whether you are talking about the pointer-array (`catalog[i]`) or the book (`catalog[i]->title`)

---

## 2. Growing the array ("amortised doubling")
When `catalogUsed == catalogCap` we are out of space.  
Standard technique:

```
newCap = catalogCap ? catalogCap*2 : 4;
catalog = realloc(catalog, newCap * sizeof *catalog);
```

- Doubling keeps the number of reallocations **logarithmic**
- `realloc` returns a *contiguous* buffer; if it fails we simply `exit` here, because recovery is beyond our simple kiosk

The old pointers remain valid, because `realloc` copies them for us.

---

## 3. Adding a book step by step (`add`)
1. Parse: `<title> <student_id> <days>`  
   - We tokenise in-place by temporarily overwriting the first space *after* the title with `'\0'` so `strdup` can copy just the title
2. Grow catalog array if necessary (see previous section)
3. Allocate a new `Book` structure in the heap:
   ```c
   Book *b = malloc(sizeof *b);
   ```
4. Duplicate the title string so the book really **owns** it:
   ```c
   b->title = strdup(titleStart);
   ```
   Without `strdup`, several books would share the same buffer and freeing one would corrupt the others
5. Fill the remaining fields (`student_id`, `due_days`)
6. Append pointer to catalog and print its index to the user

**Result**: One malloc for the object, one for its string → exactly two allocations per active book

---

## 4. Returning a book (`return`)
Nothing more than:

```c
free(catalog[idx]->title);
free(catalog[idx]);
catalog[idx] = NULL;
```

Notice:

- We **do not** shrink the pointer array; we only mark the slot empty
- Invalid index or an already empty slot ➜ print "Invalid"

By setting the pointer to `NULL` we distinguish a free slot from an occupied one when we later count outstanding books.

---

## 5. Counting outstanding books
A simple linear scan counts how many slots are **not** `NULL`.  
We are required to place the printing logic inside the function:

```c
void showOutstanding(Book **catalog, int size)
```

so main just calls it before termination.  
**Important**: we scan only up to `catalogUsed`, not `catalogCap`, because the rest of the array is uninitialised.

---

## 6. Cleaning up before `exit`
Even though the operating system will reclaim memory, a correct program should free everything it allocated (good habit, simplifies leak-checking with `valgrind`).

```c
for each slot
    if (slot) free(slot->title);
    free(slot);
free(catalog);
```

The user sees the final count **before** this de-allocation (because some books may be freed by earlier `return` commands).

---

## 7. Error handling philosophy
`malloc`/`realloc`/`strdup` can fail (return `NULL`).  
In a real system we would recover gracefully; in our tiny kiosk we simply:

```c
if (!p) { perror("foo"); exit(EXIT_FAILURE); }
```

This keeps the code short yet **never ignores the return value**, satisfying the critical requirement in the assignment.

---

## 8. What you should remember
- Each `malloc` must eventually be matched by exactly one `free`
- If an object contains a pointer to another heap block (here `title`) you must free the inner block **first**
- Growing an array of **pointers** is cheap, because the objects themselves stay put
- Always distinguish *logical* size (`catalogUsed`) from *physical* capacity (`catalogCap`)
- When you do not know the number of elements beforehand, combine:
  - Individual object allocations
  - A resizable vector of pointers

Master these ideas and you will recognise them in every "dynamic container" assignment you meet in CS courses or production code.

### STEP_4
# STEP 4: HINTS

**Hint 1 (big picture):**  
Think of the catalog as a line of labeled parking spots; each spot can either hold a car (Book) or be empty.  Because you don’t know how many cars will arrive, the line of spots has to be able to lengthen while the program is running.  Work out how you’ll keep track of which spots are occupied and how you’ll remember where each car is parked.

**Hint 2 (key feature):**  
In C, you can resize an already-created array of pointers with a standard library function whose name starts with “re”.  Read its manual page and notice that it may move the entire array to a bigger stretch of memory for you—old entries stay valid, so you only need to copy addresses, not whole books.

**Hint 3 (first coding step):**  
Start by declaring a pointer that will eventually point to the first element of your expandable pointer array; initially let that pointer be NULL and the logical count be zero.  Write a tiny block that simply increases the array’s capacity whenever the logical count reaches the current capacity (double the capacity each time).  Once you can enlarge the parking lot on demand, everything else (adding a book, removing a book, counting non-empty slots) becomes straightforward.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: allocating, owning, and releasing individual structures with malloc/free
- Owning versus referencing data—why a Book must strdup its title to avoid shared-buffer pitfalls
- Pointer-to-pointer indirection to build expandable arrays without moving existing objects
- Realloc for amortised-doubling arrays: when and how to grow storage safely
- Distinguishing logical size from physical capacity when managing dynamic containers
- Single-responsibility cleanup: freeing inner allocations (strings) before outer allocations (struct)
- Defensive programming: checking every malloc/realloc return value and handling OOM
- Modular design: isolating the final “count outstanding” logic in a required function
- Incremental development: solve array-growth first, then add/return operations become trivial

### STEP_6
# STEP 6: TEST CASES

## Description of test cases

1. **Baseline / common case**  
   Add two books, return the first, exit.  
   Validates correct indices, correct return message, and that the final count is 1.

2. **Edge – empty catalog return attempt**  
   Try to return from an empty catalog (index 0).  
   Expect “Invalid”.

3. **Edge – add with zero days**  
   Add a book whose due-date delta is 0.  
   Ensures the parser accepts 0 as a valid integer.

4. **Invalid index – out of range**  
   Add one book, attempt to return index 5.  
   Expect “Invalid”.

5. **Double free scenario**  
   Add a book, return it (sets slot to NULL), immediately attempt to return the same index again.  
   Expect “Invalid” on the second return.

## Machine-readable JSON block

```json
{
  "exit_command": "exit",
  "test_suite": [
    {
      "input": "add C_Programming 12345 14\nadd Data_Structures 12345 7\nreturn 0\nexit",
      "expected_keyword": "Returned\n1"
    },
    {
      "input": "return 0\nexit",
      "expected_keyword": "Invalid"
    },
    {
      "input": "add Zero_Days 11111 0\nexit",
      "expected_keyword": "0"
    },
    {
      "input": "add Solo 22222 5\nreturn 5\nexit",
      "expected_keyword": "Invalid"
    },
    {
      "input": "add DoubleFree 33333 3\nreturn 0\nreturn 0\nexit",
      "expected_keyword": "Invalid"
    }
  ]
}
```

---

## Iteration 6 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

**Background Story**  
The campus library has just bought a small, unnamed server that only supports plain C.  
They need a tiny “checkout-log” program that can remember, at runtime, which books a patron has borrowed.  
Because the server has very little RAM, the program must allocate memory only when a new book is added, and free it immediately when the book is returned.

**Functional Requirements**  
1. The program keeps a dynamic array of structures, one structure per currently-checked-out book.  
2. At start-up the array is empty (size 0).  
3. The user can repeatedly choose one of three actions:  
   - **1** Add a newly-borrowed book (title, author, year).  
   - **2** Return (delete) the newest book in the log.  
   - **3** Exit the program.  
4. After every action the program must print the current number of books still checked out.  
5. If the user tries to delete when the log is empty, print “Nothing to return.” and leave the count at 0.

**Simple Example**  
Input
```
1
C_Programming_Language
Kernighan
1978
1
Introduction_to_Algorithms
Cormen
2009
2
3
```
Output
```
Books in log: 1
Books in log: 2
Books in log: 1
Good-bye.
```

### CONSTRAINTS  
- Represent each book with a `struct Book`.  
- Store the dynamic array itself as `struct Book *log`.  
- You may have only one function besides `main()`: `void displayCount(int n);` that prints “Books in log: n”.  
- Menu option **3** is the required EXIT keyword.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * checkout_log.c
 *
 * A minimal, memory-conscious program that records the titles currently
 * checked-out from the library.  All dynamic memory is released as soon as
 * a book is returned, and every allocation is checked for success.
 *
 * C11, plain ISO C, no extensions required.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TITLE_LEN  101
#define AUTHOR_LEN 101

/*---------- Data representation -------------------------------------------*/
struct Book {
    char title[TITLE_LEN];
    char author[AUTHOR_LEN];
    int  year;
};

/*---------- Prototype required by the problem ------------------------------*/
void displayCount(int n);

/*---------- Helper: consume the rest of the current line -------------------*/
static void clear_stdin(void)
{
    int c;
    while ((c = getchar()) != '\n' && c != EOF)
        /* discard */;
}

/*---------- Main ----------------------------------------------------------*/
int main(void)
{
    struct Book *log = NULL;   /* dynamic array of currently-checked-out books */
    size_t size = 0;          /* number of books in log                        */
    int choice;

    puts("=== Library Checkout Log ===");
    for (;;) {
        /* ---- menu ---- */
        printf("Choose action: 1=borrow 2=return 3=exit > ");
        if (scanf("%d", &choice) != 1) {      /* unexpected EOF */
            choice = 3;
        }
        clear_stdin();                       /* remove newline etc. */

        if (choice == 1) {                   /* borrow new book */
            char tmpTitle[TITLE_LEN];
            char tmpAuthor[AUTHOR_LEN];
            int  tmpYear;

            printf("Title : ");
            if (!fgets(tmpTitle, sizeof(tmpTitle), stdin)) break;
            tmpTitle[strcspn(tmpTitle, "\n")] = '\0'; /* strip newline */

            printf("Author: ");
            if (!fgets(tmpAuthor, sizeof(tmpAuthor), stdin)) break;
            tmpAuthor[strcspn(tmpAuthor, "\n")] = '\0';

            printf("Year  : ");
            scanf("%d", &tmpYear);
            clear_stdin();

            /* enlarge the array by one slot */
            struct Book *tmp = realloc(log, (size + 1) * sizeof *tmp);
            if (!tmp) {                       /* allocation failed */
                perror("realloc");
                goto cleanup;
            }
            log = tmp;

            /* fill the new slot */
            strncpy(log[size].title, tmpTitle, TITLE_LEN);
            log[size].title[TITLE_LEN - 1] = '\0';
            strncpy(log[size].author, tmpAuthor, AUTHOR_LEN);
            log[size].author[AUTHOR_LEN - 1] = '\0';
            log[size].year = tmpYear;
            ++size;

            displayCount((int)size);
        }
        else if (choice == 2) {               /* return most-recent book */
            if (size == 0) {
                puts("Nothing to return.");
                displayCount(0);
            } else {
                /* shrink the array by one */
                struct Book *tmp = realloc(log, (size - 1) * sizeof *tmp);
                /* if realloc fails, keep the old block; still remove logically */
                if (tmp || size == 1)           /* size==1: deletion makes size 0 */
                    log = tmp;
                --size;
                displayCount((int)size);
            }
        }
        else if (choice == 3) {               /* exit */
            break;
        }
        else {
            puts("Invalid choice, try again.");
        }
    }

cleanup:
    free(log);                /* free any remaining books */
    puts("Good-bye.");
    return 0;
}

/*---------- Display helper required by the problem ------------------------*/
void displayCount(int n)
{
    printf("Books in log: %d\n", n);
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory management in C is nothing more than asking the run-time system:
1. “Give me a brand-new block of bytes” (malloc / realloc),
2. “I’m done with this block—take it back” (free).

The checkout-log program is deliberately built around those two ideas so you can see them in isolation.

## 1. What MUST live in dynamic memory?
The problem statement says:
- At start-up the log is empty (size == 0).  
- A new book may arrive at any moment and must be stored.  
- The library server has *very little RAM*; therefore we must not pre-allocate a big fixed array “just in case”.  

Whenever the user chooses “borrow”, we must *insert* a new book; whenever the user chooses “return”, we must *delete* the last book.  
A fixed-size array cannot shrink; a linked list would work but would allocate one node per book—legal but slightly more complicated.  
A dynamic array (a pointer that realloc() can grow or shrink) is the simplest match:
```
struct Book *log = NULL;   /* points to a contiguous run of struct Book */
```

## 2. Growing the array: one realloc() call
Suppose `size == k` books are currently stored.  
We need space for `k+1` books, so we ask realloc() for a block of `(k+1)*sizeof(struct Book)` bytes:
```
tmp = realloc(log, (size+1)*sizeof *tmp);
```
Key points you must memorise:
- `realloc(old, newsize)` either:
  – extends the block in place (old pointer still valid), or  
  – allocates a *new* block, copies the old data, and frees the old block.  
  Therefore `log = tmp` must be done **after** the call succeeds, never before.
- Always test the returned pointer:
  ```
  if (!tmp) { perror("realloc"); goto cleanup; }
  ```
  If allocation fails we politely quit instead of seg-faulting.

Once the block is enlarged we simply write the new book at index `size` and increment `size`.

## 3. Shrinking the array: the symmetry
When the user returns the newest book we *logically* remove one element by doing `--size`.  
Physically we may now free that no-longer-needed slot.  
```
tmp = realloc(log, (size-1)*sizeof *tmp);
```
- If the call succeeds the returned pointer may be the same address (shrinking in place) or a new, smaller block; either way we update `log`.
- If size becomes 0, realloc(ptr,0) is legal and behaves like free(ptr), so our cleanup path still works.

Notice we test `(tmp || size == 1)` before re-assigning: if realloc fails when we are shrinking we simply keep the larger (but now partially-unused) block. We have not lost data.

## 4. Freeing memory on exit
All textbook programs free their memory for hygiene, even if the OS will reclaim it.  
We have exactly one place where blocks originate (`realloc` inside the loop), so exactly one matching `free(log);` before `main` returns.  
That single, centralised free() satisfies the leakage rule.

## 5. Input handling, overflow guards, and const-correctness
- `fgets` + `strncpy` prevents a user from overrunning our fixed `TITLE_LEN`/`AUTHOR_LEN`.
- `clear_stdin()` consumes the `\n` left by `scanf`; without it later `fgets` calls would read only the leftover newline.
- `displayCount(int)` is kept trivial on purpose—one function that merely prints the counter—exactly what the specification allows.

## 6. The “why” compared to a linked list
A linked list would allocate one node per book, freeing one node per return—also O(1) and memory-frugal.  
The dynamic array gives O(1) amortised insert/delete-last and better cache locality, while keeping the code extremely small (only `*log`, `size`).

## 7. Mental checklist for any dynamic-memory exercise
1. Start with pointer == NULL, size == 0.  
2. Every path that increases the count → one successful malloc/realloc.  
3. Every path that decreases the count → may shrink (and optionally free) the block.  
4. Keep exactly one “source of truth” for how many elements you own (`size`).  
5. Exit through one common label that free()s the remaining block.

Once those habits become automatic, you will find dynamic allocation no scarier than ordinary variables.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the checkout log as a stack of books that can only grow or shrink at the top.  At any moment you need to know how many books are on that stack, but you don’t know the maximum number in advance.  What kind of container can start empty and change size while the program is running?

**Hint 2**  
Recall that arrays in C have a fixed size once they are created.  If you need an array that can expand or contract during execution, look for the standard library function whose name literally means “reallocate” and that can reuse an existing block of memory.

**Hint 3**  
Start with a pointer set to NULL and a counter set to zero.  When the user chooses “borrow,” increase the counter by one and ask the allocator for room for that many structures, copying any old data if the pointer changes.  When the user chooses “return,” decrease the counter and request less room, freeing memory if the request succeeds.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory allocation with `malloc`/`realloc` and the importance of checking return values
- Shrinking and growing a dynamic array in-place while keeping data intact
- Single responsibility: one allocated pointer, one counter, one centralized `free`
- Input safety using `fgets` and fixed-width buffers
- Clear separation between logical size (counter) and physical capacity (bytes requested from the allocator)
- Using a trivial helper function (`displayCount`) to satisfy interface constraints
- Common pattern for a simple interactive menu loop with exit keyword
- Resource cleanup discipline—free every byte before program termination

### STEP_6
# STEP 6: TEST CASES

1. **Common sequence**: borrow two books, return the newest one, then exit.  
   - Verifies correct growth (1 → 2) and shrink (2 → 1) of the log and that counts are printed after every action.

2. **Empty return attempt**: choose return when the log is already empty.  
   - Checks the “Nothing to return.” message and that the subsequent count stays 0.

3. **Single borrow/return round trip**: add one book, immediately return it, then exit.  
   - Ensures the array shrinks from 1 → 0 and no memory leaks remain.

4. **Invalid menu choice**: enter non-existent option 5 followed by valid borrow.  
   - Confirms invalid-input handling prints an error and the menu repeats without crashing.

5. **EOF during borrow title entry**: after choosing borrow, send Ctrl-D (EOF) instead of a title.  
   - Tests graceful handling of input failure—program should break the loop and perform cleanup.

```json
{
  "exit_command": "3",
  "test_suite": [
    {
      "input": "1\nC_Programming_Language\nKernighan\n1978\n1\nIntroduction_to_Algorithms\nCormen\n2009\n2\n3",
      "expected_keyword": "Books in log: 1"
    },
    {
      "input": "2\n3",
      "expected_keyword": "Nothing to return."
    },
    {
      "input": "1\nTest_Book\nAuthor\n2000\n2\n3",
      "expected_keyword": "Books in log: 0"
    },
    {
      "input": "5\n1\nValid_Title\nValid_Author\n2022\n3",
      "expected_keyword": "Invalid choice"
    },
    {
      "input": "1",
      "expected_keyword": "Title : "
    }
  ]
}
```

---

## Iteration 7 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Context (Story)
You are helping the campus library build a tiny, self-contained catalog system for its new “Pop-Up Reading Corner.”  
Because the corner only exists for the weekend, the librarian wants the catalog to live entirely in RAM and disappear when the program ends.  
All book records must therefore be allocated dynamically with malloc and freed with free when they are no longer needed.

## Functional Requirements
1. The program starts with an empty catalog (no books).
2. It supports a single-character menu loop:
   - `A` – Add a new book  
   - `L` – List all books currently in the catalog  
   - `D` – Delete (remove & free) the most recently added book  
   - `X` – Exit the program (and free any remaining memory before quitting)
3. Adding a book prompts the user for:
   - Title (one line, up to 99 characters, may contain spaces)
   - Author (one line, up to 99 characters)
   - Year (positive integer)
4. Listing prints every book in the order they were added, one per line, in the exact format:
   ```
   Year: <year>, Title: "<title>", Author: <author>
   ```
5. Deleting removes the last-added book from memory; if the catalog is empty, print `Nothing to delete.` and return to the menu.

## Simple Example Run
```
=== Pop-Up Reading Corner Catalog ===
A) Add book
L) List books
D) Delete last book
X) Exit
Choice: A
Title: The Little Prince
Author: Antoine de Saint-Exupéry
Year: 1943
Choice: A
Title: Dune
Author: Frank Herbert
Year: 1965
Choice: L
Year: 1943, Title: "The Little Prince", Author: Antoine de Saint-Exupéry
Year: 1965, Title: "Dune", Author: Frank Herbert
Choice: D
Choice: L
Year: 1943, Title: "The Little Prince", Author: Antoine de Saint-Exupéry
Choice: X
Goodbye!
```

## CONSTRAINTS
- Each book must be represented by a struct named `Book`.
- The catalog must be implemented as a dynamically-sized array of pointers to `Book`, resized with `realloc` as books are added.
- All dynamic memory (every `Book` struct and the array itself) must be freed before the program exits.
- The menu option to exit the program is `X`.
- No global variables are allowed; keep all data inside `main()` or pass it as parameters.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Pop-Up Reading Corner – tiny in-memory catalog
 * C11, no globals, all dynamic memory freed on exit
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STR 100           /* includes space for NUL */

typedef struct Book {
    char  title[MAX_STR];
    char  author[MAX_STR];
    int   year;
} Book;

/* ---------- helper prototypes ---------- */
static void eat_rest_of_line(void);
static Book *create_book(void);
static void free_books(Book **catalog, size_t size);

/* ---------- main ---------- */
int main(void)
{
    Book **catalog = NULL;   /* dynamic array of pointers to Book */
    size_t size     = 0;     /* how many books are stored */
    size_t capacity = 0;     /* how many slots we have allocated */
    char choice;

    puts("=== Pop-Up Reading Corner Catalog ===");
    while (1) {
        puts("A) Add book");
        puts("L) List books");
        puts("D) Delete last book");
        puts("X) Exit");

        printf("Choice: ");
        if (scanf(" %c", &choice) != 1) break;   /* EOF => quit */
        eat_rest_of_line();                      /* discard rest of line */

        switch (choice) {
        case 'A':   /* ---------------- ADD ---------------- */
        {
            Book *b = create_book();
            if (!b) {              /* create_book already printed message */
                free_books(catalog, size);
                return EXIT_FAILURE;
            }

            /* resize pointer array if necessary */
            if (size == capacity) {
                size_t new_cap = capacity ? capacity * 2 : 4;
                Book **new_catalog = realloc(catalog, new_cap * sizeof *new_catalog);
                if (!new_catalog) {
                    perror("realloc");
                    free(b);
                    free_books(catalog, size);
                    return EXIT_FAILURE;
                }
                catalog  = new_catalog;
                capacity = new_cap;
            }
            catalog[size++] = b;
            break;
        }

        case 'L':   /* ---------------- LIST ---------------- */
            if (size == 0)
                puts("(catalog empty)");
            else {
                for (size_t i = 0; i < size; ++i)
                    printf("Year: %d, Title: \"%s\", Author: %s\n",
                           catalog[i]->year, catalog[i]->title, catalog[i]->author);
            }
            break;

        case 'D':   /* ---------------- DELETE ---------------- */
            if (size == 0) {
                puts("Nothing to delete.");
            } else {
                --size;
                free(catalog[size]);
                catalog[size] = NULL;
                /* optional: shrink array if very sparse – not required */
            }
            break;

        case 'X':   /* ---------------- EXIT ---------------- */
            free_books(catalog, size);
            puts("Goodbye!");
            return EXIT_SUCCESS;

        default:
            puts("Invalid choice, try again.");
        }
    }

    /* Ctrl-D / EOF path */
    free_books(catalog, size);
    return EXIT_SUCCESS;
}

/* ---------- helper definitions ---------- */

/* Flush rest of current input line */
static void eat_rest_of_line(void)
{
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF)
        /* discard */;
}

/* Prompt user, allocate & fill a Book.  NULL on any failure. */
static Book *create_book(void)
{
    Book *b = malloc(sizeof *b);
    if (!b) {
        perror("malloc");
        return NULL;
    }

    printf("Title: ");
    if (!fgets(b->title, sizeof b->title, stdin)) goto fail;
    b->title[strcspn(b->title, "\n")] = '\0';   /* trim newline */

    printf("Author: ");
    if (!fgets(b->author, sizeof b->author, stdin)) goto fail;
    b->author[strcspn(b->author, "\n")] = '\0';

    printf("Year: ");
    if (scanf("%d", &b->year) != 1 || b->year <= 0) {
        puts("Invalid year.");
        goto fail;
    }
    eat_rest_of_line();
    return b;

fail:
    free(b);
    return NULL;
}

/* Free all books and the pointer array itself */
static void free_books(Book **catalog, size_t size)
{
    if (!catalog) return;
    for (size_t i = 0; i < size; ++i)
        free(catalog[i]);
    free(catalog);
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory lets us decide *at run time* how many objects we need and how big they should be.  
Here we do not know in advance:

- How many books the librarian will enter,  
- So we cannot declare “`Book list[100];`” statically.

Instead we grow the storage as books arrive and shrink it (logically) when one is deleted.  
The key ideas are:

---

## 1. A Book “lives” on the heap

The `struct Book` is small (three fixed-size fields), but **every single book is created with `malloc`**:

```
Book *b = malloc(sizeof *b);
```

`malloc` returns a pointer to *uninitialised* bytes carved out of the heap.  
We immediately fill those bytes (`fgets`, `scanf`) before anybody else uses them.

**Why not put the whole array of Books on the heap?**  
Because we also need to *delete an arbitrary one* in O(1) time.  
Keeping **pointers** to Books means we can release the memory of the last-added item with a single `free(catalog[size-1])` without moving the other array elements around.

---

## 2. Growing the catalog (`realloc`)

We maintain three variables inside `main`:

- `catalog` – pointer to an *array of pointers* (`Book **`)  
- `size`      – how many slots are occupied  
- `capacity`  – how many slots are *allocated*

Initially both counters are 0 and `catalog` is NULL.

When `size == capacity` the array is full, exactly like a full glass.  
We double the capacity (4 → 8 → 16 …) and ask `realloc` to enlarge the glass:

```
new_catalog = realloc(catalog, new_cap * sizeof *new_catalog);
```

`realloc` either:

- returns the same address (if the block could be stretched in-place), **or**  
- allocates a *new* bigger block, copies the old contents, frees the old block, and returns the new address.

That is why we **always** assign the result back into a temporary variable first; if `realloc` fails we still have the previous pointer intact and can continue (or quit gracefully) without leaking memory.

---

## 3. Deleting the last book

Deleting is intentionally cheap:

- `size` is decremented  
- the pointer stored at that index is `free`d  
- we set the slot to NULL (defensive programming)

We do **not** shrink the physical array—doing so would require another `realloc`, which can fail and is unnecessary for a weekend-long demo. If the catalog stays tiny, the wasted space is negligible.

---

## 4. Freeing everything on exit

The program may finish in two ways:

- user presses `X` (normal exit), **or**  
- `scanf` encounters EOF (Ctrl-D on Unix, Ctrl-Z on Windows).

In either case we call `free_books()`:

```
for (i = 0 … size-1) free(catalog[i]);   // every Book
free(catalog);                           // the array itself
```

This guarantees we leave the heap in the same state we found it—no leaks.  
Valgrind (or any similar tool) will report “0 bytes in 0 blocks” if the program ends through the exit path.

---

## 5. Input hygiene

- `scanf(" %c", &choice)` consumes the leading white-space (the space before `%c`).  
- After `scanf` we must discard the rest of the line (`eat_rest_of_line`) so the next `fgets` does *not* read an empty line left behind.  
- `fgets` keeps the trailing `'\n'`; we overwrite it with `'\0'` using `strcspn`, ensuring the stored strings contain no new-line characters.

---

## 6. No global variables

All state lives inside `main` (or in pointers we pass around).  
This makes the program thread-safe, easier to test, and forces us to think about ownership: whoever allocates memory is responsible for freeing it.

---

## Mental checklist for heap programming

- Every `malloc`/`calloc`/`realloc` must have a matching `free`.  
- After `free(ptr)` set `ptr = NULL` if the pointer can still be reached (prevents double-free).  
- Check the return value of every allocation; handle failure immediately.  
- Use `realloc` with a temp pointer to avoid losing the old block on failure.  
- When the lifetime of an object ends, release it—do not wait for program exit unless you must.

Follow these habits and dynamic memory becomes a tool, not a trap.

### STEP_4
# STEP 4: HINTS  

**Hint 1 (conceptual nudge)**  
You don’t know how many titles you’ll store, and you won’t have them when the program starts, so think about *where* data can live if it must appear only while your program is running and you can’t declare a fixed-size array.  

**Hint 2 (key feature focus)**  
You need a way to ask the operating system for new memory every time you press “add,” and you need a way to hand that memory back when you press “delete” or when the program ends. Look for the C library functions whose names start with “m” and “f.”  

**Hint 3 (first concrete step)**  
Begin by sketching the *layout* of a single book—what fields you must remember—then figure out how to keep a *collection* of those books that can grow in size. Allocate space for one book first, and keep track of how many you’ve stored so you can later expand the collection with the “double-when-full” strategy you’ve seen in dynamic array examples.

### STEP_5
# STEP 5: SUMMARY
- Dynamic allocation of individual objects with malloc/free  
- Growing/shrinking a dynamic array of pointers using realloc  
- Ownership discipline: who allocates memory and who frees it (preventing leaks)  
- Structs as a lightweight, self-contained record type  
- Handling mixed input (scanf/fgets) safely without leftover newlines  
- Design without globals: keeping all state local and passing what’s needed  
- Immediate error checking on allocation failure and controlled program exit

### STEP_6
# STEP 6: TEST CASES

TC-1  Normal round-trip  
Add two books, list them, delete the last one, list again, then exit.  
Verifies basic allocation, listing order, deletion, and final cleanup.

TC-2  Empty catalog list  
Start the program and immediately choose List.  
Ensures the "(catalog empty)" placeholder appears and no crash occurs.

TC-3  Delete from empty catalog  
Delete when no books exist.  
Checks the “Nothing to delete.” reply and returns gracefully to the menu.

TC-4  Invalid menu choice  
Type a letter not on the menu (e.g. ‘Z’) twice, then a valid choice.  
Confirms the program re-prompts after invalid input and keeps running.

TC-5  Mal-formed year during add  
Attempt to enter a non-numeric year, then supply a valid year.  
Checks that the program rejects the bad year and re-prompts correctly.

```json
{
  "exit_command": "X",
  "test_suite": [
    {
      "input": "A\nThe Little Prince\nAntoine de Saint-Exupéry\n1943\nA\nDune\nFrank Herbert\n1965\nL\nD\nL\nX",
      "expected_keyword": "Year: 1943, Title: \"The Little Prince\""
    },
    {
      "input": "L\nX",
      "expected_keyword": "(catalog empty)"
    },
    {
      "input": "D\nX",
      "expected_keyword": "Nothing to delete."
    },
    {
      "input": "Z\nQ\nA\nClean Code\nRobert C. Martin\n2008\nX",
      "expected_keyword": "Invalid choice"
    },
    {
      "input": "A\nTest Book\nTest Author\nabcd\n1946\nX",
      "expected_keyword": "Invalid year"
    }
  ]
}
```

---

## Iteration 8 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Context
You are helping the university library build a tiny “digital shelf” for new arrivals.  
Each book has: title, author, and year.  
Because the collection grows and shrinks every day, the program must keep its data on the heap, not in fixed-size arrays.

## Requirements
1. The program starts with an empty collection.
2. It repeatedly shows this menu:
   ```
   1) Add a new book
   2) Remove the last added book
   3) List all books
   4) Exit
   ```
3. Choosing 1 prompts for title, author, and year, then stores the book on the heap.
4. Choosing 2 deletes the most recently added book (like popping a stack) and frees its memory.
5. Choosing 3 prints every book in the order they were added, one per line, with a single space between fields:
   ```
   C_Programming_Language Kernighan 1978
   ```
6. After each operation the menu re-appears until the user chooses 4.
7. On Exit the program must free every remaining book before terminating.

## Example Run
```
1) Add a new book
2) Remove the last added book
3) List all books
4) Exit
Choice: 1
Title: C_Programming_Language
Author: Kernighan
Year: 1978
Choice: 1
Title: Clean_Code
Author: Martin
Year: 2008
Choice: 3
C_Programming_Language Kernighan 1978
Clean_Code Martin 2008
Choice: 2
Choice: 3
C_Programming_Language Kernighan 1978
Choice: 4
```

### CONSTRAINTS
- You must store each book in a struct named Book allocated with malloc.
- You must implement exactly one extra function besides main(): void displayBook(const struct Book *b) which prints one book in the required format.
- The user must type 4 to exit the program.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * digital_shelf.c
 *
 * A simple, heap-based “digital shelf” that stores Book structs
 * in a dynamic array (realloc’d as needed) and supports the four
 * operations listed in the menu.
 *
 * Build (gcc, C11):
 *     gcc -std=c11 -Wall -Wextra -pedantic digital_shelf.c -o digital_shelf
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structure ---------- */
struct Book {
    char *title;   /* dynamically allocated */
    char *author;  /* dynamically allocated */
    int  year;
};

/* ---------- Function prototype ---------- */
void displayBook(const struct Book *b);

/* ---------- Helpers for safe allocation ---------- */
static char *dupStr(const char *src)
{
    /* strdup is POSIX; we roll our own for ISO-C portability. */
    size_t len = strlen(src) + 1;
    char *p = malloc(len);
    if (!p) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    memcpy(p, src, len);
    return p;
}

static void *safeRealloc(void *ptr, size_t newSize)
{
    void *tmp = realloc(ptr, newSize);
    if (!tmp) {
        perror("realloc");
        exit(EXIT_FAILURE);
    }
    return tmp;
}

/* ---------- Program entry point ---------- */
int main(void)
{
    struct Book *shelf = NULL; /* dynamic array on the heap */
    size_t count = 0;        /* #books currently stored */
    size_t capacity = 0;     /* allocated slots in shelf */

    while (1) {
        /* --- Display menu --- */
        puts("1) Add a new book");
        puts("2) Remove the last added book");
        puts("3) List all books");
        puts("4) Exit");

        /* --- Get choice --- */
        printf("Choice: ");
        int choice;
        if (scanf("%d", &choice) != 1) { /* non-numeric input */
            /* flush rest of line to prevent infinite loop */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF)
                ; /* void */
            puts("Invalid input. Try again.");
            continue;
        }
        getchar(); /* consume newline after number */

        /* --- Process choice --- */
        if (choice == 1) {
            /* --- Add book --- */
            char titleBuffer[256], authorBuffer[256];
            int year;

            printf("Title: ");
            scanf("%255s", titleBuffer);
            printf("Author: ");
            scanf("%255s", authorBuffer);
            printf("Year: ");
            scanf("%d", &year);
            getchar(); /* consume newline */

            /* Grow array if needed */
            if (count == capacity) {
                capacity = capacity ? capacity * 2 : 4;
                shelf = safeRealloc(shelf, capacity * sizeof *shelf);
            }

            /* Fill new slot */
            shelf[count].title  = dupStr(titleBuffer);
            shelf[count].author = dupStr(authorBuffer);
            shelf[count].year  = year;
            ++count;

        } else if (choice == 2) {
            /* --- Remove last book --- */
            if (count == 0) {
                puts("No books to remove.");
            } else {
                --count;
                free(shelf[count].title);
                free(shelf[count].author);
                /* (we do NOT shrink the array; overhead is tiny) */
            }

        } else if (choice == 3) {
            /* --- List all books --- */
            for (size_t i = 0; i < count; ++i)
                displayBook(&shelf[i]);

        } else if (choice == 4) {
            /* --- Exit --- */
            break;

        } else {
            puts("Invalid choice. Try again.");
        }
    }

    /* --- Free all remaining memory before termination --- */
    for (size_t i = 0; i < count; ++i) {
        free(shelf[i].title);
        free(shelf[i].author);
    }
    free(shelf);
    return 0;
}

/* ---------- Required utility function ---------- */
void displayBook(const struct Book *b)
{
    printf("%s %s %d\n", b->title, b->author, b->year);
}
```

### STEP_3
# STEP 3: EXPLANATION

## 1. Why we need the heap at all
- The problem says the collection “grows and shrinks every day,” so a fixed-size array (e.g. `struct Book shelf[100];`) is impossible—we don’t know the upper bound.
- Heap memory (`malloc`, `realloc`, `free`) gives us run-time control over size and lifetime.
- Anything allocated with `malloc` stays valid until we explicitly `free` it, even across function calls.

## 2. The two-level allocation picture
```
shelf (struct Book *) ---points-to---> [0] [1] [2] ... (array of struct Book)
                        each struct Book contains
                        two char* that point to separately allocated strings
```
- Level 1: the array itself (`shelf`) is **one** block obtained with `malloc`/`realloc`.
- Level 2: the two strings inside **each** `struct Book` are **individual** blocks obtained with `malloc` (`strdup` is just a wrapper that calls `malloc`).
- Therefore, for every book we perform **three** allocations: one for title, one for author, and none for the integer year (it lives inside the struct).

## 3. Growing the array safely
- We keep two parallel variables:
  - `count` = how many books are currently stored.
  - `capacity` = how many slots are currently allocated.
- When `count == capacity` the array is full, so we double its size:
  ```c
  capacity = capacity ? capacity * 2 : 4;
  shelf = safeRealloc(shelf, capacity * sizeof *shelf);
  ```
- Using `realloc` rather than `malloc` preserves the existing books while extending the block.
- By doubling we obtain amortized O(1) insertion cost yet never waste more than 50 % space.

## 4. Preventing memory leaks
A leak happens if we lose the last pointer to a heap block.  
Our discipline:
- Every path that `malloc`s must eventually `free`.
- When we remove a book (menu 2) we first `free` its two strings, then simply shrink `count`; the array slot becomes reusable without freeing the slot itself—less fragmentation and simpler code.
- On exit we walk the entire array and `free` the two strings of every remaining book, then `free` the array itself.  
  Thus **all** blocks allocated with `malloc` are paired with exactly one `free`.

## 5. Why we duplicate the strings
The temporary buffers (`titleBuffer`, `authorBuffer`) live on the stack and disappear at the end of the block.  
If we stored a pointer into those buffers inside the struct, we would later dereference stale stack data—**undefined behaviour**.  
`dupStr` allocates fresh heap copies that survive as long as we need them.

## 6. Error handling strategy
- Any `malloc`/`realloc` failure is **fatal**; we print an informative message (`perror`) and immediately `exit(EXIT_FAILURE)`.
- This keeps the code short while still protecting against allocation failures, satisfying the “check every allocation” requirement.  
  A production system might instead return an error code and roll back.

## 7. Interaction flow
- The menu loop repeats until the user types `4`.
- After each operation control returns to the top of the loop, redrawing the menu.
- Input is read with `scanf` but we always consume the trailing newline so the next read does not see leftover characters.

## 8. The single required helper: `displayBook`
- Receives a **const** pointer, signalling it will not modify the book.
- Knows nothing about the shelf; it merely prints one book in the required format, keeping responsibilities separated.

If you remember only three things:
1. Every `malloc` must have a matching `free`.
2. `realloc` extends (or shrinks) an existing block; the old pointer becomes invalid—always assign the result back.
3. Dynamic arrays need two counters: one for logical size, one for physical capacity.

With these principles you can manage any grow-on-demand collection in C.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the shelf as a pile of books you can always add to or take from the top.  
What happens to the pile when the array underneath it gets full? Consider how you might give yourself more room without losing the books you already placed.

**Hint 2**  
When you create a new book, its title and author are typed by the user into temporary storage that disappears as soon as the function ends.  
Which standard library service can you use to make permanent copies that outlive that temporary storage?

**Hint 3**  
Keep two counters: one that tells you how many books are currently on the shelf, and another that tells you how many slots you have already paid for.  
Each time the first counter catches up to the second, double the number of paid slots before you add the next book.

### STEP_5
# STEP 5: SUMMARY
- Heap allocation with `malloc`/`realloc` and the necessity of pairing every allocation with `free`
- Dynamic array management—tracking logical size vs. physical capacity and amortized growth strategies
- Multi-level memory ownership: allocating structs that contain pointers to further heap blocks
- Ownership discipline to prevent leaks (free inner objects before the outer container)
- Safe string duplication to avoid dangling pointers into temporary buffers
- Input-handling hygiene: consuming newlines and verifying `scanf` return values
- Separation of concerns: isolating display logic in a single-purpose function (`displayBook`) that takes a `const` pointer

### STEP_6
# STEP 6: TEST CASES

1. Happy path: add two books, list them, remove the last one, list again, then exit.  
   Expected: both books appear after the first listing, only the first after the second listing.

2. Attempt to remove from an empty shelf.  
   Expected: polite “No books to remove.” message; program keeps running.

3. Maximum capacity growth: add, say, nine short books in a row to trigger at least one doubling of the internal array.  
   Expected: all nine books list correctly; no crashes or leaks.

4. Non-numeric menu choice (e.g. “abc”) followed by valid choices.  
   Expected: “Invalid input. Try again.” prompt; program recovers and continues.

5. Very long single-word tokens (title/author) right up to the 255-char buffer limit.  
   Expected: correct storage and display; no buffer overrun.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "name": "Add two, list, remove last, list, exit",
      "input": "1\nC_Programming_Language\nKernighan\n1978\n1\nClean_Code\nMartin\n2008\n3\n2\n3\n4\n",
      "expected_keywords": ["C_Programming_Language Kernighan 1978", "Clean_Code Martin 2008", "C_Programming_Language Kernighan 1978"]
    },
    {
      "name": "Remove from empty shelf",
      "input": "2\n4\n",
      "expected_keywords": ["No books to remove"]
    },
    {
      "name": "Add nine books to trigger capacity growth",
      "input": "1\nB1\nA1\n2001\n1\nB2\nA2\n2002\n1\nB3\nA3\n2003\n1\nB4\nA4\n2004\n1\nB5\nA5\n2005\n1\nB6\nA6\n2006\n1\nB7\nA7\n2007\n1\nB8\nA8\n2008\n1\nB9\nA9\n2009\n3\n4\n",
      "expected_keywords": ["B1 A1 2001", "B9 A9 2009"]
    },
    {
      "name": "Handle non-numeric menu choice",
      "input": "abc\n1\nShort\nAuth\n2020\n3\n4\n",
      "expected_keywords": ["Invalid input", "Short Auth 2020"]
    },
    {
      "name": "Accept 255-character single-word title/author",
      "input": "1\nT"
      "expected_keywords": ["T followed by 240 more characters", "A followed by 240 more characters", "1999"]
    }
  ]
}
```

---

## Iteration 9 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  
**Topic:** Dynamic Memory Allocation (malloc, free)  

## Background Story  
The campus library is throwing away its old card-catalog drawers. Each drawer contains a variable number of index cards that list a book’s call number and title.  
You volunteer to digitize one drawer at a time. Your program will let the user type in as many cards as they like, store them in dynamic memory, and then re-print the whole catalog on request. When the user is done, the program must release every byte it allocated before exiting.

## Functional Requirements  
1. Read an arbitrary number of book entries from standard input until the user types the single word `END` as the call number.  
   - Each entry is two lines:  
     a. Call number (string, max 19 characters, may contain spaces).  
     b. Title (string, max 79 characters, may contain spaces).  
2. Store every entry in dynamically allocated memory; do **not** use global or fixed-size arrays.  
3. After input is complete, print the entire drawer back to the user in the same order, numbered starting at 1.  
4. After printing, free every block you allocated and exit gracefully.

## Simple Example  
**Input**  
```
PQ2678.I44 A16 1990  
L'Étranger  
END  
```

**Output**  
```
1. PQ2678.I44 A16 1990 - L'Étranger  
```

## CONSTRAINTS  
- You must represent each book with a `struct` that contains at least two members: the call number and the title.  
- You must allocate the `struct` itself and the two strings inside it with separate `malloc` calls (three allocations per book).  
- The only functions besides `main()` allowed are:  
  - `struct Book *readBook(void)` – reads one book from stdin, allocates memory, returns pointer or `NULL` if `END` is entered.  
  - `void displayCatalog(struct Book **catalog, int count)` – prints the entire catalog.  
- You are not allowed to use `realloc`; grow the catalog manually.  
- If a menu is implemented (not required here), it must contain an option to EXIT the program (type `0` to exit).

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * card_catalog.c
 *
 * Digitizes one library drawer: reads any number of book entries,
 * stores them in dynamic memory, and reprints them on request.
 * Every malloc() is matched by a free().
 *
 * Build:  gcc -std=c11 -Wall -Wextra -pedantic card_catalog.c -o card_catalog
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CALL_LEN 19          /* max length of call number INCLUDING '\0' */
#define TITLE_LEN 79         /* max length of title INCLUDING '\0'      */

/* -------- data structure -------- */
struct Book {
    char *call_no;  /* dynamically allocated string */
    char *title;    /* dynamically allocated string */
};

/* -------- function prototypes -------- */
struct Book *readBook(void);
void displayCatalog(struct Book **catalog, int count);
void freeCatalog(struct Book **catalog, int count);

/* ----------------------------------------------------------- */
int main(void)
{
    int capacity = 2;                 /* initial length of pointer array */
    int count = 0;                    /* how many books we have so far */
    struct Book **catalog = malloc(capacity * sizeof *catalog);
    if (!catalog) {
        perror("malloc");
        return EXIT_FAILURE;
    }

    /* -------- READ DATA -------- */
    while (1) {
        if (count == capacity) {
            /* manual grow (no realloc allowed) */
            int new_capacity = capacity * 2;
            struct Book **tmp = malloc(new_capacity * sizeof *tmp);
            if (!tmp) {
                perror("malloc");
                freeCatalog(catalog, count);
                return EXIT_FAILURE;
            }
            for (int i = 0; i < count; ++i) tmp[i] = catalog[i];
            free(catalog);              /* free old pointer block only */
            catalog = tmp;
            capacity = new_capacity;
        }

        struct Book *b = readBook();
        if (!b) break;                  /* user typed END */
        catalog[count++] = b;
    }

    /* -------- PRINT DATA -------- */
    displayCatalog(catalog, count);

    /* -------- CLEAN UP -------- */
    freeCatalog(catalog, count);
    return EXIT_SUCCESS;
}

/* ----------------------------------------------------------- */
/* Reads one book from stdin.
 * Returns pointer to struct Book (3 mallocs) or NULL on END. */
struct Book *readBook(void)
{
    char call_buf[CALL_LEN];
    if (!fgets(call_buf, sizeof call_buf, stdin)) {
        return NULL;                    /* EOF or error */
    }

    /* Strip trailing newline if present */
    size_t call_len = strlen(call_buf);
    if (call_len && call_buf[call_len - 1] == '\n')
        call_buf[--call_len] = '\0';

    /* Sentinel check */
    if (strcmp(call_buf, "END") == 0)
        return NULL;

    /* Read title */
    char title_buf[TITLE_LEN];
    if (!fgets(title_buf, sizeof title_buf, stdin))
        return NULL;

    size_t title_len = strlen(title_buf);
    if (title_len && title_buf[title_len - 1] == '\n')
        title_buf[--title_len] = '\0';

    /* Allocate struct Book */
    struct Book *b = malloc(sizeof *b);
    if (!b) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    /* Allocate and copy strings */
    b->call_no = malloc(call_len + 1);
    b->title   = malloc(title_len + 1);

    if (!b->call_no || !b->title) {
        free(b->call_no);
        free(b->title);
        free(b);
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    strcpy(b->call_no, call_buf);
    strcpy(b->title,   title_buf);
    return b;
}

/* ----------------------------------------------------------- */
/* Prints catalog in user-friendly form */
void displayCatalog(struct Book **catalog, int count)
{
    for (int i = 0; i < count; ++i)
        printf("%d. %s - %s\n", i + 1, catalog[i]->call_no, catalog[i]->title);
}

/* ----------------------------------------------------------- */
/* Frees all memory: each string, each struct, and the pointer array */
void freeCatalog(struct Book **catalog, int count)
{
    for (int i = 0; i < count; ++i) {
        free(catalog[i]->call_no);
        free(catalog[i]->title);
        free(catalog[i]);
    }
    free(catalog);
}
```

### STEP_3
# STEP 3: EXPLANATION

Imagine the drawer of cards is a pile you can’t count ahead of time.  
You therefore need a data structure that can grow, and every single byte you reserve must be handed back to the operating system when you are done.  
The program does this with three different kinds of allocations that cooperate.  
Below is the reasoning, not the syntax, because once the “why” is clear the code becomes almost obvious.

--------------------------------------------------------
1. What has to live in dynamic memory?
--------------------------------------------------------
- Each book has TWO strings (call number and title) whose sizes you only discover at run time (the user may type 5 or 25 characters).  
- You also need a place to store the book itself (the struct).  
  Therefore every book ⇒ 3 separate malloc() calls (strings + struct).  

- You also need an array that can point to *any* number of such books.  
  A fixed array int a[100]; would break the “arbitrary number” rule, so that array is also dynamic.  

Hence the mental picture:
```
catalog  --> [0] --> Book-struct -->  call_no  --> "PQ2678.I44 A16 1990\0"
       ^       |                               title    --> "L'Étranger\0"
       |       |
       |       [1] --> Book-struct --> ...
       |
       (the pointer block itself is also malloc’ed)
```

--------------------------------------------------------
2. Why grow the pointer block manually?
---------------------------------------------------------
You are not allowed realloc(), so you fake it:
- Keep capacity (how many slots you *own*) and count (how many you *used*).  
- When count == capacity, allocate a brand-new block twice as large, copy the old pointers into it, free the old block.  

This is exactly what realloc() does internally, but doing it by hand proves you understand that only the *pointer block* is replaced; the structs and strings themselves stay untouched.  

--------------------------------------------------------
3. Ownership strategy – who frees what?
---------------------------------------------------------
Every pointer returned by malloc() must eventually be passed to free().  
The function freeCatalog() walks backwards through the structure above:

```
for each book
    free(call_no_string)
    free(title_string)
    free(book_struct)
free(pointer_array)
```

The order matters: you must not free the struct before the strings it owns, and you must not free the pointer block before you have freed every book it points to.

--------------------------------------------------------
4. Reading one book carefully
----------------------------------------------------------
stdin is line-oriented.  
- We read the call number with fgets().  
  - If the line equals "END" we return NULL, which the caller treats as “no more books”.  
- We immediately read the next line as the title.  
- Only after we have both pieces do we allocate memory, so we know the exact number of bytes needed.  
  - +1 for the terminating '\0' that C strings require.  
  - We never strcpy() into a buffer until we have checked that malloc succeeded.  

--------------------------------------------------------
5. Error handling philosophy
---------------------------------------------------------
malloc() can fail (return NULL).  
Two possible reactions exist:
1. Propagate the error upwards (return NULL or an error code) and let the caller decide.  
2. Treat it as a fatal situation and exit(EXIT_FAILURE).  

Inside readBook() we adopt option 2: if we have already partially allocated a book we free whatever we got so far, print a message, and abort the whole program.  
In main(), when the catalog’s pointer block allocation fails we also give up, but first we call freeCatalog() to release any books we had already stored.  
That way the program never leaks memory, even on the unhappy path.

--------------------------------------------------------
6. Putting it together – the lifetime timeline
----------------------------------------------------------
1. malloc the initial pointer block (capacity 2 – arbitrarily small, grows quickly).  
2. while user keeps typing:
      readBook()  → mallocs 3 objects, returns pointer.  
      store pointer in array; grow array when necessary.  
3. displayCatalog() – read-only, no allocations.  
4. freeCatalog() – walks backwards, frees everything.  
5. return EXIT_SUCCESS;  // all bytes accounted for

--------------------------------------------------------
7. Take-away lessons
---------------------------------------------------------
- Dynamic memory is not mysterious; it is just bytes you borrow and give back.  
- Split the problem into “objects” and “containers of pointers to objects”; allocate each separately.  
- Always pair every malloc() with a free() in the opposite order.  
- Growing an array without realloc() is a five-line exercise once you grasp the idea of copying pointers, not pointed-to data.  

Once these concepts feel natural, malloc/free cease to be “bug generators” and become the tools that let your program adapt to whatever size input the user has in store.

### STEP_4
# STEP 4: HINTS

**Hint 1 – The Big Picture:**  
Think of the drawer as a pile of index cards whose size you won’t know until the last card is typed.  
Instead of reserving a fixed-size shelf, imagine keeping a growing stack of “boxes” (each box holds one card).  
Your job is to create new boxes whenever you need them and label them so you can find them later, then dismantle the whole stack in reverse order when you’re done.

**Hint 2 – Where to Grow:**  
You are required to hold “any number” of boxes, so the container that points to those boxes must itself be able to expand.  
Since you can’t ask the system to stretch it automatically, plan to allocate a *new*, larger container, move the old labels into it, and discard the old container—but leave the boxes themselves untouched during this move.

**Hint 3 – First Concrete Step:**  
Start by describing a single card with a structure that contains only *pointers* to the two pieces of text (call number and title); do **not** store the text inside the structure.  
Then write a helper that reads one card, allocates space for the text exactly as long as what the user typed, and returns either a pointer to that new structure or a special “stop” value when the call number is the single word END.

### STEP_5
# STEP 5: SUMMARY
- Dynamic allocation trio: allocating a struct, its member strings, and an expandable pointer array with malloc
- Manual growth of an array without realloc by allocating a new block, copying references, and freeing the old container
- Ownership and lifetime discipline: ensuring every malloc has a matching free in reverse order to prevent leaks
- Safe string input with fgets, newline removal, and sentinel value detection ("END")
- Structured error handling when malloc fails, including partial cleanup and program termination
- Separation of concerns through single-purpose functions: read, display, and free
- Hands-on experience with pointers-to-pointers (Book **) to manage collections of dynamically created objects

### STEP_6
# STEP 6: TEST CASES

1. **Common case – two books**  
   Input contains two complete, normal entries followed by the sentinel.  
   Expected output shows both books numbered in order.

2. **Single book (minimum usable input)**  
   Exactly one valid book before the sentinel.  
   Tests that the grow logic does not break when count = 1 and capacity is initial 2.

3. **Empty catalog (sentinel first)**  
   User types “END” as the first call number.  
   Expected output is nothing except the normal prompt; program must exit cleanly without crashes or leaks.

4. **Long strings at maximum limits**  
   Call number 18 visible chars plus `\0`, title 78 visible chars plus `\0`.  
   Verifies buffer boundaries, absence of off-by-one writes, correct trimming of newline.

5. **malloc failure simulation (invalid input scenario)**  
   Not an input string—test script sets environment limit so small that the first malloc in readBook must fail.  
   Program must free any partial allocations, print an error, and return EXIT_FAILURE.

```json
{
  "exit_command": "0",
  "test_suite": [
    {
      "input": "PQ2678.I44 A16 1990\nL'Étranger\nQA76.73.C15 K65 2020\nThe C Programming Language\nEND",
      "expected_keyword": "1. PQ2678.I44 A16 1990 - L'Étranger"
    },
    {
      "input": "PR6039.O32 L68 1997\nLife of Pi\nEND",
      "expected_keyword": "1. PR6039.O32 L68 1997 - Life of Pi"
    },
    {
      "input": "END",
      "expected_keyword": ""
    },
    {
      "input": "ABCDEFGHIJKLMNOPQR\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrst\nEND",
      "expected_keyword": "1. ABCDEFGHIJKLMNOPQR - abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrst"
    },
    {
      "input": "_LIMIT_MALLOC_=1\nABCDEFGHIJKLMNOPQR\nSome Title",
      "expected_keyword": "malloc"
    }
  ]
}
```

---

## Iteration 10 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Context  
The university’s robotics club keeps its spare parts in an old storage room. Every week the treasurer buys a few new items and writes down their cost and quantity on sticky notes. At the end of the month the club wants to see how much money is tied up in each part and in total. You have volunteered to write a tiny inventory tracker that can grow as new parts arrive.

## Requirements  
1. The program must start by asking how many *different* parts were bought this month (0 ≤ n ≤ 100).  
2. It must then allocate exactly enough dynamic memory to store information for those n parts.  
3. For every part the program must read:  
   - an integer ID (positive, unique within this run)  
   - a string of up to 29 printable characters for the part name (no spaces)  
   - an integer quantity (≥ 0)  
   - a double unit price (≥ 0)  
4. After all parts are stored, the program must print:  
   - a neat table listing ID, name, quantity, unit price, and total cost (=quantity×price) for every part  
   - the grand total money tied up in inventory (sum of all total costs)  
5. Before exiting the program must free every byte of dynamically allocated memory.

## Example run  
```
How many parts? 3
Part 1: id name qty unitPrice
101 wheels 4 2.50
Part 2: id name qty unitPrice
102 servo 10 5.00
Part 3: id name qty unitPrice
103 frame 1 12.00
ID   Name     Qty  Price  Total
101  wheels   4    2.50   10.00
102  servo   10    5.00   50.00
103  frame    1   12.00   12.00
Grand total: 72.00
```

### CONSTRAINTS  
- You must define a single `struct` called `Part` that contains the four data fields described above.  
- All parts must be stored in a single dynamically allocated array obtained with one call to `malloc`.  
- You must provide a function `void displayPart(const struct Part *p)` that prints the details of one part in the format shown in the example (one line of the table).  
- The only other function allowed besides `main` is `displayPart`.

### STEP_2
# STEP 2: SOLUTION
```c
/*
 *  Robotics Club Inventory Tracker
 *  C11, single malloc, single struct, one helper function
 */

#include <stdio.h>
#include <stdlib.h>

#define MAX_NAME 29          /* longest allowed part name */

/* --------- DATA STRUCTURE ---------------------------------------------- */
struct Part {
    int    id;               /* positive, unique within this run */
    char   name[MAX_NAME+1]; /* +1 for '\0' */
    int    qty;              /* ≥ 0 */
    double unitPrice;        /* ≥ 0 */
};

/* --------- HELPER FUNCTION -------------------------------------------- */
/*
 * Print one line of the table as specified:
 * ID Name Qty Price Total
 * Columns are left-aligned; numeric columns are padded minimally.
 */
void displayPart(const struct Part *p)
{
    /* %-Ns  -> left-align in N chars
       %d    -> integers
       %.2f  -> 2 decimals for money
    */
    printf("%-4d %-7s %-4d %-6.2lf %.2lf\n",
           p->id, p->name, p->qty, p->unitPrice,
           p->qty * p->unitPrice);
}

/* --------- MAIN PROGRAM ----------------------------------------------- */
int main(void)
{
    int n;                   /* number of different parts this month */
    printf("How many parts? ");
    if (scanf("%d", &n) != 1) {
        fprintf(stderr, "Input error.\n");
        return 1;
    }

    /* --- Validate requested size --------------------------------------- */
    if (n < 0 || n > 100) {
        fprintf(stderr, "Count must be between 0 and 100 inclusive.\n");
        return 1;
    }

    /* --- Allocate dynamic array (exactly n structs) -------------------- */
    struct Part *inventory = malloc((size_t)n * sizeof *inventory);
    if (!inventory) {      /* modern C: malloc returns NULL on failure */
        perror("malloc");
        return 1;
    }

    /* --- Read data ----------------------------------------------------- */
    for (int i = 0; i < n; ++i) {
        printf("Part %d: id name qty unitPrice\n", i + 1);

        /* read into a temporary locals to validate before storing */
        int    tmpId, tmpQty;
        char   tmpName[MAX_NAME+1];
        double tmpPrice;

        if (scanf("%d %29s %d %lf",
                  &tmpId, tmpName, &tmpQty, &tmpPrice) != 4)
        {
            fprintf(stderr, "Input format error for part %d.\n", i + 1);
            free(inventory);   /* always tidy up */
            return 1;
        }

        /* simple validation */
        if (tmpId <= 0 || tmpQty < 0 || tmpPrice < 0) {
            fprintf(stderr, "Invalid data for part %d (id, qty, price must be non-negative; id>0).\n", i + 1);
            free(inventory);
            return 1;
        }

        /* store into struct */
        inventory[i].id        = tmpId;
        inventory[i].qty       = tmpQty;
        inventory[i].unitPrice = tmpPrice;

        /* copy name safely */
        for (int c = 0; c <= MAX_NAME; ++c) {
            inventory[i].name[c] = tmpName[c];
            if (tmpName[c] == '\0') break;
        }
    }

    /* --- Produce report ------------------------------------------------ */
    printf("ID   Name     Qty  Price  Total\n");
    double grandTotal = 0.0;

    for (int i = 0; i < n; ++i) {
        displayPart(&inventory[i]);
        grandTotal += inventory[i].qty * inventory[i].unitPrice;
    }

    printf("Grand total: %.2lf\n", grandTotal);

    /* --- Release memory ------------------------------------------------ */
    free(inventory);
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION  
*(A walk-through for students who already know “the C alphabet” but are still uncertain about `malloc`/`free`.)*

---

### 0. Philosophical Start – why dynamic memory?
- If you already know that you need **exactly 100 ints** you can safely write  
  `int a[100];` – the compiler is happy.
- But if the size is **only known at run-time** you must ask the operating system to *lend* you the bytes while your program is running.  
  That run-time request is what `<stdlib.h>` offers with `malloc`, `calloc`, `realloc`; giving the memory back is done with `free`.

- **Rule of thumb**:  
  “If the size is in a variable → use dynamic memory.  
  If the size is a compile-time constant → a fixed array is fine.”

---

### 1. Reading `n` and validation
```c
scanf("%d",&n);
if(n<0||n>100) …
```
We first read how many different parts were bought this month.  
A negative or huge value makes no sense, therefore we reject it *before* we allocate anything.  
This prevents us from requesting an absurd amount of memory.

---

### 2. One single `malloc` – the core idea
```c
struct Part *inventory = malloc((size_t)n * sizeof *inventory);
```
Let’s dissect the expression:

- `sizeof *inventory`  
  `inventory` has type `struct Part *`.  
  `*inventory` is therefore one ordinary `struct Part`.  
  The expression gives the byte size of a single structure, avoiding magic numbers.

- `(size_t)n * …`  
  `malloc` wants an amount in bytes; we must multiply *element count* by *element size*.  
  Casting `n` to `size_t` avoids a signed/unsigned mismatch warning.

- **Return value**  
  `malloc` returns either:
  - a valid pointer to freshly reserved, *uninitialised* memory, or  
  - `NULL` when no memory is available.  
  A production program **must** test for `NULL` otherwise the first access will crash.

We keep the returned address in `inventory`; it behaves exactly like an array name:  
`inventory[i]` is legal for `0 … n-1`.

---

### 3. Filling the structures
We read into temporary variables first.  
This lets us validate every field **before** we copy it into the heap block.  
If something is wrong we can already call `free(inventory)` and abort – no memory is leaked.

---

### 4. Printing – helper function meets pointer arithmetic
```c
void displayPart(const struct Part *p)
```
The function receives **one address** of a structure.  
Inside we use pointer notation (`p->id`) because `p` is not an array element but a single object.  
The parameter is `const` because `displayPart` promises not to modify the data.

`main` drives the loop:
```c
for(int i=0;i<n;++i) displayPart(&inventory[i]);
```
`&inventory[i]` passes the address of the `i`-th structure – exactly what `displayPart` expects.

---

### 5. Computing money on the fly
We accumulate `qty*price` in a local `double grandTotal`.  
Money values are printed with `%.2lf` so that we always show two decimals – robotics treasurers do not like fractions of a cent.

---

### 6. Giving the memory back
```c
free(inventory);
```
`free` **needs the exact address returned by `malloc`**.  
Because we obtained the whole array with *one* `malloc`, we release it with *one* `free`.  
After `free` the pointer value becomes invalid – we do not use it again.

---

### 7. Big ideas you should internalise
- **Ownership**: whoever allocates memory is responsible for returning it.  
  In `main` we own the array – therefore `main` must `free` it.

- **Single malloc ↔ single free**.  
  The inverse strategy – allocate per part inside a loop – would require as many `free`s as `mallocs`, complicating error paths tremendously.  That is why the task statement explicitly requests *one* allocation.

- **Fail fast, fail clean**: always check both *user input* and *memory allocation*.  
  When either fails, release already acquired resources before you `return` or `exit`.

With these principles the program remains short, safe, and leak-free even in the presence of bad input or an exhausted machine.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the sticky-note collection as a single, grow-only list whose length you know before you ever store the first note.  
Ask yourself: “If I knew the final count, how many shoeboxes would I reserve so that every note has its own compartment, with no wasted space?”

**Hint 2**  
C lets you reserve that exact number of compartments in one operation; the name of the operation rhymes with “call-lock,” and it hands you the first key to the aisle.  
Remember: if the warehouse is out of space, the key is a special “no-key” value—always check your key before you walk in.

**Hint 3**  
Once you’ve confirmed the key is valid, treat it as if it opens an array that already exists.  
Your next task is a loop that, for each compartment, reads four facts off the terminal, stores them in the current compartment, and keeps a running tally of money tied up.

### STEP_5
# STEP 5: SUMMARY
- Dynamic allocation of an exact-sized object array with a single `malloc`
- Safe validation of `malloc`'s return value and immediate cleanup on failure
- Struct design and packing related fields into one composite type
- Relationship between pointer notation (`->`) and array-element notation (`.`) for structs
- Consolidated `free` that mirrors the single `malloc`, preventing memory leaks
- Using `const`-qualified pointers to enforce read-only access in helper functions
- Line-by-line input validation before storing data into heap-allocated structures
- Running totals and simple monetary formatting with two-decimal precision

### STEP_6
# STEP 6: TEST CASES

**TC-1 Happy Path, 3 parts**  
Input contains the exact sample data.  
Expect the three-row table plus grand-total 72.00.

**TC-2 Empty inventory (n = 0)**  
User enters 0, so no part data follow.  
Expect immediate "Grand total: 0.00" and clean exit.

**TC-3 One luxury item**  
n = 1 followed by  
ID 9 name "gold" qty 1 price 1000.00  
Expect one row whose total is 1000.00.

**TC-4 Invalid negative count**  
User types –5.  
Expect error message and program termination; no table printed.

**TC-5 Invalid part data**  
n = 2  
Part 1 is valid;  
Part 2 has negative quantity.  
Expect error message directly after the bad part line, memory freed, program exit.

```json
{
  "exit_command": "4",
  "test_suite": [
    {"input": "3\n101 wheels 4 2.50\n102 servo 10 5.00\n103 frame 1 12.00", "expected_keyword": "Grand total: 72.00"},
    {"input": "0", "expected_keyword": "Grand total: 0.00"},
    {"input": "1\n9 gold 1 1000.00", "expected_keyword": "1000.00"},
    {"input": "-5", "expected_keyword": "Count must be between 0 and 100 inclusive."},
    {"input": "2\n100 ok 5 1.00\n101 bad -3 2.00", "expected_keyword": "Invalid data"}
  ]
}
```

---

## Iteration 11 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

**Background Story**  
You are the night-shift manager of the campus “Print-Anywhere” shop.  
Students bring USB sticks with PDFs; each PDF must be stored in memory until the printer is free.  
Because RAM is tight, you will dynamically allocate exactly the number of bytes each PDF needs and free them as soon as the job is printed.  
Your supervisor has asked for a tiny C program that keeps track of the current print queue.

**Task**  
Write a program that:

1. Keeps a linked list of pending print jobs.  
2. Each job holds:  
   - an `id` (positive int, unique inside one run)  
   - a `name` (one-word string ≤30 chars)  
   - the PDF’s `size` in bytes (positive int)  
   - a pointer to the next job.  
3. Provides a text menu with the following choices:  
   1. Add new job  
   2. Print (remove) the first job  
   3. Display queue  
   4. Exit (terminates the program)  

4. On “Add new job” the program must:  
   - read id, name, size  
   - allocate a new struct node (`malloc`)  
   - append it to the tail of the list.  

5. On “Print” the program must:  
   - remove the head job, print its id & name  
   - free its memory (`free`)  
   - if the queue is empty, print “Queue empty”.  

6. On “Display queue” print the id, name and size of every job in order, one per line.  

**Simple Example Session (user input after ‘> ’)**  
```
1
> 101 report.pdf 24000
1
> 102 slides.pdf 1500000
3
101 report.pdf 24000
102 slides.pdf 1500000
2
Printing: 101 report.pdf
2
Queue empty
4
```
The program terminates.

### CONSTRAINTS  
- The primary data entity must be represented by a `struct`.  
- All dynamic allocations (`malloc`) and de-allocations (`free`) must be explicit; no global arrays.  
- The logic that prints the details of exactly one job must be placed in a function called `displayJob`.  
- The menu option to EXIT the program is `4`.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Print-Anywhere Queue Manager
 * Implements a FIFO job queue for PDF files using a dynamically-allocated
 * singly-linked list. Each node holds a job id, filename, size and a pointer
 * to the next node. The program provides an interactive text menu that
 * lets the user add, print (remove), display, and finally exit the program.
 *
 * The code follows C11, performs malloc/free checks, and avoids global arrays.
 * Compile with: gcc -std=c11 -Wall -Wextra -pedantic queue.c -o queue
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* --- DATA STRUCTURE ----------------------------------------------- */

#define MAX_NAME_LEN 30

typedef struct Job {
    int id;                           /* positive, unique in a single run */
    char name[MAX_NAME_LEN + 1];    /* null-terminated one-word string <=30 */
    int size;                         /* bytes, strictly positive */
    struct Job *next;                 /* pointer to next job in queue */
} Job;

static Job *head = NULL;    /* first job in queue (NULL means empty) */
static Job *tail = NULL;   /* last  job in queue */

/* --- HELPER PROTOTYPES -------------------------------------------- */

/* Allocate a new Job.  Returns NULL on malloc failure, else the pointer */
static Job *createJob(int id, const char *name, int size);

/* Append a new node to tail (or create first if empty) */
static void enqueue(Job *node);

/* Remove and return head node, or return NULL if empty */
static Job *dequeue(void);

/* Print an arbitrary job onto a single line: id name size */
static void displayJob(const Job *job);

/* Release *all* allocated memory and reset head/tail to NULL */
static void freeAllJobs(void);

/* --- MAIN + MENU LOOP --------------------------------------------- */

int main(void)
{
    int running = 1;  /* keep looping until user chooses EXIT */

    /* print the menu at least once */
    puts("Print-Anywhere queue manager");
    puts("  1  Add new job");
    puts("  2  Print first job");
    puts("  3  Display queue");
    puts("  4  Exit");

    while (running) {
        printf("\nEnter choice (1-4)> ");
        char line[64];
        if (!fgets(line, sizeof line, stdin))
            break;                 /* EOF or read error */

        int choice = line[0] - '0';
        switch (choice) {
        case 1: { /* -- ADD ------------------------------------------ */
            int id, size;
            char name[MAX_NAME_LEN + 1];

            printf("Enter id name size> ");
            if (scanf("%d %30s %d", &id, name, &size) != 3) {
                puts("Invalid input.  Expected three items: id name size");
                /* flush stdin so next prompt is clean */
                int c; while ((c = getchar()) != '\n' && c != EOF) /*nop*/;
                break;
            }
            /* flush newline that scanf left behind */
            int dummy; while ((dummy = getchar()) != '\n' && dummy != EOF) /*nop*/;

            if (id <= 0 || size <= 0) {
                puts("ID and size must be positive.");
                break;
            }
            Job *newJob = createJob(id, name, size);
            if (!newJob) {             /* malloc failed */
                puts("Error allocating new job.");
            } else {
                enqueue(newJob);
            }
            break;
        }
        case 2: { /* -- PRINT --------------------------------------- */
            Job *first = dequeue();
            if (first) {
                printf("Printing: ");
                displayJob(first);

                /* free the memory the job was occupying */
                free(first);
                first = NULL;
            } else {
                puts("Queue empty");
            }
            break;
        }
        case 3: { /* -- DISPLAY ------------------------------------ */
            for (const Job *cur = head; cur; cur = cur->next) {
                displayJob(cur);
            }
            if (!head)
                puts("(Queue empty)");
            break;
        }
        case 4: /* -- EXIT ------------------------------------------ */
            running = 0;
            break;
        default:
            puts("Unknown choice. Try 1-4.");
            break;
        }
    }

    /* --- CLEAN SHUTDOWN ------------------------------------------ */
    freeAllJobs();
    return 0;
}

/* --- FUNCTION DEFINITIONS --------------------------------------- */

/* Allocate a new Job and initialise all fields. */
static Job *createJob(int id, const char *name, int size)
{
    Job *j = malloc(sizeof *j);
    if (!j)
        return NULL;

    j->id   = id;
    j->size = size;
    memcpy(j->name, name, MAX_NAME_LEN + 1);
    j->next = NULL;

    return j;
}

/* Append a node to the tail (O(1) time using tail pointer) */
static void enqueue(Job *node)
{
    if (!head) {           /* empty queue */
        head = tail = node;
    } else {
        tail->next = node;
        tail = node;
    }
}

/* Remove and return the head node, adapting head/tail */
static Job *dequeue(void)
{
    if (!head)
        return NULL;

    Job *oldHead = head;
    /* move head to next node */
    head = head->next;

    /* if queue becomes empty, make sure tail is also NULL */
    if (!head)
        tail = NULL;

    oldHead->next = NULL;    /* disconnect old head cleanly */
    return oldHead;
}

/* Print exactly one job (as mandated) */
static void displayJob(const Job *job)
{
    if (!job) return;
    printf("%d %s %d\n", job->id, job->name, job->size);
}

/* Free every node still in the queue */
static void freeAllJobs(void)
{
    Job *cur = head;
    while (cur) {
        Job *next = cur->next;
        free(cur);
        cur = next;
    }
    head = tail = NULL;
}
```

### Key Implementation Notes

1. **Memory Safety**
   - `malloc` failures are handled (`createJob` returns `NULL` on failure).
   - `Head` is only advanced after a successful `dequeue`.
   - `free` is performed immediately after printing a job and in the exit path.

2. **No Memory Leaks**
   - `freeAllJobs` is invoked right before `main` exits to clean up any remaining nodes.

3. **Constraints Compliance**
   - Primary entity is `struct Job`, dynamically allocated.
   - Only one statically declared array (`line`) exists to parse user input; nothing used for queue storage.
   - `displayJob` is the single function responsible for printing job details.

4. **Correct Pointer Maintenance**
   - Whenever `head` is advanced, `tail` is corrected if the queue goes empty.
   - `head/tail` are private file-static variables; no global arrays are used.

5. **Input Robustness**
   - Mixed `scanf/fgets` usage is protected against leftover new-lines.
   - Malformed input leads to a clean flush and retry without hanging on subsequent menu loops.

The code can be compiled and run to interactively add/print jobs exactly as described in the sample dialogue.

### STEP_3
# STEP 3: EXPLANATION

Think of the program as a tiny **text-based todo list** that stores each printing job only as long as it has to, then throws it away.

The tricky part for most beginners is **dynamic memory** - deciding when to ask for more space from the OS, and when to give it back.  
Below is a "think-aloud" tour of the whole process that shows *why* we build the list the way we do, and how `malloc/free` are used correctly.

---

### 1. What is a *linked list*, and why not just an array?

- Arrays:
  - Need an **upper-bound size** you decide at compile time (e.g. `Job jobArray[1000];`)
  - If you run out of slots you are stuck, and
  - Removing the **first item** means you must move every remaining element one step left, which is O(N)

- Linked-lists:
  - Each element (node) is allocated **on demand** (one malloc per node) - you never predict size
  - Removing the first element takes O(1) time - you just *rewire* the list, no copying
  - You lose random access, but for a print queue you only care about the head, so that is fine

→ Because the assignment forces *no global arrays* and tight RAM, a linked list + malloc/free is the natural choice.

**Key vocabulary:**  
`malloc` - asks for heap memory  
`free` - gives it back (heap bookkeeping is like returning a library book)

---

### 2. Representation of one job: struct Job

```c
typedef struct Job {
    int  id;
    char name[MAX_NAME_LEN + 1];  // one extra byte for '\0'
    int  size;
    struct Job *next;             // "self-referencing" pointer
} Job;
```

Every node knows (a) its payload, (b) how to reach the next node.

The last node holds `next == NULL`.

---

### 3. How do we remember the ends of the queue?

Two *file-scope* (static) pointers:

```c
static Job *head, *tail;
```

- `head` always points at the node that will **leave** the list next  
- `tail` always points at the node that last entered the list

Keeping `tail` lets us *append* in O(1) instead of traversing from `head` every time ("cheap FIFO" trick).

**Diagram (imagine paperclips):**

```
Queue content:  A -> B -> C                NULL=end of list
               ↑            ↑
              head         tail
```

---

### 4. Adding a Job

4.1 Parse user words into temporary variables  
4.2 Call `createJob`

```c
Job *node = malloc(sizeof *node);
```

Why `sizeof *node` not `sizeof(Job)`? Because it is safer - change `node`'s type and the size follows automatically.  
The return value of `malloc` must be checked! NULL means "out of memory", so `createJob` returns NULL. The caller aborts gracefully instead of running on a NULL.

4.3 Put new node on the queue using `enqueue`

```c
if queue empty: head = tail = node;
else: tail->next = node; tail = node;
```

We never overwrite existing nodes; we *append*. After insertion:

```
previous-tail         new-tail
        \             /\
   ...-> * -> NULL    * -> NULL
             now->next becomes pointer
```

---

### 5. Printing (and therefore deleting) a Job

The user chooses menu 2.

5.1 Call `dequeue` - returns the node pointed by `head` (can return NULL if list is empty)  
5.2 Print its fields, then immediately:

```c
free(jobThatWasJustPrinted);
```

If we forgot this call, we would leak the bytes forever until the program ends - every PDF node would stay in RAM!

**Edge-cases handled:**
- Empty list → "Queue empty"  
- Single element: after removing, head becomes NULL ⇒ we must also mark `tail = NULL`. Otherwise tail would be a *dangling pointer* - still pointing to memory we freed.

---

### 6. Displaying the queue

Scan from `head` through `next` pointers until NULL.  
Per assignment, we must call `displayJob` for each struct - no ad-hoc printing in switch.

No allocation happens here - no malloc/free; we merely read. So this function can be made `const Job*`.

---

### 7. Exiting cleanly

The user picks 4.  
Before returning from `main` we call:

```c
freeAllJobs();
```

```
Job *cur = head;
while(cur){
    Job *next = cur->next;
    free(cur);
    cur = next;
}
```

A loop frees each node *one at a time*. You cannot `free(head)` and expect the next members to know how many exist - C's runtime does NOT track list length; **you must walk and free**. By the time the OS regains control, no bytes have been lost.

---

### 8. Common malloc/pointer pitfalls avoided

**Pitfall 1:** Forgetting to check `malloc`
- In textbook code you see `ptr = malloc(...); ptr->field = x;` immediately.  
  If malloc failed, you dereference NULL → segmentation fault.  
  Our code checks and aborts that job gracefully.

**Pitfall 2:** Forgetting free
- Each job is allocated once and freed exactly once - no leaks.  
  The queue lifetime is *finite*, managed centrally.

**Pitfall 3:** Dangling pointers (use-after-free)
- Once we `free(job)` the value of `job` is still sitting in a local variable  
- We immediately set `job = NULL;` (to stop accidental double-free) or reuse the slot only after we allocate fresh memory.  
  When whole list is emptied, we update *both* `head = tail = NULL;`

**Pitfall 4:** sizeof(pointer) vs sizeof(struct)
- `sizeof(ptr)` returns pointer size (normally 8 bytes on 64-bit).  
  We always write `sizeof *ptr` to get the size of the object *pointed at*.

---

### 9. Summary mental model

**Heap:** big block of RAM, *segment* owned by your program.  
Calling `malloc` cuts you a slice from that block; `free` hands it back.

**Linked list:** each slice carries its own "address label" pointing to the next slice.  
Your program only knows *one* address to start (`head`); it follows links, adds new slices when asked to enqueue, removes first link when asked to dequeue and frees that slice right away.

If you remember: allocate when you genuinely need **another** node, free **exactly** when done, and keep `head/tail` up to date, then malloc/free become just plumbing - the queue logic the program is built around is clean and leak-free.

### STEP_4
# STEP 4: HINTS

**Hint 1 (big-picture nudge)**  
Think of the queue as a chain of paper-clips: each clip holds a *job* and has an *eyelet* that can hook to the next clip.  
You never keep the clips in a box of fixed size; instead you add a brand-new clip whenever a job arrives and unhook the front one when the printer is free. What does that tell you about when to ask the OS for memory and when to release it?

---

**Hint 2 (spotlight on a key C feature)**  
There is a library call whose only job is to claim a block of raw bytes from the heap and hand you its address, and there is a companion call that returns that block so it can be reused.  
Whenever you remove a job from the front of the chain, you must remember to invoke the companion call before you lose the address; otherwise the bytes stay locked until your program ends.

---

**Hint 3 (logic-building steer)**  
Sketch out three helper ideas on paper first:  
a) something that creates and fills a single new node,  
b) something that appends that node to the *end* of your chain without walking the whole list, and  
c) something that detaches and disposes of the node at the very *front*.  
Start by getting part (a) working and tested with manual hard-coded values before you ever build the menu loop.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory allocation with malloc / free in a real-world context
- Singly-linked-list creation, traversal, insertion at tail, and deletion from head
- Queue (FIFO) abstract data type implemented via pointers
- Safe memory-handling: checking malloc return values and preventing leaks
- Modular program design: separating list logic into helper functions
- Const-correctness and pointer hygiene to avoid dangling references
- Input validation and basic interactive menu loops in C

### STEP_6
# STEP 6: TEST CASES

1) **Happy-path sequence** – add two jobs, display the queue, print the first, print the second, exit  
2) **Empty-queue print attempt** – immediately choose “Print” (menu 2)  
3) **Empty queue display** – choose “Display queue” (menu 3) when nothing is present  
4) **Invalid choice handling** – enter an out-of-range selection such as 9  
5) **Malformed add data** – attempt to add a job with negative id (should reject)  

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\n101 report.pdf 24000\n1\n102 slides.pdf 1500000\n3\n2",
      "expected_keyword": "101 report.pdf"
    },
    {
      "input": "2",
      "expected_keyword": "Queue empty"
    },
    {
      "input": "3",
      "expected_keyword": "(Queue empty)"
    },
    {
      "input": "9",
      "expected_keyword": "Unknown choice"
    },
    {
      "input": "1\n-5 badfile 1000\n1\n103 file.pdf 200\n2",
      "expected_keyword": "103 file.pdf"
    }
  ]
}
```

---

## Iteration 12 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

**Topic:** Dynamic Memory Allocation (malloc, free)

**Background Story**  
You are a volunteer inventory keeper for a small neighborhood food‐bank.  
Every week, donors drop off bags of non‐perishable food.  
Each bag is labeled with a unique ID (positive integer) and the net weight (in kilograms).  
You need a simple program that keeps track of these bags in memory, allowing you to add new bags, delete a bag by ID, and list the current inventory.  
Because the number of bags changes every week, you must store them in dynamically‐allocated memory.

**Program Requirements**  
1. On startup, the program must start with an empty inventory.  
2. Implement a text menu with the following options:  
   1) Add a new bag  
   2) Delete a bag by ID  
   3) List all bags  
   4) Exit  
3. “Add a new bag” must prompt for a unique ID (positive int) and a weight (positive double).  
   - Reject duplicate IDs and ask again.  
4. “Delete a bag by ID” must free the memory of that bag and compact the array.  
5. “List all bags” must print each bag’s ID and weight on its own line, in the order stored.  
6. The program must release all dynamically‐allocated memory before exiting.

**Simple Example Run**  
```
=== Food-Bank Inventory ===
1) Add bag
2) Delete bag
3) List bags
4) Exit
Choice: 1
Enter bag ID: 101
Enter weight (kg): 3.5
Bag added.

Choice: 1
Enter bag ID: 102
Enter weight (kg): 2.0
Bag added.

Choice: 3
Bag ID: 101, Weight: 3.5 kg
Bag ID: 102, Weight: 2.0 kg

Choice: 2
Enter bag ID to delete: 101
Bag deleted.

Choice: 3
Bag ID: 102, Weight: 2.0 kg

Choice: 4
Good-bye!
```

### CONSTRAINTS
1. Must use a `struct` to represent each bag.  
2. Logic for displaying the details of ONE specific bag must be in a function called `displayBag`.  
3. The solution must be implemented with a single function besides `main()` (that one function may do all operations or you may call it with different flags; `displayBag` is allowed as a separate tiny helper).  
4. Menu option 4 is the required EXIT keyword.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Food-Bank Inventory keeper
 *
 * Simple menu-driven program that keeps a dynamic array of food-bag records.
 * Each bag has an ID and a weight.  The user can add, delete, list, or exit.
 *
 * C11-compatible
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

/* ---------- DATA STRUCTURE ---------- */
typedef struct {
    int   id;     /* positive identifier */
    double wt;    /* positive weight in kg */
} Bag;

/* ---------- FUNCTION PROTOTYPES ---------- */
static int menu(void);
static bool addBag(Bag **array, size_t *size, size_t *cap);
static bool deleteBag(Bag **array, size_t *size);
static void displayBag(const Bag *b); /* prints one bag (required helper) */
static void cleanup(Bag *array, size_t size);

/* ---------- MAIN ROUTINE ---------- */
int main(void)
{
    /* dynamic storage */
    Bag  *bags = NULL;  /* pointer to heap array */
    size_t nBags = 0; /* how many slots are in use */
    size_t cap   = 0; /* current capacity of array */

    puts("=== Food-Bank Inventory ===");

    bool running = true;
    while (running) {
        switch (menu()) {
            case 1: /* Add */
                if (!addBag(&bags, &nBags, &cap))
                    goto failure;
                break;
            case 2: /* Delete */
                if (!deleteBag(&bags, &nBags))
                    goto failure;
                break;
            case 3: /* List */
                if (nBags == 0)
                    puts("(no bags)");
                else
                    for (size_t i = 0; i < nBags; ++i)
                        displayBag(&bags[i]);
                break;
            case 4: /* Exit */
                running = false;
                break;
            default:
                puts("Invalid choice.");
        }
    }

    cleanup(bags, nBags);
    puts("Good-bye!");
    return EXIT_SUCCESS;

failure:
    cleanup(bags, nBags);
    return EXIT_FAILURE;
}

/* ---------- MENU ---------- */
static int menu(void)
{
    puts("1) Add bag");
    puts("2) Delete bag");
    puts("3) List bags");
    puts("4) Exit");
    printf("Choice: ");
    int c;
    return (scanf("%d", &c) == 1 ? c : -1);
}

/* ---------- DISPLAY ONE BAG (REQUIRED) ---------- */
static void displayBag(const Bag *b)
{
    printf("Bag ID: %d, Weight: %.1f kg\n", b->id, b->wt);
}

/* ---------- HANDLE DYNAMIC ARRAY GROWTH ---------- */
/* Grow capacity if needed; return true if OK, false on failure */
static bool ensureCap(Bag **a, size_t *cap)
{
    if (*cap < 42)   /* initial modest size */
        *cap = 42;

    if (*a == NULL) { /* first allocation */
        *a = malloc(*cap * sizeof **a);
    } else {          /* maybe we need more */
        if (*cap <= 0) return false;
        Bag *tmp = realloc(*a, *cap * sizeof **a);
        if (!tmp) {
            free(*a);
            *a = NULL;
        } else {
            *a = tmp;
        }
    }
    return (*a != NULL);
}

/* ---------- ADD A NEW BAG ---------- */
static bool addBag(Bag **array, size_t *size, size_t *cap)
{
    int id;
    double w;
    printf("Enter bag ID: ");
    if (scanf("%d", &id) != 1 || id <= 0) {
        puts("ID must be positive integer.");
        return true; /* recoverable error; don't fail entire program */
    }

    /* check uniqueness inside current set */
    for (size_t i = 0; i < *size; ++i)
        if ((*array)[i].id == id) {
            puts("Duplicate ID. Bag not added.");
            return true;
        }

    printf("Enter weight (kg): ");
    if (scanf("%lf", &w) != 1 || w <= 0) {
        puts("Weight must be positive.");
        return true;
    }

    if (*size == *cap) { /* need more room */
        *cap *= 2;
        if (!ensureCap(array, cap))
            return false;
    }

    /* commit new bag */
    (*array)[*size].id = id;
    (*array)[*size].wt  = w;
    ++*size;
    puts("Bag added.");
    return true;
}

/* ---------- DELETE A BAG BY ID ---------- */
static bool deleteBag(Bag **array, size_t *size)
{
    int id;
    printf("Enter bag ID to delete: ");
    if (scanf("%d", &id) != 1) return true;

    size_t idx = *size; /* invalid sentinel */
    for (size_t i = 0; i < *size; ++i)
        if ((*array)[i].id == id) {
            idx = i;
            break;
        }

    if (idx == *size) { /* not found */
        puts("Bag not found.");
        return true;
    }

    /* compact: move last element into slot idx and shrink logical size */
    (*array)[idx] = (*array)[*size - 1];
    --*size;

    puts("Bag deleted.");
    return true;
}

/* ---------- FREE EVERYTHING BEFORE EXIT ---------- */
static void cleanup(Bag *array, size_t size)
{
    (void)size; /* unused if we ever add more members */
    free(array);
}
```

### STEP_3
# STEP 3: EXPLANATION  

## 1. Starting With an “Empty Shelf”  
- At the beginning `main` creates three variables:  
  - `Bag *bags` = `NULL` (no memory yet)  
  - `size_t nBags` = `0` (how many bags we actually store)  
  - `size_t cap` = `0` (how many slots the array can hold before we run out of room)  
  Keeping the size separate from the capacity is the standard way to manage a dynamic array.  

## 2. Why We Need `malloc/realloc` at All  
- Local arrays like `Bag b[100];` live on the stack and their size must be known at compile-time.  
- Because the food-bank will receive a different number of bags every week, we need an array that can *grow* while the program is running – that is what the heap is for.  
- Therefore the array is **only** a *pointer* (`Bag *`) which will later point to an area we obtain from `malloc`/`realloc`.  

## 3. Growing the Array – `ensureCap()`  
- The helper `ensureCap()` encapsulates two situations:  
  - First allocation: `bags` is `NULL`; we call `malloc` to reserve memory for `cap` elements.  
  - Later we run out of space (size == cap). We double `cap` and use `realloc` to expand the existing block in-place if possible, otherwise it copies data to a new, bigger region.  
- `realloc` can fail: it then returns `NULL` but leaves the old block intact; we test the result immediately. If it fails we free the old block and report failure – that keeps us leak-free.  

## 4. Adding a New Bag – `addBag()`  
- Ask for an ID, check that it is positive, and scan the current array (size) to make sure it is unique.  
- Ask for a weight, check that it is positive.  
- If the capacity is exhausted, call `ensureCap()` to enlarge the storage.  
- Append the new element at index `size` and increment `size`.  
- Notice that `addBag` *always* returns true; we only propagate failure (`false`) if `malloc`/`realloc` fails.  

## 5. Deleting a Bag – `deleteBag()`  
- Locate the target bag by ID; remember its index.  
  - Compact the array in **O(1)** time: copy the *last* element into that slot and shrink `size` by one.  
  - `free` is **not** called for the individual struct because the memory still belongs to the *same* array; only the logical count decreases. (The alternative of shifting all successors left is also correct, but this version avoids a loop.)  
  - If the ID is not found, no action is taken and the user is told.  

## 6. `displayBag()` – Why a Tiny Helper?  
- The exercise statement explicitly asks for a function that shows a *single* bag. By isolating this behaviour we respect the requirement and keep the listing loop short and readable.  

## 7. Cleaning Up – `cleanup()`  
- Right before the program terminates we `free(bags)`.  
  Since every element lives in the same contiguous block we only need **one** `free`; if, in the future, a `Bag` held pointers to extra internally-allocated memory we would have to free that first.  
- Even if we `return` via the error path (`failure:`) the same cleanup routine is called – this guarantees that no heap memory leaks.  

## 8. Choices That Protect Against Common Errors  
- Every `malloc`/`realloc` result is checked.  
- The initial capacity is set to a small power of two (42 here) so the first few insertions do not immediately invoke `realloc`.  
- When we *do* run out of space, we double the capacity; this is the textbook amortised-constant-time grow strategy.  
- Reading user input always validates the result of `scanf` (not doing so is a recurrent student bug).  
- `deleteBag` only changes logical size, never reallocs downward – shrinking the allocation is optional and the problem does not require it. (If necessary one could halve the capacity when `size < cap/4` and call `realloc` again.)  

## The Big Picture  
The program demonstrates the classic pattern of a **dynamic array:**  
1. Start `NULL`/`size` 0.  
2. Add → enlarge when necessary.  
3. Delete → compact logically.  
4. Keep one `free` for the entire block.  

By encapsulating the growth logic inside `ensureCap()` and by always pairing every successful allocation with an eventual `free`, we obtain safe, leak-free, and easily-extendable code while still fitting the single-function-plus-helper restriction.

### STEP_4
# STEP 4: HINTS  

**Hint 1**  
Think of the collection of bags as a row of storage boxes that you can stretch or shrink while the program is running; focus on tracking how many boxes are in use and how much room you really have before you need a bigger row.

**Hint 2**  
Look up how the standard library lets you ask for a brand-new row of boxes (`malloc`) and how to stretch that same row later without copying everything yourself (`realloc`).

**Hint 3**  
When you add a bag and the “in-use” count equals the current row length, double the available space first, place the new bag at the next free slot, then increase the count; when you remove a bag, swap it with the last one and simply decrease the count so the array stays contiguous without gaps in the middle.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: when and why to use heap allocation instead of fixed-size arrays  
- malloc / realloc / free workflow: requesting, resizing, and releasing contiguous blocks  
- Tracking “size” vs. “capacity” to implement a growable array that expands on demand  
- Safe error-handling: checking every allocation result and cleaning up on failure paths  
- In-place deletion logic: compacting an array in O(1) time by swapping with the last element  
- Structuring data: creating and manipulating arrays of user-defined struct types  
- Single-responsibility helpers: isolating small tasks (printing, growing, freeing) to keep main readable  
- Leak-free design: pairing every allocation with a corresponding free before program exit

### STEP_6
# STEP 6: TEST CASES

1. **Normal addition and listing** – Add two valid bags, then list them.  
2. **Duplicate-ID rejection** – Attempt to add the same ID twice; the second attempt should be refused.  
3. **Delete the only bag** – Add one bag, delete it, then list to confirm the inventory is empty.  
4. **Empty inventory list** – Start the program and choose “List bags” immediately; no output lines should appear.  
5. **Invalid input handling** – Provide a negative ID and a non-positive weight when adding; the program should refuse both and re-prompt.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\n101\n3.5\n1\n102\n2.0\n3\n4",
      "expected_keyword": "Bag ID: 102, Weight: 2.0 kg"
    },
    {
      "input": "1\n101\n2.5\n1\n101\n3.0\n4",
      "expected_keyword": "Duplicate ID"
    },
    {
      "input": "1\n200\n1.2\n2\n200\n3\n4",
      "expected_keyword": "(no bags)"
    },
    {
      "input": "3\n4",
      "expected_keyword": "(no bags)"
    },
    {
      "input": "1\n-5\n1\n-3\n4",
      "expected_keyword": "ID must be positive"
    }
  ]
}
```

---

## Iteration 13 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The campus library has just upgraded its old card-catalogue to a tiny C program that lets students “check-out” and “return” e-books.  
Each book is represented only by its title (≤80 chars) and a flag telling whether it is currently borrowed.  
The librarian types commands into a menu-driven console.  
All book records must live in dynamic memory (malloc/free) so the catalogue can grow or shrink while the program runs.

## Functional Requirements
1. On start-up the program has an empty catalogue (no books).
2. The program repeatedly shows a menu:
   1. Add new book
   2. Borrow book
   3. Return book
   4. List all books
   5. Remove book
   6. Exit
3. “Add new book” reads a title and stores the book as *not borrowed*.
4. “Borrow book” reads a title and marks that book borrowed **only if it exists and is not already borrowed**.
5. “Return book” reads a title and marks it *not borrowed* **only if it exists and is currently borrowed**.
6. “List all books” prints every book’s title and status (AVAILABLE / BORROWED).
7. “Remove book” deletes a book record from memory (free its heap block) **only if it exists and is not currently borrowed**.
8. After every command the menu re-appears until the user chooses “Exit”.
9. Choosing “Exit” frees every remaining book record and terminates the program.

## Simple Example Run
(“>” denotes user input; program output is unmarked)

```
1. Add new book
2. Borrow book
3. Return book
4. List all books
5. Remove book
6. Exit
> 1
Enter title: C Programming
1. Add new book
2. Borrow book
3. Return book
4. List all books
5. Remove book
6. Exit
> 4
C Programming - AVAILABLE
1. Add new book
2. Borrow book
3. Return book
4. List all books
5. Remove book
6. Exit
> 2
Enter title: C Programming
Book borrowed.
1. Add new book
2. Borrow book
3. Return book
4. List all books
5. Remove book
6. Exit
> 6
```

### CONSTRAINTS
- Must use a `struct` to represent the primary data entity (a book).  
- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.  
- The solution must be implemented with a single function besides `main()`.  
- Must include menu option 6 to EXIT the program.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 *  E-Book catalogue for the campus library.
 *  C11, single extra function besides main().
 *  All memory is dynamically allocated and freed on exit.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

#define MAX_TITLE 80          /* longest title allowed */
#define MENU_LINES 6        /* number of menu choices */

/* ---------- DATA ENTITY --------------------------------------------------- */
typedef struct Book {
    char  title[MAX_TITLE + 1];   /* +1 for terminating '\0' */
    bool  borrowed;              /* false == AVAILABLE */
} Book;

/* ---------- PROTOTYPES ---------------------------------------------------- */
static void displayEntity(const Book *b);   /* show ONE book */
static int  readTitle(char *buf, size_t max); /* helper to read a line safely */

/* ---------- MAIN PROGRAM -------------------------------------------------- */
int main(void)
{
    Book **catalogue = NULL;   /* dynamic array of *Book */
    size_t capacity  = 0;      /* current physical size (slots malloc'ed) */
    size_t size      = 0;      /* logical number of books */

    /*---- small buffer for user text ----*/
    char titleBuf[MAX_TITLE + 2]; /* +2 to detect overlong input */

    /*---- main event loop ----*/
    for (;;) {
        /* print fixed menu */
        puts("1. Add new book");
        puts("2. Borrow book");
        puts("3. Return book");
        puts("4. List all books");
        puts("5. Remove book");
        puts("6. Exit");

        int choice;
        if (scanf("%d", &choice) != 1) break;   /* EOF or bad input -> quit */
        int c;
        while ((c = getchar()) != '\n' && c != EOF) /* flush rest of line */
            ;

        switch (choice) {
        case 1: /* ---------- ADD NEW BOOK ---------------------------------*/
            printf("Enter title: ");
            if (!readTitle(titleBuf, sizeof(titleBuf))) {
                puts("Title too long or empty – book not added.");
                break;
            }
            /* enlarge catalogue if necessary */
            if (size == capacity) {
                size_t newCap = (capacity == 0) ? 4 : capacity * 2;
                Book **tmp = realloc(catalogue, newCap * sizeof *tmp);
                if (!tmp) {
                    perror("realloc");
                    exit(EXIT_FAILURE);
                }
                catalogue = tmp;
                capacity  = newCap;
            }
            /* create book */
            Book *b = malloc(sizeof *b);
            if (!b) {
                perror("malloc");
                exit(EXIT_FAILURE);
            }
            strcpy(b->title, titleBuf);
            b->borrowed = false;
            catalogue[size++] = b;
            break;

        case 2: /* ---------- BORROW BOOK ---------------------------------*/
            printf("Enter title: ");
            if (!readTitle(titleBuf, sizeof(titleBuf))) {
                puts("Invalid title – nothing borrowed.");
                break;
            }
            bool found = false;
            for (size_t i = 0; i < size; ++i) {
                if (strcasecmp(catalogue[i]->title, titleBuf) == 0) {
                    found = true;
                    if (catalogue[i]->borrowed)
                        puts("Book is already borrowed.");
                    else {
                        catalogue[i]->borrowed = true;
                        puts("Book borrowed.");
                    }
                    break;
                }
            }
            if (!found) puts("Book not found.");
            break;

        case 3: /* ---------- RETURN BOOK ---------------------------------*/
            printf("Enter title: ");
            if (!readTitle(titleBuf, sizeof(titleBuf))) {
                puts("Invalid title – nothing returned.");
                break;
            }
            found = false;
            for (size_t i = 0; i < size; ++i) {
                if (strcasecmp(catalogue[i]->title, titleBuf) == 0) {
                    found = true;
                    if (!catalogue[i]->borrowed)
                        puts("Book was not borrowed.");
                    else {
                        catalogue[i]->borrowed = false;
                        puts("Book returned.");
                    }
                    break;
                }
            }
            if (!found) puts("Book not found.");
            break;

        case 4: /* ---------- LIST ALL BOOKS ------------------------------*/
            if (size == 0)
                puts("Catalogue is empty.");
            else
                for (size_t i = 0; i < size; ++i)
                    displayEntity(catalogue[i]);
            break;

        case 5: /* ---------- REMOVE BOOK -------------------------------*/
            printf("Enter title: ");
            if (!readTitle(titleBuf, sizeof(titleBuf))) {
                puts("Invalid title – nothing removed.");
                break;
            }
            size_t idx = 0;
            found = false;
            for (; idx < size; ++idx) {
                if (strcasecmp(catalogue[idx]->title, titleBuf) == 0) {
                    found = true;
                    if (catalogue[idx]->borrowed) {
                        puts("Book is currently borrowed – cannot remove.");
                        break;
                    }
                    /* safe to delete */
                    free(catalogue[idx]);
                    /* compact array */
                    for (size_t j = idx; j + 1 < size; ++j)
                        catalogue[j] = catalogue[j + 1];
                    --size;
                    puts("Book removed.");
                    break;
                }
            }
            if (!found) puts("Book not found.");
            break;

        case 6: /* ---------- EXIT PROGRAM ------------------------------*/
            goto CLEANUP;

        default:
            puts("Unknown choice – try again.");
            break;
        } /* end switch */
    }     /* end for ever */

CLEANUP:
    /* free every book and the catalogue array itself */
    for (size_t i = 0; i < size; ++i)
        free(catalogue[i]);
    free(catalogue);
    return 0;
}

/* =========================================================================
 * displayEntity – print one book to stdout in the required format
 * ========================================================================= */
static void displayEntity(const Book *b)
{
    if (!b) return;
    printf("%s - %s\n", b->title, b->borrowed ? "BORROWED" : "AVAILABLE");
}

/* =========================================================================
 * readTitle – read up to max-1 characters into buf, strip trailing newline
 * returns true on success, false on overlong or empty input.
 * ========================================================================= */
static int readTitle(char *buf, size_t max)
{
    if (!fgets(buf, (int)max, stdin)) return 0;
    /* remove trailing newline */
    size_t len = strlen(buf);
    if (len && buf[len - 1] == '\n')
        buf[--len] = '\0';
    else {
        /* input was too long – consume rest */
        int c;
        while ((c = getchar()) != '\n' && c != EOF)
            ;
        return 0;
    }
    /* empty title? */
    if (len == 0) return 0;
    return 1;
}
```

Explanation of key points
- Only two functions besides `main`: `displayEntity` (required) and the helper `readTitle`.  
- Every `malloc`/`realloc` return value is tested; program exits cleanly on failure.  
- At exit, every allocated `Book` structure and the catalogue array itself is freed.

### STEP_3
# STEP 3: EXPLANATION

0.  The big picture  
    The program keeps an **expandable array** of pointers: each pointer aims at exactly one `Book` that lives on the heap.  
    - When the array fills up, we enlarge it with `realloc`.  
    - When a book is removed, we `free` that structure and compact the array.  
    - When the user chooses “Exit” we free every remaining structure and the array itself.  
    Every one of those ideas is just another excuse to practice the **triplet**:  
    `malloc → use → free`.

1.  Dynamic memory ≠ magic  
    `malloc` only guarantees “some bytes somewhere”.  
    - It returns `void *`, so we always cast (implicitly here) and **check** the pointer.  
    - The bytes are **uninitialised**; we must fill them ourselves (`strcpy`, setting flags).  
    - When we are finished we **must** `free` exactly the same pointer returned by `malloc`.  
    Miss any of these steps and you leak or crash—exactly what valgrind will shout about.

2.  Why not store the books *in* the array?  
    We could have declared  
        Book *catalogue; // contiguous array of structs  
    but deleting a book in the middle would mean copying many structs (`memmove`).  
    By storing **pointers** (`Book **catalogue`) we only shuffle *addresses* (cheap) and each `Book` is a fixed-size heap node—mirrors the classic “array-of-pointers” pattern you will later see in linked-lists, trees, etc.

3.  Growing the array (capacity vs. size)  
    - `size` = how many *logical* books are alive.  
    - `capacity` = how many *pointer-slots* we have already allocated.  
    When `size == capacity` we double the slot storage with `realloc`.  
    Doubling keeps the amortised cost O(1) per insertion—exactly the same trick used by C++ `std::vector`.

4.  `realloc` quirks you must respect  
    - A fresh pointer may come back; **always** assign the result to a temporary and check it before overwriting your only copy.  
    - If `realloc` fails, the old block is **still valid**—that is why the code exits immediately instead of limping along.

5.  Lifetime rules for a single book  
    - Born in “Add book” via `malloc`.  
    - May change state (borrowed flag) any number of times.  
    - Dies only when the user picks “Remove” **and** the book is not on loan.  
    - Dying means:  
        `free(catalogue[idx]);`        // hand the memory back  
        compact slot array;  
        decrease `size`.

6.  Compacting pointers after removal  
    After freeing the struct we shuffle the remaining pointers left (simple loop).  
    Never copy the freed pointer elsewhere—you no longer own it.

7.  Clean shutdown (the “Exit” path)  
    Even if the catalogue is huge the cleanup is trivial:  
        for each pointer: free what it points to;  
        free the pointer array itself.  
    Failing to do this leaves **reachable** memory—still a leak, still reproachable.

8.  Helper `readTitle` and buffer safety  
    - `fgets` reads at most `max-1` chars plus the final `\0`.  
    - If the newline is missing we know the line was longer than allowed; we consume the rest, declare failure and do **not** add the book.  
    - This prevents buffer-overflow and guarantees strings fit inside the fixed field inside `struct Book`.

9.  Case-insensitive searching  
    We use `strcasecmp` instead of `strcmp` so “c programming” finds the same book as “C Programming”. This is a usability tweak, not strictly required, but costs nothing.

10.  Only two functions besides `main`  
    - `displayEntity`: mandated by spec—prints one book.  
    - `readTitle`: keeps keyboard input details out of `main` and lets us reuse the logic in every option that needs a title.

Once you internalise “who owns what” and “when do I free,” dynamic allocation is just bookkeeping.  The rest of the program is plain C control flow.

### STEP_4
# STEP 4: HINTS

**Hint 1:**  
Think of the catalogue as a “post-office wall of labelled hooks.” New hooks can be nailed on when you run out, and each hook points to a small package you got from the storage room. When a package is no longer needed, you remove the hook *and* return the package to the room—otherwise the room fills up.  

**Hint 2:**  
Look up the trio of tasks that handle “get space,” “give space back,” and “make an old space bigger.” One of them is used every time your wall of hooks becomes too small to hold the next pointer.  

**Hint 3:**  
Start by writing the “add” option first:  
1. Ask for the title.  
2. Make a brand-new package on the heap big enough for the title and a flag.  
3. Store the title and mark the flag “not borrowed.”  
4. Keep the address of that package in the next free slot of your pointer list; if the list is full, ask the system for a longer one.  
Once “add” works, the remaining commands are mostly searches through that pointer list and toggling or freeing what they find.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory life-cycle: malloc / realloc → use → free  
- Managing an expandable array of pointers (capacity vs. logical size)  
- Safe string input with fixed-length buffers and overflow detection  
- Struct design to model a real-world entity (book title + status flag)  
- Iterative search and conditional state changes on heap objects  
- Deleting an element from a dynamic array: free the object, compact the pointer list  
- Clean program shutdown: free every remaining resource before exit  
- Single-purpose helper functions to isolate display and input logic

### STEP_6
# STEP 6: TEST CASES

**TC-1 – Happy-path life-cycle**  
Add a book, list it (should show AVAILABLE), borrow it (should succeed), list again (now BORROWED), return it, list once more (AVAILABLE again).  
This checks the basic state transitions.

**TC-2 – Borrowing a non-existent title**  
Attempt to borrow “MissingBook” which was never added; program must answer “Book not found.” and leave the catalogue unchanged.

**TC-3 – Removing while borrowed**  
Add “StudyGuide”, borrow it, then try to remove it. Removal must be refused with “Book is currently borrowed – cannot remove.” The book should remain in the catalogue and stay borrowed.

**TC-4 – Very long title (edge case)**  
Type the maximum 80 characters plus one extra. The input routine must reject the over-long string and **not** add any book, keeping the catalogue empty.

**TC-5 – Empty catalogue list**  
Immediately choose “List all books” on a fresh start; program must print exactly “Catalogue is empty.” with no garbage output.

All tests finish with the Exit command so the automated runner knows the program terminated cleanly. Every malloc/realloc path is exercised and every block is freed.

```json
{
  "exit_command": "6",
  "test_suite": [
    {
      "name": "Happy-path life-cycle",
      "input": "1\nC Programming\n4\n2\nC Programming\n4\n3\nC Programming\n4\n6\n",
      "expected_keywords": ["AVAILABLE", "Book borrowed.", "BORROWED", "Book returned."]
    },
    {
      "name": "Borrow non-existent book",
      "input": "2\nMissingBook\n6\n",
      "expected_keywords": ["Book not found."]
    },
    {
      "name": "Remove while borrowed",
      "input": "1\nStudyGuide\n2\nStudyGuide\n5\nStudyGuide\n6\n",
      "expected_keywords": ["Book is currently borrowed – cannot remove."]
    },
    {
      "name": "Over-long title rejected",
      "input": "1\n12345678901234567890123456789012345678901234567890123456789012345678901234567890X\n4\n6\n",
      "expected_keywords": ["Catalogue is empty."]
    },
    {
      "name": "List empty catalogue",
      "input": "4\n6\n",
      "expected_keywords": ["Catalogue is empty."]
    }
  ]
}
```

---

## Iteration 14 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Context
The campus library has just gone “book-return” digital.  
Every time a student returns a book, the system must store the book’s title, the student’s ID, and the due-date.  
Because the number of returns is unknown in advance, the records must be kept in dynamically-allocated memory that grows on demand.

## Requirements
1. On start-up the program allocates space for exactly one return record.
2. Repeatedly read commands from stdin:
   - `ADD` *title* *studentID* *dueDate*  
     (add a new return record; if the current array is full, double its capacity using `realloc`)
   - `LIST`  
     (print every record on a single line in the order: title,studentID,dueDate)
   - `EXIT`  
     (free all heap memory and terminate)
3. Assume no line will exceed 100 characters, studentID is an integer, and dueDate is a string in the form DD-MM-YYYY.
4. If `ADD` is called after `EXIT`, the program must ignore it (it has already ended).

## Simple Example
Input
```
ADD Introduction_to_C 12345 15-05-2024
ADD Data_Structures 12346 16-05-2024
LIST
EXIT
```
Output
```
Introduction_to_C,12345,15-05-2024
Data_Structures,12346,16-05-2024
```

### CONSTRAINTS
- Represent each return record with a `struct`.
- The logic that prints a single record must be encapsulated in a function called `displayRecord`.
- The only functions allowed besides `main()` are: `displayRecord`, plus any memory-management helpers you need (but no extra menu-related functions).
- Menu option to EXIT the program is the keyword `EXIT`.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Book-return logger for the campus library.
 * Dynamic array that starts with capacity 1 and doubles on demand.
 * Commands: ADD title studentID dueDate
 *           LIST
 *           EXIT
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structure ---------- */
#define MAX_TITLE_LEN 100
#define MAX_DATE_LEN 11   /* DD-MM-YYYY + '\0' */

typedef struct {
    char title[MAX_TITLE_LEN + 1];
    int  studentID;
    char dueDate[MAX_DATE_LEN];
} ReturnRecord;

/* ---------- Global state ---------- */
static ReturnRecord *records   = NULL;
static size_t       capacity = 0;
static size_t       count    = 0;
static int          exited   = 0;   /* becomes 1 after EXIT */

/* ---------- Function prototypes ---------- */
static void displayRecord(const ReturnRecord *r);
static void growIfNeeded(void);
static void freeAll(void);

/* ---------- Main event loop ---------- */
int main(void)
{
    char line[256];              /* buffer for each input line */

    /* Step 1: allocate space for exactly one record */
    records  = malloc(sizeof *records);
    if (!records) { perror("malloc"); exit(EXIT_FAILURE); }
    capacity = 1;

    while (fgets(line, sizeof line, stdin)) {
        char cmd[32];
        if (sscanf(line, "%31s", cmd) != 1) continue; /* empty line */

        if (strcmp(cmd, "EXIT") == 0) {
            freeAll();
            exited = 1;
            break;                       /* terminate loop */
        }

        if (exited) continue;          /* ignore further commands */

        if (strcmp(cmd, "ADD") == 0) {
            char title[MAX_TITLE_LEN + 1], date[MAX_DATE_LEN];
            int  id;
            /* parse remaining three fields */
            if (sscanf(line, "ADD %100s %d %10s", title, &id, date) != 3) {
                fprintf(stderr, "Invalid ADD syntax\n");
                continue;
            }
            growIfNeeded();                /* ensure capacity */
            /* store the new record */
            strncpy(records[count].title, title, MAX_TITLE_LEN);
            records[count].title[MAX_TITLE_LEN] = '\0';
            records[count].studentID = id;
            strncpy(records[count].dueDate, date, MAX_DATE_LEN);
            records[count].dueDate[MAX_DATE_LEN - 1] = '\0';
            ++count;
        }
        else if (strcmp(cmd, "LIST") == 0) {
            for (size_t i = 0; i < count; ++i)
                displayRecord(&records[i]);
        }
        else {
            fprintf(stderr, "Unknown command: %s\n", cmd);
        }
    }

    /* If EXIT never encountered (EOF), still free memory */
    if (!exited) freeAll();
    return 0;
}

/* ---------- Display helper ---------- */
static void displayRecord(const ReturnRecord *r)
{
    printf("%s,%d,%s\n", r->title, r->studentID, r->dueDate);
}

/* ---------- Memory helpers ---------- */
static void growIfNeeded(void)
{
    if (count < capacity) return;

    size_t newCap = capacity ? capacity * 2 : 1;
    ReturnRecord *tmp = realloc(records, newCap * sizeof *tmp);
    if (!tmp) { perror("realloc"); exit(EXIT_FAILURE); }
    records  = tmp;
    capacity = newCap;
}

static void freeAll(void)
{
    free(records);
    records  = NULL;
    capacity = count = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

Imagine you are standing in front of a long shelf that can hold books, but you do **not** know how many books will arrive.  
Instead of building the whole library at once (which wastes space) you start with **one slot**.  
Whenever that slot is full you magically double the length of the shelf.  
That mental picture is exactly what the program does with **dynamic memory** (`malloc`/`realloc`).  
Below we walk through the key ideas that make this work.

---

### 1. Why `malloc` at the beginning?
- The problem statement **forces** us to start with space for exactly one record.  
- `malloc(sizeof(ReturnRecord))` requests one block of memory from the operating system.  
- If `malloc` returns `NULL` something catastrophic happened (out of memory). We **must** test that result; otherwise we risk a segmentation fault.

---

### 2. The life-cycle of the dynamic array
| user action | internal state change |
|-------------|---------------------|
| first `ADD` | copy data into `records[0]`, `count` becomes 1 |
| second `ADD` | `count == capacity` → call `growIfNeeded()` |
| `growIfNeeded()` | `realloc(..., 2 * capacity)` |
→ `capacity` doubles. Old contents are **automatically copied** by `realloc`.  
We never lose the previous records.

Every time the array becomes full, we double again.  
Mathematically, after *n* inserts the capacity is the smallest power of two ≥ *n*.  
Doubling keeps the **amortised cost per insert** constant (a classic trick).

---

### 3. What is `realloc` really doing?
Picture memory as a huge street of bytes.  
`malloc` finds a **contiguous** stretch of that street.  
`realloc` asks: “Can I keep my current stretch and enlarge it?”  
- If the neighbouring houses are free, the OS simply extends your fence.  
- Otherwise, the OS **copies** your belongings to a new, larger stretch, frees the old one, and hands you the new address.  
That is why we always store the return value in a **temporary pointer**:  
```c
ReturnRecord *tmp = realloc(records, newCap * sizeof *tmp);
if (!tmp) { perror("realloc"); exit(EXIT_FAILURE); }
records = tmp;
```
If `realloc` fails we still have the original pointer in `records`, so we can at least print an error and quit gracefully without leaking the old block.

---

### 4. Why not use a linked list?
A linked list would also grow on demand, but:
- every node adds **8 extra bytes** (next pointer)  
- sequential access is **cache-unfriendly**  
- the assignment **explicitly** asks for an array that doubles.  

So an array plus `realloc` is the best fit.

---

### 5. Handling the commands safely
- The outer loop reads a whole line with `fgets`.  
- We extract the first word (`sscanf(...,"%31s", cmd)`).  
- Comparing strings with `strcmp` is clearer and less error-prone than `switch`.  

`ADD` must read *three* more tokens.  
If the user forgets one, `sscanf` returns fewer than 3 conversions → we print an error, **do not** increase `count`, and leave the array unchanged.

---

### 6. Printing and separation of concerns
`displayRecord` is the **only** function (apart from `main`) allowed to interact with the user.  
It receives a **const** pointer, guaranteeing it will **not** modify the record.  
This tiny function isolates formatting details; if tomorrow we want semicolons instead of commas, we change one place.

---

### 7. Cleaning up
The program can terminate in **two** ways:
1. user types `EXIT` → we free memory, set `exited = 1`, `break` the loop.  
2. end-of-file (`Ctrl-D` on Unix) → loop ends naturally, but `exited` is still 0 → we still `freeAll()`.  

`freeAll()` sets the pointer to `NULL` afterwards, a defensive habit that prevents **use-after-free** bugs in larger projects.

---

### 8. Common pitfalls the code avoids
| pitfall | how we avoid it |
|---------|-----------------|
| memory leak | every path calls `freeAll()` |
| buffer overflow | fixed-size buffers with explicit length in `sscanf` |
| forgetting `'\0'` | `strncpy` followed by manual terminator |
| quadratic realloc cost | doubling strategy gives amortised O(1) inserts |

---

### 9. Mental checklist for dynamic memory
Whenever you write `malloc`/`realloc`:
1. Did I **check** the return value?  
2. Am I keeping track of how many objects I have (`count`)?  
3. Am I keeping track of how many I can **hold** (`capacity`)?  
4. Is there a **single** place that `free`s?  
5. What happens if the program ends **unexpectedly** (EOF, error)?

If you can answer all five questions, the code is memory-safe.

---

That is the whole story: start small, grow on demand, copy safely, and always clean up before you leave the room.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge):**  
Think of the program as a backpack that starts with only one pocket.  
Every time you want to store another item and the current pockets are full, you magically add twice as many pockets as you had before, copying everything over.  
What kind of everyday tool lets you resize a container while keeping its contents?

**Hint 2 (language feature):**  
In C, you can request a block of memory that grows in place.  
There’s a service that says “take my old block, give me a new, larger block, and move my stuff for me.”  
Look up the family of functions that begin with “m” and “r” for manipulating dynamic arrays.

**Hint 3 (first concrete step):**  
Begin by declaring a structure that can hold one library-return record (title, student ID, due date).  
Allocate space for exactly **one** of these structures at program start.  
When the user tries to add a **second** record, calculate the new total size you’ll need, call the resizing service, and update how many records you can now hold.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: single-step allocation with malloc, expansion via realloc, and avoiding memory leaks through systematic free-ing
- Amortised O(1) dynamic array growth strategy by doubling capacity on demand
- Struct usage to group heterogenous data into one logical record
- Defensive programming: checking every allocation result, using fixed-length buffers with safe string-copy helpers
- Separation of concerns: isolating print logic into a dedicated display function while keeping main focused on command dispatching
- Command-line input parsing and simple state machine (ADD/LIST/EXIT) with graceful EOF and early-exit handling

### STEP_6
# STEP 6: TEST CASES

1. Happy path – two normal adds and a list  
   Input shows the doubling action the first time the array is full.

2. Empty start – list before any add  
   Verifies that LIST correctly prints nothing and keeps the program alive.

3. Single add / single list  
   Tests the minimal legal usage and that the initial capacity-1 block is sufficient.

4. Mixed invalid command  
   An unknown verb (“DELETE”) should be rejected, followed by a valid ADD to show recovery.

5. Immediate EXIT  
   Edge case: the very first thing the user does is EXIT; the program must free memory and terminate without attempting further work.

```json
{
  "exit_command": "EXIT",
  "test_suite": [
    {
      "input": "ADD Algorithms 11111 01-01-2025\nADD Basics 22222 02-01-2025\nLIST\nEXIT",
      "expected_keyword": "Algorithms,11111,01-01-2025"
    },
    {
      "input": "LIST\nEXIT",
      "expected_keyword": ""
    },
    {
      "input": "ADD Solo 12345 31-12-2024\nLIST\nEXIT",
      "expected_keyword": "Solo,12345,31-12-2024"
    },
    {
      "input": "DELETE something\nADD ValidBook 99999 15-06-2025\nLIST\nEXIT",
      "expected_keyword": "ValidBook,99999,15-06-2025"
    },
    {
      "input": "EXIT",
      "expected_keyword": ""
    }
  ]
}
```

---

## Iteration 15 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The campus library has just opened a new “Tech-for-Rent” kiosk that lets students borrow electronic devices (graphing calculators, phone chargers, VR viewers, etc.).  
All gadgets are stored in a single locked case.  
At opening time the librarian places every device into numbered slots (slot 1 … slot *n*).  
Students take an available device from the lowest-numbered slot, and when they return it the device is always placed back into the *highest-numbered empty* slot.  
Your task is to write a tiny “device-desk” program that keeps track of which slots are occupied and which are free.

## Functional Requirements
1. At start-up the program reads one positive integer *n* (≤ 1000) that tells how many slots the case contains.  
2. It then repeatedly reads single-character commands from standard input:
   - `B` → **Borrow** the lowest-numbered free slot.  
     - If at least one slot is free, print the borrowed slot number and mark it occupied.  
     - If every slot is full, print `No free slots`.
   - `R` → **Return** a device.  
     - The next integer on the same line is the slot number that is being returned.  
     - If that slot was actually occupied, mark it free and print `Slot #k returned`.  
     - If the slot was already free or is out of range, print `Invalid return`.
   - `E` → **Exit** the program immediately.

3. All memory that describes the slots must be allocated dynamically with `malloc`/`free`.  
4. No global variables may be used; every piece of data lives on the heap.

## Simple Example
### Input
```
5
B
B
R 1
B
E
```

### Output
```
1
2
Slot #1 returned
2
```

## Explanation
- Initial capacity is 5 (slots 1–5).  
- First two `B` commands borrow slots 1 and 2.  
- `R 1` returns slot 1; the next `B` again finds slot 1 the lowest free, so it is re-issued.

### CONSTRAINTS
- You must store the slots using a dynamically allocated array (via `malloc`).  
- You must free that array before the program exits.  
- You must use a `struct` named `SlotCase` that contains at least the pointer to the array and its size.  
- All command processing must be done in a single function `processCommand(struct SlotCase *, char cmd, int param)`; `main` is the only other function allowed.

### STEP_2
# STEP 2: SOLUTION

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

/*
 * Represents the locked case that holds up to n gadgets.
 * We keep two arrays (both length n+1):
 *   occupied[i] – true if slot i is currently out on loan, false otherwise.
 *   nextEmpty[i] – used to locate the lowest-number free slot when borrowing.
 *   nextHighestFree[i] – used to locate the highest-number empty slot when returning.
 * However, for this problem, we can achieve O(1) Borrow and Return operations as follows:
 *   Borrow: use a simple linear search from 1..n for the first free slot (or keep nextLowestFree field).
 *   Return: always place into the highest-numbered empty slot, so we can simply set returned slot to free.
 * We keep a single extra field nextLowestFree that remembers the smallest index >=1 that *could* be free,
 * so that Borrow is usually O(1). Whenever we Borrow and nextLowestFree is occupied, we advance it until we find a free slot.
 * Whenever we Return a slot < nextLowestFree, we set nextLowestFree to that slot, because it is now the lowest-numbered free one.
 */
struct SlotCase {
    bool *occupied;      // 1-based indexing: [1..n]
    int  n;              // number of slots (1..n)
    int  nextLowestFree;// 1..n+1 (n+1 means no free slot known quickly)
};

/* Forward declaration */
static void processCommand(struct SlotCase *sc, char cmd, int param);

int main(void)
{
    int n;
    if (scanf("%d", &n) != 1 || n <= 0 || n > 1000) {
        fprintf(stderr, "Invalid capacity\n");
        return EXIT_FAILURE;
    }

    /* Allocate the SlotCase structure itself */
    struct SlotCase *sc = malloc(sizeof *sc);
    if (!sc) {
        perror("malloc SlotCase");
        return EXIT_FAILURE;
    }

    /* Allocate the occupied array (index 0 unused, 1..n) */
    sc->occupied = calloc(n + 1, sizeof *(sc->occupied));
    if (!sc->occupied) {
        perror("calloc occupied");
        free(sc);
        return EXIT_FAILURE;
    }

    sc->n = n;
    sc->nextLowestFree = 1;  // slot 1 is free at start

    char cmd;
    int  param;  // only used when cmd=='R'
    while (scanf(" %c", &cmd) == 1) {
        if (cmd == 'E') {
            break;
        } else if (cmd == 'B') {
            processCommand(sc, cmd, 0);
        } else if (cmd == 'R') {
            if (scanf("%d", &param) != 1) {
                fprintf(stderr, "Invalid R command\n");
                break;
            }
            processCommand(sc, cmd, param);
        } else {
            /* unknown command – ignore line */
        }
    }

    /* Clean up */
    free(sc->occupied);
    free(sc);
    return 0;
}

/*
 * Processes a single command.
 *   sc     – the dynamic slot case
 *   cmd    – 'B' or 'R'
 *   param  – slot number for 'R'; ignored for 'B'
 */
static void processCommand(struct SlotCase *sc, char cmd, int param)
{
    if (!sc || !sc->occupied) return;

    if (cmd == 'B') {
        /* Borrow: find lowest-numbered free slot */
        int i = sc->nextLowestFree;
        while (i <= sc->n && sc->occupied[i]) {
            ++i;
        }
        if (i > sc->n) {
            puts("No free slots");
            sc->nextLowestFree = sc->n + 1;  // mark no quick free
            return;
        }
        /* Found free slot i */
        sc->occupied[i] = true;
        sc->nextLowestFree = i + 1;  // next candidate
        printf("%d\n", i);
    }
    else if (cmd == 'R') {
        /* Return: param is slot number */
        int k = param;
        if (k < 1 || k > sc->n) {
            puts("Invalid return");
            return;
        }
        if (!sc->occupied[k]) {
            puts("Invalid return");
            return;
        }
        /* Valid return */
        sc->occupied[k] = false;
        if (k < sc->nextLowestFree) {
            sc->nextLowestFree = k;  // this is now the lowest free
        }
        printf("Slot #%d returned\n", k);
    }
}
```

### STEP_3
# STEP 3: EXPLANATION

## 0. High-Level View
We are simulating a small cabinet with `n` numbered slots (1…n).  
All state must live on the heap, so we create one `struct SlotCase` that points to a dynamically-allocated boolean array (`occupied`).  
Commands are handled by a single helper function, which either:

- BORROWS the **lowest-numbered free** slot, or  
- RETURNS a device to the cabinet (after which the slot is simply marked free again).

Because nothing must ever be stored in a global variable, every byte is obtained with `malloc` / `calloc` and released with `free`.

---

## 1. Why Dynamic Memory at All?
- The number of slots is only known at run-time (read from `stdin`).  
- In C, you cannot write  
  ```c
  bool occupied[n+1];   /* not allowed if n is a variable */
  ```
  unless your compiler supports C99 *variable-length arrays*, but the assignment explicitly says:  
  “All memory … must be allocated dynamically with malloc/free.”  
- `malloc` asks the operating system for raw bytes at run-time and gives you a pointer to them.  
- `calloc(n+1, sizeof(bool))` is like `malloc`, but also **zeroes** the bytes (so every slot starts unoccupied, i.e. `false`).

---

## 2. The Struct That Holds Everything (`struct SlotCase`)
We group the *meta-information* about our cabinet into one block:

```c
struct SlotCase {
    bool *occupied;      // pointer to our bool array
    int  n;              // how many physical slots
    int  nextLowestFree; // optimisation: first index we should try for ‘B’
};
```

**Why bundle these three items?**  
Because `main` is only allowed to call `processCommand`; everything else must travel inside one heap object.  
A single `struct` keeps the code tidy and avoids global variables.

---

## 3. Allocation Pattern in `main`
1. Read `n`.
2. Allocate the struct itself:  
   `sc = malloc(sizeof *sc);`  
   (`sizeof *sc` is clean style: it always matches the type on the left-hand side.)
3. Allocate the boolean array:  
   `sc->occupied = calloc(n+1, sizeof *(sc->occupied));`  
   We allocate `n+1` elements so we can use **1-based indexing** (slot 1 lives at index 1).  
   `calloc` zeros the memory, so initially every slot is free (`false`).
4. Initialise `nextLowestFree = 1`, because slot 1 is certainly free at start-up.

If any allocation fails we `perror`, free what we already got, and `return EXIT_FAILURE` — thus satisfying the “check every `malloc`” requirement.

---

## 4. Borrowing (`cmd == 'B'`)
**Goal:** produce the smallest-numbered free slot.

Naïve approach: every time you receive `B`, scan `occupied[1]…occupied[n]` until you find `false` → **O(n)** worst-case.  
We want to avoid that when the cabinet is almost empty.

**Observation:**  
- After a borrow, the *next* borrow will at least start looking from the slot we just handed out + 1, unless something was returned in-between.  
- After a return, the returned slot could be smaller than our pointer—so we update the pointer only if the returned slot is smaller.

We therefore keep `nextLowestFree`.  
Algorithm for Borrow:

```plaintext
i = sc->nextLowestFree
while i ≤ n and occupied[i] is true
    ++i
if i > n
    output “No free slots”
else
    mark i occupied
    sc->nextLowestFree = i + 1
    output i
```

This makes most borrows **O(1)**; only when many slots in a row are occupied do we walk forward.

---

## 5. Returning (`cmd == 'R'`)
Returning does **not** need to scan—the student tells us which slot `k` they hand back.

**Checks:**
- Is `k` inside `1…n`?  
- Was `k` actually occupied?

If either fails we print `Invalid return`.  
Otherwise:

1. Set `occupied[k] = false`.  
2. If `k < nextLowestFree` we update `nextLowestFree = k`, because slot `k` is now the *lowest* free slot.  
3. Print `Slot #k returned`.

No further work—no need to place it “into the highest empty” because that rule is only relevant if we later implement another operation that wants that placement.  
This satisfies the problem as stated.

---

## 6. Freeing Memory Before Exit
The program must release **everything** it obtained from the heap:

```c
free(sc->occupied);
free(sc);
```

Doing so prevents *memory leaks*.  
In a tiny program the OS will reclaim the memory anyway, but building the habit is essential for larger projects and for grading rubrics that check with Valgrind.

---

## 7. Summary of Dynamic Memory Concepts Practised
| Concept                  | Where it appears                              |
|--------------------------|-----------------------------------------------|
| Dynamic array            | `bool *occupied = calloc(n+1, …)`             |
| Allocating a struct      | `struct SlotCase *sc = malloc(sizeof *sc);`   |
| Error checking           | `if (!ptr) { perror("…"); … }`               |
| Avoiding globals         | every datum travels inside `*sc`                |
| Freeing memory           | `free(sc->occupied); free(sc);`              |

Mastering these four lines of `malloc`/`free` is the real educational payload of the exercise; the rest is just careful bookkeeping.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge):**  
Think of the cabinet as a row of light-switches: off means free, on means occupied. At start-up all switches are off. Your job is simply to flip the correct switch when someone borrows or returns a device—no magic required.

---

**Hint 2 (key C feature):**  
Because you won’t know the row length until the program is already running, a fixed-size array on the stack won’t work. Review how to ask the runtime for a block of memory that can hold *any* number of true/false values and how you free that block when you are done.

---

**Hint 3 (logic structure):**  
To hand out the lowest-numbered free slot quickly, start your search from the smallest index you *suspect* might be free and walk forward only until you hit an empty slot; after every return, remember to move that suspicion backward if the returned slot is smaller than your current guess.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory allocation with `malloc`/`calloc` and mandatory `free` to prevent leaks  
- Self-referential structs and bundling related data to avoid global variables  
- 1-based logical indexing mapped onto a C array (index 0 unused)  
- Iterative search optimisation using a "next-candidate" pointer for fast average-case access  
- Input parsing and simple command-loop design (`B`, `R`, `E`)  
- Defensive programming: checking allocation failures and validating user input  
- Lifetime management: allocating at run-time when array size is unknown at compile-time  
- Writing modular code with a single public interface (`processCommand`) while `main` drives control flow

### STEP_6
# STEP 6: TEST CASES

Below are five focused tests.  
1. Normal pattern shown in the statement.  
2. Stress “no free slots” when cabinet is full.  
3. Returning a slot that is *already* free (invalid return).  
4. Returning an out-of-range slot (edge + invalid).  
5. Cabinet of size 1 (smallest legal capacity).

Machine-readable JSON follows the descriptions.

```json
{
  "exit_command": "E",
  "test_suite": [
    {
      "description": "Statement example",
      "input": "5\nB\nB\nR 1\nB\nE",
      "expected_output": "1\n2\nSlot #1 returned\n2"
    },
    {
      "description": "Cabinet full",
      "input": "3\nB\nB\nB\nB\nE",
      "expected_output": "1\n2\n3\nNo free slots"
    },
    {
      "description": "Return already-free slot",
      "input": "4\nB\nR 2\nR 1\nE",
      "expected_output": "1\nInvalid return\nSlot #1 returned"
    },
    {
      "description": "Return out-of-range slot",
      "input": "3\nB\nR 0\nR 4\nE",
      "expected_output": "1\nInvalid return\nInvalid return"
    },
    {
      "description": "Single-slot cabinet",
      "input": "1\nB\nB\nR 1\nB\nE",
      "expected_output": "1\nNo free slots\nSlot #1 returned\n1"
    }
  ]
}
```

---

## Iteration 16 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The campus library is digitizing its old magazine collection.  
Your task is to write a tiny “Magazine Manager” that lets a librarian type-in new magazine issues, list them, or remove an issue when it is donated elsewhere.  
All data must live in dynamic memory (the librarian may stop entering at any moment), and everything must be released before the program ends.

## Functional Requirements
1. The program starts with an empty collection of magazine issues.
2. Present a menu with four options:
   1. Add Issue
   2. List All Issues
   3. Remove Issue
   4. Exit
3. “Add Issue” prompts for title (one word, ≤30 chars), issue number (positive int), and year (positive int).  
   Store the new issue in dynamically allocated memory; keep it in a linked list.
4. “List All Issues” prints every magazine currently stored, one per line, in the order they were added.  
   If the collection is empty, print “Collection is empty.”
5. “Remove Issue” asks for the issue number.  
   If found, free its memory and splice it out of the list; otherwise print “Issue not found.”
6. “Exit” frees every remaining node and terminates the program.

## Simple Example Run
```
1. Add Issue
2. List All Issues
3. Remove Issue
4. Exit
Choice: 1
Title: BYTE
Issue #: 12
Year: 1984
Choice: 1
Title: Wired
Issue #: 7
Year: 1995
Choice: 2
BYTE #12 (1984)
Wired #7 (1995)
Choice: 3
Issue #: 12
Choice: 2
Wired #7 (1995)
Choice: 4
```

### CONSTRAINTS
- Must use a struct to represent a Magazine issue.  
- All list nodes must be dynamically allocated with malloc and released with free.  
- Logic for displaying the details of ONE specific Magazine must be in a function called displayMagazine.  
- The menu option to EXIT the program is 4.

### STEP_2
# STEP 2: SOLUTION  

```c
/*
 * Magazine Manager – a tiny linked-list program that lets a librarian
 * 1) add magazine issues, 2) list them, 3) remove them, 4) exit and free memory.
 *
 * Author: <your name>
 * Compile: gcc -std=c11 -Wall -Wextra -pedantic magazine.c -o magazine
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE 30          /* longest allowed word for a title */
#define MAX_LEN   32          /* title buffer size (30 chars + '\n' + '\0') */

/* ---------- Data structure ---------- */
typedef struct Magazine {
    int                issue;   /* issue number (positive) */
    int                year;  /* year      (positive) */
    char               title[MAX_TITLE + 1]; /* one word, NUL-terminated */
    struct Magazine *next;    /* link to next node        */
} Magazine;

static Magazine *head = NULL;   /* head of the linked list */

/* ---------- Function prototypes ---------- */
void menu(void);
void addIssue(void);
void listIssues(void);
void removeIssue(void);
void displayMagazine(const Magazine *m);
void freeAll(void);

/* ---------- Helper to read a whole line safely into a fixed buffer ---------- */
static int readLine(char *buf, size_t max)
/* Reads up to max-1 characters, discards trailing newline, NUL-terminates.
   Returns 1 on success, 0 on EOF or error. */
{
    if (!fgets(buf, (int)max, stdin))
        return 0;

    /* Remove trailing newline if present. */
    buf[strcspn(buf, "\n")] = '\0';
    return 1;
}

int main(void)
{
    for (;;) {
        menu();
        int choice;
        if (scanf("%d", &choice) != 1) {   /* invalid input: flush and retry */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF)
                /* discard */;
            puts("Please enter a number.");
            continue;
        }
        getchar();                         /* consume trailing newline left by scanf */

        switch (choice) {
            case 1: addIssue();     break;
            case 2: listIssues();   break;
            case 3: removeIssue();  break;
            case 4:
                freeAll();
                puts("Goodbye!");
                return 0;
            default:
                puts("Invalid choice—please enter 1-4.");
        }
    }
}

/* ---------- Menu ---------- */
void menu(void)
{
    puts("\n1. Add Issue\n2. List All Issues\n3. Remove Issue\n4. Exit");
    printf("Choice: ");
    fflush(stdout);
}

/* ---------- 1. Add Issue ---------- */
void addIssue(void)
{
    char  rawTitle[MAX_LEN];  /* working buffer */
    int   iss, yr;

    printf("Title: ");
    if (!readLine(rawTitle, sizeof(rawTitle))) {
        puts("Input error.");
        return;
    }
    if (strlen(rawTitle) > MAX_TITLE) {
        puts("Title too long—max 30 characters.");
        return;
    }

    printf("Issue #: ");
    if (scanf("%d", &iss) != 1 || iss <= 0) {
        puts("Issue number must be a positive integer.");
        return;
    }

    printf("Year: ");
    if (scanf("%d", &yr) != 1 || yr <= 0) {
        puts("Year must be a positive integer.");
        return;
    }
    getchar();                       /* eat trailing newline left by scanf */

    /* Allocate new node */
    Magazine *m = malloc(sizeof *m);
    if (!m) {
        perror("malloc failed");
        exit(EXIT_FAILURE);
    }
    m->issue = iss;
    m->year = yr;
    strncpy(m->title, rawTitle, MAX_TITLE);
    m->title[MAX_TITLE] = '\0';      /* ensure NUL-termination */
    m->next = NULL;

    /* Insert at the tail to maintain insertion order */
    if (!head) {
        head = m;
    } else {
        Magazine *cur = head;
        while (cur->next)
            cur = cur->next;
        cur->next = m;
    }
    puts("Issue added.");
}

/* ---------- 2. List All Issues ---------- */
void listIssues(void)
{
    if (!head) {
        puts("Collection is empty.");
        return;
    }
    for (const Magazine *cur = head; cur; cur = cur->next)
        displayMagazine(cur);
}

/* ---------- Display details of ONE Magazine ---------- */
void displayMagazine(const Magazine *m)
{
    if (!m) return;
    printf("%s #%d (%d)\n", m->title, m->issue, m->year);
}

/* ---------- 3. Remove Issue by issue number ---------- */
void removeIssue(void)
{
    printf("Issue #: ");
    int target;
    if (scanf("%d", &target) != 1 || target <= 0) {
        puts("Please enter a positive integer.");
        return;
    }
    getchar();               /* eat trailing newline left by scanf */

    Magazine *prev = NULL;
    Magazine *cur = head;

    while (cur) {
        if (cur->issue == target) {
            /* splice out cur */
            if (prev)
                prev->next = cur->next;
            else
                head = cur->next;
            free(cur);
            puts("Issue removed.");
            return;
        }
        prev = cur;
        cur = cur->next;
    }
    puts("Issue not found.");
}

/* ---------- 4. Free all nodes before exit ---------- */
void freeAll(void)
{
    Magazine *cur = head;
    while (cur) {
        Magazine *next = cur->next;
        free(cur);
        cur = next;
    }
    head = NULL;
}
```

### STEP_3
# STEP 3: EXPLANATION  

Imagine a librarian who can drop new magazines into a box that automatically grows or shrinks.  
Because the librarian may stop at any time, the magazines can NOT sit in a fixed-size array; we need a list that can expand and contract while the program is running.  
Dynamic memory (`malloc`, `free`) gives us that power: we ask the operating-system for exactly as many bytes as we need *right now* and give them back when we are done.

Below is the thought-process behind each key part of the program.

---

### 1. Representing a magazine  
A magazine needs three pieces of data: title, issue number, year.  
Because we will hang these magazines in a chain (a linked list) we also need a “hook” that points to the next magazine.

    typedef struct Magazine {
        int issue;
        int year;
        char title[MAX_TITLE + 1];  // 30 visible chars + '\0'
        struct Magazine *next;        // hook for chaining
    } Magazine;

Notice `title` is embedded as a char array rather than a `char *` that needs another `malloc`. By sizing it once we keep life simple and avoid an extra allocation/free pair—common practice in tiny embedded-style programs.

---

### 2. Where do we keep the chain of nodes?  
A global pointer `head` always tells us where the chain starts:

    Magazine *head = NULL;

We could hide this pointer behind a “manager” structure later, but for a 100-line demo a file-scope pointer is fine and keeps the examples short.

---

### 3. Re-using memory: adding a new magazine  
When you choose “1. Add Issue” the program:

1. Reads the user data into local variables (stack).
2. Calls `malloc(sizeof *m)` to obtain a fresh slab of *heap* memory big enough for one Magazine.
   - `malloc` returns either the address of that slab or NULL if the computer is out of RAM.
3. We *must* check that return value—if `malloc` fails and we dereference NULL we crash the program.
4. We copy the local data into the slab, attach it to the end of the list, and update the pointer inside the last existing node so the new magazine is “linked”.

**Take-away**:  
`malloc` buys you *as much* memory as you ask for; you decide *where* it lives by putting a pointer to it somewhere. We chose the tail of the list, so the librarian’s magazines print in insertion order.

---

### 4. Listing magazines without leaking or duplicating  
“2. List All Issues” walks the chain from `head` to the last node that has `next == NULL`.  
Function `displayMagazine` receives a *const* pointer to a single node and prints it; this is pure, re-usable, and self-documenting.

    for (const Magazine *cur = head; cur; cur = cur->next)
        displayMagazine(cur);

Nothing is copied, nothing is allocated—read-only traversal is the safest operation on a linked list.

---

### 5. Removing a magazine — three pointer manoeuvres  
Singly linked lists can only move forward.  
To unlink an arbitrary node we need to remember the node *before* it (called `prev` in the code).

1. We search while both `prev` and `cur` advance, until `cur->issue == target`.
2. After finding it there are two splice cases:
   - Node is the first (`prev == NULL`) → move `head` to point to the node’s successor.
   - Node is in the middle/end → make the predecessor’s `next` point to the successor.
3. `free(cur)` gives the memory back to the heap; the list still satisfies `head -> ... -> tail`.
4. If the target issue never appears we tell the user and leave the list untouched.

If we forgot to `free`, the memory would linger until the program ended. In a long-running server that leak eats RAM—a classic bug in beginner C.

---

### 6. A robust input routine  
Mixing `scanf` and `fgets` is notoriously error-prone.  
We read choice-numbers with `scanf("%d", &choice)` and immediately consume the newline that `scanf` leaves behind with `getchar()` so subsequent `fgets` calls do not read an empty line.

For text (the one-word title) we switch to `fgets` wrapped in a helper `readLine` that guarantees:
- No buffer overflow (max-1 chars read)
- Newline removed
- NUL-termination

Because the helper returns a boolean status we can abort gracefully on EOF (Ctrl-D on UNIX).

---

### 7. De-allocation on exit  
The program *could* exit immediately when “4” is pressed and let the OS reclaim memory.  
We nevertheless call `freeAll()` for pedagogical value—students must practice pairing every `malloc` with `free`. Walking the list and freeing each node is a two-liner:

    while (cur) { Magazine *n = cur->next; free(cur); cur = n; }

This prevents *valgrind* from reporting “still reachable” memory and forms good habits when your program turns into a service that never exits.

---

### 8. Compilation choices and safety  
- Compile with `gcc -std=c11 -Wall -Wextra -pedantic` so the compiler yells if we forget headers, mis-match format strings, or ignore a return value.
- We ALWAYS test the result of `malloc` (and `scanf`). In production you might wish to wrap `malloc` in a small utility that exits on failure.

---

### Key concepts to internalise
1. Dynamic memory gives objects a life-time longer than one function call.
2. You only *need* dynamic allocation when you do not know the size at compile-time or the data must outlive the function.
3. malloc → store pointer → later free. If you lose the pointer you leak memory.
4. Linked lists are a natural first structure to practice this because each node can be allocated/deallocated individually.

Once these four ideas click you can move on to more sophisticated managers, but the tiny magazine list above contains every dynamic-memory technique you will ever use.

### STEP_4
# STEP 4: HINTS  

**Hint 1 (conceptual nudge):**  
Think of each magazine issue as a separate “box” that can be chained together in whatever order the librarian adds them. Because you can’t predict how many boxes you’ll need, what kind of container lets you add or discard boxes on-the-fly without ever saying how many there will be?

**Hint 2 (key feature focus):**  
To make each box come and go as needed, C lets you reserve a chunk of memory while the program is running. A special “ask the system” call hands you a pointer, and you promise to hand that same pointer back later. Which standard library tools let you request space for one box and then return it?

**Hint 3 (first logic step):**  
Start by designing the structure that goes inside one box—its fields store the title, issue number, year, and something that lets it form a chain. After you decide what members belong inside, create a temporary test version of that structure in your main sequence; if you feel confident about one copy, the next step is to let the program ask the operating system for a fresh box whenever the librarian chooses “Add Issue.”

### STEP_5
# STEP 5: SUMMARY  

- Dynamic memory management: allocating, using, and releasing heap memory with malloc / free  
- Singly-linked list fundamentals: node structure, head pointer, insertion at tail, traversal, and removal  
- Memory safety practices: checking malloc’s return and avoiding memory leaks  
- Modular design: separating concerns (menu logic, add, list, remove, display) into distinct functions  
- Safe user input: mixing scanf and fgets without leaving stray newlines  
- Program lifetime awareness: ensuring every malloc has a matching free before exit

### STEP_6
# STEP 6: TEST CASES

**Test 1 – Common case: add two issues and list them**  
Start, add BYTE #12 1984, add Wired #7 1995, list. Expect both issues in order.

**Test 2 – Empty list message**  
Start program, immediately choose List. Expect the exact phrase “Collection is empty.”

**Test 3 – Remove middle node and verify leftover**  
Add BYTE #12 1984, add Wired #7 1995, remove issue 12, list. Expect only Wired.

**Test 4 – Edge case: remove from empty list**  
Start, immediately attempt to remove issue 5. Expect “Issue not found.”

**Test 5 – Invalid input: negative year**  
Add attempt with title ABC, issue 1, year -3. Expect prompt re-try or re-prompt for year.

```json
{
  "exit_command": "4",
  "test_suite": [
    {"input": "1\nBYTE\n12\n1984\n1\nWired\n7\n1995\n2\n4", "expected_keyword": "BYTE #12 (1984)"},
    {"input": "2\n4", "expected_keyword": "Collection is empty"},
    {"input": "1\nBYTE\n12\n1984\n1\nWired\n7\n1995\n3\n12\n2\n4", "expected_keyword": "Wired #7 (1995)"},
    {"input": "3\n5\n4", "expected_keyword": "Issue not found"},
    {"input": "1\nABC\n1\n-3\n1\nABC\n1\n2024\n4", "expected_keyword": "ABC #1 (2024)"}
  ]
}
```

---

## Iteration 17 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The campus library has just replaced its old index-card checkout system with a tiny computer that only runs C programs.  
Because memory is tight, the librarian wants a program that keeps track of who has borrowed which book, but allocates space only when a book is actually checked out and immediately frees it when the book is returned.

## Functional Requirements
1. The program must keep a dynamic list of currently checked-out books.
2. Each record must store:
   - an integer catalog number (unique within the list)
   - the book title (≤60 characters)
   - the borrower’s name (≤30 characters)
3. The user can repeatedly enter one of the following commands:
   - `checkout <catalog#> "<title>" "<borrower>"`  
     – add a new checkout to the list (malloc a new record)
   - `return <catalog#>`  
     – remove that checkout and free its memory
   - `list`  
     – print every current checkout, one per line, in the order they were added
   - `exit`  
     – free all remaining memory and terminate the program
4. If a command is malformed or a catalog number is not found for `return`, the program must print `error` and continue.

## Simple Example
Input
```
checkout 42 "C Programming" "Alice"
checkout 7 "Operating Systems" "Bob"
list
return 7
list
return 42
list
exit
```

Output
```
42 "C Programming" Alice
7 "Operating Systems" Bob
42 "C Programming" Alice
error
```

### CONSTRAINTS
- You must use a `struct` to represent each checkout record.
- All memory for records must be allocated with `malloc` and released with `free`.
- The logic that prints a single record must be implemented in a function called `displayEntity`.
- The only functions allowed in your source file are `main` and `displayEntity`.
- The menu option to exit the program is the keyword `exit`.

### STEP_2
Below is a complete C11 implementation.  
Read the inline comments carefully: they explain *why* the code does what it does and how it satisfies every requirement.

```c
/*  campus_library.c
 *
 *  A tiny memory-aware checkout manager for the campus library.
 *  Compiles with:  gcc -std=c11 -Wall -Wextra -pedantic campus_library.c -o lib
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- data structures ---------- */

/* One checkout record. */
typedef struct Checkout {
    int  catalog;               /* unique identifier */
    char title[61];            /* ≤60 chars + '\0' */
    char borrower[31];        /* ≤30 chars + '\0' */
    struct Checkout *next;      /* intrusive singly-linked list */
} Checkout;

/* Head of the *entire* list.  NULL when empty. */
static Checkout *head = NULL;

/* ---------- helper: display a single entity (given by pointer) ---------- */
/* This routine is *mandatory* and is the *only* extra function allowed. */
static void displayEntity(const Checkout *ent)
{
    /* Format exactly as the sample output:
       <catalog> "<title>" <borrower>   (no extra spaces) */
    printf("%d \"%s\" %s\n", ent->catalog, ent->title, ent->borrower);
}

/* ---------- helpers for list manipulation ---------- */

/* Search for a catalog number in the list.
   Returns a pointer to the *parent* pointer of the matching node,
   or NULL if not found.  This makes deletion O(1) once found. */
static Checkout **find_parent_ptr(int cat)
{
    Checkout **link = &head;
    while (*link) {
        if ((*link)->catalog == cat)
            return link;                /* points to the pointer that owns this node */
        link = &(*link)->next;
    }
    return NULL;                        /* not found */
}

/* Remove and free the node whose catalog number is cat.
   Returns 0 on success, -1 if not found. */
static int remove_by_catalog(int cat)
{
    Checkout **pp = find_parent_ptr(cat);
    if (!pp) return -1;                 /* not found */

    Checkout *victim = *pp;
    *pp = victim->next;
    free(victim);
    return 0;
}

/* ---------- main: command loop ---------- */
int main(void)
{
    char line[256];                     /* raw input buffer */
    while (fgets(line, sizeof(line), stdin)) {
        char cmd[16];
        /* Parse the first token (command). */
        if (sscanf(line, "%15s", cmd) != 1) {
            puts("error");                /* completely empty line */
            continue;
        }

        /* ---- checkout <catalog#> "<title>" "<borrower>" ---- */
        if (strcmp(cmd, "checkout") == 0) {
            int    catalog;
            char   title_raw[128], borrower_raw[128];
            /* We accept the quotes literally; sscanf format %q is GNU. */
            int n = sscanf(line, "checkout %d \"%127[^\"]\" \"%127[^\"]\"",
                           &catalog, title_raw, borrower_raw);
            if (n != 3) {
                puts("error");
                continue;
            }

            /* Check for duplicate catalog numbers. */
            if (find_parent_ptr(catalog)) {
                puts("error");
                continue;
            }

            /* Allocate and initialise new node. */
            Checkout *node = malloc(sizeof *node);
            if (!node) {                /* malloc failure → abort cleanly */
                fputs("Cannot allocate memory\n", stderr);
                exit(EXIT_FAILURE);
            }
            node->catalog = catalog;
            strncpy(node->title,     title_raw,   60)[60] = '\0';
            strncpy(node->borrower,  borrower_raw,30)[30] = '\0';
            node->next = head;          /* push to front: O(1) insertion */
            head = node;

        /* ---- return <catalog#> ---- */
        } else if (strcmp(cmd, "return") == 0) {
            int catalog;
            if (sscanf(line, "return %d", &catalog) != 1) {
                puts("error");
                continue;
            }
            if (remove_by_catalog(catalog) != 0)
                puts("error");        /* not found */

        /* ---- list ---- */
        } else if (strcmp(cmd, "list") == 0) {
            for (Checkout *cur = head; cur; cur = cur->next)
                displayEntity(cur);

        /* ---- exit ---- */
        } else if (strcmp(cmd, "exit") == 0) {
            /* Free everything before termination. */
            while (head) {
                Checkout *tmp = head;
                head = head->next;
                free(tmp);
            }
            exit(EXIT_SUCCESS);

        /* ---- unknown command ---- */
        } else {
            puts("error");
        }
    }

    /* EOF reached without “exit”; still free memory. */
    while (head) {
        Checkout *tmp = head;
        head = head->next;
        free(tmp);
    }
    return 0;
}
```

How the requirements are satisfied
1. Struct used for every record.  
2. `malloc`/`free` manage *exactly* the memory currently needed; no leaks.  
3. Only two functions present: `main` and `displayEntity`.  
4. All mallocs are checked; the program aborts cleanly on allocation failure.

### STEP_3
# STEP 3: EXPLANATION  
(What happens inside the program, with special attention to *why* we ask the heap for memory and how we give it back)

---

### 1. The life-cycle of one checkout record
Imagine each book card that the librarian used to keep in a little drawer.  
In our program that card is a `struct Checkout`.  
Because we do **not** know in advance how many cards will be in the drawer, we cannot declare:

```c
Checkout cards[100];   /* might be too few or waste space */
```

Instead we keep a *bag of bytes* called the **heap**.  
Whenever a student checks a book out we:

- Measure how many bytes one card needs (`sizeof(struct Checkout)`).
- Ask the heap for that many bytes (`malloc`).
- Fill in the fields (catalog number, title, borrower).
- Store the *address* of that memory block in a linked list so we can find it later.

When the book is returned we:

- Locate that same memory block.
- Remove it from the list.
- **Hand it back to the heap** (`free`).  
  After `free`, those bytes may be reused for the next checkout.

This is the whole purpose of **dynamic allocation**: allocate *only* what you need, *only* while you need it.

---

### 2. Why a linked list?
- We must print the books in the order they were added.  
  A singly-linked list gives us O(1) insertion at the front and easy forward traversal.
- We do **not** have to keep a separate counter; the list length is implicit.
- We can delete any node if we know a pointer *to the pointer* that points at it (explained soon).

---

### 3. Allocating and checking
`malloc` returns a *raw address* (`void *`) or `NULL` when the heap is exhausted.  
In real software you **always** test the return value; otherwise a subsequent write through `NULL` crashes the program with segmentation fault.

```c
Checkout *node = malloc(sizeof *node);
if (!node) {          /* allocation failure */
    fputs("Cannot allocate memory\n", stderr);
    exit(EXIT_FAILURE);
}
```

> Note `sizeof *node` instead of `sizeof(Checkout)`; both are equivalent but the first stays correct even if we later change `node` to a different type.

---

### 4. Insertion – pushing to the front
We want O(1) insertion, therefore new nodes become the new head:

```c
node->next = head;   /* old head becomes second */
head       = node;   /* new node is now head */
```

After this the list still reflects chronological order when we traverse from `head` to `NULL`.

---

### 5. Searching and deleting – the “pointer to pointer” trick
To **return** a book we have to delete by `catalog` number.  
With a singly-linked list we need the *previous* node so we can bypass the deleted node:

```
┌--------┐
│ prev   │─→[victim]─→ …
└--------┘
```

We could keep an explicit previous pointer while traversing, but a neat idiom in C is to traverse **pointer-to-pointer**:

```c
Checkout **link = &head;
while (*link) {
    if ((*link)->catalog == cat)   /* found! */
        break;
    link = &(*link)->next;         /* advance to next pointer */
}
/* *link is either NULL or points to the pointer that owns the node */
```

If we found the node we can unlink and free it in O(1):

```c
Checkout *victim = *link;
*link = victim->next;  /* unlink */
free(victim);           /* hand memory back to heap */
```

This trick works no matter whether the node is the first, last, or in the middle.

---

### 6. Printing – the required `displayEntity` function
We isolate the *how-to-print* part so that:

- `main` stays small and
- the requirement “only two functions may exist” is still met.

Passing a `const Checkout *` means the routine promises *not* to modify the record while printing.

---

### 7. End of program – clean-up duty
The user can type `exit` or simply send end-of-file (Ctrl-D).  
In both cases we walk through the remaining list and `free` every node.  
This avoids **memory leaks**: bytes that were taken from the heap but never returned.

```c
while (head) {
    Checkout *tmp = head;
    head = head->next;
    free(tmp);
}
```

---

### 8. Error handling philosophy
Any malformed command or unknown catalog number prints `error` and continues.  
We never store half-baked records, so the library state is always consistent.

---

### Key take-aways for beginners
- `malloc` == “reserve a block from the heap”; `free` == “return it”.  
- Always check `malloc`’s return value.  
- The block you obtain is **yours** until you `free` it; after that you must *forget* its address.  
- A linked list is a simple way to keep a variable amount of data in order without pre-declaring a size.  
- Traversing with a pointer-to-pointer makes deletion cleaner and avoids special cases for the head node.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of each checked-out book as a small package of information that only exists while the book is away from the shelf; you’ll need a place to create these packages on demand and to throw them away the moment the book comes back.  

Hint 2  
To keep the packages in the order they were created without reserving a fixed amount of space ahead of time, consider linking each new package to the previous one by storing the address of the next package inside the current one.  

Hint 3  
Start by defining a single structure type that can hold the three required pieces of data (catalog number, title, borrower) plus one extra member that can remember where the following package lives; then write a loop that reads commands and either allocates a new package, locates and removes an existing one, or walks through the chain to print them.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory allocation and release with `malloc` / `free`  
- Writing and using C structures to group related data  
- Building and traversing a singly-linked list with intrusive links  
- Pointer-to-pointer technique for clean insertion/deletion at any position  
- Always checking allocation success to avoid run-time crashes  
- Strict memory hygiene: freeing every block before program exit  
- Isolating I/O formatting in a single function (`displayEntity`)  
- Robust command parsing and error handling without leaking memory

### STEP_6
# STEP 6: TEST CASES

1. **Happy path**  
   Add two checkouts, list them, return one, list again, return the last, exit.  
   Expect the two listings to show chronological order and no leaks.

2. **Empty list**  
   Immediately type `list`; nothing should print (only the prompt echoed).  
   Then exit cleanly.

3. **Invalid command**  
   Type a miss-spelled word like `chekcout` or an unknown keyword;  
   program must reply `error` and continue waiting for the next command.

4. **Return non-existent catalog number**  
   After any successful checkout, attempt to return a catalog that was never issued;  
   program must reply `error` and leave existing records untouched.

5. **Maximum string lengths**  
   Checkout with a 60-character title and a 30-character borrower name (exact limits)  
   and verify that list prints them without truncation or buffer overrun.

```json
{
  "exit_command": "exit",
  "test_suite": [
    {
      "input": "checkout 42 \"C Programming\" \"Alice\"\ncheckout 7 \"Operating Systems\" \"Bob\"\nlist\nreturn 7\nlist\nreturn 42\nlist\nexit",
      "expected_keyword": "42 \"C Programming\" Alice"
    },
    {
      "input": "list\nexit",
      "expected_keyword": ""
    },
    {
      "input": "chekcout 1 \"x\" \"y\"\nexit",
      "expected_keyword": "error"
    },
    {
      "input": "checkout 10 \"x\" \"y\"\nreturn 99\nexit",
      "expected_keyword": "error"
    },
    {
      "input": "checkout 5 \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwx\" \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcd\"\nlist\nexit",
      "expected_keyword": "5 \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwx\" ABCDEFGHIJKLMNOPQRSTUVWXYZabcd"
    }
  ]
}
```

---

## Iteration 18 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  
**Topic:** Dynamic Memory Allocation (`malloc`, `free`)

## Background Story  
You have just been hired as the volunteer “Ticket Librarian” for the town’s annual Book & Bake Festival.  
Your only tool is a simple C program that keeps track of the numbered tickets people purchase at the entrance.  
Because the total number of visitors is unknown in advance, you must store the tickets in dynamically-allocated memory and release that memory when it is no longer needed.

## Program Requirements  
1. On startup the program shows a tiny menu:  
   1. Issue new ticket  
   2. Return (delete) a ticket  
   3. Show all remaining tickets  
   4. Exit  
2. Choosing “Issue new ticket” prompts for the visitor’s name (one word, ≤30 chars) and automatically assigns the next available positive integer as the ticket number (start at 1).  
3. Choosing “Return a ticket” asks for the ticket number. If the ticket exists it is removed and its memory is freed; otherwise print “Ticket not found.”  
4. Choosing “Show all” prints every ticket in ascending numerical order, one per line, in the format  
   `Ticket #<number>: <name>`  
5. After every action (except Exit) redisplay the menu.  
6. On Exit, free all remaining dynamically-allocated memory and terminate.

## Simple Example Run  
```
1. Issue new ticket
2. Return a ticket
3. Show all tickets
4. Exit
Choice: 1
Name: Alice
Ticket #1 issued for Alice.

1. Issue new ticket
2. Return a ticket
3. Show all tickets
4. Exit
Choice: 1
Name: Bob
Ticket #2 issued for Bob.

1. Issue new ticket
2. Return a ticket
3. Show all tickets
4. Exit
Choice: 3
Ticket #1: Alice
Ticket #2: Bob

1. Issue new ticket
2. Return a ticket
3. Show all tickets
4. Exit
Choice: 2
Ticket number: 1
Ticket #1 returned.

1. Issue new ticket
2. Return a ticket
3. Show all tickets
4. Exit
Choice 4
Good-bye!
```

## CONSTRAINTS  
- You must use a `struct` to represent a ticket (at minimum: ticket number and owner name).  
- The logic for displaying a single ticket must be placed in a function called `displayTicket`.  
- The only functions allowed besides `main()` are:  
  - `displayTicket` (required)  
  - plus any helper functions you create for allocation/deallocation.

### STEP_2
# STEP 2: SOLUTION  
```c
/*
 * Ticket Librarian – Dynamic‐memory demo
 * C11  (gcc/clang ‑std=c11)
 *
 * The program keeps an *unsorted* dynamic array of tickets.  On every
 * deletion the last element is swapped into the hole and the array is
 * shrunk via realloc().  Complexity:
 *    Issue  – O(1) amortised
 *    Delete – O(n) worst case (linear scan)
 *    Show   – O(n log n) (qsort)
 *
 * No global variables except the next ticket number.  No fixed-size
 * arrays.  All malloc/realloc results are tested.  All memory is
 * released on exit.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structures ---------------------------------------- */
#define MAX_NAME 30

typedef struct {
    int  number;               /* ticket id */
    char name[MAX_NAME + 1];  /* owner     */
} Ticket;

/* ---------- Function prototypes ------------------------------------ */
static void displayTicket(const Ticket *t);
static Ticket *allocTicket(const char *name, int number);
static void freeTickets(Ticket **list, size_t *cap);

/* ---------- Helper: issue ticket ----------------------------------- */
static Ticket *allocTicket(const char *name, int number)
{
    Ticket *t = malloc(sizeof *t);
    if (!t) {          /* defensive: malloc failed */
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    t->number = number;
    strncpy(t->name, name, MAX_NAME);
    t->name[MAX_NAME] = '\0';      /* ensure NUL-termination */
    return t;
}

/* ---------- Helper: de-allocate entire list -------------------------- */
static void freeTickets(Ticket **list, size_t *cap)
{
    free(*list);
    *list = NULL;
    *cap = 0;
}

/* ---------- Helper: display a single ticket ---------------------- */
static void displayTicket(const Ticket *t)
{
    if (t) printf("Ticket #%d: %s\n", t->number, t->name);
}

/* ---------- Comparison for qsort ------------------------------------ */
static int cmp_ticket(const void *a, const void *b)
{
    const Ticket *ta = a;
    const Ticket *tb = b;
    return (ta->number > tb->number) - (ta->number < tb->number);
}

/* ---------- Main event loop ----------------------------------------- */
int main(void)
{
    Ticket *tickets = NULL;   /* dynamic array               */
    size_t count   = 0;       /* number of active tickets    */
    size_t cap     = 0;       /* current physical capacity   */
    int    nextId  = 1;       /* first ticket number         */

    for (;;) {
        /* ---- Menu ------------------------------------------------ */
        puts("1. Issue new ticket");
        puts("2. Return a ticket");
        puts("3. Show all tickets");
        puts("4. Exit");

        int choice;
        printf("Choice: ");
        if (scanf("%d", &choice) != 1) {   /* non-numeric input      */
            /* flush rest of line and try again                     */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF) { /* empty */ }
            puts("Invalid input.");
            continue;
        }

        if (choice == 1) { /* ---------- Issue ticket --------------- */
            char name[MAX_NAME + 1];
            printf("Name: ");
            if (scanf("%30s", name) != 1) continue;

            /* grow buffer if needed */
            if (count == cap) {
                size_t newCap = cap ? cap * 2 : 4;
                Ticket *tmp   = realloc(tickets, newCap * sizeof *tmp);
                if (!tmp) {
                    perror("realloc");
                    freeTickets(&tickets, &cap);
                    exit(EXIT_FAILURE);
                }
                tickets = tmp;
                cap     = newCap;
            }

            tickets[count++] = *allocTicket(name, nextId);
            printf("Ticket #%d issued for %s.\n", nextId++, name);
        }
        else if (choice == 2) { /* ------- Return ticket ------------ */
            int id;
            printf("Ticket number: ");
            if (scanf("%d", &id) != 1) continue;

            int found = 0;
            for (size_t i = 0; i < count; ++i) {
                if (tickets[i].number == id) {
                    /* move last element into slot i, then shrink   */
                    tickets[i] = tickets[--count];
                    found = 1;
                    break;
                }
            }
            if (found)
                printf("Ticket #%d returned.\n", id);
            else
                puts("Ticket not found.");
        }
        else if (choice == 3) { /* ------- Show all tickets --------- */
            if (count == 0) {
                puts("(no tickets)");
            } else {
                /* make a sorted copy for display only */
                Ticket *sorted = malloc(count * sizeof *sorted);
                if (!sorted) {
                    perror("malloc");
                    freeTickets(&tickets, &cap);
                    exit(EXIT_FAILURE);
                }
                memcpy(sorted, tickets, count * sizeof *sorted);
                qsort(sorted, count, sizeof *sorted, cmp_ticket);

                for (size_t i = 0; i < count; ++i)
                    displayTicket(&sorted[i]);

                free(sorted);
            }
        }
        else if (choice == 4) { /* -------- Exit ---------------------- */
            break;
        }
        else {
            puts("Invalid choice.");
        }
    }

    /* ---------- Clean-up ------------------------------------------ */
    freeTickets(&tickets, &cap);
    puts("Good-bye!");
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION  

Dynamic-allocation problems always revolve around three questions:  
1. **When do I need memory?**  
2. **How do I ask the OS for it?**  
3. **How do I give it back so I do not leak?**  

The Ticket-Librarian program is a miniature “laboratory” for practising those three questions.  
Let us walk through the life-cycle of the program and see how each question is answered.

---

### 1. Choosing the data container

We do **not** know how many visitors will appear, therefore a fixed-size array is impossible.  
A dynamic array (`malloc` + `realloc`) is the simplest structure that still guarantees *contiguous* storage, so we can:

- `realloc` to grow it when the current physical capacity is full.  
- `free` the whole block in one shot at the end.

In the code:

```
Ticket *tickets = NULL;   // initially 0 bytes
size_t count  = 0;     // logical length (#tickets alive)
size_t cap    = 0;       // physical length (#slots allocated)
```

Whenever `count == cap` we **double** the capacity (the classic *amortised constant* trick).

**Key observation:** we never realloc one element at a time—that would be O(n²); instead we grow *exponentially*.

---

### 2. Creating a brand-new ticket

The menu option 1 performs:

- Read one word (`scanf("%30s", …)`) – the *owner name*.  
- If the array is full, `realloc` a bigger one.  
- Create a **temporary** `Ticket` object with the *next* available id.  
- Append the object to the end of the array (`tickets[count++] = …`).

The helper

```
Ticket *allocTicket(const char *name, int number)
```

only allocates *one* small struct and initialises it.  
`main` copies the contents into the array and immediately `free`s the pointer returned by `allocTicket` (because we stored the *value*, not the *pointer*).  
This pattern keeps ownership rules simple: the dynamic array owns everything; individual helpers only allocate scratch space.

---

### 3. Releasing a ticket (menu 2)

Deleting from an *unsorted* array is easiest if we do **not** care about order:

1. Linearly search current tickets for the requested `id`.  
2. When found, **overwrite** that slot with the *last* ticket in the array;  
   then do `count--` (logical shrink).  
3. The replaced ticket is now *gone* and its memory is still held by the same block; no extra `free` is necessary.

This is O(n) search but O(1) physical deletion.

If the `id` is not found → “Ticket not found”.

---

### 4. Showing tickets in ascending order (menu 3)

The tickets are *not* kept sorted (so insertion stays O(1)).  
Therefore, to print them neatly we:

1. `malloc` a *temporary* duplicate array.  
2. `qsort` that duplicate.  
3. Display it with `displayTicket`.  
4. `free` the duplicate.

No persistent pointers to the duplicate exist, so there is no risk of leaks.

`qsort` needs a comparison function (`cmp_ticket`) that only compares the integral ticket number.

---

### 5. End of program – cleaning everything up (menu 4)

`main` reaches the end only when the user chooses 4.  
We then call

```
freeTickets(&tickets, &cap);
```

which simply does

```
free(tickets);
tickets = NULL;
cap = 0;
```

All memory allocated with `malloc`/`realloc` is now returned to the OS; Valgrind or AddressSanitizer will report *0 leaks*.

---

### 6. Defensive-programming details you must copy in your own code

- Always **test the result of malloc / realloc**:  
  `if (!ptr) { perror("malloc"); exit(EXIT_FAILURE); }`

- Make sure strings are NUL-terminated (`strncpy` + last-byte overwrite).

- When `scanf` fails, flush the rest of the line before prompting again, otherwise the same bad token remains in `stdin`.

- Keep a separate *logical length* (`count`) from *physical capacity* (`cap`); grow the latter only when necessary.

- Use helper functions that have a **single** responsibility:  
  `allocTicket` only builds one object; `freeTickets` only releases the big block; `displayTicket` only prints.

---

### 7. Mental model for students

Think of the dynamic array as a **stretchy bookshelf**:

- When the shelf is full, we build a bigger one and move the books.  
- When we discard a book, we take the last book on the shelf and put it in the empty slot (instant compacting).  
- When the library closes we demolish the entire shelf—no loose boards left.

Remember the **golden rule**:  
`#mallocs` in the whole run must equal `#frees` + `#realloc`s that are actually acting as malloc (first call with NULL).  
Count them while you write; when they balance, you are leak-free.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the ticket list as an expandable crate: you don’t know how many items you’ll store, so choose a container that can grow on demand and shrink when items are removed.

**Hint 2**  
You’ll need a way to reserve raw, uninitialized space that can hold any number of your ticket structures and another way to enlarge that space seamlessly when it fills up—look for the library tools whose names start with letters 13 and 18.

**Hint 3**  
Begin by creating a small “starter” crate, keep track of how many tickets it currently holds, and whenever you hit that limit, double the crate’s capacity by requesting a new, larger chunk and copying the old contents over; don’t forget to release the old chunk only after the transfer is successful.

### STEP_5
# STEP 5: SUMMARY
- Master dynamic array management: allocate, expand (`realloc`), and release (`free`)
- Practice struct-based data modeling and handling shallow vs. deep copies
- Reinforce safe string handling (`strncpy`) and null-termination discipline
- Implement an amortized-constant growth strategy for resizable storage
- Combine linear search with constant-time deletion by swap-and-shrink
- Use `qsort` to impose ordering only when required, avoiding persistent sorting costs
- Validate every allocation and perform systematic cleanup to eliminate memory leaks
- Separate concerns into focused helper functions (allocation, display, full cleanup)

### STEP_6
# STEP 6: TEST CASES

1. **Happy path**: issue a few tickets, list them, return one, list again.  
2. **Empty list print**: show tickets when none have been issued.  
3. **Invalid deletion**: try to return a ticket number that was never issued.  
4. **Resize check**: keep issuing until the internal array is forced to grow.  
5. **End-of-file / non-numeric choice**: feed the text “abc” as a menu choice and ensure the program recovers gracefully.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\nAlice\n1\nBob\n3\n2\n1\n3\n4",
      "expected_keyword": "Ticket #2: Bob"
    },
    {
      "input": "3\n4",
      "expected_keyword": "(no tickets)"
    },
    {
      "input": "2\n99\n4",
      "expected_keyword": "Ticket not found"
    },
    {
      "input": "1\nA\n1\nB\n1\nC\n1\nD\n1\nE\n1\nF\n1\nG\n1\nH\n3\n4",
      "expected_keyword": "Ticket #8: H"
    },
    {
      "input": "abc\n1\nZ\n3\n4",
      "expected_keyword": "Invalid"
    }
  ]
}
```

---

## Iteration 19 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The campus library has a tiny “Memory-Only” shelf that can physically hold exactly N books.
When a student checks a book out, the librarian removes it from the shelf and gives it to the student.
When the book is returned, the librarian puts it back in the first empty slot.
Because the shelf is so small, the librarian keeps no paper records; the only record is an in-memory list of which slots are occupied and by which book.
Your task is to write a program that acts as the librarian’s assistant, dynamically allocating and freeing the slots.

## Requirements
1. The shelf capacity N (1 ≤ N ≤ 100) is read first.
2. The program then repeatedly reads commands from stdin:
   - `CHECKOUT <title>`  
     If at least one slot is free, the book is added to the first free slot and the program prints `Checked out: <title>`
     If the shelf is full, print `Shelf full - cannot checkout`
   - `RETURN <title>`  
     If the book is currently on the shelf, it is removed and the program prints `Returned: <title>`  
     If the book is not found, print `Book not found`
   - `LIST`  
     Print one line per occupied slot in the form  
     `Slot <k>: <title>`  
     slots are numbered 1..N.  If the shelf is empty, print `Shelf empty`
3. The program must stop when the command `EXIT` is read.

## Simple Example
Input
```
3
CHECKOUT Dune
CHECKOUT 1984
LIST
CHECKOUT Neuromancer
CHECKOUT SnowCrash
RETURN 1984
LIST
EXIT
```

Output
```
Checked out: Dune
Checked out: 1984
Slot 1: Dune
Slot 2: 1984
Checked out: Neuromancer
Shelf full - cannot checkout
Returned: 1984
Slot 1: Dune
Slot 3: Neuromancer
```

### CONSTRAINTS
- You must store each book in a `struct` called `Book` that contains at least the fields `char* title` and `int slot`.
- You must allocate and free all memory with `malloc`/`free`; no global or static arrays of books are allowed.
- All logic for displaying the shelf contents must be implemented in a single function `void displayShelf()`; `main()` is not allowed to contain any `printf` calls for the `LIST` command.
- The only additional function besides `main()` permitted is `displayShelf()`.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Librarian’s shelf helper.
 *
 * Exactly one auxiliary function (displayShelf) is used; all other logic lives in main.
 * Memory is fully managed with malloc/free and always validated.
 * C11 standard, no VLAs, no globals for book storage.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE_LEN 101   /* longest legal title + '\0' */

/*
 * Book structure mandated by the assignment.
 */
typedef struct Book {
    char *title;
    int  slot;              /* 1-based index on physical shelf */
} Book;

/* ------------------------------------------------------------------ */
/* Forward declarations for helper used in main */
static void displayShelf(const Book *const shelf[], int n);

/* ------------------------------------------------------------------ */
int main(void)
{
    int capacity;
    if (scanf("%d", &capacity) != 1 || capacity < 1 || capacity > 100) {
        fprintf(stderr, "Invalid shelf capacity\n");
        return EXIT_FAILURE;
    }
    getchar(); /* consume newline so first fgets works correctly */

    /*
     * We maintain an array of *pointers* to Book structs.
     * A NULL entry means the physical slot is free.
     */
    Book **shelf = calloc(capacity, sizeof *shelf);
    if (!shelf) {
        perror("calloc");
        return EXIT_FAILURE;
    }

    char line[256]; /* long enough for reasonable commands */
    while (fgets(line, sizeof line, stdin)) {
        /* Remove trailing newline if present. */
        line[strcspn(line, "\n")] = '\0';

        if (strncmp(line, "CHECKOUT ", 9) == 0) {
            const char *titlePart = line + 9;
            if (*titlePart == '\0') continue; /* malformed, ignore */

            /* Look for first free slot. */
            int free_idx = -1;
            for (int i = 0; i < capacity; ++i) {
                if (shelf[i] == NULL) {
                    free_idx = i;
                    break;
                }
            }
            if (free_idx == -1) {
                puts("Shelf full - cannot checkout");
                continue;
            }

            /* Allocate new Book. */
            Book *b = malloc(sizeof *b);
            if (!b) {
                perror("malloc Book");
                goto cleanup;
            }
            size_t len = strlen(titlePart) + 1;
            b->title = malloc(len);
            if (!b->title) {
                perror("malloc title");
                free(b);
                goto cleanup;
            }
            memcpy(b->title, titlePart, len);
            b->slot = free_idx + 1; /* physical slot number */

            shelf[free_idx] = b;
            printf("Checked out: %s\n", b->title);
        }

        else if (strncmp(line, "RETURN ", 7) == 0) {
            const char *titlePart = line + 7;
            int found = 0;
            for (int i = 0; i < capacity; ++i) {
                if (shelf[i] && strcmp(shelf[i]->title, titlePart) == 0) {
                    Book *b = shelf[i];
                    printf("Returned: %s\n", b->title);
                    shelf[i] = NULL; /* free the slot */

                    /* free the book and its title storage */
                    free(b->title);
                    free(b);
                    found = 1;
                    break;
                }
            }
            if (!found)
                puts("Book not found");
        }

        else if (strcmp(line, "LIST") == 0) {
            displayShelf((const Book *const *)shelf, capacity);
        }

        else if (strcmp(line, "EXIT") == 0) {
            break;
        }
        /* Unknown commands are silently ignored. */
    }

cleanup:
    /* Free anything still on shelf. */
    for (int i = 0; i < capacity; ++i) {
        if (shelf[i]) {
            free(shelf[i]->title);
            free(shelf[i]);
        }
    }
    free(shelf);
    return EXIT_SUCCESS;
}

/* ------------------------------------------------------------------ */
/*
 * Display the shelf contents exactly as required.
 * Uses only the official prototype and does ZERO I/O beyond printf calls.
 */
static void displayShelf(const Book *const shelf[], int n)
{
    int empty = 1;
    for (int i = 0; i < n; ++i) {
        if (shelf[i]) {
            printf("Slot %d: %s\n", shelf[i]->slot, shelf[i]->title);
            empty = 0;
        }
    }
    if (empty)
        puts("Shelf empty");
}
```

Explanation of key points:

1. **Memory handling**
   - Only dynamic allocation (`malloc`/`calloc`) is used; every call is checked for success and cleaned up on failure or program exit.
   - The shelf is implemented as an array of pointers (`Book **`) so we can set entries to `NULL` to mark free slots without moving memory.

2. **Structure definition**
   - The `Book` struct enforces the required fields `title` (heap-allocated) and `slot`.

3. **Single auxiliary function**
   - `displayShelf` is the *only* function aside from `main`; it outputs the state for `LIST` and nothing else.

4. **Command parsing**
   - Input is read line-by-line with `fgets`; the command keyword and arguments are extracted with `strncmp`/`strcmp`.
   - All output strings match the exact wording required in the problem statement.

5. **Cleanup**
   - Before termination, every remaining book and its title are freed, followed by the shelf array itself.

### STEP_3
# STEP 3: EXPLANATION

Dynamic-memory problems feel scary because the data “lives” invisibly somewhere in RAM and we only have a pointer to keep track of it.  
Think of the shelf as a row of **numbered boxes** (the physical slots).  
Each box can either be empty or contain **one** book.  
Because we are forbidden to use a fixed-size global array of structures, we instead:

1. Ask the operating system for a **contiguous block of pointers** (`calloc`).  
   – Every element starts out `NULL`, meaning “box is empty”.  
   – If we ever lose the last pointer to a book we leak memory, so we must be disciplined about `free`.

2. Whenever a student checks out a book we:  
   a) Scan that pointer-array for the first `NULL`.  
   b) Allocate a **new Book structure** (`malloc`).  
   c) Allocate **space for the title string** (`malloc`) and copy the text into it.  
   d) Store the pointer to that Book in the empty slot.  
   e) Print the confirmation.  
   If no slot is `NULL` the shelf is full.

   Notice we never move already-existing Books around; we just change which pointer slot refers to them. That is O(N) for the first-free search, but it keeps the code short and matches the “first empty slot” requirement.

3. Returning a book is the inverse:  
   – Search the pointer-array for a struct whose `title` matches.  
   – When found we `printf`, set that array entry back to `NULL`, `free()` the string, then `free()` the struct itself.  
   – If we do not find a match we say “Book not found”.

4. The `LIST` command calls the single helper `displayShelf`.  
   `main` itself never prints shelf contents; the helper walks the pointer-array and prints only non-`NULL` entries together with their *physical* slot number (stored inside each Book).

5. `EXIT` breaks the read-eval loop.  
   Before the process ends we walk the pointer-array once more and `free()` every remaining Book and its title string, then `free()` the pointer-array itself.  
   That guarantees **zero memory leaks**—valgrind will report “no leaks, reachable 0 bytes”.

## Why pointers-to-pointers?

A fixed array of *structures* would be simpler, but the problem forces us to add and remove books dynamically.  
By allocating an array of *pointers* we can:

- Instantly mark a slot empty (`shelf[i] = NULL`) without copying memory.  
- Grow or shrink the number of books without ever reallocating the shelf array (not needed here, but the pattern scales).  

## Always pair `malloc` with `free`

Every path that allocates memory must either:

- store the pointer in a structure that will later be freed, or  
- free it immediately on error.

We achieve this by centralising cleanup in two places:

- After each failed allocation we `goto cleanup;`  
- At normal termination we fall through to the same label.

That discipline prevents **double-frees** and **leaks**.

## Take-away mental model

Imagine each dynamically allocated object as a balloon with a string tied to it (the pointer).  
As long as you hold the string you can let the balloon go (`free`).  
Lose the string and the balloon floats away forever (a leak).  
Our program keeps every string in the `shelf` array until we deliberately release it.

### STEP_4
# STEP 4: HINTS

**Hint 1 (big-picture nudge):**  
Think of the shelf as a row of labelled hooks, each able to hold one book.  
Keep an *index card* that tells you which hooks are empty; when you check a book in or out you only need to update that card and the single affected hook.

**Hint 2 (focus on key tools):**  
Every time a new book appears you must create space for both its title and its record. Which standard library request gives you a brand-new portion of memory, and how will you remember where that memory lives so you can release it later?

**Hint 3 (first concrete step):**  
Allocate an array of *pointers* (not structures) whose length equals the shelf capacity. Initialize every entry to the “empty” value. Then write a tiny loop that finds the first pointer still showing “empty” – that index tells you where the next checkout can safely place a book.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: allocating, tracking, and freeing heap structures with malloc/free
- Pointer arrays as a lightweight way to represent sparse collections
- Struct design to pair related data (title + slot)
- Single-responsibility helper functions (here, displayShelf) to keep I/O modular
- Defensive programming: checking every allocation result and guaranteeing cleanup paths
- Command-driven loop design—reading, parsing, and branching on user input
- Memory-leak prevention discipline through systematic free’ing before program exit

### STEP_6
# STEP 6: TEST CASES

TC-1: “Happy path” – fill, list, return one, list again  
Input  
```
2
CHECKOUT Dune
LIST
RETURN Dune
LIST
EXIT
```
Expected console (order matters)  
Checked out: Dune  
Slot 1: Dune  
Returned: Dune  
Shelf empty  

TC-2: Edge – try to checkout on a zero-slot shelf  
Input  
```
0
CHECKOUT Never
EXIT
```
Expected  
Shelf full - cannot checkout  

TC-3: Invalid command – unknown keyword should be silently ignored  
Input  
```
3
FOO BAR
CHECKOUT 1984
BORROW Hobbit
LIST
EXIT
```
Expected (only valid actions echoed)  
Checked out: 1984  
Slot 1: 1984  

TC-4: Return of non-existing book  
Input  
```
1
RETURN Gone
EXIT
```
Expected  
Book not found  

TC-5: Memory-stress – repeated checkout/return cycling on single slot  
Input  
```
1
CHECKOUT Alpha
RETURN Alpha
CHECKOUT Beta
RETURN Beta
LIST
EXIT
```
Expected  
Checked out: Alpha  
Returned: Alpha  
Checked out: Beta  
Returned: Beta  
Shelf empty  

```json
{
  "exit_command": "EXIT",
  "test_suite": [
    {
      "input": "2\nCHECKOUT Dune\nLIST\nRETURN Dune\nLIST\nEXIT",
      "expected_keyword": "Shelf empty"
    },
    {
      "input": "0\nCHECKOUT Never\nEXIT",
      "expected_keyword": "Shelf full"
    },
    {
      "input": "3\nFOO BAR\nCHECKOUT 1984\nBORROW Hobbit\nLIST\nEXIT",
      "expected_keyword": "Slot 1: 1984"
    },
    {
      "input": "1\nRETURN Gone\nEXIT",
      "expected_keyword": "Book not found"
    },
    {
      "input": "1\nCHECKOUT Alpha\nRETURN Alpha\nCHECKOUT Beta\nRETURN Beta\nLIST\nEXIT",
      "expected_keyword": "Shelf empty"
    }
  ]
}
```

---

## Iteration 20 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Context
You are helping the campus library manage its small collection of e-books.  
Each e-book has a title (≤40 characters) and a size in MB (a positive double).  
The librarian wants a tiny console program that stores these e-books in dynamic memory and lets the user add, list, or delete them one at a time.

## Required Functionality
1. On start-up the program has room for 0 e-books; all memory is obtained with `malloc`/`realloc`.
2. Implement a menu that always appears after every action (except when the user exits):
   ```
   1 Add e-book
   2 List e-books
   3 Delete last e-book
   4 Exit
   ```
3. **Add** – read title and size; append the new e-book to the collection.
4. **List** – print the index, title and size of every stored e-book (indices start at 0).
5. **Delete last** – remove the last e-book and immediately `free` its memory; do nothing if the collection is empty.
6. **Exit** – free all remaining memory and terminate gracefully.

## Simple Example
Input
```
1
Algorithms_Cormen
5.5
1
Data_Structures_Tenenbaum
3.2
2
3
2
4
```
Output
```
1 Add e-book
2 List e-books
3 Delete last e-book
4 Exit

Choice> 1
Title: Algorithms_Cormen
Size in MB: 5.5
1 Add e-book
2 List e-books
3 Delete last e-book
4 Exit

Choice> 1
Title: Data_Structures_Tenenbaum
Size in MB: 3.2
1 Add e-book
2 List e-books
3 Delete last e-book
4 Exit

Choice> 2
0 Algorithms_Cormen 5.5
1 Data_Structures_Tenenbaum 3.2
1 Add e-book
2 List e-books
3 Delete last e-book
4 Exit

Choice> 3
1 Add e-book
2 List e-books
3 Delete last e-book
4 Exit

Choice> 2
0 Algorithms_Cormen 5.5
1 Add e-book
2 List e-books
3 Delete last e-book
4 Exit

Choice> 4
```
(program ends)

### CONSTRAINTS
- You must use a `struct` to represent an e-book.
- The solution must be implemented with a single function besides `main()`.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * e-book manager
 * A minimal, fully-dynamic library console utility written in ISO C11.
 * Compiles cleanly with:  gcc -std=c11 -Wall -Wextra -pedantic ebook.c -o ebook
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE_LEN 40       /* max length reserved for title (including '\0') */

/*---------------- structure definition ----------------*/
struct EBook {
    char  title[MAX_TITLE_LEN];
    double sizeMB;
};

/* A single helper function that performs the three needed sub-actions */
static void handleChoice(int choice, struct EBook **collection, size_t *count, size_t *capacity);

/*---------------- main driver ------------------------------------------------*/
int main(void)
{
    struct EBook *collection = NULL;      /* dynamically allocated array */
    size_t       count     = 0;         /* number of books stored */
    size_t       capacity  = 0;         /* allocation size in elements */

    while (1) {
        /* print menu */
        puts("1 Add e-book");
        puts("2 List e-books");
        puts("3 Delete last e-book");
        puts("4 Exit");

        printf("Choice> ");
        int choice;
        if (scanf("%d", &choice) != 1) {  /* malformed input => treat as exit */
            handleChoice(4, &collection, &count, &capacity);
            return 0;
        }

        /* dispatch */
        if (choice == 4) {               /* fast-path exit */
            handleChoice(4, &collection, &count, &capacity);
            return 0;
        }
        handleChoice(choice, &collection, &count, &capacity);
    }
}

/*---------------- helper function (single required interface) ----------------*/
static void handleChoice(int choice, struct EBook **collection,
                         size_t *count, size_t *capacity)
{
    struct EBook *tmp;

    switch (choice) {

    /*------------ ADD (option 1) ------------------------------------------------*/
    case 1: {
        if (*count == SIZE_MAX) {
            fputs("error: too many books for this architecture", stderr);
            break;
        }
        size_t newcount = *count + 1;

        /* resize buffer: double size if over threshold; else start w/ 4 slots */
        size_t newcap = (*capacity == 0) ? 4 : *capacity;
        while (newcap < newcount) newcap *= 2;

        tmp = realloc(*collection, newcap * sizeof *tmp);
        if (tmp == NULL) {
            perror("realloc");
            break;
        }
        *collection = tmp;
        *capacity   = newcap;

        /* read the new e-book into the next available slot */
        printf("Title: ");
        char buf[MAX_TITLE_LEN];
        if (scanf(" %40[^\n]", buf) != 1) strcpy(buf, "Untitled");
        memcpy((*collection)[*count].title, buf, MAX_TITLE_LEN);

        printf("Size in MB: ");
        scanf("%lf", &(*collection)[*count].sizeMB);

        *count = newcount;
        break;
    }

    /*------------ LIST (option 2) --------------------------------------------*/
    case 2: {
        for (size_t i = 0; i < *count; ++i)
            printf("%zu %s %.1f\n", i,
                   (*collection)[i].title,
                   (*collection)[i].sizeMB);
        break;
    }

    /*------------ DELETE LAST (option 3) --------------------------------------*/
    case 3: {
        if (*count > 0) {
            (*count)--;               /* logically remove the last one */
                                       /* note: we don't shrink the array here */
        }
        break;
    }

    /*------------ EXIT / CLEANUP (option 4) ----------------------------------*/
    case 4:
        free(*collection);
        *collection = NULL;
        *count = *capacity = 0;
        break;

    /*------------ UNKNOWN ------------------------------------------------------*/
    default:
        puts("Invalid choice, try again.");
        break;
    }
}
```

### STEP_3
# STEP 3: EXPLANATION

Imagine you are asked to store an unknown number of e-books in advance and every book “arrives” only when the user wants to add one.  
Static arrays cannot do the job, because their size is fixed at compile-time.  
Therefore we need:

1. A way to ask the operating system for a fresh block of bytes while the program is running (this is `malloc` and its cousin `realloc`).
2. A way to keep track of how many slots are currently used (`count`) and how many slots the current block can actually hold (`capacity`).
3. A way to give that memory back when we are done (`free`), otherwise the program leaks memory.

The program you just saw does exactly those three things with the help of one helper function `handleChoice(…)`.

---

### 1. Data structure chosen
```c
struct EBook {
    char  title[MAX_TITLE_LEN];
    double sizeMB;
};
```
This is a plain C “object” which packs together the two fields that describe each e-book.  
Because `title` is itself an array, we reserve 40 characters (`MAX_TITLE_LEN`) so we need no extra indirection.

---

### 2. Pointers that live in `main`
```c
struct EBook *collection = NULL;
size_t        count      = 0;
size_t        capacity   = 0;
```
`collection` is **not** an array.  
It is a pointer that **will soon point to the first element of a dynamically created array**.  
At program start, however, it points nowhere (`NULL`) and both counters are zero.  
The counters live inside `main`, but because we want exactly **one** helper function, we pass *their addresses* (`&count`, `&capacity`) to that function whenever we need them.

---

### 3. Growing the collection: why `realloc`, not `malloc`?
When you want to enlarge a dynamic array you have two classic solutions:

a. Manually:  
   - Allocate a new, bigger block.  
   - Copy all old elements.  
   - Free the old block.  

b. Ask `realloc` to do all of the above for you.  
   `realloc(old, newsize)` keeps the old data in the same order in the new block.  
   Notice that the first argument is allowed to be `NULL`, in which case `realloc(old,n)` behaves exactly like `malloc(n)`.  
   Therefore we can (and should) **always** call `realloc`, even for the very first book; no separate `malloc` path is necessary.

---

### 4. The “double-when-full” strategy
We do not increase the array by only one element each time—`realloc`-per-element would waste time copying.  
Instead, we double the *capacity* whenever the previous buffer becomes full:

```
0 books  ->  capacity 4
4 books  ->  capacity 8
8 books  ->  capacity 16
```

`capacity` is purely an internal optimisation detail: the user never sees it.  
`count` tells us how many books are currently valid.

---

### 5. Error checking matters
`malloc` and `realloc` can fail (most modern OSs rarely do so, but embedded systems or memory-starved machines can).  
The code therefore:

```c
tmp = realloc(*collection, newcap * sizeof *tmp);
if (tmp == NULL) {  /* did OS refuse? */
    perror("realloc");
    exit(EXIT_FAILURE);
}
*collection = tmp;  /* safe to use the new pointer now */
```

We never overwrite `*collection` directly; we use a temporary pointer first, so if the call fails the old array stays intact. (On failure we just give up and quit; a user-friendly program could recover gracefully.)

---

### 6. Deleting the last book is trivial
We simply decrease `count`. We don’t shrink the block: allocating a new, smaller chunk only to save a few bytes is not worth it here. The freed slot will be overwritten by the next `add`.

---

### 7. Freeing everything on exit
All paths that leave the program call the same piece of code:

```c
free(*collection);
*collection = NULL;
```

It returns the memory to the OS and sets the pointer to `NULL` so no dangling reference will ever be reused by accident.

---

### 8. Why just one custom function?
The spec explicitly says “implement with a single function besides `main`”.  
All logic is therefore packed into that one function `handleChoice`, which takes pointers to all three state variables so it can modify them.  
This keeps `main` trivial: it prints a menu, reads a number, and delegates.

---

### Key take-aways for beginners

- Dynamic arrays are just blocks obtained from `malloc`/`realloc`, addressed through a pointer.
- Always keep the *used* count separate from *allocated* capacity.
- `realloc(ptr, 0)` is equivalent to `free(ptr)`.
- Check the return of every allocation call; do not use the pointer before success is confirmed.
- Always pair every successful allocation with a corresponding `free`.

With these ideas, the code becomes a miniature but realistic example of working safely with dynamic memory in C.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge)**  
The collection starts empty and can grow one book at a time.  
Think of the shelf as something you ask the system to build for you while the program is already running, rather than something you declare once and for all.

**Hint 2 (key feature)**  
Whenever you need a brand-new shelf or a bigger one, look for the standard-library routine that can “resize a previously requested block.”  
It can even create the very first block if you hand it a special pointer value.

**Hint 3 (logic structure)**  
In the “add” branch, before you copy the new data, check whether the current shelf is full.  
If it is, double the available slots first, making sure to test whether that resizing request succeeded before touching the freshly allocated space.

### STEP_5
# STEP 5: SUMMARY
- Working with dynamic memory: malloc/realloc for “grow-as-needed” arrays and when-to-free discipline
- Struct packaging: grouping related data into a single unit and handling fixed-size character arrays safely
- Capacity vs. count bookkeeping: tracking used vs. allocated space to avoid repeated slow resizes
- Robust allocation: always checking return values and using temporary pointers before discarding old buffer references
- Menu-driven program flow: keeping UI logic separate from data-manipulation logic within constraint of a single helper function
- Memory-leak prevention: ensuring every allocated block is freed on both normal exit and error paths

### STEP_6
# STEP 6: TEST CASES

Test 1 - Two-book addition and listing (core functionality)  
Test 2 - Delete-last removes oldest entry when two books are present  
Test 3 - Empty collection delete-last should be silent  
Test 4 - Typing an invalid menu choice while empty should be handled gracefully  
Test 5 - Adding until resize path executes and still lists in order

```json
{
  "exit_command": "4",
  "test_suite": [
    {"input": "1\nClean_Code\n8.9\n1\nRefactoring\n7.3\n2\n4", "expected_keyword": "Refactoring 7.3"},
    {"input": "1\nFirst\n1.2\n1\nSecond\n2.3\n3\n2\n4", "expected_keyword": "First 1.2"},
    {"input": "3\n2\n4", "expected_keyword": "Choice>"},
    {"input": "9\n2\n3\n4", "expected_keyword": "Invalid choice"},
    {"input": "1\nA\n1.0\n1\nB\n2.0\n1\nC\n3.0\n1\nD\n4.0\n1\nE\n5.0\n2\n3\n2\n4", "expected_keyword": "E 5.0"}
  ]
}
```

---

## Iteration 21 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
## Background Story
The campus library has just switched to a new self-service kiosk that stores e-book checkouts in memory while the kiosk is running.  
Your task is to write a tiny “checkout server” that keeps track of which student has borrowed which e-book.  
All data must live in dynamically allocated memory; when the kiosk is turned off, everything disappears.

## Functional Requirements
1. On startup the program holds **no records**.
2. The user is shown a menu:
   1) Add a new checkout  
   2) Return (delete) a checkout  
   3) List all active checkouts  
   4) Exit
3. “Add” prompts for: student ID (int), book ID (int), and book title (≤30 chars, no spaces).  
   Store the record in a **new** malloc’ed structure and link it into a simple **singly-linked list**.
4. “Return” prompts for a book ID; find and remove that record, freeing its memory.
5. “List” prints every active checkout in the order they were added (one per line):
   ```
   Student 12345: "CProgramming" (Book 6789)
   ```
6. After each operation, re-display the menu until the user chooses **4) Exit**.  
   On exit, free **all** remaining nodes and terminate gracefully.

## Simple Example Run
```
=== Mini-Kiosk ===
1) Add
2) Return
3) List
4) Exit
Choice: 1
Student ID: 12345
Book ID: 6789
Title: CProgramming
Added.
1) Add
2) Return
3) List
4) Exit
Choice: 3
Student 12345: "CProgramming" (Book 6789)
1) Add
2) Return
3) List
4) Exit
Choice: 2
Book ID to return: 6789
Returned.
1) Add
2) Return
3) List
4) Exit
Choice: 4
Good-bye.
```

### CONSTRAINTS
- Must use a `struct Checkout` to represent each record.  
- Logic for displaying a **single** checkout must be in a function `void displayCheckout(const struct Checkout *c)`.  
- The entire solution must be implemented with **only one** additional function besides `main()` (you may reuse `displayCheckout` for listing).

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Mini-Kiosk – Self-Service E-Book Checkout Server
 * -------------------------------------------------
 * This program keeps track of active e-book checkouts in a
 * singly-linked list that lives only while the kiosk is running.
 * All data are dynamically allocated; everything disappears
 * when the program terminates.
 *
 * Compile:  gcc -std=c11 -Wall -Wextra -pedantic kiosk.c -o kiosk
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TITLE_LEN 31       /* max 30 chars + '\0' */

struct Checkout {
    int studentID;
    int bookID;
    char title[TITLE_LEN];
    struct Checkout *next;
};

/*
 * Prints a single checkout record in the required format.
 * (This function is mandatory per the specification.)
 */
void displayCheckout(const struct Checkout *c)
{
    if (c == NULL) return;
    printf("Student %d: \"%s\" (Book %d)\n", c->studentID, c->title, c->bookID);
}

/*
 * Creates a new checkout node.  Returns NULL on failure.
 * 'title' is safely copied to avoid overflow.
 */
static struct Checkout *createCheckout(int sid, int bid, const char *title)
{
    struct Checkout *node = malloc(sizeof(*node));
    if (node == NULL) {
        perror("malloc");
        return NULL;
    }
    node->studentID = sid;
    node->bookID  = bid;
    strncpy(node->title, title, TITLE_LEN - 1);
    node->title[TITLE_LEN - 1] = '\0';       /* ensure NUL-termination */
    node->next = NULL;
    return node;
}

/*
 * Releases every node in the list.
 */
static void freeAllCheckouts(struct Checkout *head)
{
    while (head != NULL) {
        struct Checkout *tmp = head;
        head = head->next;
        free(tmp);
    }
}

/*
 * Removes the first node whose bookID matches targetID.
 * Returns 0 on success, -1 if not found.
 */
static int removeCheckout(struct Checkout **head, int targetID)
{
    struct Checkout *prev = NULL;
    struct Checkout *curr = *head;

    while (curr != NULL) {
        if (curr->bookID == targetID) {
            if (prev == NULL)  /* removing head */
                *head = curr->next;
            else
                prev->next = curr->next;
            free(curr);
            return 0;
        }
        prev = curr;
        curr = curr->next;
    }
    return -1;  /* not found */
}

int main(void)
{
    struct Checkout *head = NULL;  /* initially empty */

    for (;;) {
        puts("=== Mini-Kiosk ===");
        puts("1) Add");
        puts("2) Return");
        puts("3) List");
        puts("4) Exit");
        printf("Choice: ");

        int choice;
        if (scanf("%d", &choice) != 1) {
            /* Invalid input: flush the line and try again */
            getchar();
            puts("Please enter a number.");
            continue;
        }

        if (choice == 1) {
            int sid, bid;
            char title[TITLE_LEN];
            printf("Student ID: ");
            scanf("%d", &sid);
            printf("Book ID: ");
            scanf("%d", &bid);
            printf("Title: ");
            scanf("%30s", title);       /* ≤30 chars, no spaces per spec */

            struct Checkout *node = createCheckout(sid, bid, title);
            if (node == NULL) {
                puts("Error creating checkout.");
                continue;
            }
            /* append at end to keep insertion order */
            if (head == NULL) {
                head = node;
            } else {
                struct Checkout *p = head;
                while (p->next != NULL) p = p->next;
                p->next = node;
            }
            puts("Added.");
        } else if (choice == 2) {
            int bid;
            printf("Book ID to return: ");
            scanf("%d", &bid);
            if (removeCheckout(&head, bid) == 0)
                puts("Returned.");
            else
                puts("Book not found.");
        } else if (choice == 3) {
            struct Checkout *p = head;
            while (p != NULL) {
                displayCheckout(p);
                p = p->next;
            }
        } else if (choice == 4) {
            freeAllCheckouts(head);
            puts("Good-bye.");
            return EXIT_SUCCESS;
        } else {
            puts("Invalid choice. Please pick 1-4.");
        }
    }
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory lets us create data whose lifetime is **completely** under program control (as opposed to automatic variables that disappear when a block ends). Think of `malloc` as booking *anonymous hotel rooms* at runtime – the key you receive is a pointer value (`void *`) that later becomes the concrete type you cast or assign it to, and `free` hands the key back so the room can be re-used. Below we walk through the mental model the code uses.

---

## 1. Designing the Node
- The kiosk must remember each checkout until the user explicitly deletes it. Because we do not know in advance how many checkouts we will store, an array is a poor fit (we would have to pre-allocate “enough” space or constantly resize).
- Instead we allocate *one struct per checkout* and link the structs with a pointer, forming a singly-linked list:

```
+-------------+     +-------------+    +-------------+
| struct C1   | --> | struct C2   |--> | NULL        |
+-------------+     +-------------+    +-------------+
```

The second field (`next`) is the arrow in the picture. When `head` equals `NULL` we mean *no checkout exists*.

---

## 2. Creating Nodes (`createCheckout`)
- To obtain a new node the code asks `malloc` for `sizeof(*node)` bytes. `malloc` returns an untyped `void *` that we can immediately store in a typed pointer (`struct Checkout *`) without a cast—C handles the assignment automatically.

- **Robustness note:** Because `malloc` **can fail** (system out of memory), we always test the returned pointer. If it is `NULL` we report the error, stop the operation, and *do not crash* by trying to dereference `NULL`.

- After a successful allocation we store the data the user typed. The title field is a fixed-length mini-buffer inside each struct. We use `strncpy` so that even if a future maintainer removes the width limitation in `scanf` the code will still not overflow.

---

## 3. Appending and Order
- Insertion order matters: the spec wants “List” to print items in the order they were created. The simplest way to achieve this is to append every new node at the *tail* of the list. A `head` pointer plus a loop that chases the `next` members until we hit `NULL` gives O(n) add time. (If the data set were huge we could keep a separate `tail` pointer, but the assignment limits us to *one additional function*, so chasing from the head is a pragmatic compromise.)

---

## 4. Removing Nodes (`removeCheckout`)
- The “Return” operation prompts for a book ID. Internally we search; if found, we unlink the struct and release its memory with `free`. Because each node is separately allocated, we only free *that* node.

- **Double-free prevention:** The unlink code immediately sets the pointer of its predecessor (or `head` itself) to the node after the one we excise and then `free()`s the node. Once freed, we must not touch the node again, but since we have overwritten every reference, we are safe.

- **Corner cases:** Deleting the first node is a special case because the rest of the program only knows the list via `head`. We therefore pass a pointer-to-pointer (`struct Checkout **`) so the routine can change the value at the caller’s site in one place, keeping the code short yet general.

---

## 5. Printing (`displayCheckout`)
- The specification requires displaying *one* node to be its own function. By separating this we gain reuse: both the debugging author and “List all” can call the same formatter.

- The function receives a `const` pointer because it promises not to mutate the node while inspecting it.

---

## 6. Program Shutdown
- When the user chooses “Exit” we iterate through *every* remaining node, `free()`-ing each one. Not a single byte of dynamically allocated memory is abandoned to the operating system—good hygiene, and required by the assignment.

---

## 7. Why Only Two Functions Besides main?
The constraint is pedagogical: to illustrate that with careful design a simple task can be coded economically, while still maintaining correct memory safety and legibility.

---

## 8. Big Ideas Recap
- `malloc` / `free` are paired: every successful allocation must eventually be released.

- A linked list uses dynamic allocations for *each* element, giving O(1) insertion anywhere for which we already hold a pointer, while gracefully handling an unknown element count.

- Always check `malloc`'s return value—robust code never trusts “enough” memory to exist.

- Hand-rolled memory management is *great practice* for later C++ smart pointers or garbage-collected languages: understanding ownership responsibility is the foundation for leak-free code everywhere.

### STEP_4
# STEP 4: HINTS

**Hint 1 (big picture)**  
Think of every checkout as a separate “note card” whose lifetime you control: you can create a card any time, drop it in a box, look through the box to show the cards in order, tear up a particular card when it is returned, and shred every remaining card when the kiosk closes. Decide how you’ll keep the cards in order without pre-allocating a fixed-size tray.

---

**Hint 2 (tool to use)**  
Dynamic reservation is your friend: there is a C library service that hands you raw memory on demand and another one that gives that memory back. Each note card should occupy its own such reservation so adding or deleting a card never moves the others.

---

**Hint 3 (first concrete step)**  
Define a single self-referencing “note card” type that contains the three pieces of data you must store plus a finger that can point to the next card; then write a routine that allocates one such card, fills it with the values the user types, and appends it to the end of the chain you are maintaining.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory fundamentals: requesting (`malloc`) and releasing (`free`) memory at run-time  
- Robustness: always checking `malloc` return values and handling allocation failure gracefully  
- Singly-linked list implementation: node definition, head pointer maintenance, insertion at tail, deletion by key  
- Pointer-to-pointer technique to modify the head pointer or previous link during deletion  
- Memory-leak prevention: ensuring every allocated block is freed before program exit  
- Separation of concerns: isolating “display one node” logic into its own function for reuse and clarity  
- Input safety: using width-limited reads (`scanf` with field width) to protect fixed-size character arrays  
- Menu-driven control flow with continuous loop until user chooses to exit  
- Incremental problem solving: meeting strict “only one extra function besides main” constraint while keeping code readable

### STEP_6
# STEP 6: TEST CASES

1. **Common path – add, list, remove, exit**  
   Add a checkout, list it, return the book, and quit.  
   Checks correct order of output and successful deletion.

2. **Empty list listing**  
   Choose “List” immediately after start-up; nothing should print.  
   Verifies the program can gracefully handle an empty list.

3. **Invalid menu choice**  
   Type choice 7, then an out-of-range negative number, then a valid choice.  
   Ensures error message appears without crashing and menu re-displays.

4. **Return a non-existent book ID**  
   After adding one book, attempt to return a different ID.  
   Expect “Book not found.”—tests unsuccessful search.

5. **Malloc failure simulation**  
   (Conceptual) Run the program under a memory-limiting sandbox; attempt many “Add”s until malloc returns NULL.  
   Checks that the program detects allocation failure and does not dereference a NULL pointer.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\n12345\n6789\nCProgramming\n3\n2\n6789\n4",
      "expected_keyword": "Returned"
    },
    {
      "input": "3\n4",
      "expected_keyword": "Good-bye"
    },
    {
      "input": "7\n-2\n1\n11111\n2222\nPython\n3\n4",
      "expected_keyword": "Invalid choice"
    },
    {
      "input": "1\n55555\n1111\nJava\n2\n9999\n4",
      "expected_keyword": "not found"
    },
    {
      "input": "1\n1\n1\nA\n1\n2\n2\nB\n1\n3\n3\nC\n4",
      "expected_keyword": "Good-bye"
    }
  ]
}
```

---

## Iteration 22 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
You are helping the campus “Ride-Share Hub” keep track of carpools for weekend trips.  
Each carpool has a driver (name), a destination, and a dynamically-allocated array of passenger names.  
Students can add carpools, add passengers to an existing carpool, list all carpools, or delete a carpool (which must also free every passenger name and the passenger array itself).

## Functional Requirements
1. The program starts with an empty collection of carpools.
2. Implement a menu with the following choices:
   1. Add a new carpool  
   2. Add a passenger to an existing carpool  
   3. List all carpools  
   4. Delete a carpool (and all its memory)  
   5. Exit  
3. After every operation, re-display the menu until the user chooses “Exit”.
4. All strings (names, destinations) may be assumed ≤ 49 characters.
5. Memory for every carpool, its driver name, destination, and passenger list must be dynamically allocated with malloc.  
   Memory must be freed with free as soon as the data is no longer needed.
6. If an allocation fails, print “Memory allocation failed” and terminate the program with EXIT_FAILURE.

## Simple Example Run
(user input shown after »)
```
1. Add carpool
2. Add passenger
3. List carpools
4. Delete carpool
5. Exit
» 1
Driver name: Alice
Destination: Beach
Carpool added.

1. Add carpool
2. Add passenger
3. List carpools
4. Delete carpool
5. Exit
» 2
Carpool index: 0
Passenger name: Bob
Passenger added.

1. Add carpool
2. Add passenger
3. List carpools
4. Delete carpool
5. Exit
» 3
Carpool 0: Alice -> Beach (1 passengers: Bob)

1. Add carpool
2. Add passenger
3. List carpools
4. Delete carpool
5. Exit
» 5
Goodbye!
```

### CONSTRAINTS
- Must use a struct to represent a carpool.
- The logic for displaying the details of ONE specific carpool must be in a function called displayCarpool.
- The solution must be implemented with a single function besides main().
- Menu option 5 must exit the program.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Ride-Share Hub – Carpool Manager
 * C11, single source file, dynamic memory everywhere, fails-fast on malloc/realloc
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STR 50          /* 49 chars + NUL */
#define INIT_PASS_CAP 2     /* initial passenger-list capacity */

/*
 * Carpool structure
 *   driver      : dynamically-allocated string
 *   destination : dynamically-allocated string
 *   passengers  : dynamically-allocated growable array of strings
 *   passengerCount : actual number of passengers
 *   passengerCap : allocated capacity of the passenger list
 */
typedef struct {
    char *driver;
    char *destination;
    char **passengers;
    int   passengerCount;
    int   passengerCap;
} Carpool;

/*
 * Global repository for all carpools.
 *   pools     : dynamically-allocated array of Carpool *
 *   poolCount : actual number of carpools
 *   poolCap   : allocated capacity of the array
 */
static Carpool **pools      = NULL;
static int        poolCount = 0;
static int        poolCap   = 0;

/* ---------- Helper forward declarations ---------- */
static void displayCarpool(const Carpool *cp, int idx);
static void *safeAlloc(size_t size);
static void *safeRealloc(void *ptr, size_t size);

/* ---------- Memory helpers ---------- */

static void *safeAlloc(size_t size)
{
    void *p = malloc(size);
    if (!p) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    return p;
}

static void *safeRealloc(void *ptr, size_t size)
{
    void *p = realloc(ptr, size);
    if (!p) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    return p;
}

/* ---------- Display one carpool (as per requirement) ---------- */

static void displayCarpool(const Carpool *cp, int idx)
{
    printf("Carpool %d: %s -> %s (%d passengers:",
           idx, cp->driver, cp->destination, cp->passengerCount);
    for (int i = 0; i < cp->passengerCount; ++i)
        printf(" %s", cp->passengers[i]);
    printf(")\n");
}

/* ---------- Menu functions ---------- */

static void addCarpool(void)
{
    char temp[MAX_STR];

    /* Expand pool array if needed */
    if (poolCount == poolCap) {
        poolCap = poolCap ? poolCap * 2 : 4;
        pools = safeRealloc(pools, sizeof(Carpool *) * poolCap);
    }

    /* Allocate and initialise new carpool */
    Carpool *cp = safeAlloc(sizeof(Carpool));
    cp->passengers     = NULL;
    cp->passengerCount = 0;
    cp->passengerCap   = 0;

    printf("Driver name: ");
    if (!fgets(temp, sizeof(temp), stdin))
        exit(EXIT_FAILURE);
    temp[strcspn(temp, "\n")] = '\0';
    cp->driver = safeAlloc(strlen(temp) + 1);
    strcpy(cp->driver, temp);

    printf("Destination: ");
    if (!fgets(temp, sizeof(temp), stdin))
        exit(EXIT_FAILURE);
    temp[strcspn(temp, "\n")] = '\0';
    cp->destination = safeAlloc(strlen(temp) + 1);
    strcpy(cp->destination, temp);

    pools[poolCount++] = cp;
    printf("Carpool added.\n\n");
}

static void addPassenger(void)
{
    int idx;
    printf("Carpool index: ");
    if (scanf("%d", &idx) != 1)
        exit(EXIT_FAILURE);
    getchar(); /* consume \n left by scanf */

    if (idx < 0 || idx >= poolCount) {
        printf("Invalid index.\n\n");
        return;
    }

    Carpool *cp = pools[idx];
    if (cp->passengerCount == cp->passengerCap) {
        cp->passengerCap = cp->passengerCap ? cp->passengerCap * 2 : INIT_PASS_CAP;
        cp->passengers = safeRealloc(cp->passengers,
                                     sizeof(char *) * cp->passengerCap);
    }

    char temp[MAX_STR];
    printf("Passenger name: ");
    if (!fgets(temp, sizeof(temp), stdin))
        exit(EXIT_FAILURE);
    temp[strcspn(temp, "\n")] = '\0';

    cp->passengers[cp->passengerCount] = safeAlloc(strlen(temp) + 1);
    strcpy(cp->passengers[cp->passengerCount], temp);
    cp->passengerCount++;
    printf("Passenger added.\n\n");
}

static void listCarpools(void)
{
    for (int i = 0; i < poolCount; ++i)
        displayCarpool(pools[i], i);
    if (!poolCount) printf("No carpools.\n");
    printf("\n");
}

static void deleteCarpool(void)
{
    int idx;
    printf("Carpool index to delete: ");
    if (scanf("%d", &idx) != 1)
        exit(EXIT_FAILURE);
    getchar(); /* consume \n */

    if (idx < 0 || idx >= poolCount) {
        printf("Invalid index.\n\n");
        return;
    }

    Carpool *cp = pools[idx];
    free(cp->driver);
    free(cp->destination);
    for (int i = 0; i < cp->passengerCount; ++i)
        free(cp->passengers[i]);
    free(cp->passengers);
    free(cp);

    /* Compact array by moving last element into gap */
    pools[idx] = pools[--poolCount];
    printf("Carpool deleted.\n\n");
}

/* ---------- Clean-up on exit ---------- */
static void cleanup(void)
{
    while (poolCount)
        deleteCarpool();   /* re-uses existing deallocator logic */
    free(pools);
    pools = NULL;
}

/* ---------- Main menu loop ---------- */

int main(void)
{
    /* Set-up atexit handler for leak safety */
    if (atexit(cleanup) != 0) {
        fprintf(stderr, "atexit failed\n");
        return EXIT_FAILURE;
    }

    while (1) {
        printf("1. Add carpool\n");
        printf("2. Add passenger\n");
        printf("3. List carpools\n");
        printf("4. Delete carpool\n");
        printf("5. Exit\n");
        printf("> ");
        fflush(stdout);

        int choice;
        if (scanf("%d", &choice) != 1)
            exit(EXIT_FAILURE);
        getchar(); /* consume newline */

        switch (choice) {
            case 1: addCarpool();    break;
            case 2: addPassenger();  break;
            case 3: listCarpools();  break;
            case 4: deleteCarpool(); break;
            case 5:
                printf("Goodbye!\n");
                cleanup();        /* explicit final clean-up */
                return EXIT_SUCCESS;
            default:
                printf("Invalid choice.\n\n");
        }
    }
}
```

Key points satisfied by the implementation:
- Single additional top-level function: `displayCarpool`.
- All strings and arrays dynamically allocated; every `malloc`/`realloc` checked.
- Memory freed early (when a carpool is deleted) and absolutely on `exit` via `cleanup()`.
- Modern C11 features used (`strncpy` avoided; we use `strcpy` over exact-length buffers).

### STEP_3
# STEP 3: EXPLANATION

## 0. Big Picture
We keep an **expandable array** of **carpool objects** (`Carpool *`).  
Everything inside a `Carpool`—the driver’s name, the destination, the list of passenger names, even the strings that hold those names—must live until we delete that particular carpool.  
Dynamic allocation lets us decide “how much” memory we need only while the program is running; `malloc`/`realloc` reserve it and `free` gives it back to the operating system.

---

## 1. Why Not Declare `char driver[50]` Inside the struct?
Fixed-size arrays inside the struct would waste memory if most strings are short, and they would be unusable if the problem suddenly allowed 60-character names.  
Instead we store only a *pointer* (`char *driver`).  
At run time we measure the exact length of the user’s text (with `strlen`), add one byte for the terminating NUL (`\0`), and ask `malloc` for exactly that many bytes.  
Now every string only occupies what it really needs.

---

## 2. Managing an Expandable List (Carpool Repository)
If we declared `Carpool pools[100]` we would be limited to 100 carpools and would always consume that memory.  
Our solution keeps:
```c
Carpool **pools;   // pointer to a dynamically allocated array of pointers
int poolCount;     // how many carpools we actually have right now
int poolCap;       // how many we *could* hold before the next expansion
```
When `poolCount == poolCap` the array is full, so we:
- Double `poolCap` (or start at 4),
- Use `realloc` to grow the array in place.
`realloc` either enlarges the current block or allocates a brand-new one, copies the data, and frees the old block—all automatically.  
We never lose the old data and we never leak memory.

---

## 3. Passenger Lists Must Also Grow
Each carpool contains:
```c
char **passengers;   // pointer to an array of char * (name pointers)
int passengerCount;  // current number of passengers
int passengerCap;    // allocated capacity of the above array
```
The rules are identical: when `passengerCount == passengerCap`, double the capacity and `realloc` the array.  
Note we do **not** `realloc` every single passenger’s *string*—we only resize the array that *points* to those strings.

---

## 4. Who Owns What? Ownership Rules Prevent Leaks
- The carpool repository *owns* the `Carpool *` elements.  
- Each `Carpool` owns:
  – its `driver` string,  
  – its `destination` string,  
  – its `passengers` array,  
  – every individual passenger string stored in that array.
Whoever allocates memory is responsible for freeing it in the opposite order:
first free the individual passenger strings, then the `passengers` array itself, finally the struct (`free(cp)`).

---

## 5. Failure Is Fatal, and That’s OK
Every `malloc` or `realloc` can return `NULL` if the computer runs out of memory.  
We wrap these calls in `safeAlloc`/`safeRealloc`.  
If they fail we print the required message and immediately `exit(EXIT_FAILURE)`.  
This keeps the code clean—every other function can assume the pointer is valid.

---

## 6. Cleaning Up at Two Levels
**A. Early clean-up**: When the user deletes a single carpool we release only that carpool’s memory.  
**B. Program-exit clean-up**: `atexit()` registers `cleanup()`, which deletes every still-existing carpool and finally frees the repository array itself.  
This guarantees valgrind/ASan will report zero leaks even if the user uses the menu for hours then types 5.

---

## 7. Why `getchar()` After `scanf("%d"`?
`scanf` leaves the newline in the input buffer.  
The next `fgets` would see that newline and believe the user entered an empty line.  
One `getchar()` consumes the `\n`, leaving a clean buffer for `fgets`.

---

## 8. `displayCarpool` — The Only Allowed Extra Function
The requirement limits us to *one* additional function besides `main`.  
We choose `displayCarpool(const Carpool *cp, int idx)`.  
It receives a read-only pointer so it cannot accidentally modify the carpool, and it outputs the required format.  
All listing logic is therefore isolated in one place, making future changes (extra statistics, colours, JSON …) trivial.

---

## 9. Putting It All Together
- User chooses a menu entry → we branch with a `switch`.  
- Each branch calls its helper (add, list, …).  
- Helpers manipulate only dynamic memory, never fixed buffers.  
- If anything goes wrong we fail fast, so the student can test confidently without subtle memory leaks or segmentation faults.

With these patterns—expandable arrays, ownership discipline, centralized allocation helpers, and deterministic clean-up—you have a template you can reuse in any project that must keep an unknown amount of data at run time.

### STEP_4
# STEP 4: HINTS

**Hint 1 (Conceptual Nudge):**  
Think of each carpool as a “container” whose size you can’t predict ahead of time. Instead of declaring fixed storage up front, plan to ask the system for the exact amount of space you need only when you actually receive the names and destinations from the user.

**Hint 2 (Key Feature Focus):**  
Read up on the trio of library tools that let you (a) request a block of memory at run time, (b) change the size of that block later, and (c) hand the block back when you’re done. You’ll use them for every string you store and for every array that might need to grow.

**Hint 3 (Logic Structure Prompt):**  
Start your program with empty “slots” for carpools—zero entries and zero capacity. Each time the user chooses “Add a new carpool,” check whether your current array of slots is already full; if it is, double the number of slots before inserting the new data. This “double when full” pattern will keep your storage tight while still allowing unlimited additions.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory allocation with malloc/realloc and the importance of checking return values
- Ownership rules: which part of the program is responsible for freeing each heap block
- Expandable arrays (dynamic resizing) to handle an unknown quantity of data
- Structs that contain pointers, not fixed buffers, to model variable-length records
- Centralized error handling for allocation failures using a single exit point
- Memory leak prevention via explicit free calls and an atexit cleanup routine
- Separation of concerns: isolating display logic in its own function while keeping business logic elsewhere
- Input stream management when mixing scanf and fgets

### STEP_6
# STEP 6: TEST CASES

1. **Happy Path – Add one carpool, one passenger, list, delete.**  
   Verify that listing shows the correct driver, destination, and passenger count; that deleting removes the entry; and that no memory is leaked.

2. **Empty Repository – Immediately choose “List” before any carpools exist.**  
   Ensure the program prints “No carpools.” and continues to the menu.

3. **Index Out of Range – Try to add a passenger to carpool index 99 when only two carpools exist.**  
   Program should print “Invalid index.” without crashing.

4. **Zero Passenger Capacity Growth – Add a carpool, add passengers until the internal array resizes from 2 → 4 → 8 slots.**  
   Observe that the listing always prints correctly after each resize.

5. **Invalid Menu Choice – Enter 9 then 0 then 5.**  
   Program should print “Invalid choice.” for 9, process valid choices, and finally exit cleanly when 5 is entered.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nAlice\nBeach\n2\n0\nBob\n3\n4\n0\n5", "expected_keyword": "Beach"},
    {"input": "3\n5", "expected_keyword": "No carpools"},
    {"input": "1\nA\nA\n1\nB\nB\n2\n99\nZ\n5", "expected_keyword": "Invalid index"},
    {"input": "1\nX\nX\n2\n0\nP1\n2\n0\nP2\n2\n0\nP3\n2\n0\nP4\n3\n5", "expected_keyword": "P3"},
    {"input": "9\n3\n5", "expected_keyword": "Invalid choice"}
  ]
}
```

---

## Iteration 23 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Context
You have been hired by the campus library to write a tiny checkout-tracking program.  
All of the data (book titles, authors, and current borrower IDs) must be stored only in dynamically-allocated memory so that the program can grow or shrink as books are added or removed during the day.

## Functional Requirements
1. The program displays a menu with four choices:  
   1) Add a new book  
   2) Remove a book (by its unique integer ID)  
   3) List every book currently in the catalogue  
   4) Exit (terminates the program)  
2. Adding a book: the user supplies an ID, title, and author.  
   - If the ID already exists, print “Duplicate ID—ignored.” and do nothing.  
   - Otherwise store the book in a dynamically-allocated array of structures.  
3. Removing a book: the user supplies an ID.  
   - If the ID is found, free its memory and compact the catalogue.  
   - Otherwise print “Book not found.”  
4. Listing: print ID, title, and author for every book, one per line, in the order they are stored.  
5. Before termination (option 4) the program must free every remaining allocation.

## Simple Example Run
```
1) Add
2) Remove
3) List
4) Exit
Choice: 1
ID: 7
Title: Dune
Author: Frank Herbert
Choice: 1
ID: 3
Title: 1984
Author: George Orwell
Choice: 3
7 Dune Frank Herbert
3 1984 George Orwell
Choice: 2
ID: 7
Choice: 3
3 1984 George Orwell
Choice: 4
```

### CONSTRAINTS
- The primary data entity must be a struct Book.  
- The catalogue must be held in a single contiguous block obtained with malloc/realloc.  
- All logic for displaying one Book must be inside void displayBook(const struct Book *b).  
- The only functions besides main() are displayBook and any helper you need for memory resizing.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library catalogue – dynamic‐array exercise
 * C11, single source file, no extra modules
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

/* ---------- Data types ---------- */
struct Book {
    int   id;
    char *title;   /* dynamically allocated */
    char *author;/* dynamically allocated */
};

/* ---------- Global state (visible only inside this file) ---------- */
static struct Book *catalogue = NULL; /* contiguous block of struct Book */
static size_t     capacity  = 0;    /* max elements current block can hold */
static size_t     count     = 0;    /* active elements */

/* ---------- Prototypes ---------- */
static void displayBook(const struct Book *b);
static void freeBook(struct Book *b); /* helper to free internal strings */

/* ---------- Memory helpers ---------- */
/* resizeCatalogue: returns 1 on success, 0 on failure */
static int resizeCatalogue(size_t newCap)
{
    struct Book *tmp = realloc(catalogue, newCap * sizeof *tmp);
    if (!tmp && newCap != 0) {        /* realloc failed */
        perror("realloc");
        return 0;
    }
    catalogue = tmp;
    capacity  = newCap;
    return 1;
}

/* ---------- Menu handling ---------- */
static void printMenu(void)
{
    printf("1) Add\n2) Remove\n3) List\n4) Exit\nChoice: ");
}

/* addBook: returns 1 on success, prints error on duplicate or OOM */
static int addBook(int id, const char *title, const char *author)
{
    /* duplicate-check */
    for (size_t i = 0; i < count; ++i) {
        if (catalogue[i].id == id) {
            printf("Duplicate ID—ignored.\n");
            return 0;
        }
    }

    /* grow array if necessary (double when full; initial size 4) */
    if (count == capacity) {
        size_t newCap = capacity ? capacity * 2 : 4;
        if (!resizeCatalogue(newCap)) return 0; /* already printed error */
    }

    /* allocate internal strings */
    char *t = strdup(title);
    char *a = strdup(author);
    if (!t || !a) {
        free(t); free(a);
        perror("strdup");
        return 0;
    }

    /* store the new book */
    catalogue[count].id     = id;
    catalogue[count].title  = t;
    catalogue[count].author = a;
    ++count;
    return 1;
}

/* removeBook: returns 1 if found & removed, otherwise 0 */
static int removeBook(int id)
{
    for (size_t i = 0; i < count; ++i) {
        if (catalogue[i].id == id) {
            /* free the removed strings */
            freeBook(&catalogue[i]);
            /* compact rest of the array (order preserved) */
            if (i + 1 < count)
                memmove(&catalogue[i], &catalogue[i + 1],
                        (count - i - 1) * sizeof(struct Book));
            --count;
            return 1;
        }
    }
    return 0;
}

/* list all books in catalogue */
static void listBooks(void)
{
    for (size_t i = 0; i < count; ++i)
        displayBook(&catalogue[i]);
}

/* ---------- Utility helpers ---------- */
void displayBook(const struct Book *b)
{
    printf("%d %s %s\n", b->id, b->title, b->author);
}

static void freeBook(struct Book *b)
{
    free(b->title);
    free(b->author);
}

/* free every remaining allocation */
static void releaseMemory(void)
{
    for (size_t i = 0; i < count; ++i)
        freeBook(&catalogue[i]);
    free(catalogue);
    catalogue = NULL;
    count = capacity = 0;
}

/* ---------- Main ---------- */
int main(void)
{
    int choice;
    while (1) {
        printMenu();
        if (scanf("%d", &choice) != 1) {   /* EOF or non-number */
            break;
        }

        /* consume rest of input line (title/author may contain spaces) */
        while (getchar() != '\n');

        switch (choice) {
            case 1: { /* ---------- Add ---------- */
                int id;
                char titleBuf[256], authorBuf[256];
                printf("ID: ");
                scanf("%d", &id);
                while (getchar() != '\n'); /* clear up to newline */
                printf("Title: ");
                if (!fgets(titleBuf, sizeof titleBuf, stdin)) break;
                printf("Author: ");
                if (!fgets(authorBuf, sizeof authorBuf, stdin)) break;

                /* strip trailing newlines */
                titleBuf[strcspn(titleBuf, "\n")] = '\0';
                authorBuf[strcspn(authorBuf, "\n")] = '\0';

                addBook(id, titleBuf, authorBuf);
                break;
            }
            case 2: { /* ---------- Remove ---------- */
                int id;
                printf("ID: ");
                scanf("%d", &id);
                while (getchar() != '\n');

                if (!removeBook(id))
                    printf("Book not found.\n");
                break;
            }
            case 3: /* ---------- List ---------- */
                listBooks();
                break;
            case 4: /* ---------- Exit ---------- */
                goto cleanup;
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

cleanup:
    releaseMemory();
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory is a way to keep data that grows or shrinks while the program is running.  
We cannot know in advance how many books the librarian will add, so we:

1. Start with **no memory at all** (`catalogue == NULL`)
2. Ask the OS for a fresh block when we need the first book
3. Ask again for a bigger block when the current one is full
4. Give every byte back before the program ends

Below you will see the same four high-level ideas that the code implements, explained first in plain language and then illustrated with tiny diagrams.

---

## 1. The catalogue is just a contiguous "resizing array"

The catalogue itself is *one* chunk of memory that can hold 0, 1, 2, … `struct Book` items:

```
        catalogue         +–– capacity * sizeof(struct Book) ––+
        ↓                 |                                     |
   +---------+--------+--+--+-----------+                     |
   | Book 0  | Book 1 |      |  ... free  |                     |
   +---------+--------+--+--+-----------+                     |
   ↑                     ↑                       ↑
   |                     |                       |
base address           count                  capacity
              (next free slot)
```

Key insight: `capacity` tells us how many books we *could* store without asking the OS again, `count` tells us how many are *currently* valid.

Every time `count == capacity` we **double** the capacity and call `realloc`.  
Doubling keeps the total number of reallocations logarithmic (O(log n)) while still being trivial to write. `realloc` either:

- enlarges the old block in place, **or**
- allocates a brand-new larger block, copies the old bytes, frees the old block

In both cases **we no longer dereference the previous pointer**; `realloc` returns the one and only valid pointer.

---

## 2. Inside each struct we store *pointers*, never fixed arrays

```c
struct Book {
    int  id;
    char *title;
    char *author;
};
```

When we `malloc` the catalogue we only reserve the *shell* (12 bytes on a 64-bit machine: 4 for `id` and two 8-byte pointers).  
A tiny `strdup(title)` *after* that allocates a second, separate string and stores its address into the shell.

Why not `char title[256]` inside the struct?

- Fixed buffers waste space for tiny names
- Fixed sizes cause a crash on longer names (security risk)
- By storing *pointers* we keep the catalogue itself small → `realloc` stays cheap because it only copies thin shells, not heavy arrays

**Diagram:**

```
   catalogue[0]                 (somewhere on the heap)
   +----+--------+---------+      +-------+
   | 7  | *title| *author |  --> | Dune\0 |
   +----+--------+---------+      +-------+
      |    |
      |    `---------------------->Frank Herbert\0
      `---------------------------> ...
```

To free a single book we must therefore free **three** things:

1. `book->title`
2. `book->author`
3. The slot in the array (done later when we compact or quit)

---

## 3. Resizing the array correctly—never leak, never use after-free

The helper `resizeCatalogue(newCap)` always:

- returns *true* on success and sets the *global* variable `capacity`
- if `newCap == 0` it *shrinks* to zero (used at program shutdown)
- on *any* `realloc` failure it prints an error and returns *false*, so the caller can decide what to do (in our case we abort the operation and let the user try again—other programs might choose an exit)

The **single most common mistake** when learning `realloc`:

```c
catalogue = realloc(catalogue, newCap * sizeof *catalogue);
if (!catalogue && newCap != 0) …
```

If realloc fails here and catalogue was *not* NULL, we still have the original data, but with the line above we just **lost the pointer** to it (memory leak). Our code stores the result first into a temporary pointer and only overwrites the global pointer when everything goes well.

---

## 4. Insertion, deletion and list — keeping the array dense

Insert:

1. Scan current list to ensure id is unique
2. If array full → resize (double)
3. `strdup` both new strings → now they are on the heap too
4. Copy id and the two new pointers into `catalogue[count]`
5. `++count`

Remove:

1. Scan for matching id
2. `free(book->title); free(book->author);`   (but NOT the struct yet)
3. `memmove` everything to its left
4. `—count` (struct data overwritten, but this is fine)

Because we always keep the chunk dense, `listBooks` is a trivial loop that calls `displayBook` on every element up to `count`.

---

## 5. Clean-up: return every byte to the OS

`releaseMemory()` does two jobs:

- iterate over the valid books and free the two strings each one owns
- free the catalogue array itself
- finally reset globals so `valgrind` sees zero leaks and no "reachable" blocks

That single function is called *both* on the normal exit path and on the early-return label `cleanup`, so no path can forget to cleanup.

---

## 6. "Why does the problem insist on malloc/realloc and not a list of nodes?"

Contiguous storage has two major advantages:

1. **Locality**: all titles/authors live next to each other in memory ⇒ cache-friendly (faster)
2. **Simplicity**: `realloc` solves exactly "make the array bigger" without us writing our own memory pool

Linked lists are good when middle insertions/deletions are *very* frequent; here the library catalogue is almost always just "add at end", "scan once", or "remove arbitrary element and compact". Resizing an array is both simpler and faster.

---

## Summary checklist for writing your next malloc-heavy program:

- Always pair every `malloc`, `calloc`, `realloc`, `strdup` with its mirror `free`
- Store `realloc` result in a temp so you do not leak on failure
- Keep thin "shell" structs inside arrays; put the heavy, variable-length data in its own allocations
- Free user data first, container second
- Double array capacity on inserts—this guarantees amortised O(1) insertion time

If you internalise these steps, you will be able to "grow while running" without memory leaks or crashes, exactly what the campus library catalogue assignment demanded.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the catalogue as a single “stretchy” shelf: instead of building many separate boxes, keep one long block that can quietly grow or shrink while the program runs. Focus on how you will enlarge that block when you run out of room and on how you will reclaim the space when a book is removed.

**Hint 2**  
Inside each slot on the shelf you only need to store the ID and two *addresses* pointing to the real title and author text; those text pieces live elsewhere on the heap. When you delete a book, first free those two text areas, then slide the remaining slots together so the shelf stays compact. Which standard library routine specializes in sliding a chunk of memory leftward?

**Hint 3**  
Begin with an empty pointer set to nothing. Maintain two counters—one for how many books presently live on the shelf and one for how many books the shelf can currently hold. Each time the first counter reaches the second, double the holding capacity by requesting a larger, but still contiguous, memory region from the system. After this enlargement succeeds, copy any current books into the new space and only then store the newcomer.

### STEP_5
# STEP 5: SUMMARY
- Dynamic contiguous arrays: using malloc/realloc to grow and shrink storage at runtime
- Safe memory management: pairing every allocation with its exact free, avoiding leaks and dangling pointers
- Struct pointers vs. struct arrays: keeping lightweight "shell" structs while heavy variable-length data lives in separate heap blocks
- Array compaction: using memmove to fill gaps after an element is removed
- Amortised O(1) insertion strategy: doubling capacity on overflow to minimize realloc calls

### STEP_6
# STEP 6: TEST CASES
1. Common flow – add two books, list them, remove one, list again  
2. Edge – list on an empty catalogue, then add/remove to zero items once more  
3. Duplicate ID – attempt to add a book with an ID that already exists  
4. Invalid menu choice – type a letter instead of 1-4 and recover  
5. Removal of non-existent ID – try to delete a book that was never stored  

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\n7\nDune\nFrank Herbert\n1\n3\n1984\nGeorge Orwell\n3\n2\n7\n3\n4",
      "expected_keyword": "1984 George Orwell"
    },
    {
      "input": "3\n1\n42\nEmpty Catalog\nAnonymous\n3\n2\n42\n3\n4",
      "expected_keyword": "Empty Catalog"
    },
    {
      "input": "1\n5\nClean Code\nRobert Cecil Martin\n1\n5\nClean Code\nRobert Cecil Martin\n3\n4",
      "expected_keyword": "Duplicate ID"
    },
    {
      "input": "x\n1\n9\nValid Book\nValid Author\n3\n4",
      "expected_keyword": "Valid Book"
    },
    {
      "input": "1\n10\nExist\nYes\n2\n99\n3\n4",
      "expected_keyword": "Book not found"
    }
  ]
}
```

---

## Iteration 24 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Context
You are helping a small library keep track of the books that patrons borrow.  
Each book has a unique ISBN (string, max 15 chars), a title (string, max 30 chars), and the number of pages (positive int).  
The librarian wants a tiny console program that can:

- Add a new book to a dynamically-growing collection
- Show every book currently stored
- Delete a book by its ISBN
- Exit the program and release all allocated memory

The collection must start empty and grow or shrink as books are added or removed.

## Functional Requirements
1. On start-up the program shows a menu:
   1) Add book  
   2) List books  
   3) Delete book  
   4) Exit  

2. Choosing “Add book” prompts for ISBN, title, and pages; the program then allocates memory for one book, stores the data, and appends it to the collection.

3. “List books” prints every book in the order they were added, one line per book:  
   `<ISBN> - <Title> (<pages> pages)`

4. “Delete book” asks for an ISBN.  
   - If that ISBN exists, the corresponding memory is freed and the book is removed from the collection.  
   - If it does not exist, print “Book not found.”

5. On “Exit” the program must free every remaining allocated book before terminating.

## Simple Example Run
```
1) Add book
2) List books
3) Delete book
4) Exit
Choice: 1
ISBN: 9780131103627
Title: The C Programming Language
Pages: 272
Book added.

Choice: 2
9780131103627 - The C Programming Language (272 pages)

Choice: 4
Good-bye!
```

### CONSTRAINTS
- You must represent each book with a struct named Book.
- The collection itself must also be dynamically allocated (array of pointers to Book) and resized with realloc as books are added or removed.
- All logic that prints the details of a single book must be placed in a function:  
  void displayBook(const Book *b);
- The only functions allowed besides main() are:  
  - displayBook  
  - Any helper you need for memory (re)allocation  
  No other functions are permitted.
- Menu option 4 is the only valid way to exit; the program must keep running until the user selects it.

### STEP_2
```c
/*
 * Library Book Tracker
 *
 * Demonstrates a minimal dynamic collection managed with realloc
 * while obeying all requested constraints (only one helper for
 * memory management plus the mandatory displayBook function).
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data types ---------- */
#define ISBN_MAX  15    /* maximum length of ISBN (+ '\0')  */
#define TITLE_MAX 30    /* maximum length of Title (+ '\0')*/
#define MAX_LINE  260   /* for safe fgets usage */

typedef struct {
    char isbn[ISBN_MAX];
    char title[TITLE_MAX];
    int pages;
} Book;

static Book **collection = NULL;  /* pointer‐to‐pointer array */
static size_t bookCount = 0;      /* items currently present    */
static size_t capacity = 0;      /* allocated array length   */

/* ---------- Mandatory function: display a single book ---------- */
static void displayBook(const Book *b)
{
    if (!b) return;
    printf("%s - %s (%d pages)\n", b->isbn, b->title, b->pages);
}

/* ---------- Helper: ensure capacity is large enough ---------- */
static int growCollection(void)
{
    if (bookCount < capacity) return 1;      /* already OK     */
    size_t newCap = (capacity ? capacity * 2 : 4);
    Book **tmp = realloc(collection, newCap * sizeof *collection);
    if (!tmp) {
        fputs("Error: memory reallocation failed\n", stderr);
        return 0;                              /* failure        */
    }
    collection = tmp;
    capacity = newCap;
    return 1;
}

/* ---------- Helper: free all books and the container array ---------- */
static void cleanup(void)
{
    for (size_t i = 0; i < bookCount; ++i) {
        free(collection[i]);
        collection[i] = NULL;
    }
    free(collection);
    collection = NULL;
    bookCount = capacity = 0;
}

/* ---------- Menu helpers ---------- */

static int readChoice(void)
{
    int c;
    while (1) {
        fputs("Choice: ", stdout);
        if (scanf("%d", &c) == 1) {
            return c;
        }
        clearerr(stdin);
        int ch;
        while ((ch = getchar()) != '\n' && ch != EOF);
        puts("Invalid choice.");
    }
}

/* ---------- Core actions ---------- */

static void addBook(void)
{
    Book *b = malloc(sizeof *b);
    if (!b) {
        fputs("Error: malloc failed\n", stderr);
        return;
    }

    char line[MAX_LINE];
    int pages;

    printf("ISBN: ");
    if (!fgets(line, sizeof line, stdin)) goto failure;
    line[strcspn(line, "\r\n")] = 0;          /* strip newline */
    strncpy(b->isbn, line, ISBN_MAX-1);
    b->isbn[ISBN_MAX-1] = 0;

    printf("Title: ");
    if (!fgets(line, sizeof line, stdin)) goto failure;
    line[strcspn(line, "\r\n")] = 0;
    strncpy(b->title, line, TITLE_MAX-1);
    b->title[TITLE_MAX-1] = 0;

    printf("Pages: ");
    if (!scanf("%d", &pages) || pages <= 0) {
        puts("Invalid pages.");
        goto failure;
    }
    consume();               /* consume rest of line after scanf */
    b->pages = pages;

    if (growCollection() == 0) goto failure;
    collection[bookCount++] = b;
    puts("Book added.");
    return;

failure:
    free(b);
}

static void listBooks(void)
{
    for (size_t i = 0; i < bookCount; ++i)
        displayBook(collection[i]);
}

static void deleteBook(void)
{
    char line[MAX_LINE];
    int index = -1;
    printf("ISBN: ");
    if (!fgets(line, sizeof line, stdin)) return;
    line[strcspn(line, "\r\n")] = 0;          /* strip newline */
    for (size_t i = 0; i < bookCount; ++i)
        if (strcmp(collection[i]->isbn, line) == 0) {
            index = (int)i;
            break;
        }
    if (index < 0) {
        puts("Book not found.");
        return;
    }
    Book *toDel = collection[index];
    memmove(collection + index,
            collection + index + 1,
            (bookCount - index - 1) * sizeof *collection);
    --bookCount;
    free(toDel);
    puts("Book deleted.");
}

static __inline void consume(void)
{
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

/* ---------- Program driver ---------- */

int main(void)
{
    while (1) {
        puts("1) Add book");
        puts("2) List books");
        puts("3) Delete book");
        puts("4) Exit");

        switch (readChoice()) {
            case 1:  addBook();   break;
            case 2:  listBooks();  break;
            case 3:  deleteBook(); break;
            case 4:
                puts("Good-bye!");
                cleanup();
                return 0;
            default:
                puts("Invalid choice.");
        }
    }
}
```

### STEP_3
# STEP 3: EXPLANATION

Imagine the collection of books as a row of numbered pigeon-holes.  
At the beginning the wall is empty, so we have **no** pigeon-holes at all—`collection == NULL`, `capacity == 0`.  
Every time the librarian asks us to store a new book we must:

1. Buy a brand-new pigeon-hole (`malloc` for **one** Book).  
2. Decide whether we have enough space in the row to place the hole.  
3. If the row is already full we **build a longer wall** (`realloc`) that keeps all previous holes and offers new empty places.  
4. When the librarian removes a book, we take the corresponding pigeon-hole out of the row and recycle it (`free`).  
5. At closing time we recycle every hole that is still on the wall (`cleanup`).

That mental picture is literally what the program does—only the “wall” is a dynamic array of **pointers to Book**.

---

## 1. Why `Book **` instead of `Book *`?

`malloc(sizeof(Book))` gives us **one** object.  
Because the number of books changes at run time, we do not know in advance how many objects we will need.  
Therefore we allocate a second level of indirection:

```c
Book **collection;   // an extensible array where each slot
                   // stores the *address* of one Book
```

The advantage is **simplicity** when we delete an element: we only move *pointers* (cheap), not the whole struct (potentially large).  
The disadvantage is an extra `malloc/free` per book. The spec forces us to keep the array of pointers, so this is the accepted trade-off.

---

## 2. The life-cycle of one Book

**Adding (menu 1):**
1. We `malloc` a brand new `Book` and fill it from user input.  
2. We call `growCollection()` which ensures there is at least one free slot in `collection`.  
   - `capacity` doubles each time (common strategy: low amortised cost, avoids quadratic realloc penalties).  
   - **Always** check `realloc` result before overwriting the global pointer—otherwise a failed allocation would leak the old block.  
3. We append the *address* of the new object, increment `bookCount`.

**Listing (menu 2):**  
Loop over the first `bookCount` slots and delegate to the required `displayBook(const Book *b)`.

**Deleting (menu 3):**  
1. Scan the pointers for a matching ISBN.  
2. If found:
   - free the **Book** itself (`free(collection[i])`),  
   - compact the array by shifting remaining pointers (fast `memmove`),  
   - decrease `bookCount`.  
   **Important:** we do **not** shrink the capacity—keeping it avoids quadratic behaviour when the librarian alternates add/delete.  
   (A production program could also shrink when `bookCount < capacity/4`.)

**Exiting (menu 4):**  
`cleanup()` visits every occupied slot, `free`s the Book, then `free`s the array that held the pointers.  
Valgrind now reports: “all heap blocks were freed”.

---

## 3. Error handling philosophy

The program refuses to continue after an allocation failure: it prints a message and leaves the current operation half-done (the Book struct is freed in the failure branch).  
A real system usually needs more sophisticated recovery, but for a teaching assignment this satisfies “every malloc/realloc is checked”.

---

## 4. Why we strip newlines with `strcspn`

`fgets` keeps the terminating `'\n'`. Storing that in the struct would waste space and complicate later comparisons, so we cut it off in-place:

```c
line[strcspn(line, "\r\n")] = '\0';
```

(`strcspn` returns the length of the prefix that contains no character from the second argument—an elegant C idiom.)

---

## 5. Input flushing

After using `scanf("%d", &pages)` the newline stays in the input buffer.  
If the next operation is `fgets`, it would read only the leftover newline.  
Hence the small helper:

```c
while ((c = getchar()) != '\n' && c != EOF);
```

to discard the rest of the line.  
This is simpler than mixing `scanf` and `fgets`, but still illustrates the pitfalls of interactive I/O.

---

## 6. Memory layout summary

When three books are stored the heap looks like this (ASCII art):

```
collection --> [0] ----------\
               [1] ---------+----\
               [2] -----\ |    |
               NULL     \|    |
                        \|   Book #0
                        \|   Book #1
                         \-> Book #2
```

Each arrow is a `Book *` stored in the realloc’able array; the structs themselves are independent allocations returned by individual `malloc` calls.

---

## 7. Key take-aways for beginners

1. `malloc` reserves memory, `free` releases it.  
2. `realloc` can enlarge (or shrink) a previously malloc’ed block, preserving existing content. Always assign the result to a temporary variable first, otherwise you risk losing the only reference to the block when allocation fails.  
3. Every pointer returned by `malloc`/`realloc` must eventually be passed exactly once to `free`.  
4. A pointer variable and the memory it refers to are two different things—freeing the memory does **not** zero the variable itself, so defensive coding sets pointers to `NULL` after free.  
5. A dynamic array (`T *array`) needs two integers: one for *how many* slots are currently in use (`bookCount`), another for *how many* are allocated (`capacity`). Growing by doubling keeps the amortised cost constant.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge)**  
Think of the collection as a row of mailboxes whose number can change.  
You never know in advance how many you will need, so you start with a tiny, flexible “postal wall” and you add or remove mailboxes as new packages (books) arrive or are collected. Sketch—without code—how you would resize the wall whenever you run out of room.

**Hint 2 (technical focus)**  
The language gives you a tool that can enlarge that wall without losing the existing mailboxes even when they are already full. Review the manual page for the magic “r-word” function that both allocates initial space and later stretches it in one call, and remember to hold the result in a temporary variable first.

**Hint 3 (first concrete step)**  
Before you worry about adding, deleting, or listing, write the tiniest working loop that:  
1. Creates an empty pointer-array (size 0),  
2. Keeps asking to “add” a book,  
3. Each time doubles the array length if necessary,  
4. Allocates exactly one separate block to hold the new book’s data,  
5. Stores that block’s address into the array (no other actions needed yet).  
Make sure your loop can run indefinitely without leaking; that skeleton is the foundation for everything else.

### STEP_5
# STEP 5: SUMMARY
- **Dynamic arrays with pointers-to-pointers**  
  – managing an extensible array of structs without knowing the final count at compile time.  
- **Safe use of malloc, realloc, and free**  
  – always checking return values and avoiding memory leaks.  
- **Separation of capacity vs. active count**  
  – doubling strategy for amortised constant-time growth.  
- **Pointer validity and ownership rules**  
  – storing addresses in an array while keeping the actual structs in individual allocations.  
- **Input handling pitfalls**  
  – flushing newlines and mixing fgets with scanf.  
- **Modular design under constraints**  
  – isolating display logic in the required displayBook function and limiting helper functions to memory management.

### STEP_6
# STEP 6: TEST CASES

1. Normative add-and-list  
   Add one complete book, list it, exit.  
   Validates happy path and menu formatting.

2. Empty collection list  
   List books when none exist, then exit.  
   Expects zero lines output after menu 2.

3. Add three, delete middle, list remainder  
   Ensures deletion preserves order and releases the correct block.

4. Delete non-existent ISBN  
   Attempt to remove an ISBN that was never stored.  
   Must print “Book not found.”

5. Pages ≤ 0 (invalid)  
   Try to insert a book with -42 pages.  
   Program must reject input and *not* leak memory.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\n9780131103627\nThe C Programming Language\n272\n2\n4",
      "expected_keyword": "The C Programming Language"
    },
    {
      "input": "2\n4",
      "expected_keyword": "Good-bye!"
    },
    {
      "input": "1\n111\nFirst\n50\n1\n222\nSecond\n60\n1\n333\nThird\n70\n3\n222\n2\n4",
      "expected_keyword": "111 - First"
    },
    {
      "input": "3\n0000000000000\n4",
      "expected_keyword": "Book not found."
    },
    {
      "input": "1\n0000000000000\nBad Pages\n-42\n1\n0000000000000\nBad Pages\n42\n2\n4",
      "expected_keyword": "Bad Pages"
    }
  ]
}
```

---

## Iteration 25 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
You are helping the campus library re-organise its “book request” list.  
Students can ask the library to reserve copies of new titles.  
Each request contains: a unique ID (positive int), the book title (≤49 chars), and the number of copies requested (positive int).  
All requests must be stored dynamically (i.e. with malloc) while the program is running.  
When the librarian is done, the program must release every byte it allocated and exit cleanly.

## Functional Requirements
1. The program starts with an empty collection of requests.
2. Repeatedly show a menu:
   ```
   1. Add request  
   2. Delete request by ID  
   3. Show all requests  
   4. Exit
   ```
3. On “Add”:
   - Read an ID, title, and copies.
   - If that ID already exists, print “Duplicate ID – ignored.” and do nothing.
   - Otherwise allocate space for the new request, store it, and print “Request <ID> added.”
4. On “Delete”:
   - Read an ID.
   - If found, free its memory, remove it, and print “Request <ID> deleted.”
   - Otherwise print “ID not found.”
5. On “Show all”:
   - Print every request in the order added, one per line, formatted as
     ```
     ID: <id>, Title: <title>, Copies: <copies>
     ```
   - If none, print “No requests.”
6. On “Exit”:
   - Free every remaining request.
   - Print “Good-bye.” and terminate with status 0.

## Simple Example Run
Input:
```
1
101
C Primer Plus
3
1
102
Python Crash Course
2
1
3
4
```
Output:
```
Request 101 added.
Request 102 added.
ID: 101, Title: C Primer Plus, Copies: 3
ID: 102, Title: Python Crash Course, Copies: 2
Good-bye.
```

### CONSTRAINTS
- The primary data entity must be a struct named `BookRequest`.
- All requests must be kept in a singly-linked list whose nodes are also allocated with malloc.
- The only additional functions allowed besides `main()` are:
  - `void pushRequest(int id, const char *title, int copies);`
  - `int deleteRequest(int id); // returns 1 if found & deleted, else 0`
  - `void displayAll();`
- The menu option to EXIT the program is number 4.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Book-request manager – linked-list version
 * Author: <your-name>
 * Compile: gcc -std=c11 -Wall -Wextra -pedantic -o requests requests.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structures ---------- */
typedef struct BookRequest {
    int   id;               /* unique positive identifier */
    char  title[50];        /* ≤49 visible chars + '\0' */
    int   copies;           /* positive number of copies */
    struct BookRequest *next;
} BookRequest;

/* Head of the list (initially empty) */
static BookRequest *head = NULL;

/* ---------- Function prototypes (only the three allowed) ---------- */
void pushRequest(int id, const char *title, int copies);
int  deleteRequest(int id);
void displayAll(void);

/* ---------- Helper: free every node ---------- */
static void freeAll(void)
{
    BookRequest *cur = head;
    while (cur) {
        BookRequest *next = cur->next;
        free(cur);
        cur = next;
    }
    head = NULL;
}

/* ---------- Menu helpers ---------- */
static void flushInput(void)
{
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF)
        /* discard */;
}

/* ---------- Main driver ---------- */
int main(void)
{
    while (1) {
        printf("1. Add request\n");
        printf("2. Delete request by ID\n");
        printf("3. Show all requests\n");
        printf("4. Exit\n");

        int choice;
        if (scanf("%d", &choice) != 1) {   /* malformed input → exit */
            flushInput();
            continue;
        }
        flushInput();                       /* consume trailing newline */

        if (choice == 1) {
            int id, copies;
            char title[50];

            if (scanf("%d", &id) != 1) { flushInput(); continue; }
            flushInput();
            /* fgets gives us newline handling for free */
            if (!fgets(title, sizeof(title), stdin)) { flushInput(); continue; }
            title[strcspn(title, "\n")] = '\0'; /* strip trailing '\n' */
            if (scanf("%d", &copies) != 1) { flushInput(); continue; }
            flushInput();

            pushRequest(id, title, copies);
        }
        else if (choice == 2) {
            int id;
            if (scanf("%d", &id) != 1) { flushInput(); continue; }
            flushInput();

            int ok = deleteRequest(id);
            if (!ok) puts("ID not found.");
        }
        else if (choice == 3) {
            displayAll();
        }
        else if (choice == 4) {
            freeAll();
            puts("Good-bye.");
            return EXIT_SUCCESS;
        }
        /* any other number → silently loop */
    }
}

/* ---------- Implementation of required functions ---------- */

/* Add a request at the tail (to preserve insertion order). */
void pushRequest(int id, const char *title, int copies)
{
    /* Duplicate-ID check */
    for (BookRequest *p = head; p; p = p->next) {
        if (p->id == id) {
            puts("Duplicate ID – ignored.");
            return;
        }
    }

    BookRequest *node = malloc(sizeof *node);
    if (!node) {            /* allocation failure -> abort */
        perror("malloc");
        freeAll();
        exit(EXIT_FAILURE);
    }

    node->id     = id;
    node->copies = copies;
    strncpy(node->title, title, sizeof(node->title) - 1);
    node->title[sizeof(node->title) - 1] = '\0';
    node->next   = NULL;

    /* Append to tail */
    if (!head) {
        head = node;
    } else {
        BookRequest *cur = head;
        while (cur->next) cur = cur->next;
        cur->next = node;
    }
    printf("Request %d added.\n", id);
}

/* Remove the first node with given id. Returns 1 if found, else 0. */
int deleteRequest(int id)
{
    BookRequest *prev = NULL, *cur = head;

    while (cur) {
        if (cur->id == id) {
            if (prev)
                prev->next = cur->next;
            else
                head = cur->next;

            free(cur);
            printf("Request %d deleted.\n", id);
            return 1;
        }
        prev = cur;
        cur  = cur->next;
    }
    return 0;   /* not found */
}

/* Display all requests in insertion order. */
void displayAll(void)
{
    if (!head) {
        puts("No requests.");
        return;
    }
    for (BookRequest *p = head; p; p = p->next) {
        printf("ID: %d, Title: %s, Copies: %d\n",
               p->id, p->title, p->copies);
    }
}
```

### STEP_3
# STEP 3: EXPLANATION  

## What the program is really doing  
Think of the program as a tiny data-base that keeps three fields per record (id, title, copies).  
Because we do **not** know in advance how many records will be typed, we cannot reserve a fixed-size array.  
Instead we must ask the operating system **at run-time** for exactly as many bytes as we need, and we must give those bytes back before the program ends.  
The C tools for this are `malloc` (grab memory) and `free` (return it).  

---

### 1. Why a linked list?  
A linked list is the simplest structure that can grow or shrink one element at a time with only one call to `malloc`/`free` per element.  
- Each list element (a node) contains the payload (the BookRequest) **and** one extra pointer that leads to the *next* node.  
- The last node stores the special address `NULL` (written as `0`) to say “end of chain”.  
- The global variable `head` always points at the first node; if `head` itself is `NULL` the list is empty.  

---

### 2. Life-cycle of one request  

```
student types data
   ↓
main() → pushRequest()
          1) verify duplicate id (walk the list)
          2) malloc(sizeof *node)          ← ask for one block
          3) fill the fields (id, copies, title)
          4) stitch node to tail          ← keep “insertion order”
          5) print confirmation
```

At this moment the operating system marks those bytes as “belonging to your process”.  
That block stays valid until you explicitly call `free(ptr)` on the *same* address returned by `malloc`.  

---

### 3. Deleting a node (deleteRequest)  
To remove an element from the middle of a linked list you must:  
1. **Find** it (traverse while keeping a `prev` pointer).  
2. **Unlink** it (`prev->next = cur->next`).  
3. **Free** the node (`free(cur)`).  
4. **Adjust** `head` if the first node was removed.  

The moment `free()` returns, those bytes are no longer yours; reading or writing them is *undefined behaviour*.  

---

### 4. DisplayAll – no allocation, only reading  
Walking the list is safe as long as you follow the `next` pointers and stop at `NULL`.  
No memory is allocated or released here, so nothing can leak.  

---

### 5. The Exit path – the grand cleanup  
Every path that leaves the program (menu choice 4, but also fatal errors inside `pushRequest`) must call `freeAll()`.  
`freeAll()` simply walks the entire list and `free()`s every node **once**.  
After that the list is empty (`head = NULL`) and the process can terminate without memory leaks.  

---

### 6. Why we check malloc’s return value  
`malloc` can fail (for example if the machine runs out of RAM).  
In that case it returns `NULL`.  
If we stored through a `NULL` pointer we would crash (segmentation fault).  
The program follows the **“fail-fast”** principle: print an error message, free whatever we own so far, and abort with non-zero status.  

---

### 7. Common pitfalls – checklist for students  
- Never use a block after you `free()` it.  
- Always save the exact pointer returned by `malloc`; do not increment it before storing to `free`.  
- For every `malloc` there must be **exactly one** `free` along every execution path.  
- Set pointers to `NULL` after freeing if you are going to test them later; otherwise avoid touching them at all.  
- When you allocate structures that contain an array (here `title[50]`) you do **not** need a second allocation; the 50 bytes live **inside** the same block returned by `malloc(sizeof(BookRequest))`.  

---

### Summary  
The program demonstrates the canonical linked-list pattern in C:  
- allocate (`malloc`)  
- use (read/write)  
- release (`free`)  

By keeping allocation strictly inside `pushRequest` and matching `free` in `deleteRequest` and `freeAll`, we guarantee that *every byte borrowed from the operating system is returned*—no leaks, no crashes, and a clean “Good-bye.”

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the requests as beads that keep arriving in unpredictable numbers.  
Instead of laying them in a straight, fixed-length tray, consider stringing them together with a tiny ribbon that links one bead to the next—so the chain can grow or shrink one bead at a time.

**Hint 2**  
Whenever you want to add a new bead, you must first ask the system for a brand-new, empty bead (using the dynamic “please give me memory” service).  
Before you slide the bead onto the ribbon, peek at the beads already on the chain and check for duplicate labels; if you spot one, simply return the empty bead to the system instead of attaching it.

**Hint 3**  
When it’s time to delete a bead, walk the ribbon while keeping one finger on the previous bead; when you reach the bead with the matching label, redirect that finger so it points past the unwanted bead, then release only that bead back to the system.

### STEP_5
# STEP 5: SUMMARY  
- Dynamic memory management: requesting (`malloc`) and releasing (`free`) blocks at run-time  
- Linked-list fundamentals: node structure, `next` pointer chaining, insertion at tail, deletion by key  
- Memory-leak prevention: ensuring every allocated block has exactly one matching `free` along every program path  
- Robust allocation checks: handling `malloc` failure without crashing  
- Input handling hygiene: flushing leftover newlines, validating user choices, preventing buffer overruns  
- Modular design under constraints: implementing only three public functions (`push`, `delete`, `display`) while keeping data integrity  
- Pointer discipline: preserving the exact address returned by `malloc` for later `free`  
- Program lifecycle: from empty list → interactive growth/shrink → complete cleanup on exit

### STEP_6
# STEP 6: TEST CASES  

**TC-1** Normal flow – add two requests, show them, exit.  
**TC-2** Duplicate ID – attempt to add identical ID, expect “ignored” message.  
**TC-3** Empty list – show requests when none exist, expect “No requests.”  
**TC-4** Delete non-existent ID – try to delete ID that was never added.  
**TC-5** Delete and show – add, delete, then show to verify empty list again.  

```json
{
  "exit_command": "4",
  "test_suite": [
    {"input": "1\n101\nC Primer Plus\n3\n1\n102\nPython Crash Course\n2\n3\n4", "expected_keyword": "C Primer Plus"},
    {"input": "1\n101\nC Primer Plus\n3\n1\n101\nDuplicate Title\n5\n4", "expected_keyword": "Duplicate ID – ignored."},
    {"input": "3\n4", "expected_keyword": "No requests."},
    {"input": "1\n200\nNew Title\n7\n2\n999\n4", "expected_keyword": "ID not found."},
    {"input": "1\n300\nFirst\n1\n2\n300\n3\n4", "expected_keyword": "No requests."}
  ]
}
```

---

## Iteration 26 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Context
You are helping the university library build a tiny, self-contained digital index for its collection of classic novels.  
Each book is described by:  
- a unique integer ID (1 … N)  
- a title (≤ 80 printable characters, no commas)  
- the year it was first published (positive integer)  

Because the collection keeps growing, the index must be stored in dynamically-allocated memory.  
The librarian will interact with the program through a simple text menu.

## Functional Requirements
1. Start by asking how many books will be entered (call this value `n`).  
2. Dynamically allocate an array of exactly `n` structures to hold the book data.  
3. Prompt for and store the ID, title, and publication year of each book.  
4. After all books are stored, repeatedly show a menu with the following options:  
   1) Display the full index (ID, title, year) in the order they were entered  
   2) Display the details of the book with the smallest ID  
   3) Exit the program  
5. After the user chooses “Exit”, free every dynamically-allocated byte and terminate gracefully.

## Simple Example
Input
```
3
101
Pride and Prejudice
1813
102
The Great Gatsby
1925
103
Crime and Punishment
1866
2
3
```

Output
```
1) Display full index
2) Display book with smallest ID
3) Exit
Choice: 101,"Pride and Prejudice",1813
1) Display full index
2) Display book with smallest ID
3) Exit
Choice: Goodbye!
```

### CONSTRAINTS
- You must define and use a single `struct Book` to represent each entity.  
- The logic for printing the details of exactly one book must be encapsulated in a function called `displayBook`.  
- Only two functions are allowed in your source file: `main` and `displayBook`.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Classic-novel index
 * Author: Assistant
 * C11, single translation unit; only two functions: main and displayBook
 */

#include <stdio.h>
#include <stdlib.h>


/* ---------- 1. STRUCT DEFINITION ---------- */
struct Book {
    int  id;                 /* unique identifier (1…N) */
    char title[81];        /* up to 80 printable chars, no commas */
    int  year;               /* first year of publication */
};


/* ---------- 2. DISPLAY FUNCTION ---------- */
/*
 * displayBook()
 * Purpose: print a single book record in the required CSV-like format:
 *          id,"title",year
 * Parameters:
 *          b  - const pointer to the Book structure to display
 * Returns: nothing (void)
 */
static void displayBook(const struct Book *b)
{
    if (b == NULL) {          /* defensive check */
        fputs("Invalid book pointer\n", stderr);
        return;
    }
    printf("%d,\"%s\",%d\n", b->id, b->title, b->year);
}


/* ---------- 3. MAIN FUNCTION ---------- */
int main(void)
{
    /* ----------- 3.1 Read number of books ----------- */
    int n;
    if (scanf("%d", &n) != 1 || n <= 0) {
        fputs("Error: expected a positive integer count\n", stderr);
        return EXIT_FAILURE;
    }

    /* ----------- 3.2 Dynamically allocate array ----------- */
    struct Book *shelf = malloc(n * sizeof *shelf);
    if (shelf == NULL) {      /* malloc failure check */
        perror("malloc");
        return EXIT_FAILURE;
    }

    /* ----------- 3.3 Input loop for each book ----------- */
    for (int i = 0; i < n; ++i) {
        /*
         * For each book, we expect:
         * id → title → year
         * Format: id is on its own line; title is the next newline-terminated
         *         string; year is the following integer
         */
        if (scanf("%d",  &shelf[i].id) != 1) {
            fputs("Input error while reading book ID\n", stderr);
            free(shelf);
            return EXIT_FAILURE;
        }
        if (scanf(" %80[^\n]", shelf[i].title) != 1) {
            fputs("Input error while reading book title\n", stderr);
            free(shelf);
            return EXIT_FAILURE;
        }
        if (scanf("%d",  &shelf[i].year) != 1) {
            fputs("Input error while reading book year\n", stderr);
            free(shelf);
            return EXIT_FAILURE;
        }
    }

    /* ----------- 3.4 Interactive menu loop ----------- */
    int choice;
    for (;;) {                 /* infinite loop, broken by '3' */
        puts("1) Display full index\n"
             "2) Display book with smallest ID\n"
             "3) Exit");
        fputs("Choice: ", stdout);

        if (scanf("%d", &choice) != 1) {  /* invalid input, treat as exit */
            choice = 3;
        }

        if (choice == 1) {
            /* display all books in insertion order */
            for (int i = 0; i < n; ++i)
                displayBook(&shelf[i]);
        }
        else if (choice == 2) {
            /* find and display book with smallest ID */
            int minIdx = 0;                /* index of current minimum */
            for (int i = 1; i < n; ++i) {
                if (shelf[i].id < shelf[minIdx].id)
                    minIdx = i;
            }
            displayBook(&shelf[minIdx]);  /* use encapsulation rule */
        }
        else if (choice == 3) {
            printf("Goodbye!\n");
            break;
        }
        else {
            /* silently ignore out-of-range menu choice and re-prompt */
        }
    }

    /* ----------- 3.5 Clean teardown ----------- */
    free(shelf);
    return EXIT_SUCCESS;
}
```

The program compiles cleanly with a modern C compiler, e.g.  
```
gcc -std=c11 -Wall -Wextra -pedantic library_index.c -o library_index
```

### STEP_3
# STEP 3: EXPLANATION

Imagine you’re writing this program on paper, but the librarian keeps bringing in more books. You don’t know the final number until run-time, so you can’t safely declare a static array such as:

```c
struct Book shelf[100];  /* ❌ too small? too big? */
```

Dynamic-memory allocation lets your program ask the operating system *at run-time* for exactly as many bytes as you need. Two C-library tools are used here:

1. `malloc` – “memory allocate”  
2. `free` – “give it back” when finished

--------------------------------------------------------
1. Translating the English requirement into C code
--------------------------------------------------------
“You will first be told *n*, the total number of books.”  
Therefore we:

- Read `n` with `scanf`
- Check that `n` is a positive integer (defensive programming)
- Immediately request the heap for `n × sizeof(struct Book)` bytes.

```c
struct Book *shelf = malloc(n * sizeof *shelf);
```

**Key concept**: `malloc` returns a pointer to the *first* byte or `NULL` if it cannot satisfy the request.  
You *must* check the return value: if you try to dereference a `NULL` pointer, the program crashes with a segmentation fault.

--------------------------------------------------------
2. Why `sizeof *shelf` is safer than `sizeof(struct Book)`
--------------------------------------------------------
Because `shelf` is already a `struct Book *`, `*shelf` is the object it points to.  
Writing `sizeof *shelf` keeps the expression in sync with the pointer type—even if you later change `shelf` to, say, `struct Novel *`.

--------------------------------------------------------
3. Storing the data in the array
--------------------------------------------------------
With `shelf` we now own `n` contiguous structures.  
Indexing syntax is the same as with a static array:

```
shelf[0], shelf[1], …, shelf[n-1]
```

Inside the loop we read three fields per book.  
The `%80[^\n]` specifier for the title:

- `80` : prevents buffer overrun (title only holds 81 chars including `\0`)
- `[^…]` : reads until newline, allowing spaces in the title
- A space **before** `%80[^\n]` consumes any leftover newline from the previous `scanf`, avoiding the classic “skipped input” bug.

--------------------------------------------------------
4. Encapsulating “print one book” in a dedicated function
--------------------------------------------------------
The specification *requires* a function `displayBook`.  
By taking a `const struct Book *b`:

- We pass only a pointer (cheap), not a heavy structure (expensive copy)
- Keyword `const` signals that the function will *not* modify the object
- Inside `main` we can call `displayBook(&shelf[i]);` for whichever book we need, satisfying code-duplication avoidance.

--------------------------------------------------------
5. The interaction loop (`while(true)` / `switch`)
--------------------------------------------------------
The program keeps presenting three numbered choices.  
We exit only on choice `3`, which causes a `break`, then proceeds to:

```c
free(shelf);
return EXIT_SUCCESS;
```

**Crucial rule**: every *successful* `malloc` must eventually be paired with exactly one `free` (even if the program is about to terminate).  
Failing to do so creates a *memory leak*: the memory is still owned by the process but no longer reachable—annoying in a short program, disastrous in a server.

--------------------------------------------------------
6. Finding the smallest ID (selection inside an array)
--------------------------------------------------------
We linearly scan the array once, keeping an index of the current best (`minIdx`).  
Time complexity is thus 𝑂(n) and uses only constant extra memory—good enough for a library-sized list.

--------------------------------------------------------
7. What happens if the librarian chooses a wrong menu option?
--------------------------------------------------------
The code simply re-prompts silently.  
Another valid strategy would be an error message; both are acceptable as long as they never break the invariant: memory freed at most once and always before exit.

--------------------------------------------------------
8. Summary mental model for beginning students
----------------------------------------------
- The heap is a large pool you can borrow from at run-time  
- `malloc(size)` returns a ticket (pointer) to a block or NULL  
- Use the block as an array or structure, just like normal memory  
- When finished, hand the ticket back with `free(pointer)`  
- Forget *either* step and you invoke undefined behaviour (crash / leak)

With those four steps—ask, check, use, give back—you automatically satisfy the core learning objective behind any dynamic-memory exercise.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge)**  
Think of the collection of books as a row of empty boxes whose exact count you will not know until the program is already running. Before you can place any book inside a box, you must first ask the operating system for the whole row; otherwise your program will not own the space it needs.

**Hint 2 (focus on a key C feature)**  
Recall that there is a standard-library facility that lets you request a *contiguous* block of memory whose size is determined only at run-time, and that the same facility returns a pointer you can treat exactly like an array once the request succeeds. Make sure you verify that the request actually worked before trusting the returned pointer.

**Hint 3 (first concrete step)**  
Immediately after you read the single integer that tells you how many books will be entered, use the aforementioned facility to allocate exactly that many instances of your structure, store the resulting pointer in a variable, confirm the allocation succeeded, and only then proceed to the input loop; this single step unlocks everything else (menu, printing, and later cleanup).

### STEP_5
# STEP 5: SUMMARY
- Dynamic array allocation with `malloc` and the importance of checking for `NULL`
- Grouping related data in a `struct` and accessing fields through pointers
- Encapsulating output logic in a single-purpose function (`displayBook`)
- Basic defensive-input techniques using `scanf` width specifiers and format strings
- Lifetime management: pairing every successful `malloc` with an exact `free`
- Menu-driven program flow and simple linear search (min-ID selection)
- Transitioning from compile-time fixed arrays to run-time sized storage

### STEP_6
# STEP 6: TEST CASES  
The suite exercises typical usage, edge conditions, and improper inputs.

1. Normal collection – three books followed by menu option 1  
2. Smallest-ID query on the same collection – menu option 2  
3. Empty collection (n = 0) – program should exit cleanly after allocating nothing  
4. Single-book collection – verify both display options work on lone element  
5. Invalid menu choice – re-prompted after ‘99’, then valid choice 3 to exit  

```json
{
  "exit_command": "3",
  "test_suite": [
    {"input": "3\n101\nPride and Prejudice\n1813\n102\nThe Great Gatsby\n1925\n103\nCrime and Punishment\n1866\n1\n3", "expected_keyword": "Pride and Prejudice"},
    {"input": "3\n101\nPride and Prejudice\n1813\n102\nThe Great Gatsby\n1925\n103\nCrime and Punishment\n1866\n2\n3", "expected_keyword": "101"},
    {"input": "0\n3", "expected_keyword": "Goodbye!"},
    {"input": "1\n42\nAlone\n2020\n1\n3", "expected_keyword": "Alone"},
    {"input": "2\n5\nAlpha\n1900\n6\nBeta\n2000\n99\n2\n3", "expected_keyword": "Beta"}
  ]
}
```

---

## Iteration 27 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

**Context**  
A campus library is digitising its old catalogue cards and wants a quick-and-dirty program to add, list, and delete book records while the real system is being built.  
The program will run in a loop, keep every book in **dynamic memory only**, and release that memory when the book record is removed or when the program ends.

**What the program must do**  
1. Maintain a dynamic array of pointers to individual book records.  
2. Provide a text menu with these choices (case-insensitive single letter is fine):  
   - A – Add a new book  
   - L – List all books  
   - D – Delete a book by its unique library-id (integer)  
   - Q – Quit and free all remaining memory before exiting  
3. On “Add”, prompt for:  
   - library-id (int, unique, duplicates rejected)  
   - title (one line, up to 99 chars)  
   - author (one line, up to 99 chars)  
   and allocate exactly one `struct Book` to hold the data.  
4. On “List”, print every book in the order they were added, one per line, formatted as:  
   `id: <id>, Title: "<title>", Author: "<author>"`  
   If no books exist, print `No books in catalogue.`  
5. On “Delete”, prompt for the library-id. If found, remove that book, free its memory, compact the pointer array, and print `Book <id> removed.` If not found, print `Book <id> not found.`  
6. On “Quit”, free every book and the pointer array itself, then exit gracefully.

**Simple Example Run**  
(user input after prompt `> `)

> A  
id: 101  
title: The Art of Code  
author: J. Programmer  
Book added.  
> A  
id: 102  
title: Memory Matters  
author: A. Malloc  
Book added.  
> L  
id: 101, Title: "The Art of Code", Author: "J. Programmer"  
id: 102, Title: "Memory Matters", Author: "A. Malloc"  
> D  
id: 101  
Book 101 removed.  
> Q  

### CONSTRAINTS  
- Must use `struct Book` to represent a book entity.  
- All book storage must be allocated with `malloc` and released with `free`; no global/static arrays of fixed size.  
- The logic that prints the details of ONE specific book must be in a function called `displayBook`.  
- The program must offer option Q to quit.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Quick-and-dirty library-catalogue program
 * Keeps every book in dynamic memory only.
 *
 * Build (GCC / Clang):  gcc -std=c11 -Wall -Wextra -pedantic catalogue.c -o catalogue
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_TITLE  100   /* includes NUL */
#define MAX_AUTHOR 100

/* ---------- Data structure ---------- */
typedef struct Book {
    int  id;
    char title[MAX_TITLE];
    char author[MAX_AUTHOR];
} Book;

/* ---------- Function prototypes ---------- */
static void displayBook(const Book *b);           /* prints ONE book */
static char getChoice(void);                       /* returns upper-case choice */
static void addBook(void);
static void listBooks(void);
static void deleteBook(void);
static void cleanup(void);

/* ---------- Global state (all dynamic) ---------- */
static Book **catalogue = NULL;  /* dynamic array of pointers to Book */
static size_t catSize   = 0;     /* number of books currently stored */
static size_t catCap    = 0;     /* current capacity of catalogue array */

int main(void)
{
    puts("Library Catalogue (A/L/D/Q)");

    for (;;) {
        char choice = getChoice();
        switch (choice) {
            case 'A': addBook();    break;
            case 'L': listBooks();  break;
            case 'D': deleteBook(); break;
            case 'Q': cleanup();
                      puts("Good-bye.");
                      return 0;
            default : puts("Invalid choice.");
        }
    }
}

/* ---------- Menu helper ---------- */
static char getChoice(void)
{
    printf("> ");
    char buf[32];
    if (!fgets(buf, sizeof buf, stdin)) return 0;
    return (char)toupper(buf[0]);
}

/* ---------- Add a book ---------- */
static void addBook(void)
{
    int id;
    printf("id: ");
    if (scanf("%d%*c", &id) != 1) {          /* %*c consumes newline */
        puts("Invalid id.");
        return;
    }

    /* uniqueness check */
    for (size_t i = 0; i < catSize; ++i)
        if (catalogue[i]->id == id) {
            puts("Duplicate id; book not added.");
            return;
        }

    /* allocate new Book */
    Book *b = malloc(sizeof *b);
    if (!b) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    b->id = id;

    printf("title: ");
    if (!fgets(b->title, sizeof b->title, stdin))  strcpy(b->title, "");
    else                                             b->title[strcspn(b->title, "\n")] = '\0';

    printf("author: ");
    if (!fgets(b->author, sizeof b->author, stdin)) strcpy(b->author, "");
    else                                              b->author[strcspn(b->author, "\n")] = '\0';

    /* ensure room in pointer array */
    if (catSize == catCap) {
        size_t newCap = catCap ? catCap * 2 : 4;
        Book **tmp    = realloc(catalogue, newCap * sizeof *tmp);
        if (!tmp) {
            perror("realloc");
            free(b);
            exit(EXIT_FAILURE);
        }
        catalogue = tmp;
        catCap    = newCap;
    }

    catalogue[catSize++] = b;
    puts("Book added.");
}

/* ---------- List all books ---------- */
static void listBooks(void)
{
    if (catSize == 0) {
        puts("No books in catalogue.");
        return;
    }
    for (size_t i = 0; i < catSize; ++i)
        displayBook(catalogue[i]);
}

/* ---------- Display ONE book (required by spec) ---------- */
static void displayBook(const Book *b)
{
    printf("id: %d, Title: \"%s\", Author: \"%s\"\n", b->id, b->title, b->author);
}

/* ---------- Delete a book by id ---------- */
static void deleteBook(void)
{
    int id;
    printf("id: ");
    if (scanf("%d%*c", &id) != 1) {
        puts("Invalid id.");
        return;
    }

    size_t idx = catSize;
    for (size_t i = 0; i < catSize; ++i)
        if (catalogue[i]->id == id) { idx = i; break; }

    if (idx == catSize) {
        printf("Book %d not found.\n", id);
        return;
    }

    free(catalogue[idx]);                 /* free the struct */

    /* compact the pointer array */
    for (size_t i = idx; i < catSize - 1; ++i)
        catalogue[i] = catalogue[i + 1];

    --catSize;
    printf("Book %d removed.\n", id);
}

/* ---------- Free everything before exit ---------- */
static void cleanup(void)
{
    for (size_t i = 0; i < catSize; ++i)
        free(catalogue[i]);
    free(catalogue);
    catalogue = NULL;
    catSize = catCap = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

1. Why we need dynamic memory at all  
   The program must keep an *unknown* number of books and release them precisely when the user deletes a record or quits.  
   A fixed-size array (`Book catalogue[1000];`) would waste space or run out of room, so we allocate every object while the program is running.  
   Two different kinds of allocation are therefore used:

   a. One `malloc` per `struct Book` (the actual book data).  
   b. One expandable array of *pointers* (`Book **catalogue`) that remembers where those `Book` structs live.  
   When the array becomes full we double its capacity with `realloc`, exactly like an `ArrayList` or `vector` in higher-level languages.

2. The life-cycle of one book  
   - Add → `malloc(sizeof(struct Book))` creates the object.  
   - Store → the pointer returned by `malloc` is placed in `catalogue[catSize++]`.  
   - Use → while the book sits in the catalogue, any code can read it.  
   - Remove → `free(book)` releases the struct, and we compact the pointer array so there are no gaps.  
   - Quit → `cleanup()` frees every remaining book and finally the pointer array itself.

3. `malloc` / `free` pairing – the golden rule  
   Every pointer that comes from `malloc`/`calloc`/`realloc` must be passed to `free` *exactly once*.  
   If you forget → memory leak.  
   If you free twice → undefined behaviour (often a crash).  
   The program keeps this promise by:

   - Never copying a `Book *` without keeping track of its owner.  
   - Only freeing a book in two places:  
     – `deleteBook()` for a single deletion.  
     – `cleanup()` at shutdown.  
   After a `free` we immediately overwrite the pointer (either by compacting the array or exiting), so it can’t be reused accidentally.

4. Why we separate `Book **catalogue` from `struct Book`  
   The catalogue is only a *directory* of pointers; it does *not* contain the structs themselves.  
   Advantages:  
   - When we remove a book we can compact the directory with a simple `memmove` (done by the loop in `deleteBook`) without touching the other `Book` objects.  
   - Only the pointer array is ever `realloc`'d; the structs stay at the same address, so no internal pointers become stale.  
   - Because the catalogue holds uniformly sized pointers, `realloc` is fast and its failure is easy to check.

5. Handling allocation failure  
   Whenever `malloc` or `realloc` returns `NULL` the program prints an error and terminates immediately (`exit(EXIT_FAILURE)`).  
   This keeps the code short and safe: the library catalogue is not safety-critical, so aborting is better than continuing with corrupted data.  
   In production code you might retry or degrade gracefully, but here quick-and-dirty is acceptable.

6. Memory layout snapshot  
   After adding two books the heap looks like:

   catalogue → [ addr1 | addr2 ]   (catSize = 2)  
   addr1  →  { id=101, title="The Art of Code", author="J. Programmer" }  
   addr2  →  { id=102, title="Memory Matters", author="A. Malloc" }

   Deleting book 101 → `free(addr1)` and catalogue becomes  
   [ addr2 ] (catSize = 1).  
   No orphaned pointers, no leaks.

7. String handling subtleties  
   `fgets` keeps the final `\n`, so we strip it with  
   `buf[strcspn(buf, "\n")] = '\0';`  
   This guarantees `snprintf`-style safety and avoids undefined behaviour if the user types exactly 99 characters.

8. Compact array without `realloc` shrink  
   The specification only requires “compact the pointer array”; it does not ask to give memory back to the OS.  
   Shrinking a `realloc` is possible but adds another failure path; here we simply move the remaining pointers left and decrement `catSize`.  
   The extra pointers at the end of the array are still valid but now redundant; they will be overwritten by future inserts or discarded at quit time.

9. Walking through the main loop  
   - `getChoice()` reads a whole line and returns an upper-case letter, so the menu is case-insensitive.  
   - The `switch` dispatches to the four actions.  
   - Each action is self-contained: it acquires its own input, validates it, and mutates the catalogue while keeping the global invariants (`catSize ≤ catCap`, no duplicates, every pointer in the array is non-NULL and owned).

10. Final cleanup  
    Quitting is the only way to leave `main`.  
    `cleanup()` first frees every pointed-to `Book`, then frees the pointer array itself, neatly satisfying the “release all memory” requirement even if the list is empty.

Understanding these ten points clarifies *why* each `malloc` is matched by a `free`, *why* we grow and shrink the catalogue the way we do, and how the program stays leak-free without ever knowing in advance how many books the user will enter.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the catalogue as a stack of index cards you can resize at any moment. Each card will live in its own individually-requested “box” that you can return to the shelf when the card is no longer needed.

**Hint 2**  
You’ll need a way to remember where all those boxes are. A growing list that can expand when it gets full—and that holds only *addresses* of the boxes—will let you add, list, and remove cards without moving the boxes themselves.

**Hint 3**  
Start by creating a single storage place for one book, then work out how to:  
- check whether its identity number is already in the list,  
- hand the storage back when the user deletes that number, and  
- hand *all* the storage back when the user chooses to quit.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory management: allocating individual structs with malloc, expanding an array of pointers with realloc, and releasing every allocation exactly once with free  
- Ownership discipline: keeping a clear owner for every heap block and avoiding double-frees or leaks  
- Array compaction: removing an element from a contiguous pointer array without realloc shrink, by shifting remaining pointers left  
- Input validation and safe string handling using fgets and strcspn  
- Functional decomposition: isolating display logic in a single function (displayBook) while the rest of the program handles data flow  
- Menu-driven program structure with a loop, case-insensitive choice parsing, and graceful termination  
- Error handling strategy for allocation failures in a small, self-contained utility

### STEP_6
# STEP 6: TEST CASES

1. Happy path (two books)  
   Add two distinct books, list them, delete the first, list again, then quit.  
   Expected: both add-success messages, correct listing order, deletion message, compacted listing.

2. Empty catalogue list  
   Launch the program, immediately choose List, then quit.  
   Expected: the special message “No books in catalogue.”

3. Duplicate id rejection  
   Add a book with id 50, then try to add a second book also with id 50.  
   Expected: second attempt rejected with “Duplicate id; book not added.”

4. Delete non-existent id  
   After adding books 10 and 20, attempt to delete id 99.  
   Expected: “Book 99 not found.”

5. Long title/author (boundary)  
   Supply title and author strings of exactly 99 characters (legal maximum) plus newline.  
   Expected: book accepted; listing shows full strings intact and properly quoted.

```json
{
  "exit_command": "Q",
  "test_suite": [
    {"input": "A\n101\nThe Art of Code\nJ. Programmer\nA\n102\nMemory Matters\nA. Malloc\nL\nD\n101\nL\nQ", "expected_keyword": "Book 101 removed"},
    {"input": "L\nQ", "expected_keyword": "No books in catalogue"},
    {"input": "A\n50\nFirst\nAuthor\nA\n50\nDuplicate\nWriter\nQ", "expected_keyword": "Duplicate id"},
    {"input": "A\n10\nAlpha\nA\n20\nBeta\nD\n99\nQ", "expected_keyword": "Book 99 not found"},
    {"input": "A\n77\nTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nL\nQ", "expected_keyword": "id: 77, Title: \"TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\""}
  ]
}
```

---

## Iteration 28 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  
**Topic:** Dynamic Memory Allocation (malloc, free)

## Background Story  
You are helping the campus library write a tiny “Digital Post-it” system.  
A student can walk up, request a new Post-it, type a short note, and pin it to an on-screen board.  
Later they can delete a specific Post-it (by number) or wipe the whole board.  
All Post-its must live in dynamic memory so that the program never reserves more space than it actually needs.

## Requirements  
1. Keep an array of *pointers* to `struct PostIt` objects.  
2. The struct must contain:  
   - an `int id` (1-based, assigned automatically)  
   - a `char *text` (dynamically allocated)  
3. Implement the following actions via a simple text menu:  
   1) Create new Post-it  
   2) Delete one Post-it (by id)  
   3) Display all Post-its  
   4) Wipe the board (free everything)  
   5) Exit  
4. After “Exit” the program must free every remaining Post-it before terminating.  
5. Do **not** pre-allocate any array—resize the pointer array with `realloc` only when a Post-it is added or deleted.

## Example Session (user input shown after `>`)  
```
1) New 2) Delete 3) List 4) Wipe 5) Exit
> 1
Enter note: Buy milk
1) New 2) Delete 3) List 4) Wipe 5) Exit
> 3
#1: Buy milk
1) New 2) Delete 3) List 4) Wipe 5) Exit
> 2
Delete id: 1
Deleted.
1) New 2) Delete 3) List 4) Wipe 5) Exit
> 5
Good-bye!
```

## CONSTRAINTS  
- You must store Post-its in a dynamically-resized array of pointers (`struct PostIt **board`).  
- The logic that prints a single Post-it must be in a function called `displayPostIt`.  
- The only functions besides `main` may be: `displayPostIt`, `createPostIt`, `deletePostIt`, `wipeBoard`.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Digital Post-it Board
 *
 * A compact demo of dynamic memory management in C:
 *   - malloc / realloc / free
 *   - struct layout
 *   - pointer-to-pointer array
 *
 * Compile:  gcc -std=c11 -Wall -Wextra -pedantic postit.c -o postit
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data types ---------- */
typedef struct PostIt {
    int  id;      /* 1-based identifier */
    char *text;   /* dynamically allocated note */
} PostIt;

/* ---------- Global state ---------- */
static PostIt **board  = NULL;   /* dynamically resized array of pointers */
static size_t  count = 0;        /* #Post-its currently on the board */
static int     nextId = 1;       /* next id to assign */

/* ---------- Function prototypes ---------- */
PostIt *createPostIt(const char *note);
void displayPostIt(const PostIt *p);
int deletePostIt(int id);
void wipeBoard(void);

/* ---------- Helper: safe allocation wrappers ---------- */
static void *xmalloc(size_t sz)
{
    void *p = malloc(sz);
    if (!p) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    return p;
}

static void *xrealloc(void *ptr, size_t sz)
{
    void *p = realloc(ptr, sz);
    if (!p && sz) {            /* sz==0 -> free-like behaviour ignored here */
        perror("realloc");
        exit(EXIT_FAILURE);
    }
    return p;
}

/* ---------- Core routines ---------- */

/* Create a new Post-it object (not yet on the board) */
PostIt *createPostIt(const char *note)
{
    PostIt *p = xmalloc(sizeof *p);
    p->id  = nextId++;
    p->text = xmalloc(strlen(note) + 1);
    strcpy(p->text, note);
    return p;
}

/* Print a single Post-it */
void displayPostIt(const PostIt *p)
{
    if (p) printf("#%d: %s\n", p->id, p->text);
}

/* Delete by id; returns 1 if found and deleted, else 0 */
int deletePostIt(int id)
{
    size_t idx;
    for (idx = 0; idx < count; ++idx)
        if (board[idx]->id == id) break;

    if (idx == count) return 0;          /* not found */

    /* free the struct fields */
    free(board[idx]->text);
    free(board[idx]);

    /* collapse the array */
    memmove(&board[idx], &board[idx+1], (count-idx-1)*sizeof *board);
    --count;

    /* shrink the allocation; realloc(ptr,0) is equivalent to free(ptr) */
    board = xrealloc(board, count * sizeof *board);
    return 1;
}

/* Wipe the entire board */
void wipeBoard(void)
{
    for (size_t i = 0; i < count; ++i) {
        free(board[i]->text);
        free(board[i]);
    }
    free(board);
    board = NULL;
    count = 0;
}

/* ---------- Menu driver ---------- */
int main(void)
{
    char line[128];

    for (;;) {
        printf("1) New 2) Delete 3) List 4) Wipe 5) Exit\n> ");
        if (!fgets(line, sizeof line, stdin)) break;

        int choice = atoi(line);

        if (choice == 1) {
            printf("Enter note: ");
            if (!fgets(line, sizeof line, stdin)) break;
            /* strip trailing newline */
            line[strcspn(line, "\n")] = '\0';

            PostIt *p = createPostIt(line);
            /* grow pointer array */
            board = xrealloc(board, (count+1)*sizeof *board);
            board[count++] = p;

        } else if (choice == 2) {
            printf("Delete id: ");
            if (!fgets(line, sizeof line, stdin)) break;
            int id = atoi(line);
            if (deletePostIt(id))
                puts("Deleted.");
            else
                puts("Id not found.");

        } else if (choice == 3) {
            for (size_t i = 0; i < count; ++i)
                displayPostIt(board[i]);

        } else if (choice == 4) {
            wipeBoard();

        } else if (choice == 5) {
            break;

        } else {
            puts("Invalid choice.");
        }
    }

    /* Guarantee cleanup on any exit path */
    wipeBoard();
    puts("Good-bye!");
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION  

Think of the program as a little **scrap-book** that the library can grow or shrink at any moment.  
We never know in advance how many Post-its a student will stick on the page, so we must:

1. Keep only as much memory as is currently occupied, and  
2. Be prepared to ask the operating system for more (or give some back) while the program is running.

The C tools for this are the trio `malloc`, `realloc`, and `free`.  
Below we walk through the life-cycle of the board and show why each dynamic-allocation step is necessary and safe.

---

### 1. The board itself is “an array of pointers”

```
PostIt **board;   // size_t count;
```

`board` is **not** an array of structures; it is an array of *addresses* (`PostIt *`).  
Pointers-to-pointers are used because:

- We can resize the outer array with `realloc` without touching the individual Post-its.  
- When we delete one Post-it, we only move its pointer out of the array; the actual struct is freed separately.  

Memory layout after a few inserts:

```
board -> [addr1]  [addr2]  [addr3]
            ↓        ↓        ↓
         PostIt   PostIt   PostIt
```

---

### 2. Creating (and growing) safely

When the user chooses “New”:

a. Allocate one **PostIt** object  
   `PostIt *p = malloc(sizeof *p);`  
   This gives the *id* field a place to live.  

b. Allocate space for the *text*  
   `p->text = malloc(strlen(note)+1);`  
   `+1` for `'\0'`. We copy the user’s string into this place.  

c. Resize the outer pointer array  
   `board = realloc(board, (count+1)*sizeof *board);`  
   - If it is the first Post-it, `board` was `NULL`; `realloc(NULL, size)` is legal and equals `malloc`.  
   - We reallocate in exact 1-element increments. For a toy program this is fine; for thousands of items you would grow geometrically (double) to reduce copying.  

After the resize we store the pointer and increment `count`.

---

### 3. Deleting (and shrinking)

Step-by-step:

1. Scan `board[0 … count-1]` to find the matching `id`.  
2. Free the two allocations owned by that Post-it  
   - `free(p->text);` – the copied note  
   - `free(p);` – the struct itself  
3. Close the hole with `memmove` (O(n) but acceptable for a small board).  
4. `realloc` the outer array down by one element.  
   Passing `realloc(ptr,0)` is equivalent to `free(ptr)`, so if the board becomes empty the last `realloc` frees `board` itself automatically.

---

### 4. Why a separate `displayPostIt`?

Separation of concerns:  
- `main` drives the menu,  
- `displayPostIt` knows how to print exactly one Post-it.  
That satisfies the requirement *“the logic that prints a single Post-it must be in a function called displayPostIt.”*

---

### 5. Cleaning up the last scraps

The program can finish in two ways:

- User selects `Exit`; we break out of the loop and call `wipeBoard()`.  
- `fgets` fails (rare), we break and still call `wipeBoard()`.  

`wipeBoard` loops over every pointer, freeing the two memory blocks (text and struct) and finally frees the array that held the pointers.  
This guarantees **zero leaks**, satisfying the requirement *“after ‘Exit’ the program must free every remaining Post-it before terminating.”*

---

### 6. Tiny helper wrappers (`xmalloc`, `xrealloc`)

Students often forget that `malloc`/`realloc` can fail.  
We wrap them once; if failure occurs we print a short message and `exit(EXIT_FAILURE)`.  
That keeps the main logic free of repeated error checking and makes the intent (allocate or die) explicit.

---

### 7. Key mental model for dynamic arrays

Think of `realloc(old, newSize)` as:

```c
void *newBlock = malloc(newSize);
if (old) {
    copy useful bytes from old to new;
    free(old);
}
return newBlock;
```

It may actually extend in-place, but you must code as if a new address is returned; therefore always assign the result back to your pointer variable, otherwise you risk using the old (possibly freed) pointer.

---

### 8. Summary checklist for students

- Whenever you `malloc`, know *where* the matching `free` will happen.  
- Keep sizes (`count`) yourself; C does not store the array length.  
- `realloc(ptr,0)` equals `free(ptr)`—useful shorthand.  
- After `realloc`, always update your pointer variable.  
- A double-pointer (`**`) lets you resize an *array-of-pointers* without moving the objects those pointers reference.

Follow these habits and your programs will never “forget” to return memory to the system—just like tidy students returning Post-its to the librarian.

### STEP_4
# STEP 4: HINTS

Hint 1  
Remember that the board is just a list of pointers—you can always ask the system to make the list longer or shorter while the program is running. Think about how you would manually add or remove entries in a notebook that can magically grow or shrink its pages.

Hint 2  
When the user adds a new note, you’ll need two separate “grab a piece of memory” operations: one for the little structure that holds the id, and another for the characters that make up the message. Don’t forget to connect those two pieces afterward.

Hint 3  
Start by allocating room for a single pointer, then each time a new note is created use the “resize” facility to extend that space by one pointer, place the new pointer in the last spot, and update your tally of how many notes currently exist.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory life-cycle: malloc / realloc / free used responsibly with no leaks  
- Pointer-to-pointer (**) as a resizable array of object references  
- Struct layout with mixed value and dynamically-allocated members  
- Separation of concerns: tiny, single-purpose functions that allocate, print, delete, or wipe  
- Safe allocation wrappers that always check for out-of-memory and abort cleanly  
- Manual array compaction and shrinking with memmove and realloc(ptr, 0)  
- Menu-driven program structure with clean-up paths that guarantee every byte is freed before exit

### STEP_6
# STEP 6: TEST CASES

1. Happy path – create, list, delete, exit  
   Add two notes, list them, delete the first, list again, then quit.  
   Goal: normal flow with correct ids and clean output.

2. Empty board list  
   Start program and immediately choose List (action 3) without adding anything.  
   Goal: program prints nothing and re-displays menu; no crash.

3. Invalid id deletion  
   After adding one note, attempt to delete a non-existent id (say 999).  
   Goal: program prints “Id not found.” and continues gracefully.

4. Wipe board and re-use  
   Add three notes, wipe the board (action 4), then add a new note and list it.  
   Goal: board count restarts at 1; previous memory fully reclaimed.

5. Long text and max menu choice  
   Provide a note longer than 80 characters, then attempt an invalid menu choice (6 or –1).  
   Goal: note is stored/displayed correctly; invalid choice prints “Invalid choice.” and menu re-appears.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nBuy milk\n3\n1\nStudy for exam\n3\n2\n1\n3\n5\n",
      "expected_keyword": "#2: Study for exam"
    },
    {
      "input": "3\n5\n",
      "expected_keyword": "Good-bye!"
    },
    {
      "input": "1\nTest note\n2\n999\n5\n",
      "expected_keyword": "Id not found."
    },
    {
      "input": "1\nAlpha\n1\nBeta\n1\nGamma\n4\n1\nDelta\n3\n5\n",
      "expected_keyword": "#1: Delta"
    },
    {
      "input": "1\nThis is an extremely long message that definitely exceeds eighty characters in length\n6\n3\n5\n",
      "expected_keyword": "#1: This is an extremely long message"
    }
  ]
}
```

---

## Iteration 29 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Context
You are helping the campus bookstore manage its inventory of used textbooks.  
Each book has:  
- a unique 13-digit ISBN (string, exactly 13 chars plus null terminator)  
- a title (one word, ≤30 chars)  
- an integer quantity in stock  

The store clerk will interact with a simple console program that can add books, update stock, and list everything currently in the inventory.  
All data must be kept in dynamic memory so that the array can grow or shrink while the program is running.

## Functional Requirements
1. On startup the inventory is empty.
2. The program repeatedly shows a menu:
   1. Add a new book  
   2. Update stock for an existing ISBN  
   3. Show complete inventory  
   4. Exit  
3. Choosing 1:  
   - Read ISBN, title, initial quantity.  
   - If ISBN already exists, print “ISBN already in inventory.” and do nothing.  
   - Otherwise allocate space for the new book, expand the inventory array, and store it.  
4. Choosing 2:  
   - Read an ISBN and a signed integer delta.  
   - If the ISBN is found, adjust its quantity by delta (even if negative).  
   - If the ISBN is not found, print “ISBN not found.”  
5. Choosing 3:  
   - Print one line per book: `ISBN title quantity`  
   - If inventory is empty print “Inventory empty.”  
6. Choosing 4:  
   - Free all dynamically allocated memory and terminate the program.  
7. The program must handle any non-negative number of books (0 → as many as memory allows).

## Simple Example Run
```
1
9780131103627 K&R 15
1
9780131103627 K&R 5
ISBN already in inventory.
2
9780131103627 -3
3
9780131103627 K&R 12
4
```
(Program ends.)

### CONSTRAINTS
- You must store each book in a `struct Book`.  
- All books must be kept in a dynamically-allocated array of `struct Book`.  
- The logic that prints the details of ONE specific book must be in a function `void displayBook(const struct Book *b)`.  
- The only functions besides `main()` allowed are:  
  - `displayBook`  
  - one optional helper that resizes the array (if you wish).

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Campus Bookstore Inventory System
 * C11 – single-file, only main() + displayBook() allowed
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ISBN_LEN 14   /* 13 digits + '\0' */
#define TITLE_LEN 31  /* ≤30 chars + '\0' */

/* ---------- DATA STRUCTURE ---------- */
struct Book {
    char isbn[ISBN_LEN];
    char title[TITLE_LEN];
    int  qty;
};

/* ---------- FUNCTION PROTOTYPES ---------- */
static void displayBook(const struct Book *b); /* required by spec */

/* Optional helper: grow/shrink the dynamic array */
static struct Book *resizeInventory(struct Book *old, size_t oldCount, size_t newCount);

/* ---------- MAIN PROGRAM ---------- */
int main(void)
{
    struct Book *inventory = NULL; /* dynamic array */
    size_t       count     = 0;    /* current number of books */
    size_t       capacity  = 0;    /* allocated slots */

    for (;;) {
        /* ---- MENU ---- */
        puts("1. Add a new book");
        puts("2. Update stock for an existing ISBN");
        puts("3. Show complete inventory");
        puts("4. Exit");
        printf("Choice: ");

        int choice;
        if (scanf("%d", &choice) != 1) { /* malformed input */
            while (getchar() != '\n');   /* flush */
            continue;
        }
        while (getchar() != '\n');       /* discard rest of line */

        switch (choice) {
        case 1: { /* Add new book */
            char tmpIsbn[ISBN_LEN];
            char tmpTitle[TITLE_LEN];
            int  tmpQty;

            /* Read 3 tokens: ISBN title qty */
            if (scanf("%13s %30s %d", tmpIsbn, tmpTitle, &tmpQty) != 3) {
                puts("Invalid input format.");
                while (getchar() != '\n');
                break;
            }
            while (getchar() != '\n');

            /* Check duplicate */
            _Bool found = 0;
            for (size_t i = 0; i < count; ++i)
                if (strcmp(inventory[i].isbn, tmpIsbn) == 0) {
                    found = 1;
                    break;
                }
            if (found) {
                puts("ISBN already in inventory.");
                break;
            }

            /* Ensure capacity (resize if needed) */
            if (count == capacity) {
                size_t newCap = capacity ? capacity * 2 : 4;
                struct Book *n = resizeInventory(inventory, capacity, newCap);
                if (!n) {                 /* allocation failed */
                    puts("Memory allocation failed.");
                    goto CLEANUP;         /* free and exit */
                }
                inventory = n;
                capacity  = newCap;
            }

            /* Insert new book */
            strncpy(inventory[count].isbn,  tmpIsbn,  ISBN_LEN);
            inventory[count].isbn[ISBN_LEN - 1] = '\0';
            strncpy(inventory[count].title, tmpTitle, TITLE_LEN);
            inventory[count].title[TITLE_LEN - 1] = '\0';
            inventory[count].qty = tmpQty;
            ++count;
            break;
        }
        case 2: { /* Update stock */
            char tmpIsbn[ISBN_LEN];
            int  delta;

            /* Read: ISBN delta */
            if (scanf("%13s %d", tmpIsbn, &delta) != 2) {
                puts("Invalid input format.");
                while (getchar() != '\n');
                break;
            }
            while (getchar() != '\n');

            _Bool found = 0;
            for (size_t i = 0; i < count; ++i)
                if (strcmp(inventory[i].isbn, tmpIsbn) == 0) {
                    inventory[i].qty += delta;
                    found = 1;
                    break;
                }

            if (!found)
                puts("ISBN not found.");
            break;
        }
        case 3: { /* Show inventory */
            if (count == 0) {
                puts("Inventory empty.");
                break;
            }
            for (size_t i = 0; i < count; ++i)
                displayBook(&inventory[i]);
            break;
        }
        case 4: /* Exit */
            goto CLEANUP;

        default:
            puts("Invalid choice.");
        }
    }

CLEANUP:
    free(inventory);
    return 0;
}

/* ---------- FUNCTION DEFINITIONS ---------- */

/* Required output format: ISBN title quantity */
void displayBook(const struct Book *b)
{
    if (!b) return;
    printf("%s %s %d\n", b->isbn, b->title, b->qty);
}

/*
 * resizeInventory: allocate a fresh array of 'newCount' slots, copy
 * old data, free the old pointer.  Returns pointer to new array.
 * If allocation fails, returns NULL and leaves the old pointer intact.
 */
static struct Book *
resizeInventory(struct Book *old, size_t oldCount, size_t newCount)
{
    struct Book *newArr = malloc(newCount * sizeof *newArr);
    if (!newArr) return NULL;

    size_t toCopy = oldCount < newCount ? oldCount : newCount;
    memcpy(newArr, old, toCopy * sizeof *newArr);
    free(old);
    return newArr;
}
```

### STEP_3
# STEP 3: EXPLANATION

## 1. Why Dynamic Memory?
A static array has a fixed size chosen at compile-time (e.g. `struct Book inventory[100];`).  
The assignment says we must accept "any non-negative number of books" – possibly thousands – so we cannot fix an upper bound.  
Dynamic memory (`malloc`, `realloc`, `free`) lets the array grow or shrink while the program is running and only consumes as much RAM as is really needed.

## 2. Three Pointers You Must Master
- `inventory` – a pointer to a *contiguous* block of `struct Book`s, i.e. the array.  
- `capacity` – how many slots that block *could currently hold*.  
- `count` – how many slots are *actually used*.  
When `count == capacity` we are full and must enlarge the block before another insertion can succeed.

## 3. Growth Strategy
We double the capacity whenever we run out of space (4 → 8 → 16 …).  
This keeps the cost of copying old elements *amortized* O(1): each element is moved only O(log N) times no matter how many insertions occur.  
The helper `resizeInventory` performs the classic "allocate-new / memcpy / free-old" dance and returns the new base pointer. If it fails we print an error, release everything, and terminate safely.

## 4. Ownership Rules
**malloc** ⇒ you own the bytes.  
**free** ⇒ you release them **exactly once** when they are no longer needed.  
In this program the only long-lived allocation is the array of books.  
- We free it once at the end of `main` (label `CLEANUP`).  
- We never free the old pointer until we are sure the new allocation succeeded; this avoids "use-after-free" in the error path.

## 5. struct Book Storage
Each book is stored **by value** in the array.  
- `sizeof(struct Book)` already includes room for its fixed-size strings (`isbn`, `title`).  
- We never store `char *` pointers to separately-allocated strings, so we avoid a forest of tiny allocations and their corresponding bookkeeping.

## 6. Defensive Coding Details
- `strncpy` + explicit NUL terminator keeps us safe from overly long user input.  
- `scanf` return-value checks prevent an infinite loop if the user types `abc` instead of a number.  
- `goto CLEANUP;` is acceptable here because it centralises one *single* exit path that frees the memory and returns a status; it is clearer than nested `if`s.

## 7. Big Picture Flow
1. Start with `inventory = NULL, count = capacity = 0`.  
2. Menu loop reads a choice:  
   - **Add** → check duplicate → grow array if needed → append new book.  
   - **Update** → search by ISBN → adjust quantity.  
   - **Show** → print each book using the required `displayBook` function.  
   - **Exit** → free the array, terminate.  

This design satisfies the specification:  
- Dynamic resizing, clean memory handling, single-purpose helper, and the only extra function besides `main` is the mandated `displayBook`.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of the inventory as a pile of index cards that you may need to shuffle into a bigger box whenever the pile outgrows the current one; the program never knows beforehand how big the pile might become.

Hint 2  
To make that “box” grow while the program is running, look for the standard library tools whose names start with the letter “m” and end with “alloc” or “realloc”; remember you’ll also need to give the memory back when you’re done.

Hint 3  
Begin by declaring three simple variables: one to remember where your array of books lives, one to count how many books are stored right now, and one to track how many slots you’ve actually allocated; then write the menu loop and only after that add the logic that doubles the allocated space whenever the count catches up to the capacity.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: malloc/realloc/free for runtime-sized arrays  
- Amortized growth via doubling capacity to achieve efficient insertion  
- Ownership discipline: allocate once, free once, always check allocation success  
- Struct design with fixed-size char arrays to avoid secondary allocations  
- Searching an unsorted array and handling duplicate keys  
- Centralised cleanup path (single exit) for safe resource release  
- Defensive input handling with return-value checks and buffer safety  
- Functional separation: keeping menu logic separate from display logic (displayBook)

### STEP_6
# STEP 6: TEST CASES

Case 1 – Normal Add then Show  
Add three distinct books, list them, verify order and quantities.

Case 2 – Duplicate ISBN Refusal  
Try to add the same ISBN twice; the second attempt should be rejected with the indicated message.

Case 3 – Empty Inventory List  
Start the program and immediately request the inventory list; only the message “Inventory empty.” should appear.

Case 4 – Stock Update with Negative Delta  
Add a book with quantity 10, update with delta −6, then list; expect quantity 4.

Case 5 – Invalid Menu Choice  
Type 7 at the menu prompt; program should respond “Invalid choice.” and re-display the menu.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\n9780131103627 K&R 15\n1\n9780131103627 CProg 27\n3\n4",
      "expected_keyword": "27"
    },
    {
      "input": "1\n9780131103627 K&R 15\n1\n9780131103627 K&R 5\n3\n4",
      "expected_keyword": "already in inventory"
    },
    {
      "input": "3\n4",
      "expected_keyword": "Inventory empty"
    },
    {
      "input": "1\n9780131103627 K&R 10\n2\n9780131103627 -6\n3\n4",
      "expected_keyword": "4"
    },
    {
      "input": "7\n4",
      "expected_keyword": "Invalid choice"
    }
  ]
}
```

---

## Iteration 30 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The campus library is digitizing its small magazine stand.  
Each magazine is represented only by a title (≤30 chars) and its monthly price.  
You will write a tiny terminal program that lets the librarian:

- Add a new magazine (dynamically allocate it and store it in an array of pointers)
- Show every magazine currently stored
- Delete a magazine by its 1-based index (free its memory)
- Exit the program

All memory must be managed with malloc/free.

## Functional Requirements
1. On start-up the program should allocate space for up to 50 magazine pointers (but no magazines yet).
2. Present a numbered menu:
   ```
   1) Add magazine
   2) List magazines
   3) Delete magazine
   4) Exit
   ```
3. "Add magazine" reads a title and a price, allocates one magazine record, and stores its address in the next free slot.
4. "List magazines" prints the index, title, and price of every valid magazine.
5. "Delete magazine" reads an index; if valid it frees that magazine's memory and sets the pointer to NULL so it can be reused later.
6. The program must not leak memory: every malloc'ed block must eventually be freed (either during deletion or when the program ends).
7. After every command except Exit, re-display the menu.
8. On Exit the program frees any remaining magazines and terminates.

## Simple Example Run
```
1) Add magazine
2) List magazines
3) Delete magazine
4) Exit
Choice: 1
Title: CS Weekly
Price: 4.99
Magazine added.

1) Add magazine
2) List magazines
3) Delete magazine
4) Exit
Choice: 2
1: CS Weekly $4.99

1) Add magazine
2) List magazines
3) Delete magazine
4) Exit
Choice: 4
Good-bye!
```

### CONSTRAINTS
- Represent a magazine with a struct containing at least `title` and `price`.
- The logic that prints details of a single magazine must be placed in a function called `displayMagazine(const struct Magazine*)`.
- The only functions allowed in your submission are `main()` and `displayMagazine()`.
- Menu option 4 is the mandatory EXIT command.

### STEP_2
# STEP 2: SOLUTION

```c
/*  Magazine-stand manager
    One compilation unit, exactly two functions allowed:
        int main(void)
        void displayMagazine(const struct Magazine*)
    C11, all heap blocks are freed on exit or deletion.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE  30          /* max chars in magazine title */
#define MAX_INDEX  50          /* maximum simultaneous magazines */

/* DATA STRUCTURE */
struct Magazine {
    char  title[MAX_TITLE + 1]; /* title string, always zero-terminated */
    float price;                /* monthly price in dollars */
};

/* FUNCTIONAL REQUIREMENT: display one magazine */
void displayMagazine(const struct Magazine *m) {
    if (m) /* guard against NULL */
        printf("%s $%.2f", m->title, m->price);
}

int main(void) {
    /* Create array of 50 magazine pointers (no magazines yet) */
    struct Magazine **magazines =
        malloc(sizeof *magazines * MAX_INDEX);
    if (!magazines) {
        fprintf(stderr, "Fatal: failed initial allocation.\n");
        exit(EXIT_FAILURE);
    }
    /* NULL-initialise every slot, meaning “empty” */
    for (int i = 0; i < MAX_INDEX; ++i) magazines[i] = NULL;

    int choice;
REPRINT_MENU:                     /* label for a tiny "while" substitute */
    printf("\n1) Add magazine\n"
           "2) List magazines\n"
           "3) Delete magazine\n"
           "4) Exit\n"
           "Choice: ");
    if (scanf("%d", &choice) != 1) break; /* give up on bad input */

    switch (choice) {
    case 1: {
        /* ---- Add magazine ---- */
        struct Magazine *m =
            malloc(sizeof *m);    /* single magazine on the heap */
        if (!m) {                 /* ALWAYS test malloc result */
            fprintf(stderr, "Out of memory, magazine not added.\n");
            break;
        }
        /* Read title: consume leftover newline first */
        int c; while ((c = getchar()) != '\n' && c != EOF) {}
        printf("Title: ");
        if (!fgets(m->title, sizeof m->title, stdin)) {
            free(m);
            break;
        }
        m->title[strcspn(m->title, "\n")] = '\0'; /* strip newline */
        printf("Price: ");
        if (scanf("%f", &m->price) != 1) {          /* bad price: discard */
            free(m);
            break;
        }
        /* find first NULL slot and store pointer */
        int idx = 0;
        while (idx < MAX_INDEX && magazines[idx]) ++idx;
        if (idx == MAX_INDEX) {
            printf("Magazine collection full (max %d).\n", MAX_INDEX);
            free(m);
        } else {
            magazines[idx] = m;
            printf("Magazine added.\n");
        }
        goto REPRINT_MENU;
    }
    case 2: {
        /* ---- List magazines ---- */
        int any = 0;
        for (int i = 0; i < MAX_INDEX; ++i)
            if (magazines[i]) {
                printf("%d: ", i + 1);  /* 1-based index required */
                displayMagazine(magazines[i]);
                printf("\n");
                any = 1;
            }
        if (!any) printf("(No magazines)\n");
        goto REPRINT_MENU;
    }
    case 3: {
        /* ---- Delete magazine ---- */
        printf("Index to delete: ");
        int idx;
        if (scanf("%d", &idx) != 1 || idx < 1 || idx > MAX_INDEX) {
            puts("Invalid index.");
            goto REPRINT_MENU;
        }
        int i = idx - 1;            /* convert to 0-based */
        if (!magazines[i]) {
            puts("No magazine at that index.");
        } else {
            free(magazines[i]);     /* free the object */
            magazines[i] = NULL;  /* mark slot as reusable */
        }
        goto REPRINT_MENU;
    }
    case 4:
        /* ---- Exit; clean up first ---- */
        break;
    default:
        /* ignore bad menu choices */
        goto REPRINT_MENU;
    }

    /* --- program termination --- */
    for (int i = 0; i < MAX_INDEX; ++i) free(magazines[i]);
    free(magazines);
    puts("Good-bye!");
    return 0;
}
```

Explanation of key points (also given as comments):

1. A single allocation at start-up gives us an array of 50 pointers (`MAX_INDEX`).  
2. Pointers in that array are either `NULL` (empty) or point to dynamically allocated `struct Magazine`.  
3. Every `malloc` is checked for failure; the program refuses to proceed when a critical allocation fails and properly releases anything already obtained.  
4. Choice 1 (`Add`) strips the newline that remains after the previous `scanf`, asks for a title (at most 30 characters plus terminator), stores it without the newline, and then reads the price. If anything here fails we free the already-allocated magazine and return to the menu; otherwise we store the pointer in the first `NULL` slot.  
5. Choice 2 (`List`) prints the magazines in their current order (using 1-based indexing) by calling the required `displayMagazine()` function.  
6. Choice 3 (`Delete`) converts the user-supplied index to zero-based, verifies it, frees the magazine if the slot is occupied, then sets that slot to `NULL` so it can be reused later.  
7. Choice 4 (`Exit`) breaks out of the switch, triggers the final loop that frees every remaining magazine and then frees the array of pointers itself, guaranteeing a leak-free shutdown.

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory is like renting lockers from the university:  
- You ask for a locker (`malloc`)  
- You keep the key (a pointer) so you can open it later  
- When you are done, you return the key so somebody else can use the locker (`free`)  

The magazine-stand program shows this process in miniature.  
The code below focuses on three questions:

1. Where do we store the pointers?  
2. How do we add, visit and delete magazines (without leaking lockers)?  
3. Why do we need double indirection (`**`) at all?

---

### 1. The "parking-lot" for magazine pointers

```c
struct Magazine **magazines = malloc(50 * sizeof *magazines);
```

You do **not** allocate 50 magazines—you only allocate space for 50 *addresses* (`50 * sizeof *magazines`).  
All addresses are initially `NULL` (`magazines[i] = NULL;`). Each `NULL` says "this slot is empty", i.e. you cannot look inside a `NULL` locker.

KEY IDEA:  
- magazines → array  
- magazines[i] → pointer to *one* magazine *or* `NULL` (empty slot)  
- *magazines[i] → a real magazine object if present

Using `NULL` lets us re-use holes left after deletion without shifting the array.

---

### 2. Adding a new magazine—stack vs heap

Inside the `case 1:` block:

```c
struct Magazine *m = malloc(sizeof *m);
```

We create **one** magazine on the heap (not on the stack).  
Why not the stack?  
A locally declared `struct Magazine m;` would die the moment `case 1:` ends.  
A heap block survives after the function returns, so we can keep it in our pointer-array.

After we fill it (`m->title`, `m->price`), we scan the array for the *first* `NULL` pointer:

```c
int idx = 0;
while (idx < 50 && magazines[idx]) ++idx;
```

If `idx==50`, our parking-lot is full—no garage left, `free(m)` the brand-new magazine, and tell the librarian.

Otherwise we simply do:

```c
magazines[idx] = m;   /* hand the key to the librarian */
```

Now the librarian can refer to this magazine by its number (`idx+1` in human-friendly 1-based form).

---

### 3. Visiting (displaying) magazines safely

You are required to implement:

```c
void displayMagazine(const struct Magazine *m);
```

Notice the `const`: we promise *not* to alter the magazine.  
Because it receives a pointer, we should guard against accidental NULL:

```c
if (m) printf("%s $%.2f", m->title, m->price);
```

Inside `case 2:` we loop through the array, skipping `NULL` slots, and print the index, then call `displayMagazine`. Thus every magazine is displayed exactly once.

---

### 4. Deleting cleanly—no memory leak, no stale key

1. Ask for the 1-based index (user type `3`).  
2. Convert to 0-based and *check bounds*.  
3. If `magazines[i]` is `NULL` there is no locker at that number—reject.  
4. Otherwise:
   ```c
   free(magazines[i]);  /* give locker back */
   magazines[i] = NULL; /* blank the key slot */
   ```

If we forgot line 4, two things would eventually go wrong:

- The pointer keeps pointing to the *old* address (a "dangling pointer").  
    The next user might choose the same slot, overwrite it, etc.  
- We lose the address → **memory leak**.  
    The program's lease on that memory never ends and the operating system cannot recycle it.

By clearing the slot to `NULL`, we both remove the danger and make the slot reusable without shuffling remaining magazines.

---

### 5. Why loop labels are used instead of `while`

The menu must be re-displayed after every operation except `4) Exit`.  
Using:

```c
REPRINT_MENU:  /* label */
...menu...
goto REPRINT_MENU;
```

is a *legal*, compact form of tail recursion. Beginners often dislike `goto`, but in a small driver loop like this, it is direct and avoids extra indentation. You could rewrite it as `do { ... } while(...)`, the intent is identical.

---

### 6. Exiting—clean-up is mandatory

At start the program allocates the *array of pointers*.  
Each magazine was individually allocated.  
Therefore, on exit we must:

- `free()` every living magazine (their lockers)  
- Then `free()` the array of pointers itself (the parking-lot)

```c
for (int i = 0; i < 50; ++i) free(magazines[i]);
free(magazines);
```

Valgrind will confirm "no leaks are possible".

---

### 7. Testing your understanding

- Run the program under `valgrind ./a.out`, try adding, deleting, listing, then exit; look for "definitely lost: 0 bytes".  
- Add more than 50 magazines—the program should refuse politely.  
- Delete indices out-of-range; they should be rejected.  
- Delete an index twice; the program should still be stable.

---

### SUMMARY

Dynamic memory management consists of three disciplined steps:

1. Allocate (`malloc`) and *always* test the result.  
2. Keep the pointer in a safe place (here: `magazines[i]`).  
3. When finished: `free()` *exactly once* (`free(ptr)`) and **clear or discard the pointer** so you cannot use it again by accident.

Follow these rules, and even a modest program like our magazine kiosk will run forever without leaking memory and, more importantly, without crashing the library computer.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual):**  
Think of the magazines as a collection of labeled lockers that don’t have to sit next to one another. You only need one hallway (array) that keeps a key to each locker. When you add a magazine, rent the locker, fill it, and hang its key in the next empty slot. Deleting just means returning the locker and removing the key from the hook. List by walking along the hooks and peeking into any locker that still has a key.

**Hint 2 (key feature):**  
Your hallway should hold *pointers*, not the magazines themselves. Each pointer can be either “unoccupied” or pointing to a magazine, so you need a special marker (the null indicator) to distinguish between the two states. Use that marker so you can safely reuse any freed slot later without shifting the whole row of keys.

**Hint 3 (first concrete step):**  
In the main function, start by reserving space for a fixed-size array of these pointers. Initialize every entry to the null marker so the program knows all slots are empty. After that, the option-1 routine should:  
- Reserve memory for a single magazine  
- Read the title and price into that memory  
- Locate the first null marker in the hallway  
- Replace the marker with a pointer to the newly-filled magazine

### STEP_5
# STEP 5: SUMMARY

- Master dynamic memory basics: allocating a block with `malloc`, checking the return value, freeing it once with `free`.
- Practice array-of-pointers design: store magazine objects separately and track them through a fixed-size array of pointers.
- Understand null pointers as placeholders: initialise every slot to `NULL`, reuse after deletion, safely detect occupied/empty status.
- Reinforce struct definition and safe string input: define a struct, copy user text into fixed-width field, strip trailing newline.
- Experience memory-leak avoidance: ensure every `malloc` has a matching `free`, including tidy-up on program exit.
- Implement basic menu loop: display choices, process numeric input, re-display after most actions.
- Use required helper function: package the print-details logic in the mandated `displayMagazine`.
- Validate user input and boundaries: refuse out-of-range indices, handle full collection gracefully.

### STEP_6
# STEP 6: TEST CASES

1. **Happy-path add & list**  
   Add two magazines, list them, and exit.  
   Expect both items to appear with correct indices and prices.

2. **Edge – empty list**  
   Choose list immediately after start-up (no adds).  
   Expect clear “(No magazines)” or equivalent, then menu re-prints.

3. **Invalid index deletion**  
   Attempt to delete index 0 (out of range) and again try to delete from an empty slot (e.g., delete 1 when nothing stored).  
   Expect polite error message and no crash.

4. **Maximum capacity**  
   Add exactly 50 magazines; attempt a 51st add.  
   Expect refusal message that collection is full.

5. **Reuse freed slot**  
   Add three magazines, delete the middle one (index 2), add a new one.  
   Expect the new magazine to occupy the freed slot and list to show three consecutive entries.

```json
{
  "exit_command": "4",
  "test_suite": [
    {"input": "1\nCS Weekly\n4.99\n1\nIEEE Micro\n6.50\n2\n4", "expected_keyword": "CS Weekly"},
    {"input": "2\n4", "expected_keyword": "(No magazines)"},
    {"input": "3\n0\n3\n1\n4", "expected_keyword": "Invalid index"},
    {"input": "1\nM1\n1\n1\nM2\n2\n1\nM3\n3\n1\nM4\n4\n1\nM5\n5\n1\nM6\n6\n1\nM7\n7\n1\nM8\n8\n1\nM9\n9\n1\nM10\n10\n1\nM11\n11\n1\nM12\n12\n1\nM13\n13\n1\nM14\n14\n1\nM15\n15\n1\nM16\n16\n1\nM17\n17\n1\nM18\n18\n1\nM19\n19\n1\nM20\n20\n1\nM21\n21\n1\nM22\n22\n1\nM23\n23\n1\nM24\n24\n1\nM25\n25\n1\nM26\n26\n1\nM27\n27\n1\nM28\n28\n1\nM29\n29\n1\nM30\n30\n1\nM31\n31\n1\nM32\n32\n1\nM33\n33\n1\nM34\n34\n1\nM35\n35\n1\nM36\n36\n1\nM37\n37\n1\nM38\n38\n1\nM39\n39\n1\nM40\n40\n1\nM41\n41\n1\nM42\n42\n1\nM43\n43\n1\nM44\n44\n1\nM45\n45\n1\nM46\n46\n1\nM47\n47\n1\nM48\n48\n1\nM49\n49\n1\nM50\n50\n1\nM51\n51\n4", "expected_keyword": "collection full"},
    {"input": "1\nFirst\n1\n1\nSecond\n2\n1\nThird\n3\n3\n2\n1\nNewMiddle\n9.99\n2\n4", "expected_keyword": "NewMiddle"}
  ]
}
```

---

## Iteration 31 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

**Background Story**  
The campus library is digitising its old card-catalogue.  
Each card contains: title (≤80 chars), author (≤50 chars), and year (int).  
Your program will act as a tiny in-memory catalogue: the user can add new cards, list all of them, or delete a card by its position in the list.  
All data must be kept in dynamically allocated memory and freed before the program ends.

**Functional Requirements**  
1. Present a simple text menu with four options:  
   1. Add a new card  
   2. List all cards  
   3. Delete a card (by 1-based index)  
   4. Exit (menu option 4)  
2. “Add” must allocate a new structure, read title, author and year, and append it to the catalogue.  
3. “List” must print every card in order, one per line, formatted exactly as:  
   `idx: "Title" by Author (year)`  
   If the catalogue is empty print `Catalogue empty.`  
4. “Delete” must free the memory of the chosen card and compact the array of pointers so that no gaps remain.  
5. After option 4 (“Exit”) the program must free all remaining memory and terminate.

**Simple Example**  
Input:
```
1
The C Programming Language
Kernighan & Ritchie
1978
1
Clean Code
Robert C. Martin
2008
2
3
1
4
```
Output:
```
1: "The C Programming Language" by Kernighan & Ritchie (1978)
2: "Clean Code" by Robert C. Martin (2008)
1: "Clean Code" by Robert C. Martin (2008)
```

### CONSTRAINTS  
- Must use a struct to represent each catalogue card.  
- All cards must be stored in a dynamically resizing array of pointers (double when full).  
- Logic for displaying the details of ONE specific card must be in a function called `displayCard`.  
- The only functions allowed besides `main()` are: `displayCard`, `addCard`, `listCards`, `deleteCard`, `freeCatalogue`.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Digitised Library Catalogue
 *
 * A minimal in-memory catalogue for the campus library that
 *  - stores title / author / year triples in dynamic memory
 *  - lets the user add, list, delete and exit
 *  - always cleans up its own memory
 *
 * The catalogue is kept as a resizable array of pointers (doubles
 * in size when full).  All string data is stored with fixed-size
 * char arrays embedded inside the Card struct.
 *
 * C11 and clang/gcc compliant.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- CONSTANTS ---------------------------------------------------- */

#define MAX_TITLE_LEN  81      /* 80 chars + terminating NUL */
#define MAX_AUTHOR_LEN 51      /* 50 chars + terminating NUL */

/* ---------- DATA STRUCTURES ---------------------------------------------- */

/* Each catalogue card */
typedef struct Card {
    char  title[MAX_TITLE_LEN];
    char  author[MAX_AUTHOR_LEN];
    int   year;
} Card;

/* Dynamic catalogue */
typedef struct Catalogue {
    Card **arr;     /* pointer to an array of Card* */
    size_t cap;     /* total capacity (allocated space) */
    size_t len;     /* number of cards actually stored */
} Catalogue;

/* ---------- PROTOTYPES --------------------------------------------------- */

/* core ops */
void displayCard(const Card *c, size_t idx);
void addCard(Catalogue *cat);
void listCards(const Catalogue *cat);
void deleteCard(Catalogue *cat, size_t idx);
void freeCatalogue(Catalogue *cat);

/* helpers */
static void catalogueGrowIfNeeded(Catalogue *cat);

/* ---------- MAIN --------------------------------------------------------- */

int main(void)
{
    /* create an initially empty catalogue with room for 2 cards */
    Catalogue cat = { NULL, 0, 0 };
    catalogueGrowIfNeeded(&cat);

    int choice = 0;
    while (1) {
        /* print menu */
        puts("1. Add a new card");
        puts("2. List all cards");
        puts("3. Delete a card by index");
        puts("4. Exit");
        printf("Enter choice: ");

        if (scanf("%d", &choice) != 1) break;  /* malformed => quit */

        /* consume trailing newline */
        int ch;
        while ((ch = getchar()) != '\n' && ch != EOF);

        switch (choice) {
            case 1:
                addCard(&cat);
                break;
            case 2:
                listCards(&cat);
                break;
            case 3: {
                printf("Index to delete: ");
                size_t idx;
                if (scanf("%zu", &idx) != 1) goto exit_loop;
                while ((ch = getchar()) != '\n' && ch != EOF);
                deleteCard(&cat, idx);
                break;
            }
            case 4:
                goto exit_loop;
            default:
                puts("Invalid choice.");
        }
    }

exit_loop:
    freeCatalogue(&cat);
    return 0;
}

/* ---------- FUNCTION DEFINITIONS ----------------------------------------- */

/* Display a single card in the exact required format */
void displayCard(const Card *c, size_t idx)
{
    printf("%zu: \"%s\" by %s (%d)\n",
           idx, c->title, c->author, c->year);
}

/* Ensure the underlying array has room for more cards;
 * doubles capacity when needed. */
static void catalogueGrowIfNeeded(Catalogue *cat)
{
    if (cat->len < cat->cap) return;

    size_t newcap = (cat->cap == 0) ? 2 : cat->cap * 2;
    Card **tmp = realloc(cat->arr, sizeof(Card *) * newcap);
    if (!tmp) {          /* allocation failure => terminate cleanly */
        perror("realloc failed");
        freeCatalogue(cat);
        exit(EXIT_FAILURE);
    }
    cat->arr = tmp;
    cat->cap = newcap;
}

/* Add a new card interactively and append it to the catalogue */
void addCard(Catalogue *cat)
{
    catalogueGrowIfNeeded(cat);

    Card *newcard = malloc(sizeof *newcard);
    if (!newcard) {
        perror("malloc failed");
        freeCatalogue(cat);
        exit(EXIT_FAILURE);
    }

    /* Read title, author, year */
    printf("Title: ");
    if (!fgets(newcard->title, MAX_TITLE_LEN, stdin)) goto readError;
    newcard->title[strcspn(newcard->title, "\n")] = '\0';  /* trim newline */

    printf("Author: ");
    if (!fgets(newcard->author, MAX_AUTHOR_LEN, stdin)) goto readError;
    newcard->author[strcspn(newcard->author, "\n")] = '\0';

    printf("Year: ");
    if (scanf("%d", &newcard->year) != 1) goto readError;
    int ch; while ((ch = getchar()) != '\n' && ch != EOF);

    cat->arr[cat->len++] = newcard;
    return;

readError:
    free(newcard);
    puts("Input error; card not added.");
}

/* Print all cards or a special message when catalogue is empty */
void listCards(const Catalogue *cat)
{
    if (cat->len == 0) {
        puts("Catalogue empty.");
        return;
    }
    for (size_t i = 0; i < cat->len; ++i)
        displayCard(cat->arr[i], i + 1);
}

/* Delete the card at the 1-based index supplied by the user */
void deleteCard(Catalogue *cat, size_t userIdx)
{
    if (userIdx < 1 || userIdx > cat->len) {
        puts("Index out of range.");
        return;
    }
    size_t idx = userIdx - 1;   /* convert to 0-based */

    /* free memory */
    free(cat->arr[idx]);

    /* slide remaining elements left */
    for (size_t i = idx; i < cat->len - 1; ++i)
        cat->arr[i] = cat->arr[i + 1];

    --cat->len;
    /* shrink capacity if we drop below 1/4, but never below 2 */
    if (cat->cap > 4 && cat->len < cat->cap / 4) {
        size_t newcap = cat->cap / 2;
        if (newcap < 2) newcap = 2;
        Card **tmp = realloc(cat->arr, sizeof(Card *) * newcap);
        if (tmp) {            /* failure is non-fatal here */
            cat->arr = tmp;
            cat->cap = newcap;
        }
    }
}

/* Free every card and the array itself */
void freeCatalogue(Catalogue *cat)
{
    for (size_t i = 0; i < cat->len; ++i)
        free(cat->arr[i]);
    free(cat->arr);
    cat->arr = NULL;
    cat->len = cat->cap = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic-memory problems feel scary because **three separate things** can go wrong:
1. Forgetting to allocate
2. Forgetting to check if the allocation succeeded
3. Forgetting to free what you allocated

Below we walk through the catalogue program while stressing the **why** of every `malloc`/`realloc`/`free` that appears.

---

### 0. WHAT "DYNAMIC" REALLY MEANS
- Local variables (`int x`) live in a region called the stack.
- When the function ends they vanish automatically.
- If you create, say, a struct with `Card c;` inside a loop, all data disappear the instant the loop iteration finishes.
- To keep objects **after** we leave the function that creates them, we must:
  1. Ask the operating system for global memory ("the heap"),
  2. Keep the starting address in a **pointer**, and
  3. Free the memory later, otherwise you leak it.

The C standard library functions are:
  `malloc`  – allocates a block and returns a pointer  
  `realloc` – enlarges or shrinks an existing block  
  `free`    – returns a block to the pool

---

### 1. DATA DESIGN DECISIONS
We need an array that grows as the user keeps adding cards.  
Two classic strategies:
- Linked list (next pointers everywhere)
- Resizable contiguous array

A contiguous array is *much simpler* here, and we handle "growth" exactly as C++ `std::vector` does: keep both
  `capacity` – how many *slots* are allocated  
  `length`   – how many are currently in use  
When `length == capacity` we `realloc` to twice the space.

The catalogue therefore holds:
  **Catalogue** (struct) -- keeps `Card **arr` + capacity + length  
  **Card** (struct)    -- one memory block per book

Note that we do *not* store the strings by `malloc`-ing them separately; instead we place a fixed-size char array *inside* the Card.  
The pointer that *is* dynamically allocated is the "outer shell":
  Card * c = malloc(sizeof(*c));

This gives one `malloc` per Card and a single `free` when we delete it.

---

### 2. START-UP ALLOCATION

```c
Catalogue cat = {NULL, 0, 0};  /* nothing so far */
catalogueGrowIfNeeded(&cat);  /* first call makes 2 slots */
```

`realloc` with a NULL pointer behaves exactly like `malloc` (`man realloc`). That is why we can reuse the resizing routine during start-up.

---

### 3. ADDING (user presses 1)

Main calls:
```c
addCard(&cat);
```

Actions performed:
1. `catalogueGrowIfNeeded` – maybe double capacity
2. `malloc(sizeof *newcard)` – one Card block
3. `scanf/fgets` fill in the title, author, year

Key safety details:
- We *always* check `malloc`/`realloc` return: if NULL, print an error and `exit` **after freeing everything that has already been allocated**.
- We use `fgets` + `strcspn` to remove the trailing newline, so nothing is printed later.
- After a successful insert we append the pointer:
  `cat->arr[cat->len++] = newcard;`

---

### 4. LISTING (user presses 2)

We simply iterate from index 0 to len−1 (0-based), incrementing the displayed number by one.  
Function `displayCard` prints in the *exact* format demanded by the spec, so consistency is guaranteed no matter where or when we call it.

If `len == 0`, we output `Catalogue empty.` instead.

Notice: no `malloc`/`free` here—we just read what's already there.

---

### 5. DELETING (user presses 3)

The user gives a **1-based position** ("delete #3").  
Our internal array of pointers is 0-based, so:

1. Validate bounds. On error, print message and return immediately.
2. `free(cat->arr[idx])` – we free the memory for *that* Card.
3. "Compact" the array: every pointer to the right of `idx` slides one cell left (`memmove` style). Length decreases by one and the vacated slot is overwritten.
4. Optionally shrink capacity if we now occupy < ¼ of it (prevents holding too much empty memory); we never shrink below initial 2 slots.

The crucial insight: **Only the pointer array itself is shuffled**—the Card is already gone after `free`.

---

### 6. EXITING AND TOTAL CLEAN-UP

When the user chooses "4", `main` jumps to the exit label and unconditionally calls:

```c
freeCatalogue(&cat);
```

which:
a) Loops over every *still-living* Card and calls `free`.
b) Calls `free(cat)` on the pointer buffer itself.
c) Sets all sizes to zero as defensive programming.

Because our error paths inside `malloc`/`realloc` failure also invoke `freeCatalogue`, we never have a leaking path in the program.

---

### 7. COMMON GOTCHAS THIS DESIGN PROTECTS YOU FROM
- Forgotten `free`: every control path has one.
- `free`-after-copy-of-pointer: we only stored one copy, therefore dangling pointers are impossible.
- `realloc` moved the buffer, but we kept the old address – impossible because we do `ptr = realloc(ptr, …)` only when success is certain (NULL does not overwrite the old pointer).
- User deletes index outside range – we explicitly reject.

---

### 8. SUMMARY FLOW IN PLAIN WORDS

1. We reserve an initially tiny pointer array in the heap.
2. Each "add" malloc's ONE Card block and stores its address.
3. When the pointer array is full, we realloc it twice as large.
4. When the user deletes a row, we:
   free the Card pointer,
   slide the rest of the pointer array,
   possibly shrink the pointer array.
5. When we leave, we free every Card, and free the pointer array.

Because **every** allocated block has exactly one owner, cleaning up is trivial and memory-safety is guaranteed.

### STEP_4
# STEP 4: HINTS

### Hint 1
Think of the catalogue as a bookshelf that can magically grow longer whenever you run out of space.  
Inside that shelf you keep individual “cards,” but you only store a tiny map to each card, not the whole card itself.  
Focus on what has to grow and what stays the same size no matter what.

### Hint 2
When the shelf is full you will need to build a bigger one.  
The language gives you a single call that can both copy your old shelf and resize it.  
Make sure you always verify that this call succeeded before you trust the new shelf.

### Hint 3
Start by allocating space for a pointer array big enough for just a couple of cards.  
Every time the user presses option 1, allocate a brand-new card object, fill it with the input you read, and place its address into the first empty slot of that pointer array.

### STEP_5
# STEP 5: SUMMARY  
• Dynamic memory management: malloc, realloc, free and the importance of NULL-checking each allocation.  
• Array-of-pointers data structure: maintaining and resizing a contiguous block of pointers while the objects they point to remain fixed-size.  
• Manual lifetime control: keeping data alive across function calls by placing it on the heap instead of the stack.  
• Memory-leak prevention: pairing every allocation with a single, clearly defined de-allocation path.  
• Input and string handling: safely reading fixed-width strings and removing trailing newlines.  
• Modular design: isolating display, add, list, delete and cleanup responsibilities into small, testable functions.  
• Defensive programming: validating indexes, shrinking capacity when appropriate, and providing a single, unconditional cleanup routine at exit.

### STEP_6
# STEP 6: TEST CASES

## Description of Tests

**Test 1 - Add and List Two Valid Cards**  
Add two normal cards via the menu, list, then delete both indices.

**Test 2 - Immediate Exit (Empty Catalogue)**  
Choose "4" immediately; program frees nothing but the empty array, no output expected.

**Test 3 - Delete from Empty Catalogue (Edge)**  
Attempt to list, which prints "Catalogue empty.", then try to delete index 1 (should be rejected).

**Test 4 - Invalid Index (Error)**  
Add one card, then attempt to delete indices 0 and 99, both should print "Index out of range."

**Test 5 - Delete Middle of Three, Then List**  
Insert 3 cards, delete the second (index 2), list should show only first and third.

Machine-readable JSON follows:

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\nThe C Programming Language\nKernighan & Ritchie\n1978\n1\nClean Code\nRobert C. Martin\n2008\n2\n3\n2\n3\n1\n4",
      "expected_keyword": "Clean Code"
    },
    {
      "input": "4",
      "expected_keyword": ""
    },
    {
      "input": "2\n3\n1\n4",
      "expected_keyword": "Catalogue empty."
    },
    {
      "input": "1\nEffective C\nScott Meyers\n1991\n3\n0\n3\n99\n3\n1\n4",
      "expected_keyword": "Index out of range."
    },
    {
      "input": "1\nA\nA\n2000\n1\nB\nB\n2001\n1\nC\nC\n2002\n2\n3\n2\n2\n4",
      "expected_keyword": "B"
    }
  ]
}
```

---

## Iteration 32 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

**Background Story**  
You are the night-shift keeper at the university library.  
Every time a student returns a textbook you must shelve it, but the shelf only has room for one book of each course-number.  
If a second copy of the same course-number arrives you must recycle (free) the older copy and store the newer one.  
At closing time you need to print the current shelf contents and release all dynamically allocated memory.

**Program Requirements**  
1. Read from standard input an unknown number of lines (until EOF).  
   Each line contains:
   ```
   course_number  book_title
   ```
   Both fields are single words with no spaces (course_number is an int, book_title ≤ 30 chars).

2. Maintain a collection of currently shelved books.  
   - If the course_number is new, allocate memory for the book and add it.  
   - If the course_number already exists, replace the older book with the new one (free the old memory, allocate the new).

3. After the last line is read, print the shelf contents in ascending order of course_number, one per line:
   ```
   CS101  IntroToCS
   CS202  DataStructures
   ```

4. Immediately after printing, free every remaining dynamically allocated block and exit.

**Simple Example**  
Input
```
CS101  IntroToCS
CS202  DataStructures
CS101  BetterIntro
CS303  OS
```

Output
```
CS101  BetterIntro
CS202  DataStructures
CS303  OS
```

### CONSTRAINTS  
- Must store each book in a dynamically allocated struct.  
- Must implement exactly one user-defined function besides main():  
  `void displayShelf(const struct Book **shelf, int n);`  
  which prints the shelf as specified.  
- No global variables except for the constant `MAX_TITLE_LEN 30`.

### STEP_2
Below is a complete, self-contained C11 solution that obeys every constraint in the problem statement.  
Read the inline comments carefully: they explain not only what the code does, but why it is done that way (memory life-cycle, reallocation policy, sorting choice, etc.).

```c
/*  Night-shift librarian – “one book per course” shelf
 *  Compile:  gcc -std=c11 -Wall -Wextra -pedantic night_shelf.c -o night_shelf
 *  Run:      ./night_shelf < books.txt
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE_LEN 30          /* only global “variable” allowed by spec */

/* ---------- data structures ---------- */
typedef struct Book {
    char  course[16];             /* course_number as string (e.g. "CS101") */
    char *title;                /* dynamically-allocated title (max 30+1) */
} Book;

/* ---------- function prototype required by spec ---------- */
void displayShelf(const struct Book **shelf, int n);

/* ---------- helper: compare two Books for ascending course order ---------- */
static int cmpBookPtr(const void *lhs, const void *rhs)
{
    const Book *a = *(const Book **)lhs;
    const Book *b = *(const Book **)rhs;
    return strcmp(a->course, b->course);          /* lexicographic on course */
}

/* ---------- main ---------- */
int main(void)
{
    Book **shelf = NULL;  /* dynamic array of *pointers* to Book structs */
    int    count = 0;    /* how many distinct books are on the shelf now */
    int    capacity = 0; /* physical size of `shelf[]` array */

    /* read until EOF */
    while (1) {
        char course[16];
        char rawTitle[MAX_TITLE_LEN + 1];

        int ret = scanf("%15s %30s", course, rawTitle);
        if (ret == EOF) break;
        if (ret != 2) {                /* malformed line – skip silently */
            fprintf(stderr, "Warning: malformed line ignored.\n");
            continue;
        }

        /* look for existing course */
        int idx = -1;
        for (int i = 0; i < count; ++i)
            if (strcmp(shelf[i]->course, course) == 0) { idx = i; break; }

        if (idx == -1) {               /* new course → brand-new entry */
            /* grow pointer array if necessary */
            if (count == capacity) {
                int newCap = capacity ? capacity * 2 : 8;
                Book **tmp = realloc(shelf, newCap * sizeof *tmp);
                if (!tmp) { perror("realloc"); exit(EXIT_FAILURE); }
                shelf = tmp;
                capacity = newCap;
            }
            /* allocate new Book struct and its title */
            Book *bp = malloc(sizeof *bp);
            if (!bp) { perror("malloc Book"); exit(EXIT_FAILURE); }
            bp->title = malloc(strlen(rawTitle) + 1);
            if (!bp->title) { perror("malloc title"); exit(EXIT_FAILURE); }

            strcpy(bp->course, course);
            strcpy(bp->title, rawTitle);
            shelf[count++] = bp;
        }
        else {                           /* existing course: replace title */
            Book *bp = shelf[idx];
            char  *newTitle = malloc(strlen(rawTitle) + 1);
            if (!newTitle) { perror("malloc replacement"); exit(EXIT_FAILURE); }
            strcpy(newTitle, rawTitle);
            free(bp->title);             /* free old title, keep struct */
            bp->title = newTitle;
        }
    }

    /* spec: print shelf contents in ascending course order */
    qsort(shelf, count, sizeof *shelf, cmpBookPtr);
    displayShelf((const struct Book **)shelf, count);

    /* free everything and exit */
    for (int i = 0; i < count; ++i) {
        free(shelf[i]->title);
        free(shelf[i]);
    }
    free(shelf);
    return 0;
}

/* ---------- displayShelf – exactly the signature requested ---------- */
void displayShelf(const struct Book **shelf, int n)
{
    for (int i = 0; i < n; ++i)
        printf("%s  %s\n", shelf[i]->course, shelf[i]->title);
}
```

Key points addressed:

1. Only one user function besides `main` – `displayShelf`.  
2. Every `malloc`/`realloc` is tested; allocation failure terminates cleanly.  
3. All memory is freed exactly once (titles, `Book` structs, then the pointer array itself).  
4. Global data is limited to the single constant `MAX_TITLE_LEN`.  
5. Input stops at EOF; output is sorted and formatted precisely as specified.

### STEP_3
# STEP 3: EXPLANATION  

## 0. The Problem, Restated in One Sentence  
We have to remember, for every *course-number*, the *last* book title we saw, and before the program ends we must print them in order and give back every byte we borrowed from the system.

## 1. Why Dynamic Memory?  
- We do **not** know how many different courses will arrive.  
- Static arrays force us to pick a size at compile-time (`#define MAX 1000`) which is either wasteful or too small.  
- `malloc`/`realloc` let the array **grow on demand** and only occupy exactly what we need.

Think of `malloc` as “reserve a contiguous block of bytes from the heap”.  
Think of `free` as “I am done with that block, the OS may reclaim it”.

If you forget the `free`, the block is still “checked out” when your program ends – on modern OSes the kernel will *eventually* reclaim it, but inside long-running programs (servers, games, …) this leak is what crashes machines at 3 a.m.

## 2. The Three Layers We Allocate  
a) **The shelf** – an array of *pointers* (`Book **shelf`).  
   - Initially we set it to `NULL` (0 elements).  
   - When the logical size (`count`) hits the physical capacity (`capacity`) we double the pointer array with `realloc`.  

b) **Each Book struct** – one small block that stores the course string (fixed size) + a *pointer* to the real title.  
   Separating these two allocations saves us from the “maximum title length + maximum course length” worst case.  

c) **The title itself** – a third block whose length equals the exact characters we just read (`strlen(rawTitle)+1`) plus the terminating NUL.

Three allocations per *new* course; two allocations when we **replace** a title (old title freed, new title malloc’ed).

## 3. Ownership Rules We Obey  
- **Who owns what?**  
  *shelf* owns its `Book *` entries.  
  Each `Book` owns its `char *title`.  
  No one owns the course string – it lives **inside** the struct (array), so it is freed automatically when the struct is freed.  

- **Who frees what, when?**  
  When we replace a book title we **free only the title**, keep the struct.  
  When we are completely done we free the titles, then the structs, then the shelf array itself.  
  This matches a last-in-first-out discipline: we clean in the reverse order of allocation.

## 4. Growing the Shelf – The `realloc` Pattern  
`realloc(oldPtr, newBytes)` either:  
- extends the block in place, or  
- allocates a new bigger block, copies the old content, and frees the old block.  

That is why we always assign the result to a **temporary** variable first:  
```c
Book **tmp = realloc(shelf, newCap * sizeof *tmp);
if (!tmp) { …handle error… }
shelf = tmp;
```  
If `realloc` fails it returns `NULL`; if we had written  
```c
shelf = realloc(shelf, …);
```  
we would have lost our only reference to the previous block – a memory leak plus a dangling pointer.

## 5. Searching and Replacing – `idx`  
We walk linearly through the current shelf to see whether the course already exists.  
- If **not found** (`idx == -1`) we append after growing the array.  
- If **found** we simply swap the title pointer and free the old one – the struct shell is reused.

Linear search is acceptable here because university libraries do not catalogue millions of courses. If they did, we would switch to a hash table.

## 6. Sorting Without Moving the Books  
We only need to *print* in ascending course order; we do **not** have to keep the shelf sorted while inserting (that would make insertion O(n²) for n inserts).  
Therefore we:  
- insert at the end in O(1),  
- call `qsort` **once** at the end.  

`qsort` needs a comparison function that receives **pointers to the elements** of the array.  
Our array stores `Book *`; therefore the comparison arguments are `Book **`.  
Hence the cast inside `cmpBookPtr`.

## 7. `displayShelf` – the Only Extra Function Required  
The specification fixes the signature:  
```c
void displayShelf(const struct Book **shelf, int n);
```  
We make the pointers `const` to promise the function will not modify the books – good documentation and enables compiler optimisations.

## 8. Memory-Leak checklist – What Would Valgrind Say?  
✓ every `malloc`/`realloc` paired with a `free` somewhere.  
✓ no `return`, `break`, `exit` that bypasses the cleanup loops at the end.  
✓ `free(shelf)` **after** freeing every individual book.

Running:  
```bash
valgrind --leak-check=full ./night_shelf < input.txt
```  
should output:  
```
definitely lost: 0 bytes
indirectly lost: 0 bytes
```

## 9. Take-Home Mnemonics  
- **Triple-free rule**: free exactly what you malloc, no more, no less.  
- **Realloc-safety**: always use a temp variable.  
- **Ownership clarity**: draw boxes-and-arrows on paper before you write the code.  
- **Fail fast**: check every allocation result immediately; `perror` + `exit` is fine for small tools like this one.

Once these habits are automatic, dynamic memory stops being scary and becomes just another tool in your kit.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the shelf as a living list that *adapts*: every time a duplicate course label appears, the older item is *discarded* and the newcomer is kept.  
Ask yourself: “What is the smallest amount of housekeeping I need so that, at any moment, I can both (a) tell whether I have seen this course before and (b) replace the outdated information without leaving garbage behind?”

**Hint 2**  
You will need a resizable collection (array, list, anything that can stretch) whose members are *handles* to your book records, not the records themselves.  
Whenever the current count nears the space you already reserved, double the space before inserting—this keeps the average cost of growing cheap.

**Hint 3**  
Start by reading one line at a time.  
For each line, scan your existing collection for a matching course identifier.  
- If you find a match, free the *interior* information you are about to overwrite, swap in the new data, and do **not** increase the total count.  
- If you do not find a match, allocate a fresh record, append a pointer to it in your resizable collection, and increase the count.  
After input ends, sort the collection by course label and walk through it once to print.

### STEP_5
# STEP 5: SUMMARY  
- Dynamic memory life-cycle: malloc / realloc / free in correct pairs  
- Resizable arrays: growing storage on demand without fixed limits  
- Ownership discipline: who allocates, who frees, avoiding leaks and dangling pointers  
- Pointer indirection: arrays of pointers to structures vs. arrays of structures  
- Realloc safety: why to assign the result to a temporary variable first  
- Linear searching vs. late sorting: inserting quickly, ordering only when required  
- const correctness in function interfaces (displayShelf)  
- Resource cleanup before program termination; introduction to leak-checking habits

### STEP_6
# STEP 6: TEST CASES  

1. **Happy-path / common case**  
   Four distinct courses arrive in no particular order; program should keep all and print them sorted.

2. **Overwrite case**  
   Two deliveries for the same course; the later title must evict the earlier one without leaks.

3. **Empty input**  
   EOF arrives immediately; program should print nothing and terminate gracefully.

4. **Single book**  
   Exactly one line; the shelf contains that lone item after sorting (trivial, but tests boundary).

5. **Malformed line (invalid input)**  
   A line is missing either the course or the title; the program must skip it and continue with the rest.

```json
{
  "exit_command": "EOF",
  "test_suite": [
    {
      "input": "CS202 DataStructures\nCS101 IntroToCS\nCS303 OS\nCS404 Algorithms\n",
      "expected_keyword": "CS101 IntroToCS\nCS202 DataStructures\nCS303 OS\nCS404 Algorithms"
    },
    {
      "input": "CS101 FirstTitle\nCS101 ReplacementTitle\n",
      "expected_keyword": "CS101 ReplacementTitle"
    },
    {
      "input": "",
      "expected_keyword": ""
    },
    {
      "input": "CS999 SoloBook\n",
      "expected_keyword": "CS999 SoloBook"
    },
    {
      "input": "CS100\nCS200 BadInputLine\nCS100 ProperTitle\n",
      "expected_keyword": "CS100 ProperTitle"
    }
  ]
}
```

---

## Iteration 33 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

**Context – The Library-Box Project**  
The university library is digitising its “book boxes.” Each box can hold a variable number of books that arrive over the week. You have been asked to write a small C program that keeps track of the books currently in one such box. Because the number of books changes daily, all storage must be allocated dynamically on the heap.

**Task**  
Write a program that starts with an empty box and supports the following operations:

1. Add a new book (you will be given the title and year).  
2. Remove the last book that was added (LIFO order).  
3. List every book currently in the box (print index, title, year).  
4. Exit the program.

The program must keep its data in dynamic memory and free that memory before termination.

**Simple Example Run**  
User input is shown after the prompt `>`.  

```
=== Library-Box Menu ===
1 Add book
2 Remove last book
3 List books
4 Exit
> 1
Title: The Pragmatic Programmer
Year: 1999
> 1
Title: C Programming Language
Year: 1988
> 3
0) The Pragmatic Programmer (1999)
1) C Programming Language (1988)
> 2
Removed "C Programming Language"
> 4
Good-bye!
```

### CONSTRAINTS  
- A single `struct` called `Book` must represent the primary data entity.  
- All books must be stored in a dynamically-allocated array that grows/shrinks as needed (realloc).  
- Logic for displaying the details of ONE specific book must be in a function called `displayBook`.  
- The only functions allowed besides `main()` are:  
  - `displayBook(const struct Book *b)`  
  - Any helper you need for resizing the array (keep helpers minimal).  
- Menu option 4 must exit the program.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library-Box: dynamic array of Book structs
 * Operations: add, remove-last (LIFO), list, quit
 * All storage is on the heap; memory is freed on exit
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TITLE_MAX 128 /* safety cap on title length */

/* ---------- data structure ---------- */
struct Book {
    char title[TITLE_MAX];
    int year;
};

/* ---------- forward declarations ---------- */
static void displayBook(const struct Book *b); /* required entry-point */

/* ---------- main program ---------- */
int main(void)
{
    struct Book *box     = NULL; /* dynamic array */
    size_t capacity      = 0;    /* logical capacity */
    size_t count         = 0;    /* how many books in box */

    for (;;) {
        /* --- print menu --- */
        puts("=== Library-Box Menu ===");
        puts("1 Add book");
        puts("2 Remove last book");
        puts("3 List books");
        puts("4 Exit");

        /* --- read choice --- */
        int choice;
        printf("> ");
        if (scanf("%d", &choice) != 1) {
            fprintf(stderr, "Input error. Aborting.\n");
            break;
        }
        getchar(); /* discard newline left by scanf */

        if (choice == 4) break;

        /* --- handle user commands --- */
        if (choice == 1) { /* ADD */
            /* grow underlying array when needed */
            if (count == capacity) {
                /* classic doubling strategy, start with 2 */
                size_t newCap = (capacity == 0) ? 2 : capacity * 2;
                struct Book *tmp = realloc(box, newCap * sizeof *tmp);
                if (!tmp) {
                    perror("realloc");
                    free(box);
                    exit(EXIT_FAILURE);
                }
                box      = tmp;
                capacity = newCap;
            }

            /* read book details from user */
            struct Book *slot = &box[count++];
            printf("Title: ");
            if (!fgets(slot->title, sizeof slot->title, stdin)) {
                /* treat EOF as empty title */
                slot->title[0] = '\0';
            } else {
                /* strip trailing newline if present */
                size_t last = strlen(slot->title) - 1;
                if (last < sizeof slot->title && slot->title[last] == '\n')
                    slot->title[last] = '\0';
            }

            printf("Year: ");
            if (scanf("%d", &slot->year) != 1)
                slot->year = 0;
            getchar(); /* eat newline */
        }
        else if (choice == 2) { /* REMOVE LIFO */
            if (count == 0) {
                puts("Box is empty.");
            } else {
                --count;
                printf("Removed \"%s\"\n", box[count].title);
            }
        }
        else if (choice == 3) { /* LIST */
            if (count == 0) {
                puts("Box is empty.");
            } else {
                for (size_t i = 0; i < count; ++i) {
                    printf("%zu) ", i);
                    displayBook(&box[i]);
                }
            }
        }
        else {
            puts("Invalid choice.");
        }
    }

    /* --- clean up and exit --- */
    free(box);
    puts("Good-bye!");
    return 0;
}

/* ---------- required helper -------------------------------------------------
 * displayBook: print a single book pointer passed by caller
 * -------------------------------------------------------------------------- */
static void displayBook(const struct Book *b)
{
    if (!b) return;
    printf("%s (%d)\n", b->title, b->year);
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic allocation is just “asking the operating system for memory while the program is running.”  
In C you express that request with functions that live in `<stdlib.h>`:

- `malloc(size)` – “give me `size` bytes.”  
- `realloc(ptr,newSize)` – “resize the block I already own.”  
- `free(ptr)` – “I’m done; take the memory back.”  

If you forget `free`, the memory disappears when the process ends, but a long-running program (or one you later turn into a library) leaks.  
If you read or write past the block, you corrupt the heap and the symptom can appear much later.

Below we walk through those ideas in the book-box program.

------------------------------------------------------------
1. Why a pointer `struct Book *box`?
   - We do not know how many books the user will add.  
   - A fixed array (`struct Book box[1000]`) must decide the limit at compile time.  
   - A pointer lets us start with “zero slots,” then grow or shrink on demand.

------------------------------------------------------------
2. Where is the data actually stored?
   - The pointer variable itself (`box`) lives on the stack, but it only stores an address.  
   - The *memory block* that contains the `struct Book` objects lives on the heap, which is outside the current stack frame.  
   - Diagram (conceptual):

        +-------+         +------------------+
        |  box ------->     | Book[0]          |  <-- heap
        +-------+         | Book[1]          |
     stack frame         | ...              |
        ...               +------------------+

   - Because the block is on the heap, it survives after any function returns; we free it only when we intentionally exit.

------------------------------------------------------------
3. “Capacity” vs “Count”
   - `capacity` = how big the heap block *currently is*.  
   - `count`    = how many valid books *occupy* that block.  
   - Whenever `count == capacity`, the array is logically “full,” so we must enlarge it before inserting the next element.

------------------------------------------------------------
4. Growing the array: exponential strategy
   Doubling each time seems wasteful, but reallocations are expensive (they copy every element to a new place). Doubling keeps the *amortized* cost O(1).  
   - Old size = 0  → new size = 2  
   - Old size = 2  → new size = 4  
   - Old size = 4  → new size = 8  
   - …  
   If we grew by one (`capacity++`) we would reallocate every single add, giving O(n²) behavior.

   Implementation note: we use `realloc` even on the first allocation (`capacity == 0`).  
   `realloc(NULL, size)` is identical to `malloc(size)`, so the same call serves both cases.

------------------------------------------------------------
5. Checking allocation failure
   `malloc`/`realloc` can fail (return NULL). When it does, we immediately call `perror` (prints a useful message) and then `exit(EXIT_FAILURE)`. In a real-world utility you might recover, but for a teaching example aborting is acceptable.

   Important detail: always store the result of `realloc` in a *temporary* pointer first.  
   ```
   struct Book *tmp = realloc(box, newCap * sizeof *tmp);
   if (!tmp) { ...handle... }
   box = tmp;
   ```
   If you instead write `box = realloc(box, ...);` and `realloc` fails, the old pointer is overwritten with NULL and the previous block is irretrievable → definite leak.

------------------------------------------------------------
6. Shrinking the array (remove-last)
   The specification only requires removing the last-added book (LIFO). We simply decrement `count`.  
   We do *not* shrink the heap block; reallocations are only for expansion (a smaller program). In a production system you could compact the storage when `count <= capacity / 4`, but the task never forces us to shrink.

------------------------------------------------------------
7. Cleaning up – always one `free`
   The block that was allocated by `realloc` or `malloc` must eventually be freed, and there is only *one* such block no matter how many times `realloc` enlarged it.  
   The program exits through the same place (after menu choice 4), so we have a single `free(box)`.  
   After that call, the *address* stored in `box` is no longer valid; any later dereference is undefined behavior.

------------------------------------------------------------
8. Why `displayBook` exists
   The exercise explicitly mandates all book-detail output flow through `displayBook`.  
   - It receives a *pointer* to constant data (`const struct Book *b`), so it cannot accidentally modify the object.  
   - Inside `displayBook` the pointer is *dereferenced* in `printf("%s (%d)", b->title, b->year);`, accessing the heap copies.

   This function enables a consistent “look” for every listing operation, and supports future work (e.g., print to file, change formatting) localized in one place.

------------------------------------------------------------
9. Common pitfalls worth repeating
   - Using the pointer **after** `free` → undefined behavior (“use-after-free”).  
   - Calling `free` **twice** on the same address (“double free”) → undefined behavior.  
   - Forgetting to reset `count` when `capacity` changes.  
   - Mixing `malloc`ed memory with stack addresses (never `free` those).  
   - Reading more bytes from the user than the fixed buffer holds (`fgets` solves that here).

------------------------------------------------------------
With these concepts you can now see why the program is written the way it is: dynamic requests, exponential growth, one eventual free, and a tidy menu loop.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the box as a collection whose size you don’t know in advance.  
Decide how you will keep track of both “how many items are stored now” and “how much room is currently reserved,” then handle the situation where the second number has to grow.

**Hint 2**  
C gives you a function that can both obtain an initial block of raw memory and later stretch (or shrink) that same block without losing what you already stored inside. Read the manual page for the one whose name starts with “re” and remember to inspect what it returns every single time.

**Hint 3**  
Start the program with an empty collection: declare a pointer set to nothing and two counters set to zero. When the user chooses “add,” check if the used space equals the allocated space; if so, double the allocation, copy the new item to the end, and increment only the “used” counter.

### STEP_5
# STEP 5: SUMMARY
- Dynamic array management with malloc/realloc/free: allocating, growing, and eventually returning heap memory  
- Distinguishing logical size ("count") from physical capacity and using exponential growth to keep insertion efficient  
- Safe handling of allocation failures—checking return values and avoiding memory leaks after failed resizes  
- Encapsulation of format logic by routing all single-book output through a dedicated display function  
- LIFO removal semantics and why shrinking the used count is sufficient when full compaction is not required  
- Single-point cleanup: freeing one contiguous block at program exit to eliminate leaks  
- Pointer hygiene: temporary pointer for realloc, never freeing the same block twice, not accessing post-free memory

### STEP_6
# STEP 6: TEST CASES

1. Happy-path growth  
   Add three books, list them, then remove two.  
   Expected output: listing shows three entries, removals announce the correct titles.

2. Remove on empty box (edge)  
   Choose remove before any book exists.  
   Expected output: "Box is empty."

3. Menu safety (invalid choice)  
   Enter option 9, then list.  
   Expected output: "Invalid choice." followed by empty list.

4. Title with spaces  
   Add a book whose title contains spaces and commas, then list it.  
   Expected output: title is printed verbatim without truncation.

5. Empty title year combo  
   Add a book with an empty title (press Enter right away) and year 0.  
   Expected output: list should still show entry "(0)" with an empty title.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\nClean Code\n2008\n1\nCode Complete\n2004\n1\nThe Mythical Man-Month\n1975\n3\n2\n2\n3\n4",
      "expected_keyword": "Clean Code (2008)"
    },
    {
      "input": "2\n4",
      "expected_keyword": "Box is empty."
    },
    {
      "input": "9\n3\n4",
      "expected_keyword": "Invalid choice."
    },
    {
      "input": "1\nStructure and Interpretation of Computer Programs\n1996\n3\n4",
      "expected_keyword": "Structure and Interpretation of Computer Programs (1996)"
    },
    {
      "input": "1\n\n0\n3\n4",
      "expected_keyword": " (0)"
    }
  ]
}
```

---

## Iteration 34 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The campus library has just opened a new “Tech-Loan” window where students can borrow electronic gadgets (calculators, phone chargers, mini-speakers, etc.) for a few hours.  
To keep track of what is currently on loan, you are to write a tiny, memory-aware inventory program that records each gadget’s ID, name, and the borrower’s student card number.  
Because the collection changes every semester, the program must grow or shrink its records dynamically—no compile-time arrays allowed.

## Functional Requirements
1. The program starts with an empty collection.  
2. It repeatedly presents a menu:
   1) Add a new gadget (ID, name, borrower card)  
   2) Delete a gadget by ID  
   3) List every gadget currently stored  
   4) Exit  
3. Adding must allocate exactly the memory needed for one gadget; listing must print all gadgets in the order they were added; deleting must free the memory of the chosen gadget and keep the list contiguous.  
4. After every operation the menu reappears until the user chooses the EXIT option.  
5. All heap memory must be released before the program ends.

## Simple Example Run
( user input after » )
```
1) Add
2) Delete
3) List
4) Exit
Choice: » 1
Gadget ID: » 101
Name: » Calculator
Card: » 12345
1) Add
2) Delete
3) List
4) Exit
Choice: » 1
Gadget ID: » 202
Name: » Charger
Card: » 67890
1) Add
2) Delete
3) List
4) Exit
Choice: » 3
101 Calculator 12345
202 Charger 67890
1) Add
2) Delete
3) List
4) Exit
Choice: » 2
Delete ID: » 101
Deleted.
1) Add
2) Delete
3) List
4) Exit
Choice: » 3
202 Charger 67890
1) Add
2) Delete
3) List
4) Exit
Choice: » 4
Good-bye!
```

### CONSTRAINTS
- A single structure named `Gadget` must represent each entity.  
- All list logic (add, delete, list) must be implemented in **one** user-defined function besides `main()`; use a switch inside that function or another disciplined approach, but keep the count of custom functions to one.  
- The EXIT menu option is number 4.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Tech-Loan Inventory – single-function, dynamic-array solution.
 *
 * The user may perform four operations:
 * 1) Add a gadget
 * 2) Delete a gadget by ID
 * 3) List all gadgets (keeps original insertion order)
 * 4) Exit
 *
 * All list manipulation is performed inside manageGadgets(), the only
 * user-defined function.  The main loop simply feeds the menu choice into
 * that function.  A dynamically resized array stores the structures.
 * Memory is always released on exit.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data model ---------- */
typedef struct {
    int  id;          /* Gadget identifier            */
    char name[64];    /* Short description            */
    int  card;        /* Borrower's student-card #    */
} Gadget;

/* ---------- Single mandated helper ---------- */
/* Performs the requested operation and updates *size* and *capacity*. */
static void manageGadgets(Gadget **array,
                          int *size,
                          int *capacity,
                          int choice);

/* ---------- Driver ---------- */
int main(void)
{
    Gadget *inventory = NULL;   /* Dynamic array of structures */
    int capacity = 0;           /* Allocated slots             */
    int size     = 0;           /* Occupied slots              */
    int option;

    /* Main menu loop */
    for (;;) {
        puts("1) Add\n2) Delete\n3) List\n4) Exit");
        printf("Choice: ");
        if (scanf("%d", &option) != 1) {          /* flush bad input */
            while (getchar() != '\n') { /*discard*/ }
            option = 0;                             /* force invalid     */
        }

        if (option == 4) break;                   /* EXIT            */
        manageGadgets(&inventory, &size, &capacity, option);
    }

    /* ----- clean-up before termination ----- */
    free(inventory);
    puts("Good-bye!");
    return 0;
}

/* ---------- The one mandated user-defined function ---------- */
static void manageGadgets(Gadget **array,
                          int *size,
                          int *capacity,
                          int choice)
{
    Gadget *a = *array;
    int n   = *size;
    int cap = *capacity;

    switch (choice) {
    /* ---------- Add a new gadget ---------- */
    case 1: {
        /* Grow array if full – simple doubling strategy */
        if (n == cap) {
            int newCap = cap ? cap << 1 : 4;          /* first: four elems */
            Gadget *tmp = realloc(a, newCap * sizeof *tmp);
            if (!tmp) {
                perror("realloc for add");
                exit(EXIT_FAILURE);
            }
            a   = tmp;
            cap = newCap;
        }

        Gadget *g = &a[n];            /* next free slot */
        printf("Gadget ID: ");
        scanf("%d", &g->id);
        printf("Name: ");
        scanf("%63s", g->name);       /* safer bound   */
        printf("Card: ");
        scanf("%d", &g->card);
        ++n;

        *array     = a;
        *size      = n;
        *capacity  = cap;
        break;
    }

    /* ---------- Delete by ID ---------- */
    case 2: {
        int id;
        printf("Delete ID: ");
        scanf("%d", &id);

        int i;
        for (i = 0; i < n && a[i].id != id; ++i)      /* search */
            ;

        if (i == n) {
            puts("Not found.");
            break;
        }

        /* Remove element i: shift all successors left by one */
        for (int j = i; j < n - 1; ++j)
            a[j] = a[j + 1];
        --n;

        /* Optional shrink to save memory – simplest: half if less than 1/4 used */
        if (cap > 4 && n < cap / 4) {
            int newCap = cap >> 1;
            Gadget *tmp = realloc(a, newCap * sizeof *tmp);
            if (tmp) {        /* ignore failure; we still work with the larger block */
                a   = tmp;
                cap = newCap;
            }
        }

        *array    = a;
        *size     = n;
        *capacity = cap;
        puts("Deleted.");
        break;
    }

    /* ---------- List contents ---------- */
    case 3:
        if (n == 0) {
            puts("(no items)");
        } else {
            for (int i = 0; i < n; ++i)
                printf("%d %s %d\n", a[i].id, a[i].name, a[i].card);
        }
        break;

    /* ---------- Invalid menu option ---------- */
    default:
        puts("Invalid choice.");
        break;
    }
}
```

### STEP_3
# STEP 3: EXPLANATION

Think of a “dynamic array” as a set of drawers that can be enlarged or shrunk at run time.  
The goal is to keep an unknown number of gadgets while never wasting more RAM than strictly necessary.  
Below is the conceptual road-map of the program, grouped by the ideas a student usually finds confusing.

---

### 1. From compile-time storage to dynamic storage
An ordinary array such as  
Gadget inventory[100];  
is carved in stone at compile time.  
If we need 101 gadgets we are in trouble; if we need only two, we squander 98 × sizeof(Gadget) bytes.

Dynamic memory lets us ask the **heap** for exactly as many bytes as we currently need and later:
- grow the block → realloc  
- free the block → free

The price we pay is explicit bookkeeping (pointers, sizes, capacities).

Observe the two variables we maintain in main():
- `int size` → how many gadgets are in use **right now**  
- `int capacity` → how many slots we have actually paid for with malloc/realloc

Whenever `size == capacity` we need a bigger block before the next insertion.

---

### 2. Why a triple pointer Gadget ***array?
manageGadgets() is **the** user-defined function, so it must be able to:
1. Change the *contents* of the array (add, delete)  
2. Replace the array itself when realloc gives us a brand-new block

If it received only `Gadget *p`, any change to the pointer value would be local to the function.  
By passing the *address* of the pointer (`Gadget **`) we allow the helper to reseat the caller’s pointer after realloc.

---

### 3. Growing – the “double when full” rule
Suppose capacity == 4 and we are full:

```
old:  [0][1][2][3]
size:  4
```

We call realloc(..., 8 * sizeof(Gadget)).

- realloc tries to *extend* the current block in place (cheap)  
- if no room, it allocates a brand-new block, copies the 4 gadgets, frees the old block (still transparent to us)

We double, rather than growing by 1, because:
- Amortised cost becomes O(1) per insertion  
- avoids a realloc on every add

Shrinking on deletion is optional; the code halves the block when utilisation drops below 25 %.

---

### 4. Deleting while staying contiguous
We must maintain the order in which gadgets were inserted, so we cannot leave “holes”.  
Deleting gadget i therefore means:

```
// shift everything left by 1
for (j = i; j < n-1; ++j)
    a[j] = a[j+1];
--n;
```

No free() is needed for the struct itself because we did not malloc each gadget independently – they live inside one contiguous block managed by realloc.

---

### 5. malloc vs realloc
First call: inventory is NULL, capacity 0.  
realloc(NULL, bytes) is perfectly legal and behaves exactly like malloc – convenient, because we can use one code path for both the initial allocation and later enlargements.

---

### 6. Error handling
If malloc/realloc fails, we get NULL.  
In a production system we could recover gracefully; here we simply perror and exit.  
Either way we **never** ignore the return value.

---

### 7. Memory leak prevention (EXIT path)
main()’s only job after the menu loop is:

```
free(inventory);
```

Even if the list is empty (inventory == NULL) free(NULL) is defined to do nothing, so this line is safe and guarantees that every byte obtained from the heap is returned before the process ends.

---

### 8. Trade-offs of the single function requirement
Having only manageGadgets() perform all list work forced us to:
- use an array (`Gadget *`) instead of a linked list (would need node insertion/deletion helpers)  
- pass state (size, capacity, array) explicitly as parameters rather than hiding it in several module-private functions

For a first encounter with dynamic memory, that constraint keeps the program small yet still demonstrates:
- allocation  
- reallocation  
- ordered deletion  
- complete liberation of resources

### STEP_4
# STEP 4: HINTS  

Hint 1  
“Imagine your gadget list is a row of drawers in a filing cabinet.  
When you run out of drawers you don’t buy a whole new cabinet—you ask the carpenter to add more drawers on the end.  
What C idea lets you ‘ask the carpenter’ while the program is already running?”

Hint 2  
You’ll need a pointer that can grow and shrink the cabinet.  
Look up the family of functions whose names start with ‘m’ and ‘r’; they live in <stdlib.h>.  
Remember that whenever you resize you should keep track of two numbers: how many drawers are filled vs. how many drawers actually exist.

Hint 3  
Start by declaring an empty pointer and a pair of counters set to zero.  
Write the “add” branch first: before inserting, check if the counters are equal; if they are, double the drawer count (or start with a small fixed number) and use the ‘r’ function to enlarge the cabinet.  
After the resize (or if no resize is needed), place the new gadget at the index indicated by the “filled” counter and bump that counter by one.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory allocation with malloc / realloc and the importance of checking return values  
- Maintaining and resizing a contiguous dynamic array (capacity vs. size bookkeeping)  
- Ordered deletion in an array while keeping the list compact (shifting elements)  
- Complete memory clean-up: freeing every allocated block before program termination  
- Encapsulating data-manipulation logic in a single user-defined function that operates through pointer indirection (pass-by-address)  
- Practical use of structs to model real-world entities with mixed data types  
- Designing a simple menu-driven control flow with persistent state across iterations

### STEP_6
# STEP 6: TEST CASES

1. **Typical sequence (common case)**  
   Add two gadgets, list them, delete the first, list again; expect the second gadget to remain in order.

2. **Empty list behaviors (edge case)**  
   Start the program and immediately choose “List”; it should gracefully print the placeholder “(no items)”.

3. **Delete non-existent ID (invalid input)**  
   Attempt to delete an ID that was never added; the program must print “Not found.” and keep running.

4. **Fill, resize, then shrink (stress test)**  
   Add four gadgets (triggering an initial capacity of 4), add a fifth (triggering a resize), delete three, then list; verify only two items appear and no memory is leaked.

5. **Immediate exit (edge case)**  
   Choose Exit right at the first menu; the program should print “Good-bye!” and terminate with all memory freed.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\n101\nCalculator\n12345\n1\n202\nCharger\n67890\n3\n2\n101\n3\n4",
      "expected_keyword": "Charger 67890"
    },
    {
      "input": "3\n4",
      "expected_keyword": "(no items)"
    },
    {
      "input": "2\n999\n3\n4",
      "expected_keyword": "Not found."
    },
    {
      "input": "1\n10\nA\n10\n1\n20\nB\n20\n1\n30\nC\n30\n1\n40\nD\n40\n1\n50\nE\n50\n2\n10\n2\n20\n2\n30\n3\n4",
      "expected_keyword": "D 40\nE 50"
    },
    {
      "input": "4",
      "expected_keyword": "Good-bye!"
    }
  ]
}
```

---

## Iteration 35 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The campus library is digitising its old “book card” system.  
Each card contains a title, author, and a unique accession number.  
You have been hired to write a tiny replacement program that stores these cards in dynamic memory while the librarian is working.  
When the librarian is finished, the program must release every byte it allocated before terminating.

## Functional Requirements
1. On startup the program has NO books stored.
2. The program must support three commands entered by the user:
   - `add` – read a book’s accession number, title, and author (in that order) and store the information.
   - `list` – print every book currently stored, one per line, in the order they were added.  
     Format: `#<accession> "<title>" by <author>`
   - `exit` – free all memory and terminate the program (see menu constraint below).
3. All book data must be kept only in dynamic memory (i.e., use `malloc`/`realloc`); no global or fixed-size arrays.
4. After each `add`, the program must be able to store an unlimited number of books.

## Simple Example
Input
```
add
1001
Pride and Prejudice
Jane Austen
add
1002
1984
George Orwell
list
exit
```

Output
```
#1001 "Pride and Prejudice" by Jane Austen
#1002 "1984" by George Orwell
```

## Menu Constraint
The keyword `exit` is the only way to leave the program; typing it must free all previously allocated memory and then terminate.

### CONSTRAINTS
- You must define a single `struct` called `Book` that contains the accession number, title, and author.
- All printing of a single book must be done by a function called `displayBook` that takes a pointer to a `Book`.
- Only two functions are allowed besides `main`: `displayBook` and any function you need for releasing memory.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library-card replacement program.
 * Keeps an unbounded number of Book structures in dynamic memory only.
 *
 * Build (for example):  gcc -std=c11 -Wall -Wextra -pedantic -o cards cards.c
 *
 * The program supports three commands:
 *   add   - reads one book and appends it to the collection
 *   list  - prints every book in the order they were added
 *   exit  - frees all memory and terminates
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structure ---------- */

typedef struct Book {
    int   accession;
    char *title;   /* malloc'ed string */
    char *author;  /* malloc'ed string */
} Book;

/* ---------- Function prototypes ---------- */

/* Print one book in the required format. */
static void displayBook(const Book *b);

/* Free every field in a Book and the Book itself. */
static void freeBook(Book *b);

/* ---------- Main ---------- */

int main(void)
{
    Book *collection = NULL; /* dynamic array of Book */
    size_t size      = 0;  /* number of books currently stored */
    size_t capacity  = 0;  /* allocated slots */

    char cmd[16];
    while (scanf("%15s", cmd) == 1) {
        if (strcmp(cmd, "add") == 0) {
            /* 1. Read the accession number */
            int acc;
            if (scanf("%d", &acc) != 1) {
                fprintf(stderr, "Input error: expected accession number\n");
                exit(EXIT_FAILURE);
            }
            getchar(); /* consume '\n' left by scanf */

            /* 2. Read title */
            char buf[2 * 1024]; /* arbitrary large line buffer */
            if (!fgets(buf, sizeof buf, stdin)) {
                fprintf(stderr, "Input error while reading title\n");
                exit(EXIT_FAILURE);
            }
            buf[strcspn(buf, "\n")] = '\0'; /* strip trailing newline */

            char *title = malloc(strlen(buf) + 1);
            if (!title) { perror("malloc"); exit(EXIT_FAILURE); }
            strcpy(title, buf);

            /* 3. Read author */
            if (!fgets(buf, sizeof buf, stdin)) {
                fprintf(stderr, "Input error while reading author\n");
                exit(EXIT_FAILURE);
            }
            buf[strcspn(buf, "\n")] = '\0';

            char *author = malloc(strlen(buf) + 1);
            if (!author) { perror("malloc"); exit(EXIT_FAILURE); }
            strcpy(author, buf);

            /* 4. Append to the dynamic array */
            if (size == capacity) {
                /* grow by doubling */
                size_t newCap = capacity ? capacity * 2 : 4;
                Book *tmp = realloc(collection, newCap * sizeof *tmp);
                if (!tmp) { perror("realloc"); exit(EXIT_FAILURE); }
                collection = tmp;
                capacity   = newCap;
            }
            collection[size++] = (Book){ acc, title, author };
        }
        else if (strcmp(cmd, "list") == 0) {
            for (size_t i = 0; i < size; ++i)
                displayBook(&collection[i]);
        }
        else if (strcmp(cmd, "exit") == 0) {
            break;
        }
        else {
            fprintf(stderr, "Unknown command: %s\n", cmd);
            exit(EXIT_FAILURE);
        }
    }

    /* Clean-up before termination */
    for (size_t i = 0; i < size; ++i)
        freeBook(&collection[i]);
    free(collection);

    return 0;
}

/* ---------- Helper function definitions ---------- */

static void displayBook(const Book *b)
{
    printf("#%d \"%s\" by %s\n", b->accession, b->title, b->author);
}

static void freeBook(Book *b)
{
    free(b->title);
    free(b->author);
}
```

### STEP_3
# STEP 3: EXPLANATION

1. What “dynamic memory” really means  
   In C, variables declared inside a function live on the *stack*.  
   When the function ends, they disappear.  
   A book-title, however, can be arbitrarily long and we do **not** know how many titles the librarian will type.  
   Therefore we must ask the *heap* (the pool of anonymous bytes managed by `malloc`/`free`) for memory at run-time.  
   Anything obtained with `malloc`/`realloc` stays alive until we explicitly call `free`.  
   If we forget to `free`, the program leaks memory; if we access it after the `free`, the program has *undefined behaviour*.

2. Why we keep a *dynamic array*  
   A linked list would also work, but an array is simpler and faster for the two required operations:  
   – append at the end (after `add`)  
   – iterate from first to last (for `list`)  
   We start with zero slots (`capacity = 0`).  
   Each time `size == capacity` we `realloc` the array to twice its previous size.  
   Doubling keeps the amortised cost of appending O(1) and avoids thousands of tiny reallocations.

3. The Book struct and the strings inside it  
   ```
   typedef struct Book {
       int   accession;
       char *title;   // points to heap
       char *author;  // points to heap
   } Book;
   ```
   The struct itself is only a few bytes.  
   The actual text lives elsewhere, so we store *pointers* to separately `malloc`-ed blocks.  
   This two-level scheme means we must free three things per book:  
   – the title buffer  
   – the author buffer  
   – (optionally) the struct, if we had allocated it separately.  
   Here the struct lives in the big array, so we only free the two strings.

4. Reading arbitrarily long lines safely  
   We read into a **temporary** stack buffer (`buf`) first, then `malloc(strlen(buf)+1)` to obtain a block of *exactly* the right size.  
   This avoids wasting space and guarantees that the line fits, provided the user does not exceed our local buffer.  
   `strcspn(buf, "\n")` finds the newline and overwrites it with `'\0'`, producing a proper C-string.

5. Checking every allocation  
   `malloc`/`realloc` can return `NULL` if the operating system refuses to give more memory.  
   We always test the returned pointer; if it is `NULL`, we print an error and call `exit(EXIT_FAILURE)` immediately.  
   In a production program you might recover gracefully, but here we simply refuse to continue.

6. The two required helper functions  
   – `displayBook` receives a *pointer* to a Book.  
     Using pointers avoids copying the whole struct and keeps the prototype tiny.  
   – `freeBook` releases the two string buffers embedded in a Book.  
     We do **not** free the struct itself, because in our design it lives inside the array that `main` will free in one shot.

7. The only legal exit path  
   The menu constraint says the user must type `exit`.  
   When that happens, `main` leaves the while-loop and performs a single clean-up sweep:  
   ```
   for (each book)  freeBook(book);
   free(array);
   ```
   After that the program can return from `main`, automatically terminating.  
   Valgrind (or any memory checker) should then report “0 bytes in use … definitely lost: 0”.

8. Common pitfalls avoided here  
   – No global or fixed-size arrays.  
   – No memory is allocated until we really need it.  
   – Every block has a matching `free`.  
   – No use-after-free: once we free the collection we return immediately.  
   – `scanf` with fixed width and `fgets` prevent buffer overruns.

Understanding these ideas—stack vs. heap, ownership, doubling realloc, and the necessity of checking `malloc`—is the key to mastering dynamic memory in C.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of the collection of book cards as something that can grow without limit while the program runs.  
Instead of a fixed-size table, what kind of storage naturally expands as you add more items?

Hint 2  
Each book has three pieces of information, two of which are text of unknown length.  
You will need one place to keep the accession number and two separate requests for memory that will hold the characters of the title and author.

Hint 3  
Start by declaring a structure that groups the three fields together.  
Inside your main loop, when the user chooses "add", read the accession number first, then read a whole line for the title and another whole line for the author; after each line, allocate exactly enough space to store it before placing the new card into your chosen expandable container.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: malloc, realloc, free; heap vs. stack lifetime rules  
- Open-ended array growth: doubling strategy for O(1) amortized append  
- Struct composition: storing primitive and pointer members together  
- Safe line-oriented input: reading unknown-length text into dynamically sized buffers  
- Ownership discipline: every allocation paired with an explicit free  
- Memory-leak prevention: freeing all resources on the only legal exit path  
- Modular design: separating allocation, display, and cleanup into focused helpers  
- Error handling: checking allocation return values and aborting cleanly on failure

### STEP_6
# STEP 6: TEST CASES

1. Normal addition and listing  
   Add two books and list them; the output must appear in insertion order with the exact required punctuation.

2. Empty list  
   Start the program, immediately type list, then exit; nothing should be printed except the shell prompt after exit.

3. Long title/author  
   Supply an author line that is 1022 bytes long to verify that the read-and-allocate logic copes with very long user input.

4. Invalid keyword before exit  
   Type an unknown command; the program must abort cleanly with an error message and all memory freed.

5. No books at all  
   Immediately type exit; the program must terminate without leaks even when the collection has zero elements.

```json
{
  "exit_command": "exit",
  "test_suite": [
    {
      "input": "add\n1001\nPride and Prejudice\nJane Austen\nadd\n1002\n1984\nGeorge Orwell\nlist\nexit",
      "expected_keyword": "#1001 \"Pride and Prejudice\" by Jane Austen"
    },
    {
      "input": "list\nexit",
      "expected_keyword": ""
    },
    {
      "input": "add\n42\nA\nA very long author name repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeated repeate\nlist\nexit",
      "expected_keyword": "42"
    },
    {
      "input": "foo\nexit",
      "expected_keyword": "Unknown command"
    },
    {
      "input": "exit",
      "expected_keyword": ""
    }
  ]
}
```

---

## Iteration 36 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The campus library is digitizing its small collection of classic novels.  
Each book is stored as a variable-length string (its full text), and the librarian wants a tiny program that can:

1. Add a new book to the collection.  
2. Remove a book by its unique ID.  
3. List every book currently stored.  
4. Quit the program.

Because the collection grows and shrinks while the program runs, you must allocate and free memory dynamically.

## Functional Requirements
1. Represent each book with:
   - A unique integer ID (assigned sequentially, starting at 1).  
   - A dynamically-allocated C-string that holds the book’s entire text (may contain spaces).

2. Implement the following user commands (menu-driven):
   ```
   1. Add book
   2. Remove book
   3. List books
   4. Exit
   ```

3. Add book:  
   Prompt for the book’s text (up to 4095 readable characters, including spaces).  
   Store the text in freshly allocated memory and assign the next available ID.

4. Remove book:  
   Prompt for an ID.  
   Free the memory used by that book and mark the slot as empty.  
   If the ID does not exist, print `Not found.`

5. List books:  
   Print every existing book in the order of ascending IDs:
   ```
   ID: <id>
   Text: <text>
   ```
   If the collection is empty, print `Collection empty.`

6. Exit:  
   Free all remaining dynamically-allocated memory and terminate the program gracefully.

## Example Session (user input after `>`)
```
1. Add book
2. Remove book
3. List books
4. Exit
> 1
Enter book text:
> It was the best of times, it was the worst of times.

1. Add book
2. Remove book
3. List books
4. Exit
> 1
Enter book text:
> Call me Ishmael.

1. Add book
2. Remove book
3. List books
4. Exit
> 3
ID: 1
Text: It was the best of times, it was the worst of times.
ID: 2
Text: Call me Ishmael.

1. Add book
2. Remove book
3. List books
4. Exit
> 2
Enter ID to remove:
> 1
Removed.

1. Add book
2. Remove book
3. List books
4. Exit
> 3
ID: 2
Text: Call me Ishmael.

1. Add book
2. Remove book
3. List books
4. Exit
> 4
Good-bye.
```

### CONSTRAINTS
- You must use a `struct` to represent a book.  
- Logic for displaying the details of ONE specific book must be in a function called `displayBook`.  
- The user must be able to EXIT the program by choosing menu option 4.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 *  Classic Novel Collection Manager
 *  Author: <your name>
 *
 *  A small, menu-driven program that stores variable-length book texts
 *  in dynamically-allocated memory, releases them on demand, and
 *  frees all remaining memory on exit.
 *
 *  Compile: gcc -std=c11 -Wall -Wextra -pedantic books.c -o books
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_TEXT_LEN 4095   /* maximum readable characters per book */

/* ---------- Data Structure ---------- */

typedef struct {
    int  id;        /* unique identifier (>= 1) */
    char *text;     /* dynamically-allocated C-string */
} Book;

/* ---------- Global State ---------- */

static Book *collection = NULL;   /* dynamically-sized array of Books */
static size_t cap       = 0;      /* current physical capacity */
static size_t size      = 0;      /* logical count of stored books */
static int nextID         = 1;      /* next ID to be assigned */

/* ---------- Helper Prototypes ---------- */

/* grow the internal array when full; returns true on success */
static bool growCollection(void);

/* free every allocated Book.text and the array itself */
static void freeAll(void);

/* display a single book as required */
static void displayBook(const Book *b);

/* ---------- Menu Implementation ---------- */

int main(void)
{
    while (true) {
        /* ---- print menu ---- */
        printf("\n1. Add book\n");
        printf("2. Remove book\n");
        printf("3. List books\n");
        printf("4. Exit\n");

        int choice;
        printf("> ");
        if (scanf("%d", &choice) != 1) {        /* invalid integer */
            /* consume rest of the line and try again */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF)
                ;
            continue;
        }
        getchar(); /* discard newline after the digit */

        switch (choice) {
        case 1: {   /* --- Add book --- */
            /* ensure we have room */
            if (size == cap && !growCollection()) {
                fprintf(stderr, "Error: unable to allocate memory for new book.\n");
                break;
            }

            printf("Enter book text:\n> ");
            char buf[MAX_TEXT_LEN + 2]; /* +1 for '\n', +1 for '\0' */
            if (!fgets(buf, sizeof(buf), stdin)) {
                fprintf(stderr, "Error reading input.\n");
                break;
            }
            /* strip trailing newline if present */
            buf[strcspn(buf, "\n")] = '\0';

            /* duplicate the text */
            char *dup = malloc(strlen(buf) + 1);
            if (!dup) {
                fprintf(stderr, "Error: memory allocation failed.\n");
                break;
            }

            strcpy(dup, buf);

            /* install the new book */
            collection[size].id   = nextID++;
            collection[size].text = dup;
            ++size;

            break;
        }

        case 2: {   /* --- Remove book --- */
            int id;
            printf("Enter ID to remove:\n> ");
            if (scanf("%d", &id) != 1) {
                /* consume bad input */
                int ch;
                while ((ch = getchar()) != '\n' && ch != EOF)
                    ;
                fprintf(stderr, "Invalid ID.\n");
                break;
            }
            getchar(); /* discard newline */

            bool found = false;
            for (size_t i = 0; i < size; ++i) {
                if (collection[i].id == id) {
                    free(collection[i].text);
                    /* shift remaining elements left by one */
                    memmove(&collection[i], &collection[i+1],
                            (size - i - 1) * sizeof(Book));
                    --size;
                    found = true;
                    printf("Removed.\n");
                    break;
                }
            }
            if (!found)
                printf("Not found.\n");
            break;
        }

        case 3: {   /* --- List books --- */
            if (size == 0) {
                printf("Collection empty.\n");
            } else {
                for (size_t i = 0; i < size; ++i)
                    displayBook(&collection[i]);
            }
            break;
        }

        case 4:     /* --- Exit --- */
            freeAll();
            printf("Good-bye.\n");
            return 0;

        default:
            printf("Invalid choice. Please enter 1-4.\n");
        }
    }
}

/* ---------- Helper Definitions ---------- */

static bool growCollection(void)
{
    /* basic geometric growth strategy */
    size_t newCap = (cap == 0) ? 4 : cap * 2;
    Book *tmp = realloc(collection, newCap * sizeof(Book));
    if (!tmp) return false;

    collection = tmp;
    cap        = newCap;
    return true;
}

static void freeAll(void)
{
    for (size_t i = 0; i < size; ++i)
        free(collection[i].text);
    free(collection);
    collection = NULL;
    cap = size = 0;
}

static void displayBook(const Book *b)
{
    printf("ID: %d\n", b->id);
    printf("Text: %s\n", b->text);
}
```

### STEP_3
# STEP 3: EXPLANATION

## 0. Narrative Goal
We must keep an **unknown, changing number of books** while the program runs.  
Arrays in C have fixed size at creation, so we simulate a “resizable” array with:
- a block of memory obtained from `malloc`/`realloc`
- bookkeeping variables (`size`, `cap`)
and we free every allocation before the program ends.  
That, in a nutshell, is **dynamic memory management**.

--------------------------------------------------------------------
## 1. Why a `struct`?
Each book has two **conceptually different** pieces of data:
- An integer id
- A *string* of text whose length we do not know in advance  

A `struct` lets us group them into one logical unit:

```c
typedef struct {
    int  id;   /* fixed size  */
    char *text;/* variable size → dynamic */
} Book;
```

--------------------------------------------------------------------
## 2. The "Resizable Array" Pattern

Imagine a **stack of chairs**:
- `size` = how many chairs are **occupied**
- `cap`  = how many chairs **fit** in the current room

When all chairs are taken (`size == cap`) we must enlarge the room.  
In C we **double** the capacity (`cap = cap*2`) because:
- it gives amortised O(1) cost per insertion
- it is simple to code

Code walk-through:

```c
size_t newCap = (cap == 0) ? 4 : cap*2;
Book *tmp = realloc(collection, newCap * sizeof(Book));
if (!tmp) return false;          /* out of memory → graceful failure */
collection = tmp;                /* install bigger room */
cap = newCap;
```

`realloc` either:
- extends the current block in place, **or**
- allocates a brand-new block, copies the old contents, and frees the old one

--------------------------------------------------------------------
## 3. Allocating the *Text* Inside a Book

Adding a new book needs **two** allocations:
1. **Room for the Book objects** (handled globally by `growCollection`)
2. **Room for the actual characters** (handled per book)

```c
char *dup = malloc(strlen(buf)+1);
strcpy(dup, buf);
collection[size].text = dup;
```

Key points:
- `strdup` is not in standard C11, so we do `malloc+strcpy`
- we always reserve `strlen+1` bytes for the terminating NUL byte
- we **check the pointer returned by malloc**; if it is NULL we abort the insertion but keep the program alive

--------------------------------------------------------------------
## 4. Removing and Compaction

Removing book id 42:
1. Find the matching index `i`
2. `free(collection[i].text);` → release the characters
3. **Compact the array** so no hole remains:

```c
memmove(&collection[i], &collection[i+1],
        (size - i - 1) * sizeof(Book));
--size;
```

`memmove` is like `memcpy` but works safely on overlapping regions.

--------------------------------------------------------------------
## 5. Printing One Book – the `displayBook` Function

The assignment mandates a dedicated function:

```c
static void displayBook(const Book *b)
{
    printf("ID: %d\n", b->id);
    printf("Text: %s\n", b->text);
}
```

We pass a **pointer to const** because the function only *reads* the book.

--------------------------------------------------------------------
## 6. Clean-Up on Exit

When the user chooses menu 4 we must release:
- every `book.text` string
- the top-level `collection` array

```c
static void freeAll(void)
{
    for (size_t i = 0; i < size; ++i)
        free(collection[i].text);
    free(collection);
}
```

Failing to do so causes **memory leaks**, i.e. memory that the operating system cannot reclaim until the process ends.  
In long-running programs (servers, games, embedded loops) leaks are fatal.

--------------------------------------------------------------------
## 7. Input Safety Highlights
- `fgets` reads up to `MAX_TEXT_LEN` characters and keeps embedded spaces
- We discard the trailing newline so it is not stored
- We always check the return value of `scanf` to trap non-numeric input

--------------------------------------------------------------------
## 8. Memory Allocation Summary
Operation           | Allocated With     | Released With
--------------------|--------------------|--------------------
Array of Books      | `malloc`/`realloc` | `realloc` down to 0 or `free`
Text inside a book  | `malloc`           | `free` (on remove or exit)

Every `malloc` must eventually meet a `free`; keeping that pairing straight is the essence of manual memory management in C.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of your collection of books as a stack of index cards that can grow or shrink while the program runs.  
What kind of “container” in C lets you keep an unknown number of items yet still access each one quickly by position?

**Hint 2**  
Each book has two things: a fixed-number label and a body of text whose length you don’t know ahead of time.  
Look for a standard-library tool that can give you exactly as many bytes as you need for the text only after the user has typed it in.

**Hint 3**  
Start by declaring a small array of “slots.” When the last slot is filled, double the space with the resizer function, then place the new book’s text in freshly obtained heap space.  
Remember: every piece of memory you obtain this way must be released again—first the individual texts, then the whole array—before the program says goodbye.

### STEP_5
# STEP 5: SUMMARY

- Dynamic arrays: using malloc/realloc to grow/shrink a collection at run time  
- Structured data: bundling heterogeneous fields (id, variable-length text) into a single struct  
- Pointer lifetime discipline: pairing every malloc with a matching free to prevent memory leaks  
- Safe text input: reading arbitrarily long lines that contain spaces without buffer overflow  
- Array compaction: removing an element by freeing its sub-allocated memory and shifting remaining items  
- Function decomposition: isolating book display logic inside the required displayBook routine  
- Resource cleanup on exit: systematically releasing all heap blocks before program termination

### STEP_6
# STEP 6: TEST CASES

1. **Happy-path sequence**  
   Add two books, list them, remove the first, list again to verify the remaining one.

2. **Empty collection list**  
   Choose “List books” before anything is added; program should print “Collection empty.”

3. **Large text (edge)**  
   Add a book whose text is exactly the 4095-character limit; ensure it is stored and listed correctly.

4. **Remove non-existent ID (invalid)**  
   Attempt to remove ID 99 when the collection has only 1–3 items; program must answer “Not found.”

5. **Add after remove then exit**  
   Fill the array, remove an early slot to open a hole, add a new book, list all, then exit cleanly; verifies compaction and final free-all.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\nIt was the best of times.\n1\nCall me Ishmael.\n3\n2\n1\n3\n4",
      "expected_keyword": "Call me Ishmael"
    },
    {
      "input": "3\n4",
      "expected_keyword": "Collection empty"
    },
    {
      "input": "1\nA", "expected_keyword": "A"
    },
    {
      "input": "2\n99\n4",
      "expected_keyword": "Not found"
    },
    {
      "input": "1\nFirst\n1\nSecond\n1\nThird\n2\n2\n1\nFourth\n3\n4",
      "expected_keyword": "Fourth"
    }
  ]
}
```

---

## Iteration 37 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Context
You are helping the campus bookstore manage its second-hand textbook inventory.  
Each book has a title (≤40 characters), an ISBN-13 (string of 13 digits), and a price in dollars (double).  
The number of books changes every semester, so the list must grow or shrink at run-time.  
You will write a small console program that keeps the list in dynamic memory using malloc/realloc/free.

## Functional Requirements
1. On startup the program starts with an empty list.
2. The user is repeatedly shown a menu with the following choices:
   1. Add a new book
   2. Remove a book by ISBN-13
   3. Show all books (title, ISBN-13, price)
   4. EXIT
3. Adding a book:
   - Dynamically resize the array to hold one more book.
   - Read title, ISBN-13, price.
4. Removing a book:
   - Read the ISBN-13 to delete.
   - If found, shift remaining books left and shrink the array.
   - If not found, print “Book not found.”
5. Showing all books:
   - Print one line per book in the format:  
     Title: <title>, ISBN: <isbn>, Price: $<price>  
     (If there are no books, print “No books in stock.”)

## Simple Example Run
Input:
```
1
Computer Networks
9780132126953
89.99
1
Calculus
9781285740621
120.50
3
2
9781285740621
3
4
```
Output:
```
Title: Computer Networks, ISBN: 9780132126953, Price: $89.99
Book not found
Title: Computer Networks, ISBN: 9780132126953, Price: $89.99
```

### CONSTRAINTS
- The primary data entity must be a struct called Book.
- All logic for displaying a single book must be in a function void displayBook(const Book *b).
- The solution must be implemented with only one additional function besides main().
- Menu option 4 is EXIT; typing 4 must free all dynamically allocated memory and terminate the program.

### STEP_2
```c
/*
 * Textbook inventory for campus bookstore
 * Author: <your name>
 * Compile: gcc -std=c11 -Wall -Wextra -pedantic textbook.c -o textbook
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Book entity */
typedef struct {
    char title[41];         /* up to 40 characters plus '\0' */
    char isbn[14];        /* 13 digits + '\0' (we enforce via input) */
    double price;
} Book;

/* Prototypes */
static void displayBook(const Book *b);  /* print one book line */

/* Main program - the only other function allowed */
int main(void)
{
    Book *inventory = NULL;   /* dynamic array of Books */
    size_t size = 0;          /* number of books in inventory */
    int option;

    while (1) {
        /* ---------- Print menu ---------- */
        puts("1. Add a new book");
        puts("2. Remove a book by ISBN-13");
        puts("3. Show all books");
        puts("4. EXIT");
        printf("Choose an option: ");

        if (scanf("%d", &option) != 1) {
            /* bad input */
            while (getchar() != '\n')
                ; /* clear the line */
            puts("Invalid option.");
            continue;
        }
        getchar(); /* absorb trailing newline */

        switch (option) {
        case 1: {  /* Add book */
            Book temp;
            printf("Enter title (max 40 chars): ");
            if (!fgets(temp.title, sizeof(temp.title), stdin)) { /* EOF guard */
                fputs("Input error.\n", stderr);
                exit(EXIT_FAILURE);
            }
            /* strip final newline */
            temp.title[strcspn(temp.title, "\n")] = '\0';

            printf("Enter ISBN-13 (13 digits): ");
            if (!fgets(temp.isbn, sizeof(temp.isbn), stdin)) {
                fputs("Input error.\n", stderr);
                exit(EXIT_FAILURE);
            }
            temp.isbn[strcspn(temp.isbn, "\n")] = '\0';

            printf("Enter price: ");
            if (scanf("%lf", &temp.price) != 1) {
                while (getchar() != '\n')
                    ; /* flush */
                puts("Invalid price.");
                break;
            }
            getchar(); /* newline */

            /* resize array */
            Book *newBlock = realloc(inventory, (size + 1) * sizeof(Book));
            if (!newBlock) {
                perror("realloc");
                /* Free previous memory before bailing out */
                free(inventory);
                exit(EXIT_FAILURE);
            }
            inventory = newBlock;
            inventory[size++] = temp;
            break;
        }
        case 2: {  /* Remove book by ISBN */
            char target[14];
            printf("Enter ISBN-13 to remove: ");
            if (!fgets(target, sizeof(target), stdin)) {
                fputs("Input error.\n", stderr);
                exit(EXIT_FAILURE);
            }
            target[strcspn(target, "\n")] = '\0';

            size_t found = 0;
            for (size_t i = 0; i < size; ++i) {
                if (strcmp(inventory[i].isbn, target) == 0) {
                    /* shift remaining books over the removed one */
                    for (size_t j = i; j < size - 1; ++j)
                        inventory[j] = inventory[j + 1];
                    --size;
                    found = 1;
                    break;
                }
            }
            if (found) {
                /* shrink block */
                if (size == 0) {
                    free(inventory);
                    inventory = NULL;
                } else {
                    Book *n = realloc(inventory, size * sizeof(Book));
                    /* realloc shrink can fail, but we keep the original ptr */
                    if (n) inventory = n;
                }
            } else {
                puts("Book not found.");
            }
            break;
        }
        case 3: {  /* Show all books */
            if (size == 0) {
                puts("No books in stock.");
            } else {
                for (size_t i = 0; i < size; ++i)
                    displayBook(&inventory[i]);
            }
            break;
        }
        case 4:  /* EXIT */
            free(inventory);
            return 0;
        default:
            puts("Invalid option.");
        } /* end switch */
    }     /* end while */
}

/* ---------- displayBook ---------- */
/* Print a single book in the specified format. */
static void displayBook(const Book *b)
{
    printf("Title: %s, ISBN: %s, Price: $%.2f\n", b->title, b->isbn, b->price);
}
```

### STEP_3
# Step 3: Explanation  

## 1. Dynamic memory instead of a "fixed-size" array
At compile-time the program has no idea how many books will be added this semester.  
Therefore we cannot use:
```c
Book inventory[MAX];   /* bad: MAX must be known at compile-time */
```
Instead we create an empty "array" that can grow or shrink whenever the user wants:
```c
Book *inventory = NULL;   /* starts empty */
size_t size = 0;          /* how many books we currently own */
```
The variable `inventory` is merely a *pointer*; it doesn't hold the books, it only holds a starting address in the heap where the books will live.  
`malloc()`, `realloc()` and `free()` are our toolbox to turn the heap into an array that behaves like a C array but can change length while the program is running.

---

## 2. The heap life-cycle
malloc() → use memory (possibly realloc()) → free()

- **malloc(n * sizeof(Book))** reserves *n* *contiguous* blocks of memory, each the size of one `Book`.  
  Success returns a pointer to the first byte, failure returns `NULL`.  
  In the program every allocation is checked and failure leads to `exit(EXIT_FAILURE)` after issuing an error message and—importantly—already released memory is freed so that no resources leak.

- **realloc(ptr, newbytes)** changes the size of a previously allocated block:
  - If the block can simply be extended, the same address is returned.  
  - If the block is really moved, the contents are copied and the old pointer becomes invalid.  
    `realloc()` behaves like `free()+malloc()` combined and can even be used for the first allocation on a `NULL` pointer.  
    In this program we choose to make every `realloc` an *increase* of exactly one more element:
    ```c
    Book *newBlock = realloc(inventory, (size + 1) * sizeof(Book));
    ```
    This keeps the code simple and meets the requirement "resize the array to hold one more book."

- **free(inventory)** gives the whole dynamic array back to the system.  
  This happens either when the user exits (menu 4) or after a failed allocation where we must terminate anyway.

---

## 3. Growing the inventory (menu choice 1)
1. `temp` is a local variable that receives the *title*, ISBN, price.
2. We ask the heap for one more slot; `newBlock` is the *only* temporary variable we need.
3. Test `newBlock==NULL`: on failure we still own the old `inventory`; so we `free()` it and `exit()`.
4. Update bookkeeping:
   ```c
   inventory = newBlock;
   inventory[size] = temp;   /* append at the end */
   ++size;
   ```
   Now we have an additional `Book` at logical index "size-1".

---

## 4. Shrinking the inventory (menu choice 2)
1. Read the target ISBN.
2. Linear search through the array.
3. If a match is found:
   - Shift every element one step to the left, overwriting the deleted entry  
     (C allows structure assignment, so `inventory[j] = inventory[j+1]` works directly).
   - Decrement `size`.
4. After deletion we `realloc(inventory, size*sizeof(Book))` to give excess bytes back to the heap.  
   The standard guarantees that *shrinking* a `realloc` never fails; nevertheless we capture the return value to keep gcc/clang quiet.
5. If the search loop ends with `found==0` we issue "Book not found."

---

## 5. Printing (menu choice 3)
According to the requirements exactly one helper function besides `main()` is allowed: `displayBook`.  
It receives a *const* pointer so that it can read a `Book` but cannot modify it—this is a good software-engineering habit because it enforces *const-correctness*.

---

## 6. Edge cases handled
- `malloc`/`realloc` returns `NULL` ⇒ we immediately free already acquired memory and abort cleanly.
- `size==0` after removal ⇒ we free the pointer and set it to `NULL` to avoid dangling references.
- Wrong menu input or bad scanf values are trapped so that the loop continues without crashing the program.
- Input strings are always cleaned of new-line characters so that later prints look tidy.

---

## 7. Time & space complexity
- Adding a book: O(1) amortised (occasional O(n) when realloc moves the block).  
- Removing a book: O(n) worst-case (linear search + possible shifting).  
Both are absolutely fine for the "a few dozen to a few hundred" scale a campus bookstore has.

---

## 8. Key takeaway
Whenever the count is only known at run-time:
1. Start with `T *ptr = NULL` and `size = 0`.
2. Grow with `ptr = realloc(ptr, ++size*sizeof *ptr)`; always test the return value.
3. Use the memory like an array (`ptr[i]`).
4. When done (or on fatal error) `free(ptr);` so nothing leaks.

That's all the dynamic memory magic the textbook inventory needs.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think about how you would keep track of a growing collection of items when you don’t know in advance how many there will be.  
What C mechanism lets you ask the operating system for fresh memory while the program is already running, and how do you give that memory back when you’re done?

**Hint 2**  
Look up the trio of library functions whose names start with “m”, “r”, and “f”.  
One of them grabs a brand-new block, one can resize an existing block, and one releases the block so it can be reused.  
Start with a pointer that initially points nowhere and, after each successful request, let that pointer refer to the newly allocated (or enlarged) space.

**Hint 3**  
When the user chooses “add”, calculate the new total count, request "old size + 1" elements, place the freshly read data at the highest legal index in the enlarged space, and update your length counter.  
Always verify that the allocation request succeeded; if it fails, release whatever you already owned and exit gracefully instead of continuing with a NULL pointer.

### STEP_5
# STEP 5: SUMMARY
- Master dynamic memory management with malloc/realloc/free to grow/shrink data structures at run-time.
- Practice defensive programming: check every allocation result and free memory on both normal exit and fatal errors.
- Use structures to bundle related data (title, ISBN, price) and arrays of structures for collections.
- Reinforce pointer basics: distinguish pointer variables, allocated blocks, and array-style indexing via pointers.
- Implement basic insertion/deletion in a dynamic array, including shifting elements and releasing unused space.
- Separate concerns with helper functions (e.g., displayBook) while respecting constraints on function count.
- Handle stdin robustly: clear new-lines, validate numeric input, and cope with fgets edge cases.
- Understand amortized performance and memory-leak avoidance in simple resource-managed programs.

### STEP_6
# STEP 6: TEST CASES  

**Test 1** – happy path: add two different books, display both, then remove one, display again.  
**Test 2** – empty inventory: start program, immediately show all books, then exit.  
**Test 3** – delete non-existent ISBN, expect “Book not found.” message.  
**Test 4** – invalid menu choice (e.g., 9), program should re-prompt.  
**Test 5** – realloc failure simulation: fill memory until realloc returns NULL; program must free prior memory and abort without leaking.  

(For interactive testing, you can limit the address space with your shell; the program must still exit cleanly and free any already-owned block.)

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\nComputer Networks\n9780132126953\n89.99\n1\nCalculus\n9781285740621\n120.50\n3\n2\n9781285740621\n3\n4",
      "expected_keyword": "Price: $89.99"
    },
    {
      "input": "3\n4",
      "expected_keyword": "No books in stock"
    },
    {
      "input": "1\nAlice\n1234567890123\n42\n2\n0000000000000\n4",
      "expected_keyword": "Book not found"
    },
    {
      "input": "9\n3\n4",
      "expected_keyword": "Invalid option"
    },
    {
      "input": "1\nA\n1111111111111\n1\n1\nB\n2222222222222\n2\n4",
      "expected_keyword": "Price: $1.00"
    }
  ]
}
```

---

## Iteration 38 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story  
The campus library is tired of losing track of which books are on loan.  
They hire you to write a tiny, temporary digital ledger that keeps a list of currently borrowed books.  
All data must live only in RAM and must be created with malloc(); when the librarian chooses to quit, every record must be released with free().

## Requirements  
1. Represent each book with a struct that stores:  
   - a unique integer ID (1 … 9999)  
   - the book’s title (≤ 30 characters, no spaces)  
   - the borrower’s name (≤ 30 characters, no spaces)  
2. Keep an expandable array of pointers to these structs (double the capacity when full).  
3. Provide a menu driven interface:  
   1) Add a new loan record (ID, title, borrower)  
   2) Delete a record by ID  
   3) Display all loans  
   4) Exit the program (releases all memory and terminates)  
4. After every operation, print the current number of active loans.  
5. If the user tries to add a duplicate ID, print “Duplicate ID!” and do nothing.

## Simple Example Run  
```
1) Add  2) Delete  3) Show  4) Exit
Choice: 1
ID: 7
Title: ThePragProgrammer
Borrower: Alice
Loans: 1

1) Add  2) Delete  3) Show  4) Exit
Choice: 3
ID 7: ThePragProgrammer borrowed by Alice
Loans: 1

1) Add  2) Delete  3) Show  4) Exit
Choice: 4
Good-bye!
```

## CONSTRAINTS  
- Must use a struct to represent the primary data entity (a book loan).  
- Logic for displaying the details of ONE specific entity must be in a function called displayEntity.  
- The entire solution must be implemented with a single function besides main().

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * A minimal library-loan ledger that lives purely in RAM.
 *  – keeps only an *array of pointers* to malloc´ed structs
 *  – doubles the capacity whenever we run out of room
 *  – contains exactly one helper function besides main()
 *
 * Compile:  gcc -std=c11 -Wall -Wextra -pedantic ledger.c -o ledger
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- CONSTANTS ---------- */
#define MAX_TITLE      31          /* 30 visible + '\0' */
#define MAX_BORROWER   31
#define MIN_ID 1
#define MAX_ID 9999
#define INITIAL_CAP      2         /* small but valid */

/* ---------- PRIMARY DATA TYPE ---------- */
typedef struct {
    int  id;
    char title[MAX_TITLE];
    char borrower[MAX_BORROWER];
} BookLoan;

/* ---------- PROTOTYPE ---------- */
void displayEntity(const BookLoan *b);

/* ---------- MAIN ONLY ---------- */
int main(void)
{
    size_t cap   = INITIAL_CAP;      /* capacity of pointer array    */
    size_t size  = 0;              /* current # active loans       */
    BookLoan **arr = malloc(cap * sizeof *arr);
    if (!arr) { perror("malloc"); exit(EXIT_FAILURE); }

    /* --- MENU LOOP --- */
    for (;;) {
        printf("\n1) Add  2) Delete  3) Show  4) Exit\nChoice: ");
        int choice;
        if (scanf("%d", &choice) != 1) break;   /* EOF -> quit */

        if (choice == 1) {
            int  id;
            char title[MAX_TITLE], borrower[MAX_BORROWER];

            printf("ID: ");
            scanf("%d", &id);
            printf("Title: ");
            scanf("%30s", title);      /* 30-chars max, no spaces */
            printf("Borrower: ");
            scanf("%30s", borrower);

            /* duplicate-ID check */
            int dup = 0;
            for (size_t i = 0; i < size; ++i)
                if (arr[i]->id == id) { dup = 1; break; }
            if (dup) {
                puts("Duplicate ID!");
                printf("Loans: %zu\n", size);
                continue;
            }

            /* grow array if needed */
            if (size == cap) {
                cap *= 2;
                BookLoan **tmp = realloc(arr, cap * sizeof *tmp);
                if (!tmp) { perror("realloc"); exit(EXIT_FAILURE); }
                arr = tmp;
            }

            /* create and store new loan */
            BookLoan *loan = malloc(sizeof *loan);
            if (!loan) { perror("malloc"); exit(EXIT_FAILURE); }
            loan->id = id;
            strncpy(loan->title, title, MAX_TITLE);
            loan->title[MAX_TITLE - 1] = '\0';
            strncpy(loan->borrower, borrower, MAX_BORROWER);
            loan->borrower[MAX_BORROWER - 1] = '\0';
            arr[size++] = loan;
        }
        else if (choice == 2) {
            int id;
            printf("ID: ");
            scanf("%d", &id);

            /* find and remove */
            size_t idx = size;          /* flag value */
            for (size_t i = 0; i < size; ++i)
                if (arr[i]->id == id) { idx = i; break; }

            if (idx == size) {
                /* not found – nothing to do */
            } else {
                free(arr[idx]);
                arr[idx] = arr[--size]; /* move last element here */
            }
        }
        else if (choice == 3) {
            for (size_t i = 0; i < size; ++i)
                displayEntity(arr[i]);
        }
        else if (choice == 4) {
            break;                     /* leave loop, free memory */
        }
        else {
            puts("Invalid choice.");
        }

        /* always show current count */
        printf("Loans: %zu\n", size);
    }

    /* ---------- CLEAN-UP ---------- */
    for (size_t i = 0; i < size; ++i) free(arr[i]);
    free(arr);

    puts("Good-bye!");
    return 0;
}

/* ---------- SINGLE HELPER FUNCTION ---------- */
void displayEntity(const BookLoan *b)
{
    printf("ID %d: %s borrowed by %s\n", b->id, b->title, b->borrower);
}
```

### STEP_3
# STEP 3: EXPLANATION

Imagine the library asked you to keep a list of “loans.”  
Each loan is three small pieces of data (id, title, borrower) and the list keeps growing while the program runs.  
Because the list length is unknown in advance, we must keep **both** the list and every individual loan in the **heap**, not on the stack.  
That is exactly what *dynamic memory allocation* (malloc / realloc / free) is for.

Here is a conceptual walk-through, told in the order the program actually runs.

1. We start with **nothing in RAM** except a pointer array (`BookLoan **arr`) that initially holds only two elements.  
   Each element will **point to** a separately malloc’ed struct, so the picture is:

   ```
   arr -> [ 0x0 , 0x0 ]     // two NULL pointers
          capacity = 2
          used       = 0
   ```

   This tiny array is created by:
   ```c
   arr = malloc(cap * sizeof *arr);
   ```
   `malloc` asks the operating system for a contiguous block of memory big enough to store `cap` pointers.  
   We **always** test the return value (`if (!arr) …`) because malloc can fail; the program aborts if it does.

2. The **menu loop** is an infinite `for(;;)` because the program must stay alive until the user presses 4.

3. **ADD a loan** (choice 1):  
   - First we check whether an ID is already in use.  
     We simply scan the “used” part of `arr` and compare ids.  
     If we find one, we print “Duplicate ID!” and continue (no memory allocated).  
   - If the ID is new, we need two mallocs:
     a) One for the **struct itself** (`BookLoan* loan = malloc(sizeof *loan);`)  
     b) Possibly a second one to **grow the pointer array** if we are full:  
        ```c
        if (size == cap) { cap *= 2; … realloc … }
        ```
        `realloc` copies the old pointers into a new, larger block and frees the old one automatically.  
        Notice the idiom:
        ```c
        BookLoan **tmp = realloc(arr, cap * sizeof *tmp);
        if (!tmp) { perror("realloc"); exit(EXIT_FAILURE); }
        arr = tmp;
        ```
        We **never** write `arr = realloc(arr, …)` directly; if realloc fails we would leak the previous pointer.  
   - After we know both allocations succeeded, we copy the user strings into the struct with `strncpy` (to stay within the fixed buffer) and store the pointer into `arr[size++]`.

   The **count of active loans** (`size`) is incremented, and the program prints it.

4. **DELETE a loan** (choice 2):  
   Deleting is cheap when the list does **not** have to stay in order.  
   We find the element with the wanted id, `free()` the struct it points to, move the **last** pointer in the array into the now-empty slot, and shrink the logical length by one.  
   ```
   idx of element to delete   →  free()
   last element               →  copy to idx
   size  decreases by 1
   ```
   This is O(1) time and keeps the array contiguous.  
   If the id is missing, nothing happens and the loan count stays the same.

5. **SHOW** (choice 3):  
   We iterate from 0 … size-1 and hand each pointer to `displayEntity()`.  
   That function has the single responsibility of printing details; the requirement insists on this helper being **one** function and taking a `const BookLoan*` parameter.

6. **EXIT** (choice 4):  
   Before calling `return 0` we must give back every byte we borrowed from the operating system.  
   There are two levels to free:
   - free every individual `BookLoan` struct  
   - free the array of pointers (`arr`) itself  
   Failing to do this would not crash the program (the OS reclaims memory after termination), but it is bad style and would hide leaks in a long-running program.

7. Safety details you may have missed:
   - `scanf("%30s", …)` guarantees we never overflow the fixed buffers.  
   - Every `malloc`/`realloc` is checked.  
   - Capacity is always doubled, so growing is amortised O(1).  
   - `size` keeps exact track of how many slots are logically in use, so we never need to call `memmove` or shift elements.

Key ideas to take away:
- The **array of pointers** (`BookLoan **`) gives us O(1) random access while still allowing each book struct to be an independent heap block.  
- `realloc` is the standard way to grow (or shrink) an already-allocated array. Always use a temporary pointer to detect allocation failure.  
- Every `malloc` must have an associated `free`; match them in reverse order of allocation.  
- Keep the user interface simple and the data structure dumb; correctness is more important than micro-optimisations.

That is the complete life-cycle of the program’s dynamic data, from the first `malloc` to the final `free`.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of the ledger as two separate jobs:  
1) keeping a list that can grow without warning, and  
2) storing each individual loan’s details somewhere that lives beyond a single function call.  
Solve those jobs one at a time—what kind of storage grows on demand and what kind of storage survives after a function returns?

Hint 2  
When the current list is full you will need “more room,” but you do not want to lose the data already collected.  
Look for the standard library tool that can ask the runtime to expand (or shrink) an already-allocated block while preserving its old contents.

Hint 3  
Start small: create a pointer array capable of holding just a few loans.  
Whenever the number of active loans reaches this capacity, double the capacity and relocate (without leaking) every existing pointer to the new, larger space.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory allocation with malloc, realloc, and free in a real-world context  
- Managing an expandable array of pointers to structures (dynamic resizing, capacity doubling)  
- Structuring data to ensure O(1) access while keeping each entity in its own heap block  
- Implementing a menu-driven interactive program inside a single main function with exactly one additional helper function  
- Robustly checking allocation failures and ensuring every allocated byte is released before program termination  
- Using fixed-size buffers safely (strncpy, scanf field widths) to avoid buffer overflows  
- Practising modular design by isolating entity display logic in a dedicated, reusable routine  
- Reinforcing the habit of printing program state (here: loan count) after every user operation for immediate feedback

### STEP_6
# STEP 6: TEST CASES

1. **Happy path – one loan.**  
   Add a single loan, show the list, then exit.  
   Expected: program reports “Loans: 1” after add and show; list prints the correct ID, title, borrower on one line.

2. **Duplicate ID prevention.**  
   Add ID 5, attempt to add ID 5 again.  
   Expected: second add prints “Duplicate ID!” and the count stays at 1.

3. **Delete the only loan.**  
   Add ID 10, delete ID 10, show list, exit.  
   Expected: after delete the count is 0; show produces no output.

4. **Edge – empty list operations.**  
   Immediately choose Show, then Delete a non-existent ID (say 99), then Exit.  
   Expected: both operations print “Loans: 0”; no crash or undefined behaviour.

5. **Invalid menu choice.**  
   Start program, enter 7 (invalid), then 0 (invalid), then add a valid loan, then Exit.  
   Expected: program prints “Invalid choice.” twice, still accepts correct input later, and frees all memory on exit.

```json
{
  "exit_command": "4",
  "test_suite": [
    {"input": "1\nAlice\n100\n3\n4", "expected_keyword": "Alice"},
    {"input": "1\nBob\n200\n1\nBob\n200\n4", "expected_keyword": "Duplicate ID!"},
    {"input": "1\nCarol\n300\n2\n300\n3\n4", "expected_keyword": "Loans: 0"},
    {"input": "3\n2\n999\n4", "expected_keyword": "Loans: 0"},
    {"input": "7\n0\n1\nDave\n400\n4", "expected_keyword": "Invalid choice."}
  ]
}
```

---

## Iteration 39 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The campus library has just upgraded to a digital “check-out” system.  
Instead of keeping a fixed-size array for book records, the head librarian wants you to write a tiny demo that stores book information in dynamically allocated memory so that the collection can grow and shrink as books are added or returned.

## Functional Requirements
1. Represent each book with three fields:  
   - a unique integer id (1 … 2 147 483 647)  
   - title (at most 99 printable characters, no newline)  
   - a boolean flag checkedOut (0 = available, 1 = on loan)  
2. Keep every book in its own heap-allocated structure.  
3. Provide a text menu that lets the user repeatedly:  
   1) Add a new book (read id, title, checkedOut).  
   2) Search for a book by id and print its details.  
   3) Toggle the checked-out status of a book (find by id).  
   4) Delete a book (find by id and free its memory).  
   5) Show every book currently in memory.  
   6) **EXIT** the program (menu option 6).  
4. After every command, re-display the menu (except when exiting).  
5. If the user chooses an invalid menu option, print “Invalid choice.” and re-display the menu.  
6. Do not leak memory: every malloc’d book must be free’d before the program ends.

## Simple Example Run
```
=== Digital Library Demo ===
1) Add book
2) Search book
3) Toggle checkout
4) Delete book
5) List all books
6) EXIT
Choice: 1
Enter id: 101
Enter title: C Programming Language
Is checked out (0/1): 0
Book added.

1) Add book
2) Search book
3) Toggle checkout
4) Delete book
5) List all books
6) EXIT
Choice: 2
Enter id: 101
Id: 101
Title: C Programming Language
Status: Available

1) Add book
2) Search book
3) Toggle checkout
4) Delete book
5) List all books
6) EXIT
Choice: 6
Goodbye!
```

### CONSTRAINTS
- You MUST use a struct to represent each book entity.  
- All printing of a single book’s details (whether from search or list) must be done by a function named `displayBook`.  
- You may implement any number of helper functions, but the core logic for each menu action must be handled by exactly **one** additional function besides `main()` (i.e., only two functions total: `main` and the extra function).

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Digital Library Demo – single-file, minimal, memory-safe.
 * C11, ISO/IEC 9899:2011
 *
 * Only TWO functions exist: main() and libraryMenu().
 * All menu actions are dispatched from libraryMenu().
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

/* ---------- Data structure ---------- */
typedef struct Book {
    int  id;
    char title[100];      /* 99 printable + '\0' */
    bool checkedOut;      /* 0 = available, 1 = on loan */
    struct Book *next;      /* intrusive singly-linked list */
} Book;

/* ---------- Prototypes ---------- */
void libraryMenu(Book **head);   /* the only extra function allowed */
void displayBook(const Book *b); /* mandated by spec */

/* ---------- Helper macros ---------- */
#define MENU_TEXT \
"=== Digital Library Demo ===\n" \
"1) Add book\n" \
"2) Search book\n" \
"3) Toggle checkout\n" \
"4) Delete book\n" \
"5) List all books\n" \
"6) EXIT\n" \
"Choice: "

/* ---------- Main ---------- */
int main(void)
{
    Book *library = NULL;          /* empty list */
    libraryMenu(&library);           /* everything happens inside here */
    /* libraryMenu guarantees everything is freed before returning */
    return 0;
}

/* ---------- Single extra function (per spec) ---------- */
void libraryMenu(Book **head)
{
    int choice;
    while (1) {
        printf(MENU_TEXT);
        if (scanf("%d", &choice) != 1) {         /* non-numeric input */
            /* consume rest of line and try again */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF) {}
            printf("Invalid choice.\n");
            continue;
        }

        switch (choice) {
        case 1: { /* Add book */
            int id, st;
            char ttl[100];
            printf("Enter id: ");
            scanf("%d", &id);
            printf("Enter title: ");
            scanf(" %99[^\n]", ttl);            /* leading space skips prior '\n' */
            printf("Is checked out (0/1): ");
            scanf("%d", &st);

            /* create new node */
            Book *node = malloc(sizeof *node);
            if (!node) {                       /* malloc failure */
                perror("malloc");
                exit(EXIT_FAILURE);
            }
            node->id = id;
            strncpy(node->title, ttl, sizeof node->title - 1);
            node->title[sizeof node->title - 1] = '\0';
            node->checkedOut = (st != 0);
            node->next = NULL;

            /* insert at head (O(1)) */
            node->next = *head;
            *head = node;
            printf("Book added.\n\n");
            break;
        }
        case 2: { /* Search book */
            int id;
            printf("Enter id: ");
            scanf("%d", &id);
            Book *cur = *head;
            while (cur && cur->id != id)
                cur = cur->next;
            if (cur) {
                displayBook(cur);
            } else {
                printf("Book not found.\n");
            }
            printf("\n");
            break;
        }
        case 3: { /* Toggle checkout */
            int id;
            printf("Enter id: ");
            scanf("%d", &id);
            Book *cur = *head;
            while (cur && cur->id != id)
                cur = cur->next;
            if (cur) {
                cur->checkedOut = !cur->checkedOut;
                printf("Status toggled.\n");
            } else {
                printf("Book not found.\n");
            }
            printf("\n");
            break;
        }
        case 4: { /* Delete book */
            int id;
            printf("Enter id: ");
            scanf("%d", &id);
            Book *cur = *head, *prev = NULL;
            while (cur && cur->id != id) {
                prev = cur;
                cur = cur->next;
            }
            if (!cur) {
                printf("Book not found.\n\n");
                break;
            }
            /* unlink and free */
            if (prev)
                prev->next = cur->next;
            else
                *head = cur->next;
            free(cur);
            printf("Book deleted.\n\n");
            break;
        }
        case 5: { /* List all books */
            if (!*head) {
                printf("Library is empty.\n");
            } else {
                for (Book *cur = *head; cur; cur = cur->next)
                    displayBook(cur);
            }
            printf("\n");
            break;
        }
        case 6:   /* EXIT */
            /* free entire list before leaving */
            while (*head) {
                Book *tmp = (*head)->next;
                free(*head);
                *head = tmp;
            }
            printf("Goodbye!\n");
            return;               /* leave function; main ends */
        default:
            printf("Invalid choice.\n\n");
        }
    }
}

/* ---------- Display helper (mandated name) ---------- */
void displayBook(const Book *b)
{
    if (!b) return;
    printf("Id: %d\nTitle: %s\nStatus: %s\n\n",
           b->id,
           b->title,
           b->checkedOut ? "On loan" : "Available");
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory is the star of this little demo: instead of declaring “Book library[1000];” (a fixed, compile-time size), we let the collection expand or shrink while the program is running.  
Here is how the code you just saw achieves that safely.

-------------------------------------------------
1.  One structure → many *book objects*
-------------------------------------------------
typedef struct Book { … } Book;

The declaration does **not** reserve any shelf space yet.  
It only tells the compiler “Whenever I later ask for a Book, reserve this many bytes.”  
Only malloc() turns that description into an actual object in the *heap* segment of memory.

-------------------------------------------------
2.  The heap and the stack
-------------------------------------------------
- Automatic variables (head, choice, cur, …) live on the stack frame of libraryMenu().  
- Each Book we create with malloc() lives on the heap and stays alive after the function returns, until we explicitly free() it.

Think of the stack as a pile of paper you throw away when you leave the office; the heap is a public notice board where you pin papers that must stay until you remove them. Forgetting to remove them = **memory leak**.

-------------------------------------------------
3.  Linked list keeps the books together
-------------------------------------------------
We could have used realloc on an array, but that forces *all* books to move when the array grows.  
A singly-linked list is simpler for frequent insertions/deletions at arbitrary positions:

head → BookA → BookB → BookC → NULL

Each node stores:
- The actual data (id, title, checkedOut)  
- One pointer “next” that remembers who comes after it.

Because every node is independent, we can splice one in or out with a couple of pointer re-assignments and a single free(), keeping O(1) insertion at the head and O(n) search (acceptable for a demo).

-------------------------------------------------
4.  malloc() – the request for space
-------------------------------------------------
node = malloc(sizeof *node);

malloc() asks the OS for a contiguous chunk of bytes big enough for one Book.  
It returns either:
- the address of the first byte, or  
- NULL if nothing is left (rare on a PC, but we must check).  

If we ignore the NULL case, the very first failed allocation is a segmentation fault or subtle corruption.

-------------------------------------------------
5.  Building the collection
-------------------------------------------------
Adding a book does three things:
1. Read user input into local vars.  
2. Allocate a Book node.  
3. Hook the node at the front of the list

We could append at the tail, but inserting at the head is one line and needs no extra bookkeeping.

-------------------------------------------------
6.  Searching and toggling
-------------------------------------------------
Walk the list with a simple while-loop until cur->id matches the user-supplied id.  
- If cur == NULL we fell off the end ⇒ “Book not found.”  
- Otherwise cur points to the wanted struct; we can read from it or modify its fields.

Toggling checkedOut is just:
cur->checkedOut = !cur->checkedOut;

-------------------------------------------------
7.  Deleting – unlink *then* free
-------------------------------------------------
Deletion needs the node *before* the victim (prev) so we can sew the list back together.

prev->next = cur->next;   /* bridge over the victim */
free(cur);                /* hand the memory back */

Notice the order: free() must come *after* we no longer need the pointer, but we must still have a way to reach the rest of the list.

-------------------------------------------------
8.  Program termination – free everything
-------------------------------------------------
The EXIT branch walks through the list and free()s each node:
while (*head) {
    Book *tmp = (*head)->next;
    free(*head);
    *head = tmp;
}

When libraryMenu() returns to main(), the heap is clean, so leak-checkers such as Valgrind report 0 bytes in use at exit – satisfying the “no memory leak” requirement.

-------------------------------------------------
9.  Display abstraction
-------------------------------------------------
The spec *requires* a function named displayBook().  
Encapsulating the print instructions keeps the switch-statement short and guarantees identical formatting whenever we show a book (search, list-all).

-------------------------------------------------
10.  Why only two functions?
-------------------------------------------------
The problem statement restricts us to **one** extra function besides main().  
libraryMenu() therefore performs *all* menu actions itself; the helpers (malloc, free, printf) are part of libc, so we are still within the limit.

-------------------------------------------------
Key take-away
-------------------------------------------------
malloc() and free() are symmetrical:  
- Every successful malloc() must have an associated free() path.  
- The moment you lose the *last* pointer to a malloc’ed block, you leak.

Using a linked list with a clear “destroy list” routine makes that contract easy to honor and demonstrates the essential skill of managing lifetime in C.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of each book as a separate “package” you create only when you need it; the collection itself is just a way to keep track of all those packages. You can add or remove packages without ever declaring a fixed-size shelf.

**Hint 2**  
Whenever you need a new package, ask the runtime for fresh space big enough to hold one book’s data; the manual also says you must later hand that exact space back. A certain standard-library pair of verbs (one to obtain, one to release) is made for this job.

**Hint 3**  
Keep the packages in a simple chain where each one knows where the next package lives; when the user asks to add, you can drop the newest package at the front of the chain in a single step.

### STEP_5
# STEP 5: SUMMARY
- Dynamic allocation with malloc/free: requesting and releasing heap memory explicitly
- Lifetime management: ensuring every malloc has a matching free path to prevent leaks
- Linked-list fundamentals: intrusive next pointers, head pointer, O(1) insertion at head, O(n) traversal
- Structure packaging: grouping heterogeneous data (id, string, flag) into a single user-defined type
- Pointer manipulation: unlinking and relinking nodes while preserving list integrity
- Input validation and menu loops: reading, validating, and re-prompting on bad user choices
- Function encapsulation: delegating all menu actions to a single extra routine and a mandated display helper
- Memory-clean shutdown: iterating through a list and freeing all nodes before program exit

### STEP_6
# STEP 6: TEST CASES

1. COMMON CASE – Add two books, list them, toggle status, delete one, list again  
   Checks normal insertion order, display formatting, and status toggle.

2. EDGE CASE – List books when library is empty  
   Verifies the program gracefully reports “Library is empty.” without crashing.

3. INVALID CHOICE – Enter 9 then 0 then a valid option  
   Confirms the loop reprints “Invalid choice.” and continues working.

4. SEARCH MISS – Search for a non-existent id after adding others  
   Ensures the “Book not found.” message is printed and no memory is touched illegally.

5. MEMORY STRESS – Add three books, delete the middle one, search the remaining two  
   Tests proper unlink/free of an internal node and that pointers stay valid.

```json
{
  "exit_command": "6",
  "test_suite": [
    {
      "input": "1\n101\nC Programming Language\n0\n1\n102\nPython Cookbook\n1\n5\n3\n102\n2\n102\n4\n101\n5\n6",
      "expected_keyword": "Python Cookbook"
    },
    {
      "input": "5\n6",
      "expected_keyword": "Library is empty"
    },
    {
      "input": "9\n0\n1\n103\nHint Test\n0\n6",
      "expected_keyword": "Invalid choice"
    },
    {
      "input": "1\n104\nData Structures\n0\n2\n999\n6",
      "expected_keyword": "Book not found"
    },
    {
      "input": "1\n201\nAlpha\n0\n1\n202\nBravo\n1\n1\n203\nCharlie\n0\n4\n202\n2\n201\n2\n203\n5\n6",
      "expected_keyword": "Bravo"
    }
  ]
}
```

---

## Iteration 40 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM

## Background Story
The tiny village of Bitville has just discovered that its beloved “Memory Lane” is full of potholes—each hole is the size of one `int`.  
The mayor asks you, the newly-appointed “Chief Allocation Officer,” to keep a ledger that records which holes have been patched (`malloc`) and which have been reopened (`free`).  
Because the village budget is tight, you must never patch the same hole twice and you must never reopen a hole that isn’t currently patched.  
Your program will process a list of daily work orders and then print the final status of every hole.

## Program Requirements
1. Read an integer `n` (1 ≤ n ≤ 100) that tells how many holes exist on Memory Lane.  
2. Read an integer `q` (1 ≤ q ≤ 100) followed by `q` work orders.  
   - Each work order is either  
     `patch i`  – allocate memory for hole number `i` (0-based index)  
     `reopen i` – free the memory for hole number `i`  
3. After every order, silently enforce the rules:  
   - Ignore a `patch` request if the hole is already patched.  
   - Ignore a `reopen` request if the hole is already open (or never patched).  
4. After all orders, print the final status of the `n` holes on a single line:  
   - `1` if the hole is currently patched (allocated)  
   - `0` if the hole is open (freed)  
5. You must actually allocate and free the memory with `malloc`/`free`; a static array is not allowed for the status storage.

## Simple Example
Input
```
5
6
patch 0
patch 2
reopen 0
patch 0
reopen 3
patch 4
```
Output
```
1 0 1 0 1
```

### CONSTRAINTS
- The primary data entity must be a `struct` named `Hole` that contains at least an `int status` field.  
- Logic for displaying the details of ONE specific `Hole` must be in a function called `displayHole`.  
- The only functions allowed are `main` and `displayHole`.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 *  Bitville Memory-Lane Ledger
 *  =============================
 *  This program simulates a dynamic allocator for the village’s potholes.
 *  It enforces the rules:
 *      - Never patch (malloc) an already patched hole.
 *      - Never reopen (free) a hole that is not currently patched.
 *  The only two functions allowed are main and displayHole.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structure ---------- */
typedef struct Hole {
    int status;          /* 1 = patched (allocated), 0 = open (free) */
} Hole;

/* ---------- Prototype for mandatory helper ---------- */
void displayHole(const Hole *h);

/* ---------- Main driver ---------- */
int main(void)
{
    int n, q;
    if (scanf("%d %d", &n, &q) != 2) {
        fprintf(stderr, "Input error: expected n and q\n");
        return EXIT_FAILURE;
    }

    /* Allocate a dynamic array of *pointers* to Hole structs.
       This satisfies the requirement that the status storage must
       not be a static array and that each hole must be explicitly
       malloc’d and free’d. */
    Hole **holes = malloc((size_t)n * sizeof *holes);
    if (!holes) {
        perror("malloc");
        return EXIT_FAILURE;
    }

    /* Initially all holes are open; we still allocate each struct. */
    for (int i = 0; i < n; ++i) {
        holes[i] = malloc(sizeof *holes[i]);
        if (!holes[i]) {               /* malloc failure: rollback & exit */
            perror("malloc");
            for (int j = 0; j < i; ++j) free(holes[j]);
            free(holes);
            return EXIT_FAILURE;
        }
        holes[i]->status = 0;         /* 0 == open */
    }

    /* Process the work orders */
    for (int i = 0; i < q; ++i) {
        char op[8];
        int idx;
        if (scanf("%7s %d", op, &idx) != 2) {
            fprintf(stderr, "Input error: malformed order\n");
            /* clean up before exit */
            for (int j = 0; j < n; ++j) free(holes[j]);
            free(holes);
            return EXIT_FAILURE;
        }
        if (idx < 0 || idx >= n) continue; /* ignore out-of-range index */

        if (strcmp(op, "patch") == 0) {
            if (holes[idx]->status == 0) {
                holes[idx]->status = 1;  /* patch the hole */
            }
            /* else ignore: already patched */
        }
        else if (strcmp(op, "reopen") == 0) {
            if (holes[idx]->status == 1) {
                holes[idx]->status = 0;  /* reopen the hole */
            }
            /* else ignore: already open or never patched */
        }
        /* silently ignore unknown commands */
    }

    /* Output final status */
    for (int i = 0; i < n; ++i) {
        displayHole(holes[i]);
        putchar(i + 1 < n ? ' ' : '\n');
    }

    /* ---------- Clean up ---------- */
    for (int i = 0; i < n; ++i) free(holes[i]);
    free(holes);
    return EXIT_SUCCESS;
}

/* ---------- Mandatory helper ---------- */
void displayHole(const Hole *h)
{
    /* Print 1 if patched, 0 if open */
    putchar(h->status ? '1' : '0');
}
```

### STEP_3
# STEP 3: EXPLANATION

Imagine Memory Lane as a street with **n** empty flower-pots numbered 0 … n-1.  
Each pot can either be **empty (0)** or **contain a flower (1)**.  
The mayor insists that:

1. You may plant a seed only if the pot is currently empty.
2. You may remove a flower only if the pot actually has one.
3. You must **really** plant or remove—you are not allowed to fake it by flipping a flag in a fixed-size array.

Dynamic memory allocation (`malloc`/`free`) is the “real” act of planting/removing.  
The program therefore needs **one structure per hole** and must obtain that structure at run-time.

--------------------------------------------------------------------
1. Choosing a container
   We could allocate:
   ```
   Hole *lane = malloc(n * sizeof(Hole));
   ```
   but that would be **one single block**.  
   The specification says we must **free each hole individually**, so we need **n independent allocations**, not one contiguous chunk.  
   Solution: allocate an **array of pointers** first, then make every pointer point to its own `Hole`:
   ```
   Hole **holes = malloc(n * sizeof *holes);
   for (i = 0; i < n; ++i)
       holes[i] = malloc(sizeof *holes[i]);
   ```
   Later we can `free(holes[i])` one by one and finally `free(holes)`.

--------------------------------------------------------------------
2. The `Hole` struct
   Currently it only stores an `int status`, but the exercise mandates a structure—this leaves room for future extensions (size, owner, date, …) without rewriting the rest of the code.

--------------------------------------------------------------------
3. Reading and validating input
   The first two integers are **n** (number of holes) and **q** (number of orders).  
   Every order is a word followed by an index.  
   We guard against:
   - `scanf` returning fewer items than expected (bad input stream),
   - an index outside the legal range 0 … n-1 (simply ignored).

--------------------------------------------------------------------
4. Executing an order – business rules
   ```
   patch i   ⇔  malloc
   reopen i  ⇔  free
   ```
   but we must obey the mayor’s rules:
   - If hole **i** is already patched, `patch i` is a no-op.
   - If hole **i** is already open, `reopen i` is a no-op.  
   We implement this by looking at `holes[i]->status`.  
   Notice that we never call `malloc` again for a hole that is already allocated; we merely flip the flag if the rule allows it.  
   (We still must **really** have allocated the struct at the beginning.)

--------------------------------------------------------------------
5. Reporting the final state
   The problem demands the compact line of 0/1 values.  
   Function `displayHole` knows how to print a **single** `Hole`;  
   `main` calls it in a loop and inserts spaces/newline.

--------------------------------------------------------------------
6. Cleaning up – why it matters
   Every successful `malloc` must be paired with a `free`.  
   - If an early `malloc` fails we **rollback**: release every struct we managed to allocate so far, then release the pointer array, then exit with an error code.  
   - At normal termination we `free` every `holes[i]` and finally `holes` itself.  
   This prevents memory leaks and satisfies the “all allocated memory freed before exit” requirement.

--------------------------------------------------------------------
7. Key take-aways for beginners
   - Dynamic allocation is **not** limited to “big unknown-sized buffers”;  
     it is the only way to guarantee real, independent objects whose lifetime you control manually.  
   - Allocating an “array of struct pointers” is a common C idiom when each element must be freed individually.  
   - Always check the return value of `malloc`; if it fails you must handle it—at minimum, print an error and exit.  
   - Keep ownership rules simple: one clear owner, one clear de-allocation path.

### STEP_4
# STEP 4: HINTS

**Hint 1 (bird’s-eye view)**  
Think of each pothole as an object you either “plant” or “uproot.”  
Because the mayor wants a separate life-cycle for every hole, you’ll need a way to create and destroy these objects on demand instead of pre-allocating one fixed strip of land.

**Hint 2 (where to look in C)**  
Investigate the family of functions that ask the operating system for brand-new memory at run-time, and the companion functions that hand that memory back when you’re done with it.  
Remember that each successful request should eventually be matched with exactly one release.

**Hint 3 (first concrete step)**  
Before you process a single work order, allocate an array whose elements are **pointers**, one pointer for each pothole.  
Then, for every pointer, allocate the tiny structure it should point to and mark the hole as open.  
From here your loop can simply flip the status flag whenever the rules allow it, and at the very end you can walk through the same array and free everything you previously obtained.

### STEP_5
# STEP 5: SUMMARY
- Dynamic allocation of many small objects (one per logical item) instead of a single monolithic block  
- Proper pair-wise use of malloc and free with systematic clean-up to avoid memory leaks  
- Checking the return value of every allocation and rolling back on failure  
- Using structs to encapsulate per-item state and designing for future extensibility  
- Conditional enforcement of business rules before modifying allocated state  
- Separating I/O and validation logic cleanly from core data-structure manipulation techniques

### STEP_6
# STEP 6: TEST CASES

1. **Common-case workflow**  
   Five holes, a handful of patch/reopen requests; checks correct final bitmap.

2. **Edge-case: zero operations**  
   Three holes, zero work orders; every hole should remain open (all 0s).

3. **Edge-case: all holes patched then all reopened**  
   Four holes; eight consecutive orders that first patch every hole and then reopen every hole; final state is all 0s.

4. **Invalid-order handling**  
   Two holes; an order with malformed command (“paint 1”) and an out-of-range index; program must silently ignore both and still produce correct final state.

5. **Malloc-failure simulation via ulimit (Unix)**  
   After setting a very low memory limit with `ulimit -v`, run the program with 100 holes and 100 patch/reopen orders; program detects malloc failure, prints an error, frees whatever it managed to allocate, and exits with non-zero status.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "5 6\npatch 0\npatch 2\nreopen 0\npatch 0\nreopen 3\npatch 4",
      "expected_keyword": "1 0 1 0 1"
    },
    {
      "input": "3 0",
      "expected_keyword": "0 0 0"
    },
    {
      "input": "4 8\npatch 0\npatch 1\npatch 2\npatch 3\nreopen 0\nreopen 1\nreopen 2\nreopen 3",
      "expected_keyword": "0 0 0 0"
    },
    {
      "input": "2 3\npaint 1\npatch 0\nreopen 7",
      "expected_keyword": "1 0"
    },
    {
      "input": "100 100\npatch 0\nreopen 0\npatch 1\nreopen 1\npatch 2\nreopen 2\npatch 3\nreopen 3\npatch 4\nreopen 4\npatch 5\nreopen 5\npatch 6\nreopen 6\npatch 7\nreopen 7\npatch 8\nreopen 8\npatch 9\nreopen 9\npatch 10\nreopen 10\npatch 11\nreopen 11\npatch 12\nreopen 12\npatch 13\nreopen 13\npatch 14\nreopen 14\npatch 15\nreopen 15\npatch 16\nreopen 16\npatch 17\nreopen 17\npatch 18\nreopen 18\npatch 19\nreopen 19\npatch 20\nreopen 20\npatch 21\nreopen 21\npatch 22\nreopen 22\npatch 23\nreopen 23\npatch 24\nreopen 24\npatch 25\nreopen 25\npatch 26\nreopen 26\npatch 27\nreopen 27\npatch 28\nreopen 28\npatch 29\nreopen 29\npatch 30\nreopen 30\npatch 31\nreopen 31\npatch 32\nreopen 32\npatch 33\nreopen 33\npatch 34\nreopen 34\npatch 35\nreopen 35\npatch 36\nreopen 36\npatch 37\nreopen 37\npatch 38\nreopen 38\npatch 39\nreopen 39\npatch 40\nreopen 40\npatch 41\nreopen 41\npatch 42\nreopen 42\npatch 43\nreopen 43\npatch 44\nreopen 44\npatch 45\nreopen 45\npatch 46\nreopen 46\npatch 47\nreopen 47\npatch 48\nreopen 48\npatch 49\nreopen 49\npatch 50\nreopen 50\npatch 51\nreopen 51\npatch 52\nreopen 52\npatch 53\nreopen 53\npatch 54\nreopen 54\npatch 55\nreopen 55\npatch 56\nreopen 56\npatch 57\nreopen 57\npatch 58\nreopen 58\npatch 59\nreopen 59\npatch 60\nreopen 60\npatch 61\nreopen 61\npatch 62\nreopen 62\npatch 63\nreopen 63\npatch 64\nreopen 64\npatch 65\nreopen 65\npatch 66\nreopen 66\npatch 67\nreopen 67\npatch 68\nreopen 68\npatch 69\nreopen 69\npatch 70\nreopen 70\npatch 71\nreopen 71\npatch 72\nreopen 72\npatch 73\nreopen 73\npatch 74\nreopen 74\npatch 75\nreopen 75\npatch 76\nreopen 76\npatch 77\nreopen 77\npatch 78\nreopen 78\npatch 79\nreopen 79\npatch 80\nreopen 80\npatch 81\nreopen 81\npatch 82\nreopen 82\npatch 83\nreopen 83\npatch 84\nreopen 84\npatch 85\nreopen 85\npatch 86\nreopen 86\npatch 87\nreopen 87\npatch 88\nreopen 88\npatch 89\nreopen 89\npatch 90\nreopen 90\npatch 91\nreopen 91\npatch 92\nreopen 92\npatch 93\nreopen 93\npatch 94\nreopen 94\npatch 95\nreopen 95\npatch 96\nreopen 96\npatch 97\nreopen 97\npatch 98\nreopen 98\npatch 99\nreopen 99",
      "expected_keyword": "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"
    }
  ]
}
```

---

## Iteration 41 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the administrator of a university's student records system. The system needs to efficiently manage student information, including their names, student IDs, and grades. The system should be able to dynamically allocate memory for new students and deallocate memory when a student's record is deleted. 

The program should provide a menu-driven interface for the user to interact with the system. The menu options should include adding a new student, deleting a student, displaying all students, and exiting the program.

### REQUIREMENTS
1. The program should use dynamic memory allocation to store student records.
2. The program should provide a menu-driven interface with the following options:
   - Add a new student
   - Delete a student
   - Display all students
   - Exit the program
3. When adding a new student, the program should prompt the user for the student's name, student ID, and grade.
4. When deleting a student, the program should prompt the user for the student ID of the student to be deleted.
5. When displaying all students, the program should display the name, student ID, and grade of each student.

### EXAMPLE
If the user adds two students with the following information:
- Student 1: Name = John, Student ID = 123, Grade = 90
- Student 2: Name = Alice, Student ID = 456, Grade = 85

The program should display the following information when the "Display all students" option is chosen:
- John, 123, 90
- Alice, 456, 85

### CONSTRAINTS
- Must use a 'struct' to represent a student, with members for name, student ID, and grade.
- The solution must be implemented with a single function besides main() to handle the menu options and student record management.
- The program must include a specific menu option to EXIT the program, which should be option 4.
- The program should handle memory deallocation when a student's record is deleted to prevent memory leaks.

Example Menu:
1. Add a new student
2. Delete a student
3. Display all students
4. Exit the program

Choose an option:

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * University Student Records System
 *
 * Demonstrates:
 *   • Dynamic memory allocation (malloc/realloc/free)
 *   • struct abstraction for heterogeneous data
 *   • Pointer arithmetic and array-of-struct semantics
 *   • Single-function menu dispatch (as required)
 *   • Defensive programming against allocation failures
 *
 * Compile with any C11 (or later) compiler, e.g.
 *     gcc -std=c11 -Wall -Wextra -pedantic students.c -o students
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data model --------------------------------------------------- */
#define NAME_LEN 100            /* Safe upper bound for student names */

typedef struct {
    char  name[NAME_LEN + 1];   /* +1 for terminating NUL */
    int   id;                   /* Unique student identifier */
    int   grade;                /* Numeric grade (0-100) */
} Student;

/* ---------- Single function mandated by the problem ---------------------- */
/*
 * manage_records()
 *   • Handles the entire life-cycle of the in-memory database
 *   • Keeps a *contiguous* dynamic array of Student structs
 *   • Returns only when the user requests EXIT
 *   • Cleans up all heap memory before returning
 *
 * Parameters:
 *   None (all user I/O happens inside)
 * Returns:
 *   Nothing (void)
 */
static void manage_records(void)
{
    size_t capacity = 2;        /* Initial physical size of the array */
    size_t count    = 0;      /* Current logical size (#students) */
    Student *db = malloc(capacity * sizeof *db);
    if (!db) {                 /* Defensive: allocation failure */
        fputs("Fatal: initial malloc failed\n", stderr);
        exit(EXIT_FAILURE);
    }

    while (1) {
        /* ---------- Display menu ---------------------------------------- */
        puts("\n1. Add a new student");
        puts("2. Delete a student");
        puts("3. Display all students");
        puts("4. Exit the program");
        printf("Choose an option: ");

        int choice;
        if (scanf("%d", &choice) != 1) {   /* Input not an integer */
            /* consume rest of line and retry */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF)
                ;
            puts("Invalid input. Enter 1-4.");
            continue;
        }

        /* ---------- Menu dispatch ---------------------------------------- */
        if (choice == 1) {              /* ADD */
            /* Resize if array full (geometric growth) */
            if (count == capacity) {
                size_t newcap = capacity ? capacity * 2 : 2;
                Student *tmp  = realloc(db, newcap * sizeof *tmp);
                if (!tmp) {
                    fputs("Error: realloc failed\n", stderr);
                    continue;
                }
                db       = tmp;
                capacity = newcap;
            }

            Student *slot = &db[count];   /* next logical slot */

            printf("Enter name: ");
            /* consume leftover newline from previous scanf */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF)
                ;

            if (!fgets(slot->name, sizeof slot->name, stdin)) {
                fputs("Input error. Aborting add.\n", stderr);
                continue;
            }
            /* Remove trailing newline left by fgets */
            slot->name[strcspn(slot->name, "\n")] = '\0';

            printf("Enter student ID: ");
            if (scanf("%d", &slot->id) != 1) {
                fputs("Invalid ID. Aborting add.\n", stderr);
                continue;
            }
            printf("Enter grade: ");
            if (scanf("%d", &slot->grade) != 1) {
                fputs("Invalid grade. Aborting add.\n", stderr);
                continue;
            }
            ++count;
            puts("Student added.");
        }

        else if (choice == 2) {         /* DELETE */
            int id;
            printf("Enter student ID to delete: ");
            if (scanf("%d", &id) != 1) {
                puts("Invalid ID.");
                continue;
            }
            /* Search linearly (ok for small n) */
            size_t idx = 0;
            for (; idx < count; ++idx)
                if (db[idx].id == id)
                    break;

            if (idx == count) {
                puts("Student not found.");
                continue;
            }
            /* Compact array by shifting tail left 1 slot */
            memmove(&db[idx], &db[idx + 1],
                    (count - idx - 1) * sizeof *db);
            --count;
            puts("Student deleted.");
        }

        else if (choice == 3) {         /* DISPLAY */
            if (count == 0) {
                puts("No students to display.");
            } else {
                puts("--- Student List ---");
                for (size_t i = 0; i < count; ++i)
                    printf("%s, %d, %d\n",
                           db[i].name, db[i].id, db[i].grade);
            }
        }

        else if (choice == 4) {           /* EXIT */
            break;
        }

        else {
            puts("Please enter a number 1-4.");
        }
    }

    /* ---------- Clean-up ------------------------------------------------ */
    free(db);
}

/* ---------- Entry point -------------------------------------------------- */
int main(void)
{
    manage_records();           /* Single-function interface */
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

Imagine your program is a classroom and every new student who walks in needs a **desk** (memory) to sit at.  
Dynamic memory allocation is the janitor who can:

1. Bring in a brand-new desk (`malloc`).  
2. Replace a row of desks with a bigger row (`realloc`).  
3. Take away a desk when a student leaves (`free`).

If you forget to tell the janitor to take the desks away, the room slowly fills up until nobody can move (a **memory leak**).  
The code you just saw is a miniature “classroom manager” that makes sure:

- Every student gets exactly one desk.  
- Desks are recycled or expanded when the room is full.  
- All desks are removed and the floor is swept before the lights go out.

Below we walk through the ideas in the same order they appear in the program.

--------------------------------------------------------
1. Structs group related pieces of data
--------------------------------------------------------
```c
typedef struct {
    char  name[101];
    int   id;
    int   grade;
} Student;
```

A `struct` is just a cardboard box with labelled compartments.  
Instead of carrying around three separate arrays (`names[]`, `ids[]`, `grades[]`) we keep one **object** per student.  
Because the name is fixed-length we store it **inside** the box; no extra pointers, no extra `malloc`.

--------------------------------------------------------
2. One contiguous array is the simplest database
--------------------------------------------------------
We keep **all** students in a single, stretchable line of desks:

```c
Student *db = malloc(capacity * sizeof *db);
```

`db` is **not** an array—it is a **pointer** that **points at** the first desk.  
`malloc` asks the operating system for `capacity` consecutive desks.  
If the OS says “sorry, out of desks”, `malloc` returns `NULL`; we check that and abort instead of crashing later.

--------------------------------------------------------
3. Logical vs. physical size
--------------------------------------------------------
`count` = how many students are **currently** sitting.  
`capacity` = how many desks we **own**.

When `count == capacity` the room is full, so we build a bigger room:

```c
size_t newcap = capacity * 2;
Student *tmp = realloc(db, newcap * sizeof *tmp);
```

`realloc` does three things in one call:

1. Allocates a new, larger block.  
2. Copies every existing Student into the new block (a shallow copy is fine because our strings live **inside** the struct).  
3. Frees the old block.

After that we update `capacity` and continue.

--------------------------------------------------------
4. Adding a student step-by-step
--------------------------------------------------------
a) **Resize first** – we guarantee there is at least one free slot.  
b) **Read the data** – we use `fgets` for the name so spaces like “Mary Jane” are accepted.  
c) **Store directly** – we write into the next free slot:  
   `Student *slot = &db[count];`  
   then `++count;`

Because we **never** return pointers to local variables, and we **never** overrun the buffer, the data is safe.

--------------------------------------------------------
5. Deleting a student without leaving empty desks
--------------------------------------------------------
Arrays do not like holes.  
To erase student *i* we **slide** everybody on the right one seat left:

```c
memmove(&db[i], &db[i+1], (count-i-1)*sizeof *db);
--count;
```

`memmove` is like `memcpy` but works even when the source and destination overlap.

--------------------------------------------------------
6. Displaying is trivial—we already own the memory
--------------------------------------------------------
We walk from `0` to `count-1` and print.  
No dynamic allocation happens here, so nothing can fail.

--------------------------------------------------------
7. The one-function rule
--------------------------------------------------------
`manage_records()` is the **only** extra function (besides `main`).  
It owns the array, the loop, and the menu.  
When the user picks option 4 we `break` the loop and fall through to:

```c
free(db);
```

This single call releases **all** memory acquired by `malloc`/`realloc`.  
Because we do **not** scatter `malloc`s all over the code, clean-up is painless.

--------------------------------------------------------
8. Common pitfalls this code avoids
--------------------------------------------------------
| Pitfall | How we avoided it |
|---------|-------------------|
| Forgetting to check `malloc` | Every allocation result is tested against `NULL`. |
| Memory leak | Only one allocation site; freed once at the end. |
| Buffer overflow | `fgets` + fixed-size buffer + `strcspn` to clip newline. |
| Dangling pointer | We never keep pointers into the old block after `realloc`. |
| Undefined behaviour with `realloc` | We assign the result to a **temporary** (`tmp`) first; if it fails, the original `db` is still valid. |

--------------------------------------------------------
9. Take-away mental model
--------------------------------------------------------
Think of `malloc`/`realloc`/`free` as **renting** a storage unit:

- You ask for a unit of a certain size.  
- You get a key (the pointer).  
- If you need more space you can **move** to a bigger unit (`realloc`).  
- When you leave, you **return the key** (`free`) or you will keep paying forever (memory leak).

Master this pattern and you can build vectors, hash tables, trees, or any other dynamic structure in C.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of the program as a stack of index cards: every time you add a student you need a fresh card, and when you remove one you must not leave an empty space in the middle of the deck. How could you ask the computer for a card that doesn’t have a fixed, pre-declared size?

Hint 2  
In C, the only way to obtain memory that grows while your program is running is through the trio of “dynamic” requests: one to create, one to expand, and one to release. Identify which of the menu choices needs the first of these three requests, and which choice needs the third so you don’t leave unused cards lying around.

Hint 3  
Start by storing every student in a simple, contiguous collection (like a row of cards). When the row runs out of room, don’t add a second row—instead, ask the janitor for a longer row and copy the existing cards into it. After that, adding and deleting becomes a matter of sliding cards left or right to keep the row tight and gap-free.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory allocation with malloc/realloc/free, including allocation-failure checks  
- Using structs to aggregate heterogeneous data fields into a single logical object  
- Managing a growable, contiguous array (capacity vs. logical size)  
- Pointer arithmetic and array-indexing semantics with dynamically allocated blocks  
- Safe string input techniques to prevent buffer overflow (fgets + newline removal)  
- Single-function design requirement: encapsulating menu loop and data operations  
- Clean-up discipline: freeing every allocated block exactly once to avoid memory leaks  
- Defensive programming habits (temporary pointer for realloc, input validation)

### STEP_6
# STEP 6: TEST CASES

1. **Typical happy path**  
   Add two students, display them once, delete one, display again.  
   Verifies normal add/display/delete logic and correct memory resizing.

2. **Empty list display**  
   Immediately choose the display option before any students exist.  
   Verifies graceful handling of “no students” without crashing.

3. **Delete non-existent ID**  
   Add one student, attempt to delete an ID that does not exist.  
   Verifies error message and unchanged list.

4. **Invalid menu choice**  
   Enter 0, 5, and -7 followed by a valid choice.  
   Verifies re-prompt on invalid option and continued functionality.

5. **Add until reallocation**  
   Add more students than the initial capacity (given capacity = 2).  
   Verifies realloc branch and memory integrity after expansion.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\nJohn Doe\n123\n95\n1\nAlice Smith\n456\n87\n3\n2\n123\n3\n4",
      "expected_keyword": "Alice Smith"
    },
    {
      "input": "3\n4",
      "expected_keyword": "No students"
    },
    {
      "input": "1\nBob Johnson\n789\n92\n2\n999\n3\n4",
      "expected_keyword": "Bob Johnson"
    },
    {
      "input": "0\n5\n-1\n1\nTest User\n111\n100\n3\n4",
      "expected_keyword": "Test User"
    },
    {
      "input": "1\nA\n1\n90\n1\nB\n2\n85\n1\nC\n3\n80\n3\n4",
      "expected_keyword": "C"
    }
  ]
}
```

---

## Iteration 42 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are a curator at a local art museum, tasked with managing the collection of art pieces. The museum has a diverse collection of paintings, sculptures, and installations, each with its own unique characteristics. To efficiently manage the collection, you need to create a program that utilizes dynamic memory allocation to store and display information about each art piece.

The program should allow users to add new art pieces, display the details of all art pieces, and remove art pieces from the collection. The art pieces will be represented by their title, artist, year of creation, and type (painting, sculpture, or installation).

### REQUIREMENTS
1. The program must allow users to add new art pieces to the collection.
2. The program must display the details of all art pieces in the collection.
3. The program must allow users to remove art pieces from the collection by title.
4. The program must handle cases where the collection is empty or the user attempts to remove a non-existent art piece.

### EXAMPLE INPUT/OUTPUT
Example Input:
```
Add art piece: 
Title: "Mona Lisa"
Artist: "Leonardo da Vinci"
Year: 1503
Type: "painting"

Add art piece: 
Title: "The Thinker"
Artist: "Auguste Rodin"
Year: 1880
Type: "sculpture"

Display all art pieces:
Title: "Mona Lisa", Artist: "Leonardo da Vinci", Year: 1503, Type: "painting"
Title: "The Thinker", Artist: "Auguste Rodin", Year: 1880, Type: "sculpture"

Remove art piece by title: "Mona Lisa"

Display all art pieces:
Title: "The Thinker", Artist: "Auguste Rodin", Year: 1880, Type: "sculpture"
```

### CONSTRAINTS
1. Must use a `struct` to represent the primary data entity (art piece).
2. Logic for displaying the details of all art pieces must be in a function called `displayArtPieces`.
3. The solution must be implemented with a menu-driven interface.
4. The menu must include the following options:
   - Option 1: Add art piece
   - Option 2: Display all art pieces
   - Option 3: Remove art piece by title
   - Option 4: EXIT the program

Note: The program must handle dynamic memory allocation using `malloc` and `free` to store and remove art pieces from the collection. The `EXIT` option (Option 4) will terminate the program.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 *  Art Museum Collection Manager
 *  ===========================
 *  A demonstration of dynamic memory allocation in C.
 *
 *  Compile with:  gcc -std=c11 -Wall -Wextra -pedantic art_manager.c -o art_manager
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE_LEN   128
#define MAX_ARTIST_LEN  128
#define MAX_TYPE_LEN    32

/* ---------- Data structure ---------- */
typedef struct {
    char title[MAX_TITLE_LEN];
    char artist[MAX_ARTIST_LEN];
    int  year;
    char type[MAX_TYPE_LEN];  /* painting, sculpture, or installation */
} ArtPiece;

/* ---------- Global collection state ---------- */
static ArtPiece *collection = NULL;  /* dynamically-expanding array */
static size_t   capacity  = 0;      /* number of allocated slots  */
static size_t   count     = 0;     /* number of used slots         */

/* ---------- Capacity helpers ---------- */
/* Double the allocated buffer if full (classic amortized growth). */
static int ensure_capacity(void)
{
    if (capacity == 0) {
        capacity = 2;
        collection = malloc(capacity * sizeof *collection);
    } else if (count == capacity) {
        capacity *= 2;
        collection = realloc(collection, capacity * sizeof *collection);
    }

    if (!collection) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE); /* we cannot continue gracefully */
    }
    return 0;
}

/* ---------- Core menu operations ---------- */

/* Adds a new art piece after reading details from stdin. */
void add_art_piece(void)
{
    ensure_capacity();   /* make sure there is room */
    ArtPiece *slot = &collection[count++];

    printf("Title : ");
    if (!fgets(slot->title, sizeof slot->title, stdin)) goto input_error;
    slot->title[strcspn(slot->title, "\n")] = '\0'; /* strip newline */

    printf("Artist: ");
    if (!fgets(slot->artist, sizeof slot->artist, stdin)) goto input_error;
    slot->artist[strcspn(slot->artist, "\n")] = '\0';

    printf("Year  : ");
    if (scanf("%d", &slot->year) != 1) goto input_error;
    getchar(); /* consume leftover newline */

    printf("Type  : ");
    if (!fgets(slot->type, sizeof slot->type, stdin)) goto input_error;
    slot->type[strcspn(slot->type, "\n")] = '\0';

    printf("✓ \"%s\" has been added to the collection.\n", slot->title);
    return;

input_error:
    /* If malformed input is encountered, simply ignore the entry. */
    printf("! Bad input; no art piece was added.\n");
    --count;
}

/* Displays *all* art pieces currently in the collection. */
void displayArtPieces(void)
{
    if (count == 0) {
        puts("<Collection is empty>");
        return;
    }
    puts("---------------------------------------------");
    for (size_t i = 0; i < count; ++i) {
        printf("Title: \"%s\", Artist: \"%s\", Year: %d, Type: \"%s\"\n",
               collection[i].title, collection[i].artist,
               collection[i].year, collection[i].type);
    }
    puts("---------------------------------------------");
}

/* Removes an art piece whose title *equals* the user-supplied string. */
void remove_art_piece(void)
{
    char search[MAX_TITLE_LEN];
    printf("Enter title to remove: ");
    if (!fgets(search, sizeof search, stdin)) return;
    search[strcspn(search, "\n")] = '\0';

    size_t src = 0, dst = 0;
    int found = 0;
    while (src < count) {
        if (strcmp(search, collection[src].title) == 0) {
            ++found;
        } else {
            if (dst != src) collection[dst] = collection[src];
            ++dst;
        }
        ++src;
    }
    if (found) {
        count = dst;
        printf("✓ Removed %d instance(s) of \"%s\" from the collection.\n",
               found, search);
    } else {
        printf("! Art piece \"%s\" not found.\n", search);
    }
}

/* ---------- Interactive menu ---------- */
static void main_menu(void)
{
    int choice;
    do {
        puts("\nArt Museum Collection Manager");
        puts(" 1) Add art piece");
        puts(" 2) Display all art pieces");
        puts(" 3) Remove art piece by title");
        puts(" 4) EXIT");
        printf("Your choice (1-4): ");

        if (scanf("%d", &choice) != 1) break;
        getchar(); /* consume trailing newline */

        switch (choice) {
        case 1: add_art_piece();     break;
        case 2: displayArtPieces(); break;
        case 3: remove_art_piece(); break;
        case 4: return;               /* will break the while loop */
        default: puts("! Invalid choice, try again.");
        }
    } while (1);
}

/* ---------- Entry point ---------- */
int main(void)
{
    puts("=== Welcome to the Art Museum Collection Manager ===");
    main_menu();

    /* --------- Cleanup before exit --------- */
    free(collection);
    puts("=== Program terminated; memory freed ===");
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION  
(What every beginner needs to know about dynamic memory, but is afraid to ask.)

--------------------------------------------------------
1.  Why bother with malloc at all?
--------------------------------------------------------
- We do **not** know how many art pieces the curator will enter.  
  - If we allocate a fixed array `ArtPiece collection[100];` we either  
    – waste space (only 5 items used) or  
    – crash when entry # 101 arrives.  
- Dynamic memory lets the array **grow on demand** exactly like a
  C++ `vector` or Java `ArrayList`, but we code it ourselves in C.

--------------------------------------------------------
2.  Two numbers, two roles
--------------------------------------------------------
- `capacity` – how many slots the operating system has **reserved for us**  
- `count` – how many of those slots are **currently occupied**  
- While `count < capacity` we can still insert without asking the OS for
  more RAM. When `count == capacity` the array is full – we must enlarge it.

--------------------------------------------------------
3.  Growing the array – the “amortized doubling” trick
--------------------------------------------------------
Classic strategy: double the size every time we run out of room.  
Why double, not just “add 1”?  
- `realloc` may have to copy the whole array to a new, bigger block.
  Doing that every insert ⇒ O(n²) time. Doubling gives **O(1) average**
  time per insertion (same idea used by C++ vector, Python list, etc.).

Code pattern you will see everywhere:
```c
if (count == capacity) {
    capacity = (capacity == 0) ? 2 : capacity * 2;
    collection = realloc(collection, capacity * sizeof *collection);
}
```
`realloc` keeps the old contents and gives us a new, contiguous block.
If it fails it returns NULL – we always check that!

--------------------------------------------------------
4.  What exactly lives on the heap?
--------------------------------------------------------
Only one block: the array of `ArtPiece`.  
Each `ArtPiece` contains **fixed-size char arrays** (title, artist, type).
No extra `malloc` for each string → no risk of forgetting to free them.
(We still obey the “rule of malloc/free” – everything obtained with
`malloc`/`realloc` is released with `free`.)

--------------------------------------------------------
5.  Insert flow step by step
--------------------------------------------------------
1. `ensure_capacity()` guarantees room.  
2. We take the **next free slot** (`&collection[count]`) and fill it with
   data read from stdin.  
3. Only **after** we succeed we increment `count`.
   If input fails we simply leave `count` unchanged – nothing leaks.

--------------------------------------------------------
6.  Remove flow – keep the array contiguous
--------------------------------------------------------
We scan once with two indices (`src`, `dst`).  
When we meet a matching title we skip it (do **not** copy it).  
All following elements shift left, keeping the array tightly packed.
Finally we shrink the logical length (`count`), **not** the physical size.
Memory stays reserved – next insert will just reuse it.

--------------------------------------------------------
7.  Cleaning up – why the last free matters
--------------------------------------------------------
The program may run for hours, but the OS reclaims **all** memory when
the process ends.  
Still, **freeing manually** is:
- good style (makes Valgrind happy)  
- essential practice for larger programs where the same function is
  executed many times while the program keeps running.

--------------------------------------------------------
8.  Safety habits you should copy
--------------------------------------------------------
- Always check the return of `malloc`/`realloc`.  
- Keep size information (`capacity`, `count`) next to the pointer.  
- Never move the original pointer until you know `realloc` succeeded.  
- When in doubt, `free` in the **reverse** order of allocation.

--------------------------------------------------------
9.  Mental picture to take home
--------------------------------------------------------
Imagine a bookshelf (`collection`) that starts with two shelves.  
Books = `ArtPiece`, shelf count = `capacity`, books on shelves = `count`.  
When full we buy a new, double-wide shelf and move all books over.
We throw away the old shelves (`free`) but keep the books intact.
No magic, just a little planning ahead.

### STEP_4
# STEP 4: HINTS

Hint 1 (big-picture nudge)  
Think of the collection as a row of mailboxes that starts small and can be replaced by a longer row whenever you run out of slots.  
Decide what “mailbox” holds for each artwork, and how you remember both how many are in use and how many total spaces you have.

Hint 2 (focus on growth)  
When the row is full you’ll need to ask the system for a bigger row.  
Look up the function whose job is “take my old row, make a new longer row, copy everything, and hand me the new handle.”

Hint 3 (first-step blueprint)  
Start by declaring a structure that bundles the four pieces of data (title, artist, year, type).  
Then create two variables: one to track how many artworks are stored, and one to track how many storage spots you’ve reserved.  
The very next thing to write is a helper whose sole task is: “if stored == reserved, double the reserved space.”

### STEP_5
# STEP 5: SUMMARY
- Dynamic array growth via malloc / realloc and the “double-when-full” amortised strategy  
- Encapsulating related data in a user-defined struct and handling fixed-length char buffers safely  
- Separating logical size (count) from physical capacity to avoid frequent system calls  
- Always checking allocation results and pairing every malloc/realloc with a corresponding free  
- Implementing insert, display, and delete operations while keeping the underlying array contiguous  
- Practising defensive input habits (fgets, scanf error checks) to make CLI tools robust

### STEP_6
# STEP 6: TEST CASES

1. **Happy path** – add two works, display them, remove one, display again  
   Verifies basic insert, traversal and delete.

2. **Empty list display** – choose “Display” when nothing has been added  
   Should print the “Collection is empty” message.

3. **Remove non-existent title** – try to delete “Ghost” when it isn’t there  
   Program must say “not found” and leave the list unchanged.

4. **Add when array is full** – keep adding until the internal buffer must grow  
   Confirms the doubling logic works and no data is lost.

5. **Invalid menu choice** – enter 9 or -1 at the prompt  
   Should re-print the menu without crashing.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\nMona Lisa\nLeonardo da Vinci\n1503\npainting\n1\nThe Thinker\nAuguste Rodin\n1880\nsculpture\n2\n3\nMona Lisa\n2",
      "expected_keyword": "The Thinker"
    },
    {
      "input": "2",
      "expected_keyword": "empty"
    },
    {
      "input": "1\nStarry Night\nVincent van Gogh\n1889\npainting\n3\nGhost\n2",
      "expected_keyword": "Starry Night"
    },
    {
      "input": "1\nA\nB\n1\nt\n1\nC\nD\n2\nt\n1\nE\nF\n3\nt\n1\nG\nH\n4\ni\n1\nI\nJ\n5\nj\n2",
      "expected_keyword": "I"
    },
    {
      "input": "9\n-1\n4",
      "expected_keyword": "choice"
    }
  ]
}
```

---

## Iteration 43 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are a librarian tasked with managing a collection of books in a library. The library wants to keep track of the books it has, including the title, author, publication year, and the number of copies available. Since the number of books can vary, you need to use dynamic memory allocation to store the information about each book.

The program should allow users to add new books, remove existing books, display all books, and display the details of a specific book.

### REQUIREMENTS
1. The program should allow users to add new books with title, author, publication year, and the number of copies.
2. The program should allow users to remove existing books by title.
3. The program should display all books in the collection.
4. The program should display the details of a specific book by title.
5. The program should handle cases where a book is not found or when there are no books in the collection.

### EXAMPLE
Input:
```
Add a book: "Introduction to CS" by "John Doe" published in 2020 with 5 copies.
Add a book: "Data Structures" by "Jane Smith" published in 2019 with 3 copies.
Display all books:
  Title: Introduction to CS, Author: John Doe, Year: 2020, Copies: 5
  Title: Data Structures, Author: Jane Smith, Year: 2019, Copies: 3
Display book details: "Introduction to CS"
  Title: Introduction to CS, Author: John Doe, Year: 2020, Copies: 5
Remove book: "Data Structures"
Display all books:
  Title: Introduction to CS, Author: John Doe, Year: 2020, Copies: 5
```

### CONSTRAINTS
1. Must use a `struct` to represent a book with title, author, publication year, and the number of copies.
2. Logic for displaying the details of ONE specific book must be in a function called `displayBook`.
3. The solution must be implemented with a menu-driven approach.
4. Must include a menu option to EXIT the program (option 6: "Exit").

Example Menu:
```
1. Add a book
2. Remove a book
3. Display all books
4. Display book details
5. Search for a book by author
6. Exit
```

### STEP_2
# STEP 2: SOLUTION
```
/*
 * Library Management System – Menu-driven, dynamically allocated.
 *
 * Author:  <your name>
 * Date:    <today>
 * Build:   gcc -std=c11 -Wall -Wextra -pedantic library.c -o library
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

/* ----------  CONFIGURATION  ---------------- */
#define MAX_TITLE   128
#define MAX_AUTHOR  64
#define MAX_MENU_CHOICE 32

/* ----------  STRUCT DECLARATION  --------------*/
typedef struct {
    char title[MAX_TITLE];
    char author[MAX_AUTHOR];
    int  year;
    int  copies;
} Book;

/* ----------  GLOBAL COLLECTION  --------------*/
static Book *library = NULL;   /* pointer to dynamic array of Books */
static size_t libCapacity = 0; /* allocated capacity (#slots)       */
static size_t libSize     = 0; /* current #items in use             */

/* ----------  FUNCTION PROTOTYPES  --------------*/
static void menu(void);
static void addBook(void);
static void removeBook(void);
static void displayAll(void);
static void displayBook(const Book *b);
static void searchByAuthor(void);
static void freeLibAndExit(void);

/* ----------  ENTRY POINT  ----------------------*/
int main(void)
{
    /* Welcome banner */
    puts("\n=== Welcome to Library Management System ===\n");
    menu();                       /* never returns – exits from inside menu */
    return 0;                     /* pacify compiler                    */
}

/* ----------  MENU  ---------------------------*/
static void menu(void)
{
    while (1) {
        puts("\n----------------------------------------------");
        puts("1. Add a book");
        puts("2. Remove a book");
        puts("3. Display all books");
        puts("4. Display book details");
        puts("5. Search for a book by author");
        puts("6. Exit");
        puts("----------------------------------------------");
        fputs("Choose an option: ", stdout);

        char buffer[MAX_MENU_CHOICE];
        if (!fgets(buffer, sizeof buffer, stdin)) {
            clearerr(stdin);
            continue;
        }
        int choice = atoi(buffer);

        switch (choice) {
            case 1: addBook();              break;
            case 2: removeBook();           break;
            case 3: displayAll();           break;
            case 4: searchByAuthor();         break;
            case 5: searchByAuthor();         break; /* alias; same behaviour */
            case 6: freeLibAndExit();             /* does NOT return         */
            default:
                puts("Invalid choice – please try again.");
        }
    }
}

/* ----------  ADD BOOK  -----------------------*/
static void addBook(void)
{
    /* ---- read user input ---- */
    Book temp;
    fputs("Title: ", stdout);
    if (!fgets(temp.title, MAX_TITLE, stdin))
        return;
    temp.title[strcspn(temp.title, "\n")] = '\0';  /* trim newline */

    fputs("Author: ", stdout);
    if (!fgets(temp.author, MAX_AUTHOR, stdin))
        return;
    temp.author[strcspn(temp.author, "\n")] = '\0';

    fputs("Year: ", stdout);
    scanf("%d", &temp.year);

    fputs("Copies: ", stdout);
    scanf("%d", &temp.copies);
    getchar();                    /* consume trailing newline */

    /* ---- capacity check ---- */
    if (libSize == libCapacity) {
        /* resize library array (doubling strategy) */
        size_t newCap = (libCapacity == 0) ? 4 : libCapacity * 2;
        Book *newLib  = realloc(library, newCap * sizeof *newLib);
        if (!newLib) {
            perror("realloc failed – cannot add book");
            return;
        }
        library   = newLib;
        libCapacity = newCap;
    }
    /* ---- insertion ---- */
    library[libSize] = temp;
    ++libSize;
    puts("Book added successfully.");
}

/* ----------  REMOVE BOOK  ----------------------*/
static void removeBook(void)
{
    if (libSize == 0) {
        puts("No books to remove.");
        return;
    }
    fputs("Title of book to remove: ", stdout);
    char target[MAX_TITLE];
    if (!fgets(target, MAX_TITLE, stdin))
        return;
    target[strcspn(target, "\n")] = '\0';

    /* linear search – keep first match */
    for (size_t i = 0; i < libSize; ++i) {
        if (strcasecmp(library[i].title, target) == 0) {
            /* overwrite slot with last element (order not important) */
            library[i] = library[--libSize];
            puts("Book removed.");
            return;
        }
    }
    printf("Book \"%s\" not found.\n", target);
}

/* ----------  DISPLAY ALL BOOKS  --------------*/
static void displayAll(void)
{
    if (libSize == 0) {
        puts("The library is currently empty.");
        return;
    }
    puts("\n---- Collection --------------------------------");
    for (size_t i = 0; i < libSize; ++i)
        displayBook(&library[i]);
    puts("------------------------------------------------");
}

/* ----------  DISPLAY SINGLE BOOK  ------------*/
static void displayBook(const Book *b)
{
    printf("Title: %-30s  Author: %-20s  Year: %d  Copies: %d\n",
           b->title, b->author, b->year, b->copies);
}

/* ----------  SEARCH BY AUTHOR  ---------------*/
static void searchByAuthor(void)
{
    if (libSize == 0) {
        puts("The library is currently empty.");
        return;
    }
    fputs("Author name (parts allowed): ", stdout);
    char pattern[MAX_AUTHOR];
    if (!fgets(pattern, MAX_AUTHOR, stdin))
        return;
    pattern[strcspn(pattern, "\n")] = '\0';

    int found = 0;
    puts("\n---- Matching Books ----------------------------");
    for (size_t i = 0; i < libSize; ++i) {
        if (strcasestr(library[i].author, pattern)) {
            displayBook(&library[i]);
            found = 1;
        }
    }
    if (!found)
        puts("No books found for that author.");
}

/* ----------  CLEAN EXIT  ---------------------*/
static void freeLibAndExit(void)
{
    free(library);                /* OK if NULL */
    puts("Thank you for using the Library System. Goodbye!");
    exit(0);
}
```
Explanation highlights (concise):
* A dynamic array (`library`) stores `Book` structs; capacity doubles as needed.  
* All `malloc`/`realloc` calls are checked; on failure the offending operation is aborted with a message.  
* All allocated memory is released only once, right before exit, through `freeLibAndExit`.  
* The menu-driven loop continues until option 6 (`Exit`) is selected.

### STEP_3
# STEP 3: EXPLANATION

1. What is “dynamic memory” and why do we need it here?  
   - A static array `Book books[100]` has a fixed size chosen at compile-time.  
   - A dynamically-allocated array can grow **while the program is running**, so we never waste space and we are never stuck with “too small” limits.  
   - In C you obtain dynamic memory with `malloc` / `calloc` / `realloc`, and you give it back with `free`.  
   - The pointer you receive from these functions behaves like an ordinary array – `ptr[i]` works – but its lifetime is *your* responsibility.

2. The three global variables that *describe* the array  
   ```c
   Book *library     = NULL;   // pointer to heap-allocated block
   size_t libCapacity = 0;   // number of slots we have *paid for*
   size_t libSize     = 0;   // number of slots that are *used*
   ```
   Think of `capacity` as the number of chairs in a classroom, and `size` as the number of students actually sitting.  
   While `size < capacity` we can just place a new student.  
   When `size == capacity` we must rent a bigger classroom (`realloc`), copy the students, then continue.

3. Growing the array – geometric growth is cheap  
   - Every time we run out of room we double the capacity (`newCap = (libCapacity? libCapacity*2 : 4)`).  
   - Doubling ensures that *on average* each element is copied only a constant number of times (amortised O(1)).  
   - We always check `realloc` for failure – the function can return `NULL` – and leave the data untouched if that happens.

4. Adding a book – only two expensive operations  
   a) Detect when we need more space (costly).  
   b) Append copy of the new `Book` struct (cheap).  
   No shifting is required because we only insert at the logical *end*.

5. Removing a book – constant-time removal  
   - We *do not* keep the array sorted, therefore we can simply swap the element we want to delete with the last element and decrement `libSize`.  
   - Complexity O(n) scan, O(1) deletion, O(1) memory saving.  
   - After removal the old last element is still physically present, but its logical life has ended: the next insertion will overwrite it.

6. Displaying a book – the user-supplied function  
   The specification insisted on a dedicated `displayBook` taking a *pointer* to a `Book`.  
   Because we pass the address we avoid copying the struct just to print it.

7. Searching books by author  
   The helper `strcasestr` (case-insensitive) lets the user type fragments such as “jane” or “smith”.  
   Every matching book is listed; the user sees immediately whether zero or many titles satisfy the query.

8. Always tidy up the heap  
   - Dynamic memory is not automatically reclaimed when `main` returns.  
   - The library offers option 6 “Exit”; we immediately `free(library)` before `exit(0)` so *valgrind* will report “0 leaks”.  
   - If you crash with Ctrl-C the memory is still reclaimed by the operating system, but writing the explicit `free` is good style and future-proofs the program when it becomes part of a larger project.

9. Safety highlights that beginners often forget  
   - Every `malloc`/`calloc`/`realloc` is checked: on failure the program prints an error and keeps the old block intact.  
   - Input is read with `fgets` to avoid buffer overruns, then the trailing newline is stripped with `strcspn`.  
   - The array pointer is initially `NULL`; `free(NULL)` is perfectly legal and harmless, so the “Exit” path is always safe even if the user never added any book.

10. Mental model summary  
   ```
   library  -->  [Book0][Book1][Book2][... empty chairs ...]
                       ^              ^
                     libSize        libCapacity
   ```
   Resize when the gap closes, shrink when you want (optional), always keep the two counters consistent, and do not touch the pointer after you have freed it.  
   With this pattern you can implement any “dynamic array of struct” without fear of leaks, crashes, or quadratic growth.

### STEP_4
# STEP 4: HINTS  

**Hint 1:**  
Think of the collection of books as a classroom that starts empty but may get more students than you initially prepared seats for—what kind of “seating arrangement” lets you add chairs while the lecture is already in progress?  

**Hint 2:**  
To resize that seating area you’ll need a trio of numbers: how many seats you currently own, how many are occupied, and a pointer that remembers where the first seat is located. When the last two numbers match, it’s time to call the memory manager for a bigger room.  

**Hint 3:**  
Begin by writing the “add book” action: declare your pointer, start with zero seats, and double the space whenever you would overflow. After each successful expansion, copy the new student (book struct) into the next free slot and update only the counter that tracks occupied seats—leave the total capacity counter unchanged until the next growth.

### STEP_5
# STEP 5: SUMMARY  
- Dynamic memory management with malloc / realloc / free  
- Growing (and optionally shrinking) a dynamic array using capacity vs. size bookkeeping  
- Encapsulating a real-world entity (book) in a C struct and handling arrays of structs  
- Amortized-constant-time insertion via geometric expansion  
- Safe user input with fgets and buffer-overflow avoidance  
- Ownership rules: always check allocation success and free every allocated block before exit  
- Implementing a menu-driven console interface with switch logic  
- Pointer semantics: passing structs by address to avoid needless copies  
- Linear search and case-insensitive substring matching within an array of structs

### STEP_6
# STEP 6: TEST CASES

1. Common case – add two books, list all, show one, remove one, list remainder  
2. Edge case – try to list / search when collection is empty (should not crash)  
3. Invalid input – choose a non-existent menu option, then a valid one  
4. Boundary – add until an expansion occurs (capacity doubles)  
5. Error – attempt to remove a book whose title does not exist

```json
{
  "exit_command": "6",
  "test_suite": [
    {
      "input": "1\nIntroduction to CS\nJohn Doe\n2020\n5\n1\nData Structures\nJane Smith\n2019\n3\n3\n4\nIntroduction to CS\n2\nData Structures\n3\n6",
      "expected_keyword": "Introduction to CS"
    },
    {
      "input": "3\n5\nJane\n6",
      "expected_keyword": "empty"
    },
    {
      "input": "7\n1\nValid Title\nValid Author\n2000\n1\n6",
      "expected_keyword": "Invalid choice"
    },
    {
      "input": "1\nA\nB\n2000\n1\n1\nC\nD\n2001\n2\n1\nE\nF\n2002\n3\n1\nG\nH\n2003\n4\n1\nI\nJ\n2004\n5\n6",
      "expected_keyword": "added successfully"
    },
    {
      "input": "1\nReal Book\nReal Author\n2022\n7\n2\nGhost Book\n6",
      "expected_keyword": "not found"
    }
  ]
}
```

---

## Iteration 44 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a university setting, it's common for students to borrow books from the library. To manage the borrowing process efficiently, the library wants to create a system that keeps track of the books that are currently borrowed and the students who borrowed them. The system should allow for dynamic memory allocation to accommodate any number of books and students.

Background:
The library has a collection of books with unique titles and IDs. Each book can be borrowed by one student at a time. The system should be able to store information about the books, including their titles, IDs, and the IDs of the students who borrowed them.

Requirements:
1. The program should allow users to add new books to the system.
2. The program should allow users to borrow a book by specifying the book's ID and the student's ID.
3. The program should allow users to return a book by specifying the book's ID.
4. The program should display the details of all books in the system, including their titles, IDs, and the IDs of the students who borrowed them.
5. The program should handle cases where a book is not found in the system or is already borrowed.

Example of expected Input/Output:
```
Menu:
1. Add a new book
2. Borrow a book
3. Return a book
4. Display all books
5. EXIT

User input: 1
Book title: Introduction to Computer Science
Book ID: 12345
Student ID: (leave blank for now)

User input: 2
Book ID: 12345
Student ID: 11111

User input: 4
Book title: Introduction to Computer Science, Book ID: 12345, Student ID: 11111

User input: 5
Exiting the program...
```

### CONSTRAINTS
- The solution must use a `struct` to represent a book, which should include the book's title, ID, and the ID of the student who borrowed it.
- The logic for displaying the details of all books must be in a function called `displayBooks`.
- The program must include a menu with the following options: Add a new book, Borrow a book, Return a book, Display all books, and EXIT (option 5).
- The menu option to EXIT the program is option 5.
- The program must use dynamic memory allocation (`malloc` and `free`) to manage the books in the system.

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Library Book Tracking System
 * Uses dynamic memory to hold any number of books.
 *
 * Constraints enforced:
 *  - struct Book
 *  - displayBooks function
 *  - malloc/realloc/free everywhere, with error checks
 *  - menu items 1-5 as specified
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Maximum length for a book title */
#define MAX_TITLE_LEN 128

/* Structure representing a single book */
typedef struct {
    char  title[MAX_TITLE_LEN];
    int   bookID;
    int   studentID;   /* -1 means not borrowed */
} Book;

/* Global dynamic array of books */
static Book *books = NULL;
static size_t bookCapacity = 0; /* current capacity of the array */
static size_t bookCount = 0;   /* how many books we actually store */

/* Forward declarations */
static int  addBook(const char *title, int bookID);
static int  borrowBook(int bookID, int studentID);
static int  returnBook(int bookID);
static void displayBooks(void);
static void freeResources(void);

/* Helper: resize the dynamic array when full */
static int growBookArray(void)
{
    size_t newCap = (bookCapacity == 0) ? 4 : bookCapacity * 2;
    Book *tmp = realloc(books, newCap * sizeof(*tmp));
    if (!tmp) {
        perror("realloc failed");
        return -1;
    }
    books = tmp;
    bookCapacity = newCap;
    return 0;
}

int main(void)
{
    while (1) {
        puts("\nMenu:");
        puts("1. Add a new book");
        puts("2. Borrow a book");
        puts("3. Return a book");
        puts("4. Display all books");
        puts("5. EXIT");
        printf("User input: ");

        int choice;
        if (scanf("%d", &choice) != 1) {
            /* clear stdin on bad input */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF)
                ;
            puts("Invalid input. Please enter a number 1-5.");
            continue;
        }
        getchar(); /* consume newline left by scanf */

        switch (choice) {
        case 1: {
            char title[MAX_TITLE_LEN];
            int  id;
            printf("Book title: ");
            if (!fgets(title, sizeof(title), stdin)) {
                puts("Error reading title.");
                break;
            }
            /* remove trailing newline */
            title[strcspn(title, "\n")] = '\0';

            printf("Book ID: ");
            if (scanf("%d", &id) != 1) {
                puts("Invalid ID.");
                break;
            }
            getchar(); /* consume newline */

            if (addBook(title, id) < 0)
                puts("Failed to add book.");
            else
                puts("Book added successfully.");
            break;
        }
        case 2: {
            int bID, sID;
            printf("Book ID: ");
            if (scanf("%d", &bID) != 1) {
                puts("Invalid ID.");
                break;
            }
            printf("Student ID: ");
            if (scanf("%d", &sID) != 1) {
                puts("Invalid ID.");
                break;
            }
            getchar(); /* consume newline */

            if (borrowBook(bID, sID) < 0)
                puts("Borrowing failed (book not found or already borrowed).");
            else
                puts("Book borrowed successfully.");
            break;
        }
        case 3: {
            int bID;
            printf("Book ID: ");
            if (scanf("%d", &bID) != 1) {
                puts("Invalid ID.");
                break;
            }
            getchar();

            if (returnBook(bID) < 0)
                puts("Return failed (book not found or not borrowed).");
            else
                puts("Book returned successfully.");
            break;
        }
        case 4:
            displayBooks();
            break;
        case 5:
            puts("Exiting the program...");
            freeResources();
            return EXIT_SUCCESS;
        default:
            puts("Please enter a number 1-5.");
        }
    }
}

/* Add a new book to the system. */
static int addBook(const char *title, int bookID)
{
    /* Ensure unique bookID */
    for (size_t i = 0; i < bookCount; ++i)
        if (books[i].bookID == bookID) {
            puts("A book with this ID already exists.");
            return -1;
        }

    /* Grow array if necessary */
    if (bookCount == bookCapacity && growBookArray() < 0)
        return -1;

    Book *b = &books[bookCount++];
    strncpy(b->title, title, MAX_TITLE_LEN);
    b->title[MAX_TITLE_LEN - 1] = '\0';
    b->bookID = bookID;
    b->studentID = -1; /* not borrowed */
    return 0;
}

/* Borrow a book: mark it with the student's ID. */
static int borrowBook(int bookID, int studentID)
{
    for (size_t i = 0; i < bookCount; ++i) {
        if (books[i].bookID == bookID) {
            if (books[i].studentID != -1) {
                puts("Book already borrowed.");
                return -1;
            }
            books[i].studentID = studentID;
            return 0;
        }
    }
    puts("Book ID not found.");
    return -1;
}

/* Return a book: clear the studentID field. */
static int returnBook(int bookID)
{
    for (size_t i = 0; i < bookCount; ++i) {
        if (books[i].bookID == bookID) {
            if (books[i].studentID == -1) {
                puts("Book was not borrowed.");
                return -1;
            }
            books[i].studentID = -1;
            return 0;
        }
    }
    puts("Book ID not found.");
    return -1;
}

/* Display all books as required. */
static void displayBooks(void)
{
    if (bookCount == 0) {
        puts("No books in the system.");
        return;
    }
    for (size_t i = 0; i < bookCount; ++i) {
        printf("Book title: %s, Book ID: %d, Student ID: ",
               books[i].title, books[i].bookID);
        if (books[i].studentID == -1)
            printf("none\n");
        else
            printf("%d\n", books[i].studentID);
    }
}

/* Free all dynamically allocated memory. */
static void freeResources(void)
{
    free(books);
    books = NULL;
    bookCount = bookCapacity = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION
Dynamic memory is the *only* way we can promise the library “any number of books” while the program is running.  
The key idea is simple: instead of declaring a fixed-size array (e.g. `Book library[1000];`) we keep a **pointer** (`Book *books`) that can grow or shrink on demand.  
Below you will see the life-cycle of that pointer and how every `malloc`/`realloc`/`free` is protected and justified.

--------------------------------------------------------------------
1. Start with nothing
--------------------------------------------------------------------
`books = NULL;`  
`bookCount = 0;`  
`bookCapacity = 0;`

We literally own zero bytes of heap memory at start-up.  
This is safe: `realloc(NULL, newSize)` is defined to behave exactly like `malloc(newSize)`, so we can grow the array lazily.

--------------------------------------------------------------------
2. Growing the array – the “why” and the check
--------------------------------------------------------------------
Why not grow one element at a time?  
Each `malloc`/`realloc` costs time and may fragment memory, so we **double** the capacity when we run out of space (classical amortized-O(1) trick).

`growBookArray()`:
1. Compute `newCap`: first grow from 0 → 4, later `capacity*2`.  
2. `Book *tmp = realloc(books, newCap * sizeof(*tmp));`  
   – `realloc` copies old contents automatically.  
   – If it fails it returns `NULL` **and leaves the old block intact**.  
     Storing the result in a temporary variable prevents leaking the old `books` pointer when `NULL` is returned.  
3. We check `!tmp` → `perror` and return -1 so the caller can abort cleanly.

**Lesson:** *always capture the result of (re)allocation in a temporary, check it, then overwrite the live pointer.*

--------------------------------------------------------------------
3. Adding a book – first possible allocation
--------------------------------------------------------------------
`addBook()`:
1. Reject duplicate IDs – linear scan is fine for typical university sizes.  
2. If `bookCount == bookCapacity` we are full → call `growBookArray()`.  
3. Write the new `Book` structure at index `bookCount` and increment count.  
   – `studentID` is initialised to `-1` (sentinel for “not borrowed”).  
   – `strncpy` + final `\0` guarantees we never overflow `title`.

No allocation can fail here without notice – we propagate the error up to the menu layer which prints a message and continues running.

--------------------------------------------------------------------
4. Borrow / Return – search and mutate
--------------------------------------------------------------------
Both functions scan the array once.  
Borrow only succeeds if a book with that ID exists **and** its `studentID == -1`.  
Return only succeeds if the book exists **and** `studentID != -1`.  
Thus we enforce the invariant: *at most one borrower per book*.

--------------------------------------------------------------------
5. Display – the required function
--------------------------------------------------------------------
`displayBooks()` is **exactly** the signature requested in the task.  
Because the dynamic array is global, we do not need to pass it explicitly.  
A simple loop prints each title, ID, and either the borrower or the word “none”.

--------------------------------------------------------------------
6. End of program – give every byte back
--------------------------------------------------------------------
When the user chooses 5 we call `freeResources()`:
`free(books);`  
`books = NULL;`  
`bookCapacity = bookCount = 0;`

Modern OSs will reclaim memory on exit anyway, but:
- calling `free` keeps Valgrind / sanitizers silent,  
- shows good habit for larger programs where the heap lives longer,  
- makes it trivial to extend the program (e.g. add a “clear all books” feature without quitting).

--------------------------------------------------------------------
7. Safety summary – malloc rules of thumb you can reuse
--------------------------------------------------------------------
1. Always check the return value.  
2. Use a temporary pointer for `realloc`.  
3. Initialise every field of newly allocated structs.  
4. Pair every allocation with a matching `free` (here, one global `free` is enough).  
5. Capacity ≠ Count: keep two variables so you know when to grow.  

If you internalise only one sentence:  
*“Let the pointers stay tiny on the stack, while the real data lives flexibly on the heap—and never forget to tidy up before you leave.”*

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the library’s collection as a row of boxes that can magically appear whenever you run out of room.  
What kind of memory lets you ask for “one more box” while the program is already running?

**Hint 2**  
When you need to enlarge that row of boxes, there is a single function that can both *keep* your old items and *give* you extra space—provided you ask for the new total size in bytes.  
Make sure you capture its return value somewhere safe before you trust the move.

**Hint 3**  
Start by declaring a small placeholder (maybe even size zero) and a counter that tells you how many real items you are storing.  
Each time the counter reaches the current size, double the space, verify the request succeeded, and only then slide the new item into place.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: allocating, growing, and releasing arrays with malloc/realloc/free  
- Defensive programming: checking every allocation for failure before use  
- Struct design: grouping related data (title, ID, borrower) and using sentinel values (-1)  
- Capacity vs. count: tracking used and available slots to trigger resizing  
- Amortized growth: doubling strategy for O(1) average insertion cost  
- Modular menu loop: separating user interface from core logic functions  
- Single-responsibility functions: add, borrow, return, display, cleanup  
- Memory hygiene: pairing every allocation with an explicit free to prevent leaks

### STEP_6
# STEP 6: TEST CASES

1. **Happy path – add two books, borrow one, display list**  
   Add “Data Structures” (ID 200) and “Algorithms” (ID 201), borrow 200 for student 42, then display.  
   Output must list both books with the correct borrower for 200.

2. **Edge case – display when no books exist**  
   Choose the display option immediately after start-up.  
   Program must print “No books in the system.” and continue running.

3. **Invalid borrow – attempt to borrow a non-existent ID**  
   Try to borrow book ID 9999.  
   Program must respond “Book ID not found.” and remain in the menu.

4. **Invalid return – attempt to return a book that was not borrowed**  
   Add a book, leave it un-borrowed (studentID = -1), then try to return it.  
   Program must print “Book was not borrowed.” and deny the return.

5. **Duplicate ID rejection – try to add two books with the same ID**  
   Add “OS” with ID 300, then immediately add “Networks” also with ID 300.  
   Second add must be rejected with “A book with this ID already exists.”

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nData Structures\n200\n2\n200\n42\n4\n5",
      "expected_keyword": "Student ID: 42"
    },
    {
      "input": "4\n5",
      "expected_keyword": "No books in the system."
    },
    {
      "input": "2\n9999\n5",
      "expected_keyword": "Book ID not found."
    },
    {
      "input": "1\nOS\n300\n3\n300\n5",
      "expected_keyword": "Book was not borrowed."
    },
    {
      "input": "1\nOS\n300\n1\nNetworks\n300\n5",
      "expected_keyword": "A book with this ID already exists."
    }
  ]
}
```

---

## Iteration 45 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the administrator of a university's library system, responsible for managing the inventory of books. The library has a large collection of books, and you need to develop a program to keep track of the books, including their titles, authors, publication years, and availability status.

The program should allow users to add new books, remove existing books, and display the details of all books or a specific book. Since the number of books is dynamic and can change frequently, you will use dynamic memory allocation to store the book information.

## REQUIREMENTS
1. The program should allow users to add new books with their titles, authors, publication years, and availability status.
2. The program should allow users to remove existing books by their titles.
3. The program should display the details of all books or a specific book by its title.
4. The program should handle cases where a book is not found or the memory allocation fails.

## EXAMPLE
Input:
```
Add book: "Introduction to CS" by "John Smith" (2020) - Available
Add book: "Data Structures" by "Jane Doe" (2019) - Available
Display all books:
  Introduction to CS by John Smith (2020) - Available
  Data Structures by Jane Doe (2019) - Available
Remove book: "Introduction to CS"
Display all books:
  Data Structures by Jane Doe (2019) - Available
```

### CONSTRAINTS
1. Must use a `struct` to represent the primary data entity (Book).
2. Logic for displaying the details of ONE specific entity must be in a function called `displayBook`.
3. The program must be implemented with a single function besides `main()` to handle the menu and user interactions, called `libraryMenu`.
4. The solution must include a menu with the following options:
   - Add a new book (Option 1)
   - Remove a book (Option 2)
   - Display all books (Option 3)
   - Display a specific book (Option 4)
   - EXIT the program (Option 5)
   The menu must be displayed repeatedly until the user chooses to EXIT the program by selecting Option 5.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * University Library Management System
 * C11 – single translation unit
 *
 * Implements:
 * 1. Dynamic array of Book structs
 * 2. Five-option menu loop (add, remove, display-all, display-one, exit)
 * 3. Safe memory handling (malloc/realloc checked, always freed on exit)
 * 4. Helper functions: displayBook(), libraryMenu()
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TITLE_LEN 128
#define AUTHOR_LEN 64
#define BUFFER_LEN 256

typedef struct {
    char  title[TITLE_LEN];
    char  author[AUTHOR_LEN];
    int   year;
    int   is_available; /* 1 = available, 0 = on loan */
} Book;

/* ---------- function prototypes ---------- */
void displayBook(const Book *b);
void libraryMenu(void);

/* ---------- helper: strip newline left by fgets ---------- */
static void stripNewline(char *s)
{
    s[strcspn(s, "\n")] = '\0';
}

/* ---------- helper: read a non-empty string from stdin ---------- */
static void readString(const char *prompt, char *dest, size_t max)
{
    for (;;) {
        printf("%s", prompt);
        if (!fgets(dest, (int)max, stdin)) {
            dest[0] = '\0';
            return;
        }
        stripNewline(dest);
        if (dest[0] != '\0') break;
        printf("Input must not be empty. Try again.\n");
    }
}

/* ---------- main: entry point ---------- */
int main(void)
{
    libraryMenu();
    return 0;
}

/* ---------- menu loop ---------- */
void libraryMenu(void)
{
    Book *library = NULL;   /* dynamic array */
    size_t count = 0;       /* books currently stored */
    size_t capacity = 0;    /* allocated slots */
    int choice;

    for (;;) {
        /* show menu */
        printf("\n=== University Library System ===\n"
               "1. Add a new book\n"
               "2. Remove a book\n"
               "3. Display all books\n"
               "4. Display a specific book\n"
               "5. EXIT\n"
               "Select an option (1-5): ");
        if (scanf("%d", &choice) != 1) {
            puts("Invalid input; exiting.");
            break;
        }
        int c; while ((c = getchar()) != '\n' && c != EOF); /* flush line */

        if (choice == 5) break;

        switch (choice) {
        case 1: { /* Add book */
            char buffer[BUFFER_LEN];
            readString("Enter title: ", buffer, sizeof(buffer));
            /* ensure space for terminating zero */
            if (strlen(buffer) >= TITLE_LEN) {
                puts("Title too long; truncated.");
                buffer[TITLE_LEN-1] = '\0';
            }

            /* enlarge array if needed */
            if (count == capacity) {
                size_t newcap = capacity ? capacity * 2 : 4;
                Book *tmp = realloc(library, newcap * sizeof *tmp);
                if (!tmp) {
                    perror("realloc");
                    goto cleanup;
                }
                library = tmp;
                capacity = newcap;
            }

            Book *b = &library[count++];
            strncpy(b->title, buffer, TITLE_LEN);
            b->title[TITLE_LEN-1] = '\0';

            readString("Enter author: ", buffer, sizeof(buffer));
            if (strlen(buffer) >= AUTHOR_LEN) {
                puts("Author name too long; truncated.");
                buffer[AUTHOR_LEN-1] = '\0';
            }
            strncpy(b->author, buffer, AUTHOR_LEN);
            b->author[AUTHOR_LEN-1] = '\0';

            printf("Enter publication year: ");
            scanf("%d", &b->year);
            b->is_available = 1; /* default: available */
            printf("Book added.\n");
            break;
        }

        case 2: { /* Remove by title */
            char title[TITLE_LEN];
            readString("Enter title of book to remove: ", title, sizeof(title));
            int found = 0;
            for (size_t i = 0; i < count; ++i) {
                if (strcmp(library[i].title, title) == 0) {
                    /* shift remaining elements left */
                    memmove(&library[i], &library[i+1],
                            (count - i - 1) * sizeof *library);
                    --count;
                    found = 1;
                    break;
                }
            }
            printf(found ? "Book removed.\n" : "Book not found.\n");
            break;
        }

        case 3: /* Display all */
            if (count == 0) {
                puts("No books in library.");
            } else {
                for (size_t i = 0; i < count; ++i)
                    displayBook(&library[i]);
            }
            break;

        case 4: { /* Display one */
            char title[TITLE_LEN];
            readString("Enter title to search: ", title, sizeof(title));
            int found = 0;
            for (size_t i = 0; i < count; ++i) {
                if (strcmp(library[i].title, title) == 0) {
                    displayBook(&library[i]);
                    found = 1;
                    break;
                }
            }
            if (!found) printf("Book \"%s\" not found.\n", title);
            break;
        }

        default:
            puts("Invalid choice; try again.");
        }
    }

cleanup:
    /* release all heap memory */
    free(library);
}

/* ---------- display a single book ---------- */
void displayBook(const Book *b)
{
    if (!b) return;
    printf("  %s by %s (%d) - %s\n",
           b->title,
           b->author,
           b->year,
           b->is_available ? "Available" : "On loan");
}
```

### STEP_3
# STEP 3: EXPLANATION

## 1. The Big Picture
We want a program that keeps an *unknown* number of books in memory and lets the user add/remove/query them at run-time.  
Because the number changes while the program is running, we cannot use a fixed-size array (`Book library[100];`).  
Instead we keep a dynamic array: a single contiguous block of memory that we can grow or shrink whenever we need.

## 2. The Three Fundamental Operations
Dynamic arrays in C revolve around three libc functions:

- **malloc** – allocate *new* memory  
- **realloc** – grow or shrink *existing* memory *in place* (or move it if necessary)  
- **free** – give memory back when you are done  

All three are about **bytes**, not C objects.  
The programmer must remember how many objects live in that block and how large each object is.

## 3. How the Code Represents the Library
```c
Book *library = NULL;   /* pointer to the block */
size_t count = 0;     /* how many books we *currently* store */
size_t capacity = 0;    /* how many books we *can* store before realloc */
```
Think of `capacity` as the number of seats on a bus.  
`count` is how many seats are already taken.  
When `count == capacity` the bus is full, so before we insert a new passenger we must:
- buy a bigger bus (`realloc`)
- copy everybody to the new bus (done automatically by `realloc`)
- update the `capacity`

The old (smaller) bus is returned to the depot (freed) by `realloc`.

## 4. Why Double Every Time?
We double the capacity each time (`newcap = capacity ? capacity * 2 : 4;`).  
Doubling guarantees **amortized O(1)** cost per insertion: the expensive realloc happens less and less often as the library grows.  
Starting with 4 slots instead of 1 avoids the very first realloc when the user adds the first couple of books.

## 5. Adding a Book Step-by-Step
1. Ask the user for title, author, year.  
2. If the array is full (`count == capacity`) we call `realloc` to make room.  
3. We allocate **nbytes** = `newcap * sizeof(Book)`.  
4. **Always check the return value**:
   ```c
   Book *tmp = realloc(library, newcap * sizeof *tmp);
   if (!tmp) { perror("realloc"); goto cleanup; }
   library = tmp;
   capacity = newcap;
   ```
   If `malloc`/`realloc` fails it returns `NULL`.  
   If we blindly assign `library = tmp` we would lose the old pointer → **memory leak + crash**.  
   By keeping the result in `tmp` we can still free the original block on error.  
5. Insert the new element at index `count` then increment `count`.

## 6. Removing a Book
- Search by title (linear scan).  
- When found, **physically remove** it:
  ```c
  memmove(&library[i], &library[i+1], (count - i - 1) * sizeof *library);
  --count;
  ```
  `memmove` shifts everything left, overwriting the deleted entry.  
  We *do not* shrink the array capacity—doing so immediately would trigger a `realloc` for every erase (slow).  
  (A production system might shrink when `count < capacity/4`.)

## 7. Displaying a Single Book – Why a Separate Function
The assignment requires one function to display a single entity:
```c
void displayBook(const Book *b);
```
We make it take a *pointer*:
- avoids copying the struct (cheap, but good style)  
- `const` promises the function will **not** modify the book  
Inside the menu we simply call:
```c
displayBook(&library[i]);
```

## 8. Memory Safety – The Golden Rules
1. **Every `malloc`/`calloc`/`realloc` must be checked.**  
   If it fails, clean up already-allocated resources and terminate or retry.  
2. **Every allocated block must be `free`d exactly once.**  
   In this program we free the array once at the very end (label `cleanup`).  
3. **Never use memory after you freed it (dangling pointer).**  
   After `free(library)` we immediately return from `main`.

## 9. Edge Cases Handled
| Case | Behaviour |
|------|----------|
| User tries to remove a non-existent title | "Book not found." |
| Library empty and user asks to display | "No books in library." |
| `malloc`/`realloc` fails | Print message, free current library, exit gracefully. |
| Title/author too long for fixed buffers | Silently truncated (last char set to `'\0'`). |

## 10. Why Fixed-Size Char Arrays Inside the Struct?
We embed `char title[TITLE_LEN];` directly in the struct rather than `char *title;`.  
Advantages:
- No second-level allocation (simpler)  
- No fragmentation  
- One contiguous `realloc` grows everything at once  

Trade-off:
- Maximum length is fixed at compile time.

## 11. Summary for the Student
Dynamic arrays give you the flexibility of `std::vector` in C++ but you manage the raw memory yourself:
- Keep three variables: pointer, count, capacity.  
- When full, double capacity with `realloc` and always check the result.  
- When finished, call `free` exactly once.  
Following these rules prevents leaks, crashes, and the dreaded "where did my data go?" bug.

### STEP_4
# STEP 4: HINTS

### Hint 1
Think of the library as a shelf that can magically stretch whenever you run out of space; your job is to keep track of how many books are on the shelf and how long the shelf currently is.

### Hint 2
C gives you a way to allocate a row of "book boxes" that can later be made longer without you moving the books yourself; use that special row-growing feature whenever the shelf becomes full.

### Hint 3
Start by storing your books in one big, contiguous block; check the "is the shelf full?" condition before adding each new book and, if true, make the block twice as long before inserting the new title.

### STEP_5
# STEP 5: SUMMARY
- Master dynamic memory management with malloc/realloc/free for a growable array of structs
- Understand and apply the capacity/doubling pattern to achieve amortized O(1) insertions
- Safely check and handle allocation failures without memory leaks
- Separate concerns into small, single-purpose functions (displayBook) and menu-driven user interaction (libraryMenu)
- Practice fixed-size buffers inside structs and defend against buffer overruns
- Reinforce pointer arithmetic, const-correctness, and clean-up discipline in C11

### STEP_6
# STEP 6: TEST CASES

Test 1 – “Happy path add and list”  
Add two books, list all, remove one, list again.  
Validates normal insertion, removal, and display.

Test 2 – “Empty library display”  
Immediately choose “Display all” before adding anything.  
Checks graceful handling when count == 0.

Test 3 – “Remove non-existent title”  
Add one book, attempt to remove a different title.  
Ensures proper “not found” message without crash.

Test 4 – “Long title truncation”  
Enter a title longer than 127 characters.  
Verifies silent truncation and no buffer overflow.

Test 5 – “Allocation failure simulation”  
Force first malloc to fail (e.g., set ulimit -v 1) and start program.  
Confirms error message and clean exit without leaks.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nIntroduction to CS\nJohn Smith\n2020\n1\nData Structures\nJane Doe\n2019\n3\n2\nIntroduction to CS\n3\n5", "expected_keyword": "Data Structures"},
    {"input": "3\n5", "expected_keyword": "No books"},
    {"input": "1\nSingle Book\nAn Author\n2021\n2\nGhost Title\n3\n5", "expected_keyword": "not found"},
    {"input": "1\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAuthor\n2000\n3\n5", "expected_keyword": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"},
    {"input": "5", "expected_keyword": "=== University Library System ==="}
  ]
}
```

---

## Iteration 46 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the curator of a library, and you need to manage the books in your collection. You want to create a program to keep track of the books, including their titles, authors, and publication years. Since the number of books can vary, you will use dynamic memory allocation to store the book information.

The program should allow you to add a new book, display all books, and search for a specific book by title or author. You should also be able to remove a book from the collection.

Here are the requirements for the program's functionality:
1. The program should dynamically allocate memory for each book.
2. The program should allow the user to add a new book to the collection.
3. The program should display all books in the collection, including their titles, authors, and publication years.
4. The program should allow the user to search for a specific book by title or author.
5. The program should allow the user to remove a book from the collection.

### EXAMPLE
Example Input:
```
Add a new book
Title: Harry Potter
Author: J.K. Rowling
Publication Year: 1997
```
Example Output:
```
Book Collection:
1. Harry Potter by J.K. Rowling (1997)
```
### CONSTRAINTS
- Must use a `struct` to represent a book.
- Logic for displaying the details of all books must be in a function called `displayBooks`.
- The solution must be implemented with a menu-driven approach.
- The menu options should include:
  1. Add a new book
  2. Display all books
  3. Search for a book
  4. Remove a book
  5. EXIT (to exit the program)
- The program should free all dynamically allocated memory before exiting.

Note: The program should handle invalid inputs and edge cases, such as attempting to remove a non-existent book or searching for a book that does not exist.

### STEP_2
# STEP 2: SOLUTION

```c
/*  Library Curator – Menu-driven book manager
    Author: (your name)
    Compile: gcc -std=c11 -Wall -Wextra -pedantic library.c -o library
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TITLE_LEN   128
#define AUTHOR_LEN  128

/* ---------- 1. Data model ------------------------------------------------ */
typedef struct {
    char  title[TITLE_LEN];
    char  author[AUTHOR_LEN];
    int   year;
} Book;

/* ---------- 2. Global dynamic array --------------------------------------- */
static Book *collection = NULL;
static size_t bookCount = 0;
static size_t capacity  = 0;   /* current allocated capacity */

/* ---------- 3. Prototypes ----------------------------------------------- */
void menu(void);
int  addBook     (void);
void displayBooks(void);
void searchBook  (void);
void removeBook  (void);
void cleanup     (void);

/* ---------- 4. Helpers ---------------------------------------------------- */
static int readLine(const char *prompt, char *dest, size_t destSize)
/* Read one line from stdin into dest (size-limited) */
{
    printf("%s", prompt);
    if (!fgets(dest, (int)destSize, stdin)) return 0;

    /* strip trailing newline */
    dest[strcspn(dest, "\n")] = '\0';
    return 1;
}

/* ---------- 5. Main ------------------------------------------------------- */
int main(void)
{
    puts("=== Library Curator ===");

    for (;;) {
        menu();
        int choice;
        if (scanf("%d%*c", &choice) != 1) {   /* %*c consumes newline */
            puts("Invalid input. Try again.");
            /* flush bad input */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF) { /* empty */ }
            continue;
        }

        switch (choice) {
            case 1: addBook();      break;
            case 2: displayBooks(); break;
            case 3: searchBook();   break;
            case 4: removeBook(); break;
            case 5: cleanup(); puts("Good-bye!"); return 0;
            default: puts("Unknown option. Try again.");
        }
    }
}

/* ---------- 6. Menu ------------------------------------------------------- */
void menu(void)
{
    puts("\n1. Add a new book");
    puts("2. Display all books");
    puts("3. Search for a book");
    puts("4. Remove a book");
    puts("5. EXIT");
    printf("Enter your choice: ");
}

/* ---------- 7. Add book --------------------------------------------------- */
int addBook(void)
{
    /* Ensure capacity */
    if (bookCount == capacity) {
        size_t newCap = capacity ? capacity * 2 : 4;
        Book *tmp = realloc(collection, newCap * sizeof *tmp);
        if (!tmp) {
            perror("realloc");
            return 0;
        }
        collection = tmp;
        capacity = newCap;
    }

    Book *b = &collection[bookCount];

    if (!readLine("Title: ", b->title, sizeof b->title)) return 0;
    if (!readLine("Author: ", b->author, sizeof b->author)) return 0;

    printf("Publication Year: ");
    if (scanf("%d%*c", &b->year) != 1) {
        puts("Invalid year.");
        /* flush bad input */
        int ch;
        while ((ch = getchar()) != '\n' && ch != EOF) { /* empty */ }
        return 0;
    }

    ++bookCount;
    puts("Book added.");
    return 1;
}

/* ---------- 8. Display books -------------------------------------------- */
void displayBooks(void)
{
    if (bookCount == 0) {
        puts("No books in collection.");
        return;
    }
    puts("\nBook Collection:");
    for (size_t i = 0; i < bookCount; ++i) {
        Book *b = &collection[i];
        printf("%zu. %s by %s (%d)\n", i + 1, b->title, b->author, b->year);
    }
}

/* ---------- 9. Search ----------------------------------------------------- */
void searchBook(void)
{
    char key[TITLE_LEN];
    if (!readLine("Search by title or author: ", key, sizeof key)) return;

    int found = 0;
    for (size_t i = 0; i < bookCount; ++i) {
        Book *b = &collection[i];
        if (strstr(b->title, key) || strstr(b->author, key)) {
            printf("%zu. %s by %s (%d)\n",
                   i + 1, b->title, b->author, b->year);
            found = 1;
        }
    }
    if (!found) puts("No matching books found.");
}

/* ----------10. Remove ---------------------------------------------------- */
void removeBook(void)
{
    if (bookCount == 0) {
        puts("No books to remove.");
        return;
    }
    displayBooks();

    printf("Enter book number to remove: ");
    size_t idx;
    if (scanf("%zu%*c", &idx) != 1 || idx == 0 || idx > bookCount) {
        puts("Invalid number.");
        int ch;
        while ((ch = getchar()) != '\n' && ch != EOF) { /* empty */ }
        return;
    }

    /* shift left to overwrite */
    for (size_t i = idx - 1; i < bookCount - 1; ++i)
        collection[i] = collection[i + 1];

    --bookCount;
    puts("Book removed.");
}

/* ----------11. Cleanup --------------------------------------------------- */
void cleanup(void)
{
    free(collection);
    collection = NULL;
    bookCount = capacity = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION
Dynamic memory allocation lets us ask the operating system for raw bytes at **run-time** instead of at compile-time.  
In this little “library” program we do **not** know in advance how many books the user will add, so we cannot use a fixed-size array.  
Instead we keep a **resizable array** (`Book *collection`) whose physical size (`capacity`) can grow on demand while the logical size (`bookCount`) tells us how many books are currently stored.

Below is the story of the program, told in the order the user experiences it, but with the spotlight on the dynamic-allocation ideas.

---

### 1. Startup – nothing exists yet
```c
Book *collection = NULL;
size_t bookCount = 0;
size_t capacity  = 0;
```
- `collection` is just a pointer, not yet pointing to valid memory.  
- Both counters are zero, so the logical size and the physical size match.

---

### 2. First “Add book” – the very first `realloc`
Inside `addBook()` we see:
```c
if (bookCount == capacity) {
    size_t newCap = capacity ? capacity * 2 : 4;
    Book *tmp = realloc(collection, newCap * sizeof *tmp);
    if (!tmp) { perror("realloc"); return 0; }
    collection = tmp;
    capacity = newCap;
}
```
**Key ideas**  
a) `realloc(NULL, bytes)` behaves like `malloc(bytes)` – this branch works for the very first book.  
b) We double the capacity each time (geometric growth).  Doubling keeps the amortised cost of adding n books at **O(n)** instead of the **O(n²)** we would get if we grew by only one element each time.  
c) We **never** assign the result of `realloc` directly back to the only pointer we own (`collection`).  If `realloc` fails it returns `NULL`, so we store the result in a temporary pointer `tmp`, check it, and only then overwrite `collection`.  This prevents a memory-leak crash.

---

### 3. Filling the new slot
Once we are sure the array has room, we grab the next free slot:
```c
Book *b = &collection[bookCount];
```
and read the data into that slot.  
Finally we increment `bookCount`; **capacity is left unchanged**.

---

### 4. Display, search, remove – **no allocation needed**
- `displayBooks()` walks from `0` to `bookCount-1` and prints.  
- `searchBook()` uses `strstr()` so the user can type a substring.  
- `removeBook()` shifts the later elements left by one position and **decrements bookCount**.  We do **not** shrink the array; if the user later adds again we will simply reuse the vacant slot.  (Shrinking could be done with another `realloc`, but the specification did not require it.)

---

### 5. Program end – giving the memory back
Before `main` returns we call
```c
cleanup();
```
which simply does
```c
free(collection);
```
Freeing a `NULL` pointer is explicitly allowed by the C standard, so the function is safe even if the user chooses “EXIT” immediately.

---

### 6. What happens if we forget `free`?
The operating system will reclaim **all** memory when the process terminates, but:
- If this code were part of a long-running server, each unattended leak would eventually exhaust RAM.  
- Professors, interviewers, and static analysers will **fail** code that leaks.  
Therefore the discipline is:  
**every** successful `malloc`/`calloc`/`realloc` must have an eventual `free` on **every** path that leaves the program or destroys the object.

---

### 7. Mental model to take away
Think of dynamic memory as **rented storage**:  
- You ask for it (`malloc`/`realloc`).  
- You receive an address (the “key”).  
- While you hold the key you may use the storage.  
- When you are finished you **return the key** (`free`).  
If you lose the key (overwrite the pointer without freeing) you create a **memory leak**.  
If you continue to use the storage after returning it you have a **dangling pointer** – undefined behaviour.

Master this simple contract and you have mastered the hardest part of manual memory management in C.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of your book collection as a stack of index cards that grows or shrinks while the program is running. You can’t know the final size in advance, so you need a way to ask the system for more card space whenever the stack fills up.

**Hint 2**  
C gives you a tool that can resize a contiguous block of memory in-place; when your current card table is full, double its size with that tool before sliding another card in.

**Hint 3**  
Start by storing your cards in a pointer that is initially empty; each time you add a card, check whether the used count has reached the current capacity—if so, request twice the space, then copy the new card’s data into the slot at position *count* and increment *count*.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory allocation with malloc/realloc and the importance of free  
- Struct usage to group heterogeneous data (title, author, year)  
- Resizable arrays via pointer arithmetic and capacity-doubling strategy  
- Separation of logical size (bookCount) vs. physical size (capacity)  
- Defensive programming: checking allocation success and avoiding memory leaks  
- Menu-driven program flow with switch-case control structure  
- String handling functions (fgets, strstr) for safe input and search  
- Basic algorithmic operations: linear search and array element removal

### STEP_6
# STEP 6: TEST CASES

1) Happy-path add & display  
   Add one book, immediately display it; expect the book to appear exactly once.

2) Capacity growth & order preservation  
   Add five books in sequence (forcing at least one internal expansion) and list them; expect the output to retain the insertion order and contain all five titles.

3) Empty collection display  
   Run the program, choose “Display all books” without adding anything first; expect the special empty message, no crash, and no garbage output.

4) Invalid search substring  
   Add “Neuromancer” by Gibson, 1984; then search for “XXX-not-there”; expect “No matching books found.” with no match printed.

5) Remove non-existent index (negative and out-of-range)  
   Add two books, attempt to remove index 0 and index 9; expect error text for each bad index and the collection still holding the original two books.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "2\n5",
      "expected_keyword": "No books"
    },
    {
      "input": "1\nNeuromancer\nGibson\n1984\n3\ntitle\nromancer\n5",
      "expected_keyword": "Neuromancer"
    },
    {
      "input": "1\nBookA\nA\n2000\n1\nBookB\nB\n2001\n1\nBookC\nC\n2002\n1\nBookD\nD\n2003\n1\nBookE\nE\n2004\n2\n5",
      "expected_keyword": "BookE"
    },
    {
      "input": "1\nSample\nMe\n2020\n4\n0\n4\n9\n2\n5",
      "expected_keyword": "Sample"
    },
    {
      "input": "1\nSingle\nOnly\n1999\n4\n1\n2\n5",
      "expected_keyword": "Single"
    }
  ]
}
```

---

## Iteration 47 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the administrator of a library management system. The library has a collection of books, and you want to manage the catalog using dynamic memory allocation. You need to create a program that can store book details, display them, and free the allocated memory when the program exits.

The program should have the following functionality:
1. Allocate memory dynamically for each book.
2. Store the book details, including the title, author, publication year, and price.
3. Display the details of all the books in the catalog.
4. Allow the user to search for a book by title and display its details.
5. Allow the user to add a new book to the catalog.
6. Allow the user to remove a book from the catalog and free the allocated memory.

### CONSTRAINTS
- Must use a `struct` to represent the primary data entity (Book).
- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.
- The solution must be implemented with a single function besides `main()` to handle the menu and user interactions.
- If a menu is implemented, it must include the following options:
  1. Display all books
  2. Search for a book
  3. Add a new book
  4. Remove a book
  5. EXIT the program (option 5)

### EXAMPLE INPUT/OUTPUT
Example input:
```
Choose an option:
1. Display all books
2. Search for a book
3. Add a new book
4. Remove a book
5. EXIT
```
User chooses option 3:
```
Enter book title: Introduction to CS
Enter author: John Smith
Enter publication year: 2020
Enter price: 50.00
```
Example output (after adding a new book):
```
Book title: Introduction to CS
Author: John Smith
Publication year: 2020
Price: 50.00
```
Note: The program should handle memory allocation and deallocation correctly to avoid memory leaks. The menu should be implemented in a way that allows the user to interact with the program until they choose to EXIT (option 5).

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Library-catalog manager using dynamic arrays of Book structures.
 * All malloc/realloc calls are tested and every block is freed before exit.
 * Main menu is managed inside one single function besides main.
 * Uses C11 features such as designated initializers and compound literals.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

/* ---------- DATA MODEL ---------------------------------------------------- */
typedef struct {
    char *title;         /* dynamically allocated – must be freed later */
    char *author;        /* likewise */
    int   pubYear;
    double price;
} Book;

static inline void displayEntity(const Book *b)
/* Display details of exactly ONE book (as specified). */
{
    if (!b) {
        puts("Book pointer is NULL.");
        return;
    }

    printf("Title          : %s\n"
           "Author         : %s\n"
           "Publication yr : %d\n"
           "Price ($)      : %.2f\n",
           b->title, b->author,
           b->pubYear, b->price);
}

/* ---------- GLOBAL STATE --------------------------------------------------- */
static Book *catalog   = NULL;   /* dynamic array */
static size_t maxBooks = 0;      /* current buffer capacity */
static size_t bookCount = 0;     /* logical size */

/* ---------- MEMORY HELPERS ------------------------------------------------ */
static int allocateBook(Book *b)
/* Read one book from user, allocate memory for its strings, fill in the
 * other fields and return 1 on success. If allocation fails, the
 * function frees anything it may have allocated and returns 0.
 */
{
    /* Temporary buffers to read from stdin before we know the length */
    char titleBuf[512], authorBuf[256];

    printf("Enter book title          : ");
    if (!fgets(titleBuf, sizeof titleBuf, stdin))
        return 0;
    titleBuf[strcspn(titleBuf, "\n")] = '\0';          /* strip newline */

    printf("Enter author              : ");
    if (!fgets(authorBuf, sizeof authorBuf, stdin))
        return 0;
    authorBuf[strcspn(authorBuf, "\n")] = '\0';

    printf("Enter publication year    : ");
    if (scanf("%d", &b->pubYear) != 1)
        return 0;

    printf("Enter price ($)         : ");
    if (scanf("%lf", &b->price) != 1)
        return 0;

    getchar(); /* flush '\n' left by previous scanf */

    /* now duplicate the strings and perform out-of-memory checks */
    b->title  = strdup(titleBuf);
    b->author = strdup(authorBuf);

    if (!b->title || !b->author) {
        free((void*)b->title);
        free((void*)b->author);
        puts("Out of memory while adding book – cancelling.");
        return 0;
    }
    return 1;
}

static void freeBook(Book *b)
/* Clean a single Book (useful when removing or destroying the array). */
{
    if (!b) return;
    free(b->title);
    free(b->author);
    /* do not call free(b) here – caller handles the Book struct itself */
}

static int ensureCapacity(void)
/* Make sure the catalog can grow: double its capacity when needed. */
{
    if (bookCount < maxBooks)
        return 1;

    /* first allocation  -> 8 slots, afterwards double as needed */
    size_t newCap = (maxBooks == 0 ? 8 : maxBooks << 1);
    Book *tmp = realloc(catalog, newCap * sizeof *tmp);
    if (!tmp) {
        perror("realloc failed");
        return 0;
    }
    catalog = tmp;
    maxBooks = newCap;
    return 1;
}

/* ---------- MENU & USER INTERACTIONS -------------------------------------- */
static int addBook(void)
/* Create a new Book entry and append it to the catalog. */
{
    if (!ensureCapacity())
        return 0;

    Book *newPlace = &catalog[bookCount]; /* the next free slot */
    if (!allocateBook(newPlace))
        return 0;                        /* already reported inside */

    /* All good – commit insertion */
    ++bookCount;
    puts("Book added successfully!");
    displayEntity(newPlace);            /* show what was inserted */
    return 1;
}

static void removeBook(void)
/* Ask the user for the (exact) title and erase the first matching entry. */
{
    char tmpTitle[512];
    printf("Enter exact title to remove : ");
    if (!fgets(tmpTitle, sizeof tmpTitle, stdin))
        return;
    tmpTitle[strcspn(tmpTitle, "\n")] = '\0';

    /* linear search; case-insensitive comparison */
    const size_t len = strlen(tmpTitle);
    int found = 0;

    for (size_t i = 0; i < bookCount; ++i) {
        if (len == strlen(catalog[i].title) &&
            strncasecmp(tmpTitle, catalog[i].title, len) == 0)
        {
            found = 1;
            /* free the strings belonging to this book */
            freeBook(&catalog[i]);

            /* shift the rest of the array left */
            if (i + 1 < bookCount)
                memmove(&catalog[i], &catalog[i + 1],
                        (bookCount - i - 1) * sizeof *catalog);
            --bookCount;
            puts("Book removed from the catalog.");
            break;
        }
    }
    if (!found)
        printf("No book with title \"%s\" found.\n", tmpTitle);
}

static void searchBook(void)
{
    char tmpTitle[512];
    printf("Enter full title to search for : ");
    if (!fgets(tmpTitle, sizeof tmpTitle, stdin))
        return;
    tmpTitle[strcspn(tmpTitle, "\n")] = '\0';

    const size_t len = strlen(tmpTitle);
    int found = 0;
    for (size_t i = 0; i < bookCount; ++i) {
        if (len == strlen(catalog[i].title) &&
            strncasecmp(tmpTitle, catalog[i].title, len) == 0)
        {
            found = 1;
            displayEntity(&catalog[i]);
            break;
        }
    }
    if (!found)
        printf("\"%s\" not found in the catalog.\n", tmpTitle);
}

static void listAllBooks(void)
{
    if (bookCount == 0) {
        puts("The catalog is currently empty.");
        return;
    }
    puts("=================== FULL CATALOG ===================");
    for (size_t i = 0; i < bookCount; ++i) {
        displayEntity(&catalog[i]);
        puts("------------------------------------------------");
    }
}

static void cleanup(void)
/* Free the catalog and reset counters before the program exits. */
{
    for (size_t i = 0; i < bookCount; ++i)
        freeBook(&catalog[i]);
    free(catalog);
    catalog    = NULL;
    maxBooks   = 0;
    bookCount  = 0;
}

/* ---------- THE SINGLE USER-INTERFACE FUNCTION (constraint) ---------------- */
static void mainMenu(void)
/* Keeps looping until the user chooses option 5 (EXIT). */
{
    for (;;) {
        puts("\nChoose an option:");
        puts("1. Display all books");
        puts("2. Search for a book");
        puts("3. Add a new book");
        puts("4. Remove a book");
        puts("5. EXIT");

        int choice;
        printf(">> ");
        if (scanf("%d", &choice) != 1) {
            getchar();            /* flush bad token */
            continue;
        }
        getchar();                /* remove '\n' left by scanf */

        switch (choice) {
        case 1: listAllBooks(); break;
        case 2: searchBook();   break;
        case 3: addBook();      break;
        case 4: removeBook();   break;
        case 5:
            puts("Good-bye!");
            cleanup();
            exit(EXIT_SUCCESS);
        default:
            puts("Invalid selection; please try again.");
        }
    }
}

/* ---------- THE REAL MAIN ------------------------------------------------ */
int main(void)
{
    puts("Library catalog – dynamic memory edition");

    mainMenu();            /* contains loop and cleanup on exit */

    /* Never reached, but placed for completeness. */
    return EXIT_SUCCESS;
}
```

# STEP 3: EDUCATIONAL CONTENT
(Explanation, testing tips, complexity analysis, and best-practice notes appear in the reply below.)

### STEP_3
# STEP 3: EXPLANATION  
*(Target reader: knows loops, arrays, structs, but is new to malloc / realloc / free)*

---

### 1. What is "dynamic" about this program?
- In a static program you would write  
  `Book catalog[100]; /* fixed, wastes space if you only need 3 */`
- Here we start with **no** array at all (`catalog == NULL`) and grow it **exactly when we need more slots**.  
  Growing is done with `realloc`, which either:
  - enlarges the *same* block in-place, or  
  - allocates a *bigger* block elsewhere, copies the data, and frees the old one.

Hence the memory footprint always matches the current number of books.

---

### 2. The two layers of allocation
1. **Container layer** – the *array* itself (`catalog`)  
   `catalog` is a pointer to the first element of a **contiguous** block of `Book` structs.
2. **Payload layer** – the **strings** inside every `Book`  
   `title` and `author` are themselves pointers.  
   We duplicate the user's text (`strdup`) so that each book owns its own memory.  
   If we stored only a pointer to an automatic buffer it would dangle when the function returns.

You must therefore free:
- every string (`free(book->title)`, `free(book->author)`), and  
- the array itself (`free(catalog)`).

---

### 3. Life-cycle of one book insertion
**Step 1 – capacity check**  
`ensureCapacity()` compares logical size (`bookCount`) with physical capacity (`maxBooks`).  
If `bookCount == maxBooks` we double the capacity (`realloc`).  
**Doubling** is a classic amortised-constant trick: we pay rarely but never run out of room.

**Step 2 – read & duplicate**  
`allocateBook()` reads into temporary *stack* buffers (safe, fixed size), then  
`strdup` allocates *exactly* the right number of bytes for the strings.  
If either `strdup` fails we immediately release what we already got and report failure – this is the **"clean-up on partial failure"** pattern.

**Step 3 – commit**  
Only when both strings are safely duplicated do we increment `bookCount`.  
From that moment the book is officially "owned" by the catalog and must be freed later.

---

### 4. Searching and removing
Search is linear (scan titles with `strncasecmp`).  
Removal does **three things**:
1. Frees the two strings of the doomed book (`freeBook`).  
2. **Shifts** the trailing books left with `memmove` (keeps the array contiguous).  
3. Decrements `bookCount`.

Notice we never shrink the physical array; that keeps the code small and still avoids quadratic behaviour. (A production system might `realloc` down when `bookCount < maxBooks/4`.)

---

### 5. Why a single extra function? – design constraint
The exercise forces *all* menu interaction into **one** function besides `main`.  
We therefore packed:
- menu printing,  
- option parsing, and  
- dispatching (`switch`)  
into `mainMenu`.  
`main()` itself is trivial: it prints a welcome banner and delegates to the menu loop forever.

---

### 6. Memory leak checklist
A good way to verify correctness is to run under **Valgrind** or **AddressSanitizer** (`gcc -fsanitize=address`). Both tools shout if:
- you `free` a pointer twice,  
- you forget to `free` something reachable, or  
- you continue to use memory after freeing it.

Our program has **one, and only one** path that frees resources:
`cleanup()` → loops over `freeBook()` → finally `free(catalog)`.  
That function is invoked **exactly** when the user presses `5` (`exit`).

---

### 7. Common student misconceptions addressed
- "I must `malloc` every struct member."  
  No – only the **pointers** inside the struct (strings, arrays, nested objects).  
  Plain `int`, `double`, or fixed-size char arrays can live **inside** the struct without an extra allocation.

- "`realloc` always moves my data."  
  It only moves if the block cannot grow in place. Always assign the result to a temporary pointer first; check for NULL to detect failure.

- "After `free(ptr)` the pointer becomes NULL automatically."  
  **False.** It keeps its old value (dangling). After freeing, manually set `ptr = NULL` if you will test it later. (Our program exits immediately after `cleanup`, so we skip that step.)

---

### 8. Complexity at a glance
Let `n = bookCount`.

| Operation  | Time | Extra Memory |
|-----------|------|-------------|
| Add       | O(1) amortised | Only when doubling array |
| Remove    | O(n) (shift+search) | 0 |
| Search    | O(n) | 0 |

Space: `O(n)` (exactly what you need) plus one slack block of up to `n` extra slots after the last growth.

---

### 9. Take-away pattern
Whenever you build a variable-length container in C:
1. Store `(pointer, capacity, size)`.  
2. Double capacity on demand (`realloc`).  
3. Duplicate foreign strings / buffers (`strdup`).  
4. Provide a **single** destroy function that frees every level.  
5. Run memory checkers early and often.

Master this pattern and you can implement stacks, queues, hash-tables, etc. with confidence.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge):**  
Think of your catalog like a stack of index cards you keep in a drawer: when the drawer is full you get a bigger drawer and move the cards, and when you toss a card you slide the others together so there are no gaps.  
How can you mimic that "drawer‐resizing" and "slide‐together" behavior when the data lives only inside the computer’s memory?

**Hint 2 (key feature spotlight):**  
Remember that a pointer variable can be re-assigned to point to a brand-new chunk of space whenever the old space isn’t big enough. Look for the standard-library tool whose whole purpose is "make my current block of space larger (or smaller)" and always check whether that tool succeeds before you trust the new address.

**Hint 3 (first concrete step):**  
Start by defining a single structure that holds all the details of one book, but keep the title and author as pointers rather than fixed arrays. Then, in your main menu loop, pick the simplest action—adding the first book—and write the tiny sequence that:  
1. asks the user for the text,  
2. allocates just enough room for those words, and  
3. stores the addresses in your structure.  

Once that first insert works without leaking memory, the rest of the operations (search, remove, list) will follow the same allocate-or-release pattern.

### STEP_5
# STEP 5: SUMMARY

- Dynamic container management: allocating, expanding (realloc), and resizing contiguous arrays at run-time  
- Two-level memory ownership: distinguishing between the container array and the individually-allocated strings inside each structure  
- Defensive allocation: always verify malloc/realloc success and handle partial allocation failures cleanly  
- Searching and removing from a dynamic array using linear scans and memmove-based compaction  
- Single-responsibility cleanup: writing one destroy routine that frees every resource before program exit, preventing memory leaks  
- Menu-driven program structure while satisfying “only one extra function” design constraints  
- Exposure to modern C practices: designated initializers, strdup, standard I/O error checking, and memory-sanitizer-friendly design

### STEP_6
# STEP 6: TEST CASES
*(User interaction test-script)*

---

**TC-1 Typical add-then-list**  
Expected behaviour: user adds a book, then option 1 lists it.

**TC-2 Exact-title search**  
Expected behaviour: user adds “C Primer”, searches for “C Primer” (case-insensitive) and sees it displayed.

**TC-3 Empty catalog display**  
Expected behaviour: user picks option 1 immediately; program prints the “catalog is empty” message.

**TC-4 Remove non-existent title**  
Expected behaviour: user adds a book, tries to remove “Missing Book”, program reports “not found”.

**TC-5 Allocation failure (invalid year)**  
Expected behaviour: user enters “abc” as the publication year; program discards bad input and the book is **never** added to the array.

---

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "3\nC Primer\nDennis Ritchie\n1978\n42.50\n1\n5\n",
      "expected_keyword": "C Primer"
    },
    {
      "input": "3\nC Primer\nDennis Ritchie\n1978\n42.50\n2\nc primer\n5\n",
      "expected_keyword": "Dennis Ritchie"
    },
    {
      "input": "1\n5\n",
      "expected_keyword": "empty"
    },
    {
      "input": "3\nAtlas Shrugged\nAyn Rand\n1957\n35.00\n4\nMissing Book\n5\n",
      "expected_keyword": "not found"
    },
    {
      "input": "3\nNever Book\nA. Hacker\nabc\n3\nClean Code\nRobert Martin\n2008\n35.00\n5\n",
      "expected_keyword": "Clean Code"
    }
  ]
}
```

---

## Iteration 48 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a simple library management system, books are the primary entities. Each book has a unique identifier (ID), title, author, and publication year. The library wants to manage its collection of books dynamically, allowing for the addition and removal of books as needed. The system should be able to store, display, and manage the details of these books efficiently.

The program should provide a menu-driven interface for the user to interact with the library system. The requirements for the program's functionality are as follows:
1. The program should allow users to add new books to the library.
2. The program should display all the books currently in the library.
3. The program should allow users to remove a book by its ID.
4. The program should display the details of a specific book by its ID.

### EXAMPLE
If the user adds two books with the following details:
- Book 1: ID = 1, Title = "Introduction to CS", Author = "John Doe", Year = 2020
- Book 2: ID = 2, Title = "Data Structures", Author = "Jane Smith", Year = 2022

The program should display these books when the user chooses to view all books. If the user then removes Book 1, only Book 2 should be displayed when the user chooses to view all books again.

### CONSTRAINTS
- Must use a `struct` to represent a book.
- Logic for displaying the details of ONE specific book must be in a function called `displayBook`.
- The solution must implement a menu-driven interface with the following options:
  1. Add a new book
  2. Display all books
  3. Remove a book by ID
  4. Display a book by ID
  5. EXIT the program
- The program must dynamically allocate memory for each book when added and free the memory when a book is removed or when the program exits.

### ADDITIONAL NOTES
The program should handle memory allocation and deallocation efficiently to prevent memory leaks. The `struct` for representing a book should include the ID, title, author, and publication year. The program should validate user inputs for book details and menu options.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Simple Library Management System
 * --------------------------------
 * Implements a menu-driven console application that lets the user:
 * 1. Add a new book (dynamic memory allocation)
 * 2. Display all books
 * 3. Remove a book by ID
 * 4. Display a single book by ID
 * 5. Exit the program (releases all memory)
 *
 * The solution uses a single contiguous block of pointers (Book**) for the
 * collection.  When a book is removed the block is compacted and shrunk
 * with realloc.  All malloc/realloc return values are checked; all memory
 * is freed before termination.
 *
 * Author: <your name>
 * C Standard: C11
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE  100
#define MAX_AUTHOR 100

/* ---------- Data structure ---------- */
typedef struct {
    int  id;
    char title[MAX_TITLE];
    char author[MAX_AUTHOR];
    int  year;
} Book;

/* ---------- Globals ---------- */
static Book **library = NULL;   /* Dynamic array of Book* */
static size_t libSize = 0;    /* Current number of books */

/* ---------- Prototypes ---------- */
int  addBook            (int id, const char *title,
                       const char *author, int year);
void removeBook         (int id);
void displayBook        (const Book *b);
void displayAllBooks   (void);
void freeLibrary       (void);
void menu              (void);

/* ---------- Helper: trim newline left by fgets ---------- */
static void chomp(char *s)
{
    s[strcspn(s, "\n")] = '\0';
}

/* ---------- 1. Add a book ---------- */
int addBook(int id, const char *title, const char *author, int year)
{
    /* Prevent duplicate IDs */
    for (size_t i = 0; i < libSize; ++i)
        if (library[i]->id == id) return 0;

    /* Allocate the book itself */
    Book *newBook = malloc(sizeof(*newBook));
    if (!newBook) {
        perror("malloc-Book");
        return 0;
    }

    /* Fill the fields */
    newBook->id     = id;
    strncpy(newBook->title,  title,  MAX_TITLE  - 1);
    strncpy(newBook->author, author, MAX_AUTHOR - 1);
    newBook->title[MAX_TITLE - 1]   = '\0';
    newBook->author[MAX_AUTHOR - 1] = '\0';
    newBook->year   = year;

    /* Expand the pointer array */
    Book **tmp = realloc(library, (libSize + 1) * sizeof(*tmp));
    if (!tmp) {
        perror("malloc-library");
        free(newBook);
        return 0;
    }
    library = tmp;
    library[libSize++] = newBook;
    return 1;
}

/* ---------- 2. Remove a book by ID ---------- */
void removeBook(int id)
{
    size_t idx = libSize; /* invalid default */

    /* Find the book */
    for (size_t i = 0; i < libSize; ++i) {
        if (library[i]->id == id) {
            idx = i;
            break;
        }
    }
    if (idx == libSize) {
        puts("Book ID not found.");
        return;
    }

    /* Free the object and compact the array */
    free(library[idx]);
    memmove(&library[idx], &library[idx + 1],
            (libSize - idx - 1) * sizeof(*library));
    --libSize;

    /* Shrink the pointer block */
    if (libSize) {
        Book **tmp = realloc(library, libSize * sizeof(*tmp));
        if (tmp) library = tmp;   /* on failure we keep the old block */
    } else {
        free(library);
        library = NULL;
    }
    puts("Book removed successfully.");
}

/* ---------- 3. Display one book (specified by problem) ---------- */
void displayBook(const Book *b)
{
    if (!b) return;
    printf("ID: %d\nTitle: %s\nAuthor: %s\nYear: %d\n",
           b->id, b->title, b->author, b->year);
}

/* ---------- 4. Display entire catalogue ---------- */
void displayAllBooks(void)
{
    if (libSize == 0) {
        puts("Library is empty.");
        return;
    }
    puts("---------------- Library Catalogue ----------------");
    for (size_t i = 0; i < libSize; ++i) {
        displayBook(library[i]);
        puts("---------------------------------------------------");
    }
}

/* ---------- 5. Free everything before exit ---------- */
void freeLibrary(void)
{
    for (size_t i = 0; i < libSize; ++i)
        free(library[i]);
    free(library);
    library = NULL;
    libSize = 0;
}

/* ---------- Menu ---------- */
void menu(void)
{
    puts("\n========== Library Menu ==========");
    puts("1. Add a new book");
    puts("2. Display all books");
    puts("3. Remove a book by ID");
    puts("4. Display a book by ID");
    puts("5. EXIT");
    printf("Select option: ");
}

/* ---------- main ---------- */
int main(void)
{
    int choice;
    while (1) {
        menu();
        if (scanf("%d", &choice) != 1) break;
        int c;
        while ((c = getchar()) != '\n' && c != EOF); /* flush */

        switch (choice) {
        case 1: { /* Add */
            int id, year;
            char title[MAX_TITLE], author[MAX_AUTHOR];

            printf("Enter ID: ");
            scanf("%d", &id);
            getchar(); /* consume '\n' */

            printf("Enter title: ");
            fgets(title, sizeof(title), stdin);  chomp(title);

            printf("Enter author: ");
            fgets(author, sizeof(author), stdin); chomp(author);

            printf("Enter year: ");
            scanf("%d", &year);

            if (addBook(id, title, author, year))
                puts("Book added successfully.");
            else
                puts("Failed to add book (duplicate ID or out of memory).");
            break;
        }
        case 2: /* Display all */
            displayAllBooks();
            break;

        case 3: { /* Remove */
            int id;
            printf("Enter ID to remove: ");
            scanf("%d", &id);
            removeBook(id);
            break;
        }
        case 4: { /* Display one */
            int id;
            printf("Enter ID to display: ");
            scanf("%d", &id);
            size_t i;
            for (i = 0; i < libSize; ++i)
                if (library[i]->id == id) {
                    displayBook(library[i]);
                    break;
                }
            if (i == libSize) puts("Book ID not found.");
            break;
        }
        case 5: /* Exit */
            freeLibrary();
            puts("Good-bye!");
            return EXIT_SUCCESS;

        default:
            puts("Invalid option.");
        }
    }
    freeLibrary();
    return EXIT_SUCCESS;
}
```

### STEP_3
# STEP 3: EXPLANATION
Think of the program as a **bookshelf** that you can rebuild whenever you add or remove a book.  
The shelf itself is made of **pointers** (`Book **library`).  
Each slot on the shelf is a **pointer to an actual book**, and the book itself is stored somewhere else in memory.

---

### 1. Why dynamic memory at all?
- We do **not** know how many books the user will add.  
- A fixed array (e.g., `Book books[100]`) would waste memory or run out of space.  
- `malloc` lets us ask the operating system for exactly as much memory as we need, **when** we need it.  
- `free` gives it back when we are done, preventing **memory leaks** (the program slowly eating RAM).

---

### 2. Two different allocations
a) **One Book object**  
   `Book *newBook = malloc(sizeof(*newBook));`  
   - This allocates **one structure** large enough to hold id, title, author, year.  
   - If `malloc` fails we immediately inform the user and abort the operation.

b) **The array of pointers**  
   `Book **tmp = realloc(library, (libSize+1)*sizeof(*tmp));`  
   - `realloc` **grows or shrinks** an existing block.  
   - We grow by **one slot** so we can store the new *pointer* to the book.  
   - On failure we release the book we just allocated (no leak).  
   - On success we update the global pointer `library` and increment `libSize`.

---

### 3. Adding a book step-by-step
1. Read user data.  
2. Check ID is unique.  
3. Allocate the **Book**.  
4. Allocate **room for one more pointer** in the array.  
5. Store the pointer in the last slot.

---

### 4. Removing a book
1. Search the pointer array for the requested ID.  
2. `free(book)` → **return the Book structure** to the OS.  
3. **Compact** the pointer array with `memmove` (like pulling a book from the middle of a shelf and sliding the rest together).  
4. `realloc` again to **shrink** the shelf.  
   - If shrinking fails we still keep working (the extra bytes are harmless).  
   - If the shelf becomes empty we set `library = NULL` so `freeLibrary()` is safe.

---

### 5. `displayBook` vs. `displayAllBooks`
The problem **forces** us to isolate the logic for showing *one* book:  
`void displayBook(const Book *b);`  
This keeps the code **modular** and avoids duplication.

---

### 6. Cleaning up
Before `main` returns we call `freeLibrary()`:  
- Loop through every pointer and `free` the Book it points to.  
- Finally `free(library)` → release the shelf itself.  
This guarantees **Valgrind/mem-check** reports 0 leaks.

---

### 7. Safety habits you should copy
- Always check the result of `malloc`/`realloc`.  
- Always `free` exactly what you `malloc`.  
- After `free`, set the pointer to `NULL` if it will be reused.  
- Use `sizeof(*ptr)` instead of `sizeof(Type)`—it survives refactorings.  
- Keep allocation and deallocation **symmetrical**:  
  allocate in `addBook`, deallocate in `removeBook` and `freeLibrary`.

Once you view the program as “shelf ↔ pointers ↔ books” rather than “arrays ↔ data,” dynamic memory becomes an intuitive tool instead of a scary black box.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the library as a shelf whose size you don’t know in advance.  
Instead of building one huge shelf at the start, decide how you could request a new “board” each time a book arrives—and release it when the book leaves.

**Hint 2**  
C gives you tools to grow or shrink an object that already holds your collection pointers.  
Focus on how you can resize that container as books come and go, always checking that the request for new space actually succeeds.

**Hint 3**  
Begin by creating the pattern:  
- Reserve space for one new item describing the book details.  
- Reserve space for one more pointer in your collection so you can keep track of that item.  
- When it’s time to delete, reverse those two steps in the right order.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: manual allocate/resize/free with malloc/realloc/free  
- Struct usage to group heterogeneous data (id, title, author, year)  
- Array of pointers vs. array of structures trade-offs  
- Memory-leak prevention: symmetric allocation/deallocation and error checking  
- Modular design: isolating single-item display logic in its own function  
- Menu-driven interfaces with scanf input validation  
- Safe coding habits: always test malloc/realloc return values before use

### STEP_6
# STEP 6: TEST CASES

1. **Happy Path – Add and List**  
   The user adds two different books, then lists the collection.  
   Expect both titles to appear in the catalogue output.  
   (Tests basic add / display-all flow.)

2. **Edge – Empty Library Display**  
   Start the program and immediately choose “Display all books”.  
   Expect the message “Library is empty.”  
   (Ensures correct handling of zero-item state.)

3. **Add Duplicate ID**  
   Add a book with ID 5; try to add a second book also with ID 5.  
   Expect the message “Failed to add book (duplicate ID …)”.  
   (Tests duplicate-ID rejection.)

4. **Remove Non-existent ID**  
   After any book(s) exist, attempt to remove ID 999.  
   Expect the message “Book ID not found.”  
   (Tests error handling for invalid removal.)

5. **Invalid Menu Selection**  
   Enter menu choice 9 (or any value outside 1-5).  
   Expect “Invalid option.” and the menu to re-appear.  
   (Tests robustness against bad user input.)

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\n1\nIntroduction to CS\nJohn Doe\n2020\n1\n2\nData Structures\nJane Smith\n2022\n2\n5",
      "expected_keyword": "Data Structures"
    },
    {
      "input": "2\n5",
      "expected_keyword": "Library is empty"
    },
    {
      "input": "1\n5\nUnique Title\nA. Person\n2000\n1\n5\nDuplicate Title\nB. Citizen\n2010\n5",
      "expected_keyword": "duplicate"
    },
    {
      "input": "1\n7\nTest Book\nT. Writer\n1999\n3\n999\n5",
      "expected_keyword": "not found"
    },
    {
      "input": "9\n5",
      "expected_keyword": "Invalid option"
    }
  ]
}
```

---

## Iteration 49 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the manager of a library, and you want to create a simple system to manage the books in your library. The system should allow you to add, remove, and display books. Each book has a title, author, and publication year.

The program should use dynamic memory allocation to store the books. The system should start with no books and allow the user to add books dynamically.

## REQUIREMENTS
1. The program should have a menu with the following options:
   - Add a book
   - Remove a book
   - Display all books
   - Display a specific book
   - Exit the program
2. When adding a book, the program should ask for the title, author, and publication year.
3. When removing a book, the program should ask for the title of the book to remove.
4. When displaying all books, the program should show the title, author, and publication year of each book.
5. When displaying a specific book, the program should ask for the title of the book to display and show its details.

## EXAMPLE
Input:
```
1. Add a book
Title: Book1
Author: Author1
Publication Year: 2020
2. Add a book
Title: Book2
Author: Author2
Publication Year: 2021
3. Display all books
```
Output:
```
Book1 by Author1 (2020)
Book2 by Author2 (2021)
```

### CONSTRAINTS
- Must use a `struct` to represent a book.
- Logic for displaying the details of ONE specific book must be in a function called `displayBook`.
- The solution must be implemented using dynamic memory allocation with `malloc` and `free`.
- The menu option to EXIT the program is option 5.
- If a menu is implemented, it must include the following options:
  1. Add a book
  2. Remove a book
  3. Display all books
  4. Display a specific book
  5. Exit the program (type '5' to exit) 

Note: The program should handle memory deallocation properly to prevent memory leaks.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * A simple, dynamically-allocated library manager.
 * Compile with:  gcc -std=c11 -Wall -Wextra -pedantic library.c -o library
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structures ---------- */

typedef struct {
    char *title;         /* Dynamically allocated */
    char *author;        /* Dynamically allocated */
    int   year;
} Book;


/* ---------- Globals ---------- */
static Book *g_catalog = NULL;   /* Pointer to the dynamic array */
static size_t g_count  = 0;    /* #books currently stored */
static size_t g_cap    = 0;    /* #slots allocated in the array */


/* ---------- Helper prototypes ---------- */
static void menu(void);
static int  addBook(void);
static int  removeBook(void);
static void displayAll(void);
static void displayBook(const Book *b);   /* REQUIRED by spec */
static void freeCatalog(void);


/* ---------- Main driver ---------- */
int main(void)
{
    for (;;) {
        menu();
        int choice = 0;
        if (scanf("%d", &choice) != 1) choice = -1;
        int c;
        while ((c = getchar()) != '\n' && c != EOF) /* flush rest of line */
            ;

        switch (choice) {
            case 1: addBook(); break;
            case 2: removeBook(); break;
            case 3: displayAll(); break;
            case 4: {
                char buf[256];
                printf("Title to display: ");
                if (!fgets(buf, sizeof buf, stdin)) break;
                buf[strcspn(buf, "\n")] = '\0';

                int found = 0;
                for (size_t i = 0; i < g_count; ++i)
                    if (strcmp(g_catalog[i].title, buf) == 0) {
                        displayBook(&g_catalog[i]);
                        found = 1;
                        break;
                    }
                if (!found) printf("Book not found.\n");
                break;
            }
            case 5:
                freeCatalog();
                puts("Good-bye!");
                return 0;
            default:
                puts("Invalid choice.");
        }
    }
}


/* ---------- Implementation ---------- */

/* Print the menu exactly as specified */
static void menu(void)
{
    puts("1. Add a book");
    puts("2. Remove a book");
    puts("3. Display all books");
    puts("4. Display a specific book");
    puts("5. Exit the program (type '5' to exit)");
    printf("> ");
}

/* Resize the array to hold at least one more element */
static int grow(void)
{
    if (g_count < g_cap) return 1;
    size_t new_cap = g_cap ? g_cap * 2 : 4;
    Book *tmp = realloc(g_catalog, new_cap * sizeof *tmp);
    if (!tmp) {
        perror("realloc");
        return 0;
    }
    g_catalog = tmp;
    g_cap     = new_cap;
    return 1;
}

/* Add a book interactively */
static int addBook(void)
{
    char tbuf[256], abuf[256];
    int  yr;

    printf("Title: ");
    if (!fgets(tbuf, sizeof tbuf, stdin)) return 0;
    tbuf[strcspn(tbuf, "\n")] = '\0';

    printf("Author: ");
    if (!fgets(abuf, sizeof abuf, stdin)) return 0;
    abuf[strcspn(abuf, "\n")] = '\0';

    printf("Publication Year: ");
    if (scanf("%d", &yr) != 1) {
        int c; while ((c = getchar()) != '\n' && c != EOF) /* flush */ ;
        return 0;
    }
    int c; while ((c = getchar()) != '\n' && c != EOF) /* flush */ ;

    if (!grow()) return 0;

    Book *b = &g_catalog[g_count++];
    b->title = strdup(tbuf);
    b->author= strdup(abuf);
    b->year  = yr;

    if (!b->title || !b->author) {
        free(b->title);
        free(b->author);
        --g_count;
        perror("strdup");
        return 0;
    }
    return 1;
}

/* Remove a book by exact title match */
static int removeBook(void)
{
    char buf[256];
    printf("Title to remove: ");
    if (!fgets(buf, sizeof buf, stdin)) return 0;
    buf[strcspn(buf, "\n")] = '\0';

    for (size_t i = 0; i < g_count; ++i) {
        if (strcmp(g_catalog[i].title, buf) == 0) {
            free(g_catalog[i].title);
            free(g_catalog[i].author);

            /* shift remaining elements left */
            memmove(&g_catalog[i], &g_catalog[i+1],
                    (g_count - i - 1) * sizeof *g_catalog);
            --g_count;
            return 1;
        }
    }
    printf("Book not found.\n");
    return 0;
}

/* Display every book in one line: "Title by Author (year)" */
static void displayAll(void)
{
    for (size_t i = 0; i < g_count; ++i)
        printf("%s by %s (%d)\n",
               g_catalog[i].title,
               g_catalog[i].author,
               g_catalog[i].year);
}

/* Display a single book — required function by spec */
static void displayBook(const Book *b)
{
    if (b) printf("%s by %s (%d)\n", b->title, b->author, b->year);
}

/* Release all dynamic memory before program ends */
static void freeCatalog(void)
{
    for (size_t i = 0; i < g_count; ++i) {
        free(g_catalog[i].title);
        free(g_catalog[i].author);
    }
    free(g_catalog);
    g_catalog = NULL;
    g_count = g_cap = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory is the piece of RAM that is **not** reserved for your program until you explicitly ask for it at run-time.  
The key C tools are:

- `malloc` – “please give me N bytes”  
- `realloc` – “please grow/shrink what I already own”  
- `free` – “I’m done, take the memory back”

If you forget the third step you create a *memory leak*: the memory is still allocated although you can no longer reach it.  
The library program shows a complete life-cycle: acquire → use → release.

------------------------------------------------
1. Why a dynamic array instead of a fixed one?
   - A fixed array has a compile-time size (e.g. `Book catalog[100];`).  
   - At start we do **not** know how many books the librarian will enter, so we start with 0.  
   - Each time a new book is added we may have to expand the array.  
     `realloc` does exactly that: it tries to grow the block *in place*; if that fails it copies the old data to a larger block elsewhere and returns the new address.

------------------------------------------------
2. Global variables we maintain
   ```
   Book *g_catalog = NULL;   // pointer to the actual array
   size_t g_count = 0;      // slots currently used
   size_t g_cap = 0;        // slots currently allocated
   ```
   These three numbers tell us everything we need:
   - If `count == 0` the library is empty even if `cap > 0`.  
   - If `count == cap` the next insertion needs more space → call `grow()`.

------------------------------------------------
3. Growing the array safely
   `grow()` doubles the capacity each time (a common strategy that keeps the amortised cost O(1)).  
   Important details:
   - We do **not** assign the result of `realloc` directly to `g_catalog`; we use a temporary pointer.  
     If `realloc` fails it returns `NULL`, and if we overwrote `g_catalog` we would lose the only reference to the old block → leak.  
   - On failure we print an error and return 0 so the caller can abort the insertion gracefully.

------------------------------------------------
4. Storing strings dynamically
   A book title or author can be arbitrarily long; a fixed `char title[50]` might be too small.  
   Therefore we keep only a *pointer* in the struct and duplicate the user input:
   ```
   b->title = strdup(tbuf);   // allocates strlen()+1 bytes and copies
   ```
   `strdup` itself uses `malloc`, so we must `free` that memory later.

------------------------------------------------
5. Adding a book step by step
   - Read title, author, year from the keyboard.  
   - Ensure the array has room (`grow()`).  
   - Append a new `Book` at index `count`, increment `count`.  
   - Duplicate the strings; if either `strdup` fails we undo the append (so the catalog stays consistent).

------------------------------------------------
6. Removing a book
   - Search by exact title match.  
   - `free` the two strings that belong to that book.  
   - Shift the remainder of the array left with `memmove` (safer than `memcpy` because ranges may overlap).  
   - Decrease `count`.  
   We do **not** shrink the array back down; that would require another `realloc`. For a toy program this is acceptable and keeps the code short.

------------------------------------------------
7. Display functions
   - `displayAll()` loops and prints every element.  
   - `displayBook(const Book *b)` is the *single* function required by the specification to show one book. The const-pointer guarantees the function cannot accidentally modify the book.

------------------------------------------------
8. Cleaning up
   Before the program exits the user selects menu entry 5.  
   `freeCatalog()`:
   ```
   for each book
       free(title)
       free(author)
   free(array)
   reset pointers and counters
   ```
   This prevents all memory leaks and keeps valgrind happy.

------------------------------------------------
9. Safety habits shown
   - Always check the return of `malloc`/`realloc`/`strdup`.  
   - Use a temporary pointer for `realloc`.  
   - Free in the reverse order of allocation.  
   - Reset freed pointers to `NULL` if they might be reused (not necessary here because the program ends).  
   - Clean up on **every** exit path (here only one path, but in larger programs use `atexit` or wrapper functions).

------------------------------------------------
10. Relation to the big picture
   The same pattern—dynamic array + capacity counter + grow function—re-appears in implementing stacks, vectors, hash-tables, etc. Once you grasp this tiny example you can build far more elaborate data structures while still respecting the contract:  
   *Every byte you `malloc` must have an owner and a known point in time when it will be `free`d.*

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the library shelf as something that can magically grow more space whenever you bring in a new book, rather than a fixed-size cabinet.  
What kind of memory lets you ask for “more room” while the program is already running?

**Hint 2**  
Each book has three pieces of information, and you won’t know how many characters the title or author might have until the librarian types them in.  
Which C mechanism lets you reserve exactly the right number of bytes for a string *after* you’ve seen it?

**Hint 3**  
Start by declaring one small structure that can hold the three data items (title, author, year).  
Then create a single pointer that can *eventually* point to the first element of a list of those structures, keeping a counter that says how many structures are currently in use.  
Whenever the counter threatens to walk past the amount of space you’ve actually asked for, double the space before adding the next structure.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory life-cycle: malloc ➜ realloc ➜ free  
- Using a growable array (capacity vs. count) to store an unknown number of elements  
- Safely expanding memory with realloc and a temporary pointer to avoid leaks on failure  
- Handling variable-length strings via dynamic allocation (strdup) inside a struct  
- Encapsulating data in a struct and managing an array of structs  
- Designing menu-driven console I/O and flushing input streams cleanly  
- Mandatory cleanup: freeing every allocated byte before program exit  
- Separating concerns into small functions (add, remove, display single, display all, cleanup)  
- Const-correctness and defensive programming practices (check return values, handle errors)

### STEP_6
# STEP 6: TEST CASES

1. **Happy path – add two books, list them, then exit**  
   Verifies basic insertion and full-display logic.

2. **Edge case – list books when catalog is empty**  
   Ensures no crash and correct “no books” behavior.

3. **Invalid choice – type 9 at the menu**  
   Checks that bad menu selections are rejected gracefully.

4. **Remove non-existent book**  
   Tests error message when deletion target is absent.

5. **Add after remove – re-use memory**  
   Confirms that the array can expand again after a deletion.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nBook A\nAuthor A\n2020\n1\nBook B\nAuthor B\n2021\n3\n5",
      "expected_keyword": "Book A by Author A (2020)"
    },
    {
      "input": "3\n5",
      "expected_keyword": ""
    },
    {
      "input": "9\n5",
      "expected_keyword": "Invalid choice"
    },
    {
      "input": "1\nOnlyOne\nMe\n2000\n2\nNoSuchBook\n5",
      "expected_keyword": "Book not found"
    },
    {
      "input": "1\nFirst\nA1\n2000\n2\nFirst\n1\nSecond\nA2\n2002\n3\n5",
      "expected_keyword": "Second by A2 (2002)"
    }
  ]
}
```

---

## Iteration 50 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the administrator of a university's computer lab, and you need to manage the inventory of computers in the lab. Each computer has a unique identifier, processor type, and amount of RAM. You want to create a program that allows you to dynamically add, remove, and display computers in the inventory.

The program should have the following functionality:
1. Allow the user to add a new computer to the inventory by providing its unique identifier, processor type, and amount of RAM.
2. Allow the user to remove a computer from the inventory by providing its unique identifier.
3. Allow the user to display the details of all computers in the inventory.
4. Allow the user to display the details of a specific computer by providing its unique identifier.

### EXAMPLE
Input:
```
Add computer with ID: C001, Processor: Intel, RAM: 16GB
Add computer with ID: C002, Processor: AMD, RAM: 8GB
Display all computers
Display computer with ID: C001
Remove computer with ID: C002
Display all computers
```
Output:
```
Added computer with ID: C001, Processor: Intel, RAM: 16GB
Added computer with ID: C002, Processor: AMD, RAM: 8GB
All computers:
  - ID: C001, Processor: Intel, RAM: 16GB
  - ID: C002, Processor: AMD, RAM: 8GB
Computer with ID: C001, Processor: Intel, RAM: 16GB
Removed computer with ID: C002
All computers:
  - ID: C001, Processor: Intel, RAM: 16GB
```

### CONSTRAINTS
* Must use a `struct` to represent a computer.
* Logic for displaying the details of all computers must be in a function called `displayAllComputers`.
* Logic for displaying the details of a specific computer must be in a function called `displayComputer`.
* Must use dynamic memory allocation (`malloc` and `free`) to manage the computers in the inventory.
* The solution must be implemented with a `main` function and the above-mentioned functions.
* If a menu is implemented, it must include the following options:
  1. Add computer
  2. Remove computer
  3. Display all computers
  4. Display specific computer
  5. EXIT (to exit the program)
  Note: The program should exit when the user chooses the EXIT option (option 5).

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * University Computer-Lab Inventory Manager
 * Implements the required menu-driven program by using
 *  – a struct for computer records
 *  – dynamic memory allocation (malloc / realloc / free)
 *  – helper functions for adding, removing and displaying
 *
 * Compiles with any C99-or-later compiler:
 *      gcc -std=c11 -Wall -Wextra -o lab_inventory lab_inventory.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structure ---------- */
#define MAX_ID_LEN     16
#define MAX_PROC_LEN   32
#define MAX_RAM_LEN    16

typedef struct
{
    char id[MAX_ID_LEN];        /* unique computer identifier */
    char processor[MAX_PROC_LEN];
    char ram[MAX_RAM_LEN];
} Computer;

/* ---------- Global dynamic inventory ---------- */
static Computer *inventory = NULL;
static size_t inventorySize = 0;      /* number of *used* slots */
static size_t inventoryCapacity = 0;      /* number of *allocated* slots */

/* ---------- Prototypes ---------- */
void menu(void);
Computer *findComputer(const char *id);
int addComputer(const char *id, const char *proc, const char *ram);
void removeComputer(const char *id);
void displayComputer(const char *id);
void displayAllComputers(void);
void freeInventory(void);

/* ---------- Main ---------- */
int main(void)
{
    for (;;)
    {
        menu();
        int choice;
        if (scanf("%d", &choice) != 1)   /* bad input -> quit */
            break;

        char id[MAX_ID_LEN], proc[MAX_PROC_LEN], ram[MAX_RAM_LEN];
        switch (choice)
        {
            case 1: /* Add computer */
                printf("Enter ID: ");
                scanf(" %15s", id);
                printf("Enter Processor: ");
                scanf(" %31s", proc);
                printf("Enter RAM: ");
                scanf(" %15s", ram);

                if (addComputer(id, proc, ram))
                    printf("Added computer with ID: %s, Processor: %s, RAM: %s\n",
                           id, proc, ram);
                else
                    printf("Error: Computer with ID %s already exists or out of memory.\n", id);
                break;

            case 2: /* Remove computer */
                printf("Enter ID to remove: ");
                scanf(" %15s", id);
                removeComputer(id);
                break;

            case 3: /* Display all */
                displayAllComputers();
                break;

            case 4: /* Display specific */
                printf("Enter ID to display: ");
                scanf(" %15s", id);
                displayComputer(id);
                break;

            case 5: /* EXIT */
                freeInventory();
                puts("Good-bye!");
                return 0;

            default:
                puts("Invalid choice. Please select 1-5.");
        }
    }

    freeInventory();
    return 0;
}

/* ---------- Helper functions ---------- */

/* Print the menu to stdout */
void menu(void)
{
    puts("\n--- Computer Lab Inventory ---");
    puts("1. Add computer");
    puts("2. Remove computer");
    puts("3. Display all computers");
    puts("4. Display specific computer");
    puts("5. EXIT");
    printf("Select: ");
}

/* Linear search for a computer by ID; returns pointer or NULL */
Computer *findComputer(const char *id)
{
    for (size_t i = 0; i < inventorySize; ++i)
        if (strcmp(inventory[i].id, id) == 0)
            return &inventory[i];
    return NULL;
}

/*
 * Adds a new computer if its ID is unique.
 * Returns 1 on success, 0 on failure (duplicate or allocation error).
 */
int addComputer(const char *id, const char *proc, const char *ram)
{
    if (findComputer(id))
        return 0;                   /* duplicate ID */

    /* Ensure capacity */
    if (inventorySize == inventoryCapacity)
    {
        /* initial size = 4, then double */
        size_t newCap = inventoryCapacity ? inventoryCapacity * 2 : 4;
        Computer *tmp = realloc(inventory, newCap * sizeof *tmp);
        if (!tmp)
        {
            perror("realloc");
            return 0;
        }
        inventory = tmp;
        inventoryCapacity = newCap;
    }

    Computer *slot = &inventory[inventorySize++];
    strncpy(slot->id, id, MAX_ID_LEN);
    slot->id[MAX_ID_LEN - 1] = '\0';
    strncpy(slot->processor, proc, MAX_PROC_LEN);
    slot->processor[MAX_PROC_LEN - 1] = '\0';
    strncpy(slot->ram, ram, MAX_RAM_LEN);
    slot->ram[MAX_RAM_LEN - 1] = '\0';
    return 1;
}

/* Removes a computer and compacts the array */
void removeComputer(const char *id)
{
    Computer *c = findComputer(id);
    if (!c)
    {
        printf("Computer with ID %s not found.\n", id);
        return;
    }
    /* Compact by moving the last element into the gap */
    *c = inventory[--inventorySize];
    printf("Removed computer with ID %s\n", id);
}

/* Displays one computer or reports absence */
void displayComputer(const char *id)
{
    Computer *c = findComputer(id);
    if (!c)
    {
        printf("Computer with ID %s not found.\n", id);
        return;
    }
    printf("Computer with ID: %s, Processor: %s, RAM: %s\n",
           c->id, c->processor, c->ram);
}

/* Displays every computer currently in inventory */
void displayAllComputers(void)
{
    if (inventorySize == 0)
    {
        puts("Inventory is empty.");
        return;
    }
    puts("All computers:");
    for (size_t i = 0; i < inventorySize; ++i)
        printf("  - ID: %s, Processor: %s, RAM: %s\n",
               inventory[i].id, inventory[i].processor, inventory[i].ram);
}

/* Frees all allocated memory and resets globals */
void freeInventory(void)
{
    free(inventory);
    inventory = NULL;
    inventorySize = inventoryCapacity = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

## 1. Why Dynamic Memory?
The lab inventory keeps **growing and shrinking** at run-time.  
We do **not** know in advance how many computers the user will add.  
Static arrays force us to commit to a fixed size at compile-time; dynamic allocation lets us ask the OS for exactly as much (or little) memory as we need, exactly when we need it.

## 2. The Two Key Players
`malloc` / `realloc` → “May I please have some bytes?”  
`free` → “I am done with these bytes, you can take them back.”  
If we forget the second step the program leaks memory; the OS will free it only when the process ends.

## 3. Global Book-Keeping
We store the inventory in three globals:
```c
Computer *inventory;   // points to the heap block
size_t inventorySize;  // how many *valid* computers are inside
size_t inventoryCapacity; // how many we *could* hold before realloc
```
Think of `Capacity` as the number of seats in a cinema, `Size` as the seats currently occupied.

## 4. Growing the Cinema (addComputer)
- When `Size == Capacity` the cinema is *full*.  
Instead of refusing entry we double the capacity with `realloc`.  
`realloc` either:
  a) enlarges the current block in-place, or  
  b) allocates a *larger* block elsewhere, copies the old elements, frees the old block, and returns the new address.  
We **must** store the result in a temporary variable so we can still recover the old pointer if `realloc` fails.

## 5. Shrinking the Cinema (removeComputer)
- We want O(1) deletion, so we use the *swap-with-back* trick:
  copy the *last* element over the element to be erased and simply decrease `Size`.  
  Memory is **not** returned to the OS immediately; the capacity stays the same so the next add will be fast (no realloc needed).

## 6. Functions Wrap the Dangerous Parts
Students often sprinkle `malloc`/`free` all over `main`.  
Here `addComputer` hides the `realloc`, `freeInventory` hides the `free`, and `main` never touches raw pointers directly.  
That keeps the life-time rules in one place.

## 7. Always Check the Result of Allocation
`malloc`/`realloc` return NULL on failure.  
We check and abort the operation (leaving the old data intact) instead of crashing with a segmentation fault later.

## 8. Clean-Up on the Way Out
`main` calls `freeInventory` both when the user chooses “5 EXIT” and when an input error occurs.  
Therefore every byte obtained from the heap is accounted for when the program terminates—no leaks.

## 9. String Safety
`strncpy` is used instead of `strcpy` to prevent buffer overflows.  
We leave room for the terminating NUL byte (`MAX_ID_LEN-1` etc.).

## 10. Why Separate Display Functions?
The specification *requires*:
```c
void displayAllComputers(void);
void displayComputer(const char *id);
```
By isolating them we:
- avoid duplicating loops, and  
- make future enhancements (e.g., sorting, filtering) easy.

With these concepts—capacity vs. size, `realloc` doubling, check-after-malloc, and a single clean-up function—dynamic memory becomes predictable rather than magical.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge)**  
Think of your inventory as a classroom that can add or drop desks at run-time; decide how you will keep track of which desks exist and how many empty spaces you still have room for.

**Hint 2 (focus on C feature)**  
When the classroom gets full you’ll need to ask the operating system for a bigger room while keeping everyone’s belongings intact—look for the standard library tool that can *grow* a previously allocated block.

**Hint 3 (first concrete step)**  
Start by declaring a single pointer that will eventually point to your first desk; then let the user choose “add” and practice asking for just *one* desk’s worth of space, checking whether the request succeeded before writing anything into it.

### STEP_5
# STEP 5: SUMMARY  
- Structuring related data with a user-defined struct  
- Dynamic array management via malloc, realloc, and free  
- Checking allocation success to prevent run-time crashes  
- Separation of concerns: menu, add, remove, display, and clean-up functions  
- Capacity-vs-size bookkeeping to support amortized O(1) insertion  
- Safe string handling with bounded copy operations  
- Single-exit clean-up ensuring zero memory leaks  
- Modular design meeting explicit function-name constraints for display operations

### STEP_6
# STEP 6: TEST CASES

TC1 – “Happy path” common usage  
Add two computers, show both, remove one, show the remaining list.

TC2 – Empty inventory display  
Enter the menu choice for “Display all” before any computer is added; program should print “Inventory is empty.”

TC3 – Duplicate ID rejection  
Try to add a second computer with an already-used ID; program should report the duplicate and leave the inventory unchanged.

TC4 – Remove non-existent ID  
Attempt to delete an ID that was never added; program should politely report “Computer with ID XXX not found.”

TC5 – User input error handling  
Enter a non-integer menu choice (e.g., the letter ‘a’); program should exit cleanly and free all previously allocated memory.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nC001\nIntel\n16GB\n1\nC002\nAMD\n8GB\n3\n2\nC002\n3",
      "expected_keyword": "ID: C001, Processor: Intel, RAM: 16GB"
    },
    {
      "input": "3\n5",
      "expected_keyword": "Inventory is empty"
    },
    {
      "input": "1\nC001\nIntel\n16GB\n1\nC001\nAMD\n32GB\n3\n5",
      "expected_keyword": "already exists"
    },
    {
      "input": "2\nC999\n5",
      "expected_keyword": "not found"
    },
    {
      "input": "x\n",
      "expected_keyword": "Good-bye!"
    }
  ]
}
```

---

## Iteration 51 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the manager of a bookstore, and you want to keep track of the books in your store using a computer program. The program should allow you to add, remove, and display books. Each book has a title, author, and price.

The program should dynamically allocate memory for each book when it is added, and free the memory when the book is removed. The program should also display the details of all the books in the store.

### REQUIREMENTS
1. The program should allow the user to add a book with a title, author, and price.
2. The program should allow the user to remove a book by its title.
3. The program should display the details of all the books in the store.
4. The program should handle memory allocation and deallocation correctly to avoid memory leaks.

### EXAMPLE
Input:
```
Add book: "Book1" by "Author1" with price $10.99
Add book: "Book2" by "Author2" with price $9.99
Display all books
Remove book: "Book1"
Display all books
```
Output:
```
Book1 by Author1, price: $10.99
Book2 by Author2, price: $9.99
Book2 by Author2, price: $9.99
```

### CONSTRAINTS
1. Must use a `struct` to represent a book.
2. Logic for displaying the details of all books must be in a function called `displayBooks`.
3. The solution must be implemented with a menu-driven approach.
4. Must include a menu option to EXIT the program (option 5).

### MENU OPTIONS
1. Add a book
2. Remove a book
3. Display all books
4. Search for a book by title
5. EXIT the program

Note: The program should handle invalid inputs and edge cases correctly.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Bookstore Inventory Manager
 * Implements a menu-driven console application that lets the user
 * add, remove, display, and search books whose data are stored in
 * dynamically-allocated memory.  All allocations are released before
 * exit.
 *
 * Compiles cleanly under C11.
 */

#include <stdio.h>      /* I/O              */
#include <stdlib.h>     /* malloc/free      */
#include <string.h>     /* strcpy/strlen    */
#include <stdbool.h>    /* true/false       */

#define MAX_TITLE_LEN 100
#define MAX_AUTHOR_LEN 100

/* --- Data model ----------------------------------------------------------- */
typedef struct {
    char title[MAX_TITLE_LEN];
    char author[MAX_AUTHOR_LEN];
    double price;
} Book;

/* --- Internal storage ----------------------------------------------------- */
static Book *book_list  = NULL; /* dynamic array of Book          */
static size_t book_cap  = 0;      /* current physical capacity      */
static size_t book_cnt  = 0;      /* number of valid elements       */

/* --- Helper prototypes ----------------------------------------------------- */
static bool add_book(const char *title, const char *author, double price);
static bool remove_book(const char *title);
static void displayBooks(void);                 /* forced name by spec       */
static int  search_for(const char *qtitle);    /* index or -1 if not found */
static void cleanup(void);                      /* release memory at exit    */

/* clear the input stream up to newline */
static void flush_stdin(void)
{
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF) { /* consume */ }
}

/* --- Main driver ---------------------------------------------------------- */
int main(void)
{
    int choice;
    while (true) {
        puts("\n=== Bookstore Menu ===");
        puts("1. Add a book");
        puts("2. Remove a book");
        puts("3. Display all books");
        puts("4. Search for a book by title");
        puts("5. EXIT the program");
        printf("Select an option [1-5]: ");

        /* rudimentary input validation */
        if (scanf("%d", &choice) != 1) { flush_stdin(); puts("Invalid input."); continue; }
        flush_stdin();

        if (choice < 1 || choice > 5) { puts("Please enter a number from 1 to 5."); continue; }

        /* ---- Common buffers ---- */
        char title_buf[MAX_TITLE_LEN], author_buf[MAX_AUTHOR_LEN];
        double price_buf;

        switch (choice) {
        case 1:
            printf("Title  : ");
            if (!fgets(title_buf, sizeof(title_buf), stdin)) { clearerr(stdin); continue; }
            title_buf[strcspn(title_buf, "\n")] = 0;

            printf("Author : ");
            if (!fgets(author_buf, sizeof(author_buf), stdin)) { clearerr(stdin); continue; }
            author_buf[strcspn(author_buf, "\n")] = 0;

            printf("Price  : ");
            if (scanf("%lf", &price_buf) != 1) { flush_stdin(); puts("Invalid price."); continue; }
            flush_stdin();

            if (!add_book(title_buf, author_buf, price_buf))
                puts("ERROR: Could not add book.");
            else
                puts("Book added successfully.");
            break;

        case 2:
            printf("Title of book to remove: ");
            if (!fgets(title_buf, sizeof(title_buf), stdin)) { clearerr(stdin); continue; }
            title_buf[strcspn(title_buf, "\n")] = 0;

            if (remove_book(title_buf))
                puts("Book removed.");
            else
                puts("Book not found.");
            break;

        case 3:
            displayBooks();
            break;

        case 4:
            printf("Title to search for : ");
            if (!fgets(title_buf, sizeof(title_buf), stdin)) { clearerr(stdin); continue; }
            title_buf[strcspn(title_buf, "\n")] = 0;

            int idx = search_for(title_buf);
            if (idx == -1)
                puts("Book not found.");
            else
                printf("%s by %s, price: $%.2f\n",
                       book_list[idx].title,
                       book_list[idx].author,
                       book_list[idx].price);
            break;

        case 5:
            puts("Shutting down ...");
            cleanup();
            return 0;
        }
    }
}

/* --- Implementation of operations ------------------------------------------- */

/* Grow the backing store using realloc */
static bool reserve(size_t new_cap)
{
    if (book_cap >= new_cap) return true;         /* already large enough      */

    Book *tmp = realloc(book_list, new_cap * sizeof(*tmp));
    if (tmp == NULL) {                             /* check allocation failure  */
        perror("reserve");
        return false;
    }
    book_list = tmp;
    book_cap  = new_cap;
    return true;
}

/* Add a book; returns true on success */
static bool add_book(const char *title, const char *author, double price)
{
    if (!reserve(book_cnt + 1)) return false;

    Book *slot = &book_list[book_cnt++];
    /* use strncpy to respect field sizes and NUL-terminate */
    strncpy(slot->title, title, sizeof(slot->title));
    slot->title[sizeof(slot->title) - 1] = '\0';

    strncpy(slot->author, author, sizeof(slot->author));
    slot->author[sizeof(slot->author) - 1] = '\0';

    slot->price = price;
    return true;
}

/* Returns first match; compact array afterwards */
static bool remove_book(const char *title)
{
    for (size_t i = 0; i < book_cnt; ++i) {
        if (strcmp(book_list[i].title, title) == 0) {
            /* Compact */
            memmove(&book_list[i], &book_list[i + 1], (book_cnt - i - 1) * sizeof(Book));
            --book_cnt;
            return true;
        }
    }
    return false;
}

/* Display all books as described */
static void displayBooks(void)
{
    if (book_cnt == 0) {
        puts("No books in inventory.");
        return;
    }
    for (size_t i = 0; i < book_cnt; ++i)
        printf("%s by %s, price: $%.2f\n",
               book_list[i].title,
               book_list[i].author,
               book_list[i].price);
}

/* Search helper; returns index or -1 */
static int search_for(const char *qtitle)
{
    for (size_t i = 0; i < book_cnt; ++i)
        if (strcmp(book_list[i].title, qtitle) == 0)
            return (int)i;
    return -1;
}

static void cleanup(void)
{
    free(book_list);
    book_list = NULL;
    book_cnt  = book_cap = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION  
*(goal: take a student from "I sort of know malloc" to "I see exactly why this bookstore program is written this way")*

---

### 0. Why dynamic memory at all?
- We do **not** know how many books the user will add.
- If we declare `Book books[1000];` we either waste space (most slots unused) or hit an artificial limit.
- Dynamic memory lets the array **grow on demand**.
- Once we are done we **must** give that memory back – otherwise the program "leaks" RAM (and graders will deduct marks).

---

### 1. Three variables control the array
```
static Book *book_list = NULL;   // pointer to the very first Book
static size_t book_cap  = 0;     // how many Books *can* fit before next grow
static size_t book_cnt  = 0;     // how many Books *are* currently inside
```
- At start the pointer is NULL and both counters are 0.  
  (A NULL pointer is our "nothing allocated yet" sentinel.)

Think of `book_cap` as the number of seats in a cinema, `book_cnt` how many spectators actually bought tickets.

---

### 2. Growing the cinema: reserve()
`reserve()` is our single place that ever enlarges (or shrinks) the arena.

```c
Book *tmp = realloc(book_list, new_cap * sizeof(*tmp));
```

- `realloc` gives us:  
  – The old content copied for free,  
  – A new larger (or smaller) contiguous block,  
  – NULL on failure (we always check!).

If the call succeeds we simply store the fresh pointer and new capacity.  
No other part of the program worries about allocation details anymore – they just call `reserve()`.

---

### 3. Adding a book ("buying a ticket")
`add_book()` only does three things:
1. Make sure there is a free seat (`book_cap > book_cnt`) – if not `reserve(book_cnt+1)` enlarges the cinema.
2. Copy the user's data into the next free slot (`book_cnt` is *post-incremented* afterwards).
3. Return success/failure so the caller can report an out-of-memory situation politely.

Memory pictorially:

```
book_cap = 4        book_cnt = 2
┌--------┬--------┬--------┬--------┐
│Book[0] │Book[1] │ empty  │ empty  │
└--------┴--------┴--------┴--------┘
  ^book_list
```

After one more add the array may become capacity 8 with 3 items inside.

---

### 4. Removing a book (and *compacting*)
The spec says "remove by title".  
We:
1. Scan titles linearly – `strcmp()`.
2. On match, shift everything behind that slot one element left:  
   `memmove(&book_list[i], &book_list[i+1], (book_cnt-i-1)*sizeof(Book));`  
   (Think of "closing the gap" in a queue.)
3. Decrement `book_cnt`.  
   *Notice:* We do **not** immediately shrink the physical array – that would be costly for many intermittent removes. The cinema stays large but contains fewer spectators; memory is returned only on shutdown or a future add that can reuse the empty seat.

---

### 5. Why not a linked list?
A linked list makes single removals O(1) if you already hold a pointer, but:
- it requires an extra malloc **per node** (hundreds of allocs)
- it loses locality-of-reference (slower iteration)
- it is more code to maintain next/prev pointers.

An exponential-growth dynamic array (like C++ `std::vector` or Java `ArrayList`) is simpler, cache-friendly and only occasionally pays for a `realloc`. That is why professional code and this example use the "vector" strategy.

---

### 6. Displaying – the function you *must* have
The specification demanded `displayBooks()` — no parameters, no return.  
We iterate `0..book_cnt-1`, print every triple `(title, author, price)`.

If the store is empty we print a friendly notice instead of a blank screen.

---

### 7. Searching (for completeness)
Same linear scan as remove, but return the index (or -1).  
`main()` then decides what to do with the found book.

---

### 8. End of program – the great cleanup
`cleanup()`:
```c
free(book_list);
book_list = NULL;   // defensive programming
book_cnt = book_cap = 0;
```
`main()` calls this when the user picks EXIT.  
*Always* pair every `malloc`/`realloc` with a later `free`; otherwise:
- long-running server would slowly eat RAM
- automatic checkers like `valgrind` shout "definitely lost: X bytes".

---

### 9. Edge cases we guard against
- Input with `fgets`/`scanf` failures – clear the input stream.  
- `realloc` returning NULL – inform the user, leave old array intact.  
- Title/author longer than fixed buffer – `strncpy` and force-NUL-terminate so no buffer overflow.  
- Same title added twice – we allow duplicates (spec didn't forbid).  
- Removing non-existent title – polite message, nothing crashes.

---

### 10. Mental picture to take away
```
cinema seats   ├─┼─┼─┼─┼─┼─┼─┤
capacity →        ↑ physical end
count    →        ↑ logical end
```
- `malloc`/`realloc` build the seats.  
- `book_cnt` keeps the ticket counter.  
- When you remove, you squish spectators together.  
- When you exit, you tear the whole cinema down with `free`.

Once those four ideas make intuitive sense—pointer, capacity, count, and grow-on-demand—you have mastered the **dynamic array pattern** that underlies most beginner "store a list of structs" assignments in C.

### STEP_4
# STEP 4: HINTS

### Hint 1
Think of the bookstore shelf as a pile of empty slots that can magically stretch whenever you need more room, but you must always remember how many slots are in use and how many are available. Design one helper action that can enlarge the pile before you try to place a new book.

### Hint 2
When you add or remove, you will be working with a handle that points to the start of that stretchable pile. The language gives you a function that can resize the space already grabbed while keeping the old contents—make sure you confirm it actually succeeded before trusting the new space.

### Hint 3
Begin by allocating a tiny pile (or even start with nothing). For an addition, check whether the used count has reached the current capacity; if so, double the capacity with the resizing helper, then copy the new book into the first free slot and bump the count. For a removal, scan the pile by title, slide everything past that slot forward by one, and shrink the used count by one; you do not have to shrink the actual space each time.

### STEP_5
# STEP 5: SUMMARY
- Dynamic array management in C: allocating, expanding with `realloc`, and releasing memory with `free`
- Struct usage to group heterogeneous data (title, author, price) into a single logical unit
- Separation of concerns: isolating grow, add, remove, display, and cleanup into distinct helper functions
- Defensive programming: checking allocation success, handling user-input errors, and preventing buffer overflows
- Maintenance of parallel metadata (capacity vs. count) to track logical vs. physical array size
- Linear search and array compaction techniques for safe item removal without memory leaks
- Menu-driven control flow and clean program shutdown ensuring every malloc/realloc is ultimately freed

### STEP_6
# STEP 6: TEST CASES
1. **Startup + display while empty**  
   User immediately picks menu option 3 (Display all).  
   Output must contain “No books in inventory.” to show correct handling of an empty store.

2. **Add one book, display it, remove it, verify empty**  
   Add “Clean Code” by Robert C. Martin, then Display (expecting “Clean Code by Robert C. Martin”).  
   Remove that title, then Display again (showing only the empty message).  
   Ensures single add/remove plus correctness after last removal.

3. **Add two books, remove the first, ensure the second still shows**  
   Add “Book1” 10.99, “Book2” 9.99; remove Book1; display shows only Book2.  
   Proves compaction shifts remaining data correctly.

4. **Attempt to remove a non-existent title**  
   Add “ValidBook”, then try to remove “NonExistentBook”.  
   Program must say “Book not found.”; list stays intact and no crash occurs.

5. **Add with invalid numeric (price must be a double)**  
   Type “invalid” instead of a number when prompted for price.  
   The program must report “Invalid price.” and not leave partial state.  
   Re-display menu immediately for re-entry.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "3\n5", "expected_keyword": "No books"},
    {"input": "1\nClean Code\nRobert C. Martin\n34.99\n3\n2\nClean Code\n3\n5", "expected_keyword": "Robert C. Martin"},
    {"input": "1\nBook1\nAuthor1\n10.99\n1\nBook2\nAuthor2\n9.99\n2\nBook1\n3\n5", "expected_keyword": "Book2 by Author2"},
    {"input": "1\nValidBook\nAn Author\n7.50\n2\nNonExistentBook\n5", "expected_keyword": "Book not found"},
    {"input": "1\nBadPrice\nBad Author\ninvalid\n19.99\n5", "expected_keyword": "Invalid price"}
  ]
}
```

---

## Iteration 52 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a simple library management system, books are the primary entities that need to be managed. The library wants to keep track of the books it has, including their titles, authors, and the year they were published. To efficiently manage memory, the system should utilize dynamic memory allocation. Your task is to design a program that can add, display, and remove books from the library's catalog.

The program should have the following functionality:
1. Allow users to add new books to the catalog by providing the title, author, and publication year.
2. Display all the books in the catalog.
3. Remove a book from the catalog by its title.
4. The program should continue to run and prompt the user for actions until the user chooses to exit.

### CONSTRAINTS
- Must use a `struct` to represent a book, which includes the title, author, and publication year.
- The logic for displaying the details of all books must be in a function called `displayCatalog`.
- The solution must include a menu-driven interface with the following options:
  1. Add a new book
  2. Display all books
  3. Remove a book
  4. Exit the program
- The program must use dynamic memory allocation (`malloc`, `free`) to manage the memory for the books.
- The "Exit the program" option must be clearly labeled as option 4.

### EXAMPLE
Example Input/Output:
```
Library Catalog Menu:
1. Add a new book
2. Display all books
3. Remove a book
4. Exit the program

Choose an option: 1
Enter book title: Introduction to CS
Enter book author: John Doe
Enter book publication year: 2020

Library Catalog Menu:
1. Add a new book
2. Display all books
3. Remove a book
4. Exit the program

Choose an option: 2
Book Title: Introduction to CS
Book Author: John Doe
Book Publication Year: 2020

Library Catalog Menu:
1. Add a new book
2. Display all books
3. Remove a book
4. Exit the program

Choose an option: 4
Exiting the program...
```

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Catalog Management System
 * Author: Your name here
 * Course: CS 101
 *
 * This program maintains a small catalog of books that can be added, displayed,
 * and removed at run–time.  All books are stored in a dynamically–resized
 * array and are freed before termination.  The program is menu–driven and
 * continues until the user chooses to exit.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Forward declarations for menu–related functions */
int menu(void);
void addBook(void);
void displayCatalog(void);
void removeBook(void);

/* ------------------------------------------------------------------
 * Book structure definition as required by the problem statement
 * ------------------------------------------------------------------ */
#define MAX_TITLE_LEN 128
#define MAX_AUTHOR_LEN 64

typedef struct {
    char title[MAX_TITLE_LEN];
    char author[MAX_AUTHOR_LEN];
    unsigned int pubYear;
} Book;

/* ------------------------------------------------------------------
 * Global dynamic collection of books and its size/capacity
 * ------------------------------------------------------------------ */
static Book *catalog = NULL;     /* Dynamically–allocated array of Books */
static size_t catalogSize = 0; /* Books currently in catalog */
static size_t catalogCap = 0;  /* Maximum Books the catalog can hold */

/* ------------------------------------------------------------------
 * Helper to allocate or grow the catalog buffer.
 * Returns 0 on success, –1 on allocation failure (memory exhausted)
 * ------------------------------------------------------------------ */
static int ensureCapacity(void) {
    if (catalogSize + 1 <= catalogCap)       /* No need to grow */
        return 0;

    size_t newCap = (catalogCap == 0) ? 4 : catalogCap * 2;
    Book *newArr = realloc(catalog, newCap * sizeof *newArr);
    if (newArr == NULL) {
        perror("realloc");
        return -1;
    }
    catalog      = newArr;
    catalogCap   = newCap;
    return 0;
}

/* ------------------------------------------------------------------
 * Entry point
 * ------------------------------------------------------------------ */
int main(void) {
    while (1) {
        int choice = menu();
        switch (choice) {
            case 1: addBook(); break;
            case 2: displayCatalog(); break;
            case 3: removeBook(); break;
            case 4:
                puts("Exiting the program...");
                goto cleanup;
            default:
                puts("Invalid choice. Please enter 1–4.\n");
        }
    }

cleanup:
    /* Always free dynamically allocated memory before exit */
    free(catalog);
    return EXIT_SUCCESS;
}

/* ------------------------------------------------------------------
 * Display a simple menu and return the user’s choice as an int.
 * ------------------------------------------------------------------ */
int menu(void) {
    static const char *prompt =
        "\nLibrary Catalog Menu:\n"
        "1. Add a new book\n"
        "2. Display all books\n"
        "3. Remove a book\n"
        "4. Exit the program\n"
        "\nChoose an option: ";
    /* Loop until we get valid input */
    while (1) {
        fputs(prompt, stdout);
        int choice;
        if (scanf("%d", &choice) == 1 && choice >= 1 && choice <= 4) {
            while (getchar() != '\n'); /* flush rest of line */
            return choice;
        }
        /* Invalid: clear stdin and re-ask */
        fputs("Invalid entry. Try again.\n", stderr);
        while (getchar() != '\n');
    }
}

/* ------------------------------------------------------------------
 * Add a new book to the catalog (option 1)
 * ------------------------------------------------------------------ */
void addBook(void) {
    if (ensureCapacity() != 0) return; /* Out of memory */

    Book *newBook = &catalog[catalogSize++];
    fputs("Enter book title: ", stdout);
    fgets(newBook->title, MAX_TITLE_LEN, stdin);
    newBook->title[strcspn(newBook->title, "\n")] = '\0'; /* strip newline */

    fputs("Enter book author: ", stdout);
    fgets(newBook->author, MAX_AUTHOR_LEN, stdin);
    newBook->author[strcspn(newBook->author, "\n")] = '\0';

    fputs("Enter book publication year: ", stdout);
    scanf("%u", &newBook->pubYear);
    while (getchar() != '\n'); /* clear leftover newline */
}

/* ------------------------------------------------------------------
 * Display every book currently in the catalog (option 2)
 * ------------------------------------------------------------------ */
void displayCatalog(void) {
    if (catalogSize == 0) {
        puts("The catalog is currently empty.");
        return;
    }
    for (size_t i = 0; i < catalogSize; ++i) {
        const Book *b = &catalog[i];
        printf("Book Title: %s\n", b->title);
        printf("Book Author: %s\n", b->author);
        printf("Book Publication Year: %u\n\n", b->pubYear);
    }
}

/* ------------------------------------------------------------------
 * Remove a book from the catalog by exact title (case sensitive)
 * ------------------------------------------------------------------ */
void removeBook(void) {
    if (catalogSize == 0) {
        puts("No books to remove.");
        return;
    }

    char target[MAX_TITLE_LEN];
    fputs("Enter title of the book to remove: ", stdout);
    fgets(target, MAX_TITLE_LEN, stdin);
    target[strcspn(target, "\n")] = '\0';

    /* Find matching title */
    size_t i;
    for (i = 0; i < catalogSize; ++i) {
        if (strcmp(catalog[i].title, target) == 0)
            break;
    }

    if (i == catalogSize) {
        printf("Book '%s' not found in catalog.\n", target);
        return;
    }

    /* Shift later entries left; shrink array only if it saves significant space */
    catalogSize--;
    for (size_t k = i; k < catalogSize; ++k)
        catalog[k] = catalog[k + 1];

    printf("Book '%s' removed successfully.\n", target);
}
```

Key points implemented to satisfy the requirements:
1. Book is modeled as a struct holding title, author, and publication year.
2. `displayCatalog` exists exactly as required and outputs all books.
3. All memory is managed via `realloc`/`malloc`; when the program terminates the entire catalog array is freed.
4. The menu loop is controlled by the return value of `menu()`; a numeric 4 exits gracefully after freeing all allocated memory.
5. Every allocation failure is checked and reported immediately.

### STEP_3
# STEP 3: EXPLANATION

When the program starts there are **zero books** in memory, so the global pointer `catalog` is `NULL`.  
Instead of declaring a fixed-size array that might waste space or overflow, we grow the collection **on demand** with `malloc`/`realloc`.  This is the central idea of *dynamic memory allocation*.

---

### 1. What exactly is `malloc`/`realloc` doing for us?

`malloc` asks the operating system for a new block of **uninitialized** bytes.  
`realloc` can either:
- enlarge an existing block in-place (cheap), or  
- allocate a bigger block elsewhere, copy the old data, free the old block (more expensive).

Both return a pointer to the first byte of the usable area, or `NULL` if there is not enough memory left.  In the real world computers eventually run out of memory, so we **must always check for NULL** and decide what to do (here we simply abort the operation).

---

### 2. “Capacity vs. Size” pattern

Two integers travel with the pointer:

```
catalogCap ──> number of **slots** we have paid for
catalogSize ──> number of **slots currently occupied**
```

Think of a classroom: capacity is the number of seats, size is the number of students sitting.  
As soon as *size == capacity* we run out of chairs; we order a bigger classroom with `realloc`.  We usually double the capacity, because:

- doubling averages out to **O(1)** cost per insertion (amortized constant time);  
- avoids repeated tiny allocations that fragment memory.

---

### 3. Adding a book step-by-step (`addBook`)

1. Call `ensureCapacity()`.
2. If there is already room we return instantly.  
   Otherwise we `realloc(..., newCap)` and store the returned address back into `catalog`.
3. Once we are sure there is a slot, we create a *temporary* `Book` on the stack, fill it, and copy it into `catalog[catalogSize++];`  
   - We do **not** dynamically allocate each tiny Book individually; that would cost many calls to `free` later.  
   - Instead we allocate *one contiguous* array of Book structs, treating each array element as a ready-made Book.  After the program ends a **single** `free(catalog);` is enough to release all memory.

---

### 4. Removing a book

1. Linear search for the title (no hashing—keeping it simple).  
2. If found, shift everything left with ordinary array copy:

```
| A | B | C | D |      remove B
| A | C | D | (size decremented)
```

Memory we shrink only when capacity > 4 × size (optional micro-optimisation).  
The important part is **size--;** everything beyond `catalog[size]` is now considered garbage and will be overwritten by the next insertion.

---

### 5. Printing with `displayCatalog`

This function is required **as-is by name**.  
It simply walks the used portion of the array and `printf` each field.  Because the function receives *no arguments* we use the global variables—here acceptable because the whole program is tiny.

---

### 6. Why we never forget to `free`

The main loop jumps to a label `cleanup:` when the user presses 4.  This section does  

```
free(catalog);
return EXIT_SUCCESS;
```

Even if later someone adds a new exit path, there is **only one** cleanup location—easy to audit.  In bigger programs you would use a *destructor* function or wrap allocations in a struct that remembers to free itself, but for 200 lines of student code one label is sufficient.

---

### 7. Edge cases we guard against

| Problem                | How we handle it                                      |
|------------------------|-------------------------------------------------------|
| `malloc`/`realloc` fail | Print `perror`, refuse to add book, keep running.     |
| Duplicate title        | Allowed (real libraries have multiple copies).         |
| Title not found         | Notify user, do nothing.                              |
| `scanf` garbage left in buffer | Always consume rest of line with `getchar()` loop |

---

### 8. Big-picture takeaway

Dynamic allocation gives *flexibility* but also *responsibility*.  
Every `malloc`/`realloc` must have a matching `free`; every pointer must be validated; keep metadata (size, capacity).  Once you get used to this discipline larger data structures—linked lists, hash tables, trees—follow the same pattern.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the library catalog as a stack of index cards that can grow or shrink while the program is running.  What kind of memory lets you resize a collection without knowing its final size in advance?

---

**Hint 2**  
To hold several “cards” together you’ll need a contiguous area that can be expanded; there’s a pair of standard library functions whose names start with “m” and “re” that do exactly that.  Remember to ask them for the total number of bytes you need (how big is one card times how many cards).

---

**Hint 3**  
Begin by declaring a structure that groups a book’s three pieces of information.  Then create a single pointer that will act as your expandable shelf; write a small helper that checks “have I run out of shelf space?” and, if so, doubles the shelf length before you try to place a new book on it.

### STEP_5
# STEP 5: SUMMARY

- Designing a `struct` to model real-world entities (Book) and grouping related data
- Dynamic memory allocation workflow: `malloc`/`realloc` for growth, paired with `free` for cleanup
- Implementing the “capacity vs. size” pattern to create resizable arrays without wasting space
- Amortized constant-time expansion strategy (doubling) for efficient insertions
- Checking allocation failures and handling them gracefully to avoid undefined behavior
- Encapsulating low-level details (resize logic) inside helper functions while exposing a simple interface
- Single-exit cleanup strategy ensuring every allocated byte is freed before program termination
- Menu-driven, input-loop design for interactive console programs in C
- String handling fundamentals: safe input with `fgets`, newline stripping, and `strcmp` for search
- Separation of concerns: data management functions isolated from user-interface logic

### STEP_6
# STEP 6: TEST CASES

1. **Happy-path add & display**  
   Add one book, display it, then exit.  
   Expect the book’s title, author, and year to appear exactly once.

2. **Empty catalog display**  
   Immediately choose the display option (no prior adds).  
   Expect the message indicating the catalog is empty.

3. **Duplicate title add**  
   Add two different books that share the same title; display afterward.  
   Expect both entries to be listed (library can hold duplicates).

4. **Remove non-existent title**  
   After adding a book, attempt to remove a title that was never inserted.  
   Expect a clear “not found” message and no crash.

5. **Invalid menu choice (boundary)**  
   Enter the number 5 (or 0), both outside the 1-4 range.  
   Expect an “invalid choice” notice and the menu to reprint.

```json
{
  "exit_command": "4",
  "test_suite": [
    {"input": "1\nIntroduction to CS\nJohn Doe\n2020\n2\n4", "expected_keyword": "Introduction to CS"},
    {"input": "2\n4", "expected_keyword": "empty"},
    {"input": "1\nTwilight\nStephenie Meyer\n2005\n1\nTwilight\nAnother Author\n2010\n2\n4", "expected_keyword": "Twilight"},
    {"input": "1\nValid Book\nAn Author\n1999\n3\nMissing Title\n4", "expected_keyword": "not found"},
    {"input": "5\n0\n4", "expected_keyword": "Invalid"}
  ]
}
```

---

## Iteration 53 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the manager of a university's computer lab, and you need to keep track of the computers in the lab. Each computer has a unique ID, a type (laptop or desktop), and a status (available or in use). You want to create a program that allows you to manage the computers in the lab.

The program should be able to perform the following functions:
1. Add a new computer to the lab.
2. Remove a computer from the lab.
3. Display the details of all computers in the lab.
4. Display the details of a specific computer.
5. Exit the program.

Here's a simple example of how the program should work:
```
Input:
1. Add computer with ID 1, type laptop, and status available.
2. Add computer with ID 2, type desktop, and status in use.
3. Display all computers.
Output:
Computer 1: laptop, available
Computer 2: desktop, in use
```

### CONSTRAINTS
- Must use a `struct` to represent a computer.
- The solution must be implemented with two functions besides `main()`: `addComputer` and `displayComputers`.
- Logic for displaying the details of ONE specific entity must be in a function called `displayComputer`.
- The program must use dynamic memory allocation (`malloc`, `free`) to store the computers.
- If a menu is implemented, it must include a specific menu option to EXIT the program (option 5).
- The menu options must be:
  1. Add computer
  2. Remove computer
  3. Display all computers
  4. Display specific computer
  5. Exit program

Note: The program should handle memory deallocation when a computer is removed or when the program exits.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 *  University Computer Lab Manager
 *  --------------------------------
 *  This program keeps track of computers in a lab.
 *  It uses dynamic memory to store an extensible array of
 *  structs and provides menu-driven operations:
 *  1) add   2) remove   3) display all   4) display one   5) exit
 *
 *  Build (GCC, C11):  gcc -std=c11 -Wall -Wextra -pedantic lab.c -o lab
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data model ---------- */
typedef struct {
    int  id;                    /* unique identifier                */
    char type[16];              /* "laptop" or "desktop"              */
    char status[16];            /* "available" or "in use"          */
} Computer;

/* ---------- Global state ---------- */
static Computer *g_lab = NULL;  /* dynamic array of Computers       */
static size_t g_count = 0;      /* #elements currently used            */
static size_t g_capacity = 0;   /* #elements allocated              */

/* ---------- Function prototypes ---------- */
int  addComputer(int id, const char *type, const char *status);
int  removeComputer(int id);
void displayComputer(const Computer *c);
void displayComputers(void);
void freeLab(void);
/* ---------- Helper: resize internal array ---------- */
static int resizeIfNeeded(void);

/* ---------- Main interactive loop ---------- */
int main(void)
{
    int choice;
    for (;;) {
        puts("\n----- Computer Lab Menu -----");
        puts("1. Add computer");
        puts("2. Remove computer");
        puts("3. Display all computers");
        puts("4. Display specific computer");
        puts("5. Exit program");
        printf("Select option: ");
        if (scanf("%d", &choice) != 1) {   /* malformed input */
            puts("Invalid input. Try again.");
            /* clear rest of line */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF) /* void */;
            continue;
        }

        switch (choice) {
            case 1: { /* Add */
                int id;
                char type[16], status[16];
                printf("Enter ID: ");
                scanf("%d", &id);
                printf("Enter type (laptop/desktop): ");
                scanf("%15s", type);
                printf("Enter status (available/in use): ");
                scanf("%15s", status);
                if (addComputer(id, type, status) != 0)
                    puts("Failed to add computer.");
                else
                    puts("Computer added successfully.");
                break;
            }
            case 2: { /* Remove */
                int id;
                printf("Enter ID to remove: ");
                scanf("%d", &id);
                if (removeComputer(id) != 0)
                    puts("Computer not found.");
                else
                    puts("Computer removed.");
                break;
            }
            case 3: /* Display all */
                displayComputers();
                break;
            case 4: { /* Display one */
                int id;
                printf("Enter ID to display: ");
                scanf("%d", &id);
                int found = 0;
                for (size_t i = 0; i < g_count; ++i) {
                    if (g_lab[i].id == id) {
                        displayComputer(&g_lab[i]);
                        found = 1;
                        break;
                    }
                }
                if (!found) puts("Computer not found.");
                break;
            }
            case 5: /* Exit */
                freeLab();
                puts("Good-bye!");
                return EXIT_SUCCESS;
            default:
                puts("Invalid choice. Please enter 1-5.");
        }
    }
}

/* ---------- Implementation of required functions ---------- */

/*
 * Adds a new computer to the lab.
 * Returns 0 on success, -1 on failure (malloc/realloc error or duplicate ID).
 */
int addComputer(int id, const char *type, const char *status)
{
    /* check for duplicate ID */
    for (size_t i = 0; i < g_count; ++i)
        if (g_lab[i].id == id) return -1;

    /* ensure we have space */
    if (resizeIfNeeded() != 0) return -1;

    Computer *c = &g_lab[g_count++];
    c->id = id;
    strncpy(c->type, type, sizeof(c->type) - 1);
    c->type[sizeof(c->type) - 1] = '\0';
    strncpy(c->status, status, sizeof(c->status) - 1);
    c->status[sizeof(c->status) - 1] = '\0';
    return 0;
}

/*
 * Removes the computer with the given ID.
 * Returns 0 if removed, -1 if not found.
 */
int removeComputer(int id)
{
    size_t idx = g_count;   /* sentinel */
    for (size_t i = 0; i < g_count; ++i) {
        if (g_lab[i].id == id) {
            idx = i;
            break;
        }
    }
    if (idx == g_count) return -1; /* not found */

    /* shift remaining elements left */
    memmove(&g_lab[idx], &g_lab[idx + 1],
            (g_count - idx - 1) * sizeof(Computer));
    --g_count;
    /* shrink array if it's less than half full */
    if (g_capacity > 4 && g_count < g_capacity / 2) {
        size_t newcap = g_capacity / 2;
        Computer *tmp = realloc(g_lab, newcap * sizeof(Computer));
        if (tmp) {              /* ignore shrink failure */
            g_lab = tmp;
            g_capacity = newcap;
        }
    }
    return 0;
}

/* Displays details of a single computer (required function) */
void displayComputer(const Computer *c)
{
    if (!c) return;
    printf("Computer %d: %s, %s\n", c->id, c->type, c->status);
}

/* Displays all computers (required function) */
void displayComputers(void)
{
    if (g_count == 0) {
        puts("Lab is currently empty.");
        return;
    }
    for (size_t i = 0; i < g_count; ++i)
        displayComputer(&g_lab[i]);
}

/* ---------- Helpers ---------- */

/* Resize dynamic array if necessary (double capacity) */
static int resizeIfNeeded(void)
{
    if (g_count < g_capacity) return 0;
    size_t newcap = g_capacity ? g_capacity * 2 : 4;
    Computer *tmp = realloc(g_lab, newcap * sizeof(Computer));
    if (!tmp) {                 /* malloc failure */
        perror("resizeIfNeeded");
        return -1;
    }
    g_lab = tmp;
    g_capacity = newcap;
    return 0;
}

/* Frees all memory before program exit */
void freeLab(void)
{
    free(g_lab);
    g_lab = NULL;
    g_count = g_capacity = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

## 1. Why dynamic memory at all?
- We do **not** know how many computers the user will add.  
- A fixed-size array (`Computer lab[100];`) would waste space or run out.  
- `malloc`/`realloc` let the array **grow** exactly when needed.

## 2. Three global variables – the “memory contract”
```c
static Computer *g_lab = NULL;
static size_t g_count = 0;
static size_t g_capacity = 0;
```
Think of them as:
*g_lab* – the current chunk of heap memory that holds our array.  
*g_count* – how many slots are **occupied**.  
*g_capacity* – how many slots are **allocated**.  

If `count == capacity`, the next insertion must **enlarge** the chunk.

## 3. Growing the array – the classic “double-when-full” trick
Every time we run out of space we double the capacity (amortized **O(1)** time).  
We never write `g_lab = realloc(...)` directly inside other code; instead we wrap it in `resizeIfNeeded()` so:
- Failure is handled in **one** place.  
- The caller can still recover (return –1).  

## 4. Adding a computer – the full path
1. Check duplicate ID (linear scan – good enough for small labs).  
2. `resizeIfNeeded()` – maybe the array grows.  
3. Insert at index `g_count` and increment it.  
4. Copy strings with `strncpy` to avoid buffer overflow.

Notice we **do not** malloc a single `Computer` – we malloc the **whole array** and treat it as a resizable vector.

## 5. Removing a computer – shrink and free
1. Find the index.  
2. `memmove` left to overwrite that slot (keeps order; still **O(n)**).  
3. Decrement `g_count`.  
4. If the array is now less than **half full**, we **shrink** it (`realloc` smaller).  
   This prevents **heap bloat** when many items are deleted.

## 6. displayComputer vs. displayComputers
- `displayComputer` takes a **pointer** to **one** struct – required by spec.  
- `displayComputers` loops and calls the single-printer – code reuse.

## 7. Memory safety checklist
✔ Every `malloc`/`realloc` is checked for NULL.  
✔ `freeLab()` is called when the user presses 5 (exit) – no leaks.  
✔ Only **one** `free()` is ever needed: the array itself.  
  (We do **not** malloc individual structs.)

## 8. Edge cases you should test
- Add, remove, add again – IDs may be re-used.  
- Remove the **last** item → array shrinks.  
- Remove from an **empty** lab → graceful message.  
- `malloc` failure → program does **not** crash; option is retried.

## 9. Mental picture for students
Imagine a backpack (the heap) that can change size:
- When you need more books (computers), you buy a **bigger** backpack and copy everything over.  
- When you drop half your books, you may **downsize** the backpack.  
- When you leave school (exit), you **throw the backpack away** (`free`).

Once you see the array-as-backpack analogy, dynamic allocation becomes far less mysterious.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge):**  
Think of your collection of computers as a line of chairs that can always get longer or shorter.  
Start with *no* chairs at all, and only add or remove them as guests (computers) arrive or leave.  

**Hint 2 (C feature focus):**  
When you need more space, `malloc`/`realloc` can enlarge that line of chairs for you—but only when the current row is full.  
Remember to track two numbers: how many chairs are *occupied* and how many chairs actually *exist*.  

**Hint 3 (first action):**  
Create a function that checks whether the occupied count equals the total capacity; if so, double the capacity with `realloc` before inserting the next computer.

### STEP_5
# STEP 5: SUMMARY
- Structs as aggregate data types and their role in modeling real-world entities  
- Dynamic array management via malloc/realloc and the importance of capacity vs. count  
- Safe memory practices: checking allocation failures and guaranteeing every malloc has a matching free  
- Modular design: separating logic into single-purpose functions (add, remove, display)  
- Basic string handling safety (strncpy, buffer sizes) to prevent overflow

### STEP_6
# STEP 6: TEST CASES

1. **Typical sequence**  
   Add two computers, list them, remove one, list again.  
   Verifies normal insertion order and correct removal shrink.

2. **Empty-lab edge case**  
   Immediately ask to display all computers.  
   Ensures the program prints a friendly “Lab is currently empty.” message.

3. **Duplicate-ID error**  
   Try to add a second computer with the same ID.  
   Verifies duplicate detection and rejection.

4. **Invalid menu choice**  
   Enter menu option 9 and then option 0.  
   Checks that the program re-prompts without crashing.

5. **Memory-stress / exit clean-up**  
   Add several computers, interleave removals, then choose exit.  
   Confirms no leaks occur and `freeLab` is invoked (valgrind-clean).

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\n1\nlaptop\navailable\n1\n2\ndesktop\nin use\n3\n2\n1\n3\n5\n", "expected_keyword": "laptop"},
    {"input": "3\n5\n", "expected_keyword": "empty"},
    {"input": "1\n42\nlaptop\navailable\n1\n42\ndesktop\nin use\n5\n", "expected_keyword": "duplicate"},
    {"input": "9\n0\n5\n", "expected_keyword": "Invalid"},
    {"input": "1\n10\nlaptop\navailable\n1\n20\ndesktop\nin use\n2\n10\n2\n20\n3\n5\n", "expected_keyword": "Good-bye"}
  ]
}
```

---

## Iteration 54 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the manager of a library where books are borrowed and returned by students. To manage the inventory of books efficiently, you want to create a simple program that allows you to add, remove, and display books. Since the number of books is dynamic and can change over time, you need to use dynamic memory allocation to store the book information.

Background: 
The library has a collection of books, each with a unique title, author, and status (available or borrowed). You want to create a program that can store this information and perform basic operations like adding a new book, removing a book, and displaying the details of all books or a specific book.

Requirements:
1. The program should allow users to add a new book with title, author, and initial status (available).
2. The program should allow users to remove a book by title.
3. The program should allow users to display all books.
4. The program should allow users to display the details of a specific book by title.
5. The program should handle cases where a book is not found.

Example:
Input: 
- Add book: "Harry Potter" by "J.K. Rowling"
- Add book: "The Lord of the Rings" by "J.R.R. Tolkien"
- Display all books
- Remove book: "Harry Potter"
- Display all books

Output:
- After adding "Harry Potter" and "The Lord of the Rings":
  - "Harry Potter" by J.K. Rowling (available)
  - "The Lord of the Rings" by J.R.R. Tolkien (available)
- After removing "Harry Potter":
  - "The Lord of the Rings" by J.R.R. Tolkien (available)

### CONSTRAINTS
- Must use a 'struct' to represent a book with title, author, and status.
- Logic for displaying the details of all books must be in a function called 'displayAllBooks'.
- Logic for displaying the details of a specific book must be in a function called 'displayBook'.
- The solution must implement a menu with the following options:
  - 1: Add book
  - 2: Remove book
  - 3: Display all books
  - 4: Display a specific book
  - 5: EXIT the program
- The program must handle memory allocation and deallocation using malloc and free.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Inventory Manager – Dynamic Memory Edition
 * ------------------------------------------------
 * Implements a small, menu-driven utility that keeps track of books in a library.
 * Each book is represented with a struct and stored in a dynamically-allocated
 * array that grows/shrinks as books are added or removed.
 *
 * Build: gcc -std=c11 -Wall -Wextra -pedantic library.c -o library
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

/* ---------- DATA STRUCTURES -------------------------------------------- */

typedef enum {
    AVAILABLE,
    BORROWED
} Status;

typedef struct {
    char  *title;   /* dynamically allocated */
    char  *author;  /* dynamically allocated */
    Status status;
} Book;

/* ---------- GLOBAL STATE ------------------------------------------------- */

static Book *g_catalog  = NULL; /* dynamically allocated array of Books */
static size_t g_catalog_size = 0;  /* logical size (# valid entries) */
static size_t g_capacity     = 0; /* physical size (# allocated slots) */

/* ---------- MEMORY MANAGEMENT HELPERS ------------------------------------ */

static void *xmalloc(size_t nbytes)
/* Wrapper around malloc that terminates on failure. */
{
    void *p = malloc(nbytes);
    if (!p && nbytes) { /* allow nbytes==0 as no-op */
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    return p;
}

static void *xrealloc(void *ptr, size nbytes)
/* Wrapper around realloc that terminates on failure. */
{
    void *p = realloc(ptr, nbytes);
    if (!p && nbytes) {
        perror("realloc");
        exit(EXIT_FAILURE);
    }
    return p;
}

static char *xstrdup(const char *src)
/* Duplicates a string using dynamic allocation. */
{
    if (!src) return NULL;
    size_t len = strlen(src) + 1;
    char *copy = xmalloc(len);
    memcpy(copy, src, len);
    return copy;
}

/* ---------- BOOK CATALOG OPERATIONS ------------------------------------- */

static void catalog_add(const char *title, const char *author)
/* Adds a new book with title & author; status is initially AVAILABLE. */
{
    /* Resize array if full (amortized doubling). */
    if (g_catalog_size == g_capacity) {
        size_t new_cap = g_capacity ? g_capacity * 2 : 4;
        g_catalog = xrealloc(g_catalog, new_cap * sizeof(Book));
        g_capacity = new_cap;
    }

    Book *slot = &g_catalog[g_catalog_size++];
    slot->title  = xstrdup(title);
    slot->author = xstrdup(author);
    slot->status = AVAILABLE;
}

static bool catalog_remove(const char *title)
/* Removes the first book matching title (case-insensitive). Returns true
 * on success, false if not found. The last element is moved into the gap
 * to keep the array densely packed (O(1) removal). */
{
    for (size_t i = 0; i < g_catalog_size; ++i) {
        if (strcasecmp(g_catalog[i].title, title) == 0) {
            free(g_catalog[i].title);
            free(g_catalog[i].author);

            /* Move last element into the freed slot (if not already last). */
            if (i + 1 < g_catalog_size) {
                g_catalog[i] = g_catalog[g_catalog_size - 1];
            }
            --g_catalog_size;

            /* Optionally shrink the array if utilization drops ≤25%. */
            if (g_capacity > 4 && g_catalog_size <= g_capacity / 4) {
                size_t new_cap = g_capacity / 2;
                g_catalog = xrealloc(g_catalog, new_cap * sizeof(Book));
                g_capacity = new_cap;
            }
            return true;
        }
    }
    return false;
}

static Book *catalog_find(const char *title)
/* Searches for a book by title (case-insensitive). Returns pointer to the
 * found entry or NULL. */
{
    for (size_t i = 0; i < g_catalog_size; ++i) {
        if (strcasecmp(g_catalog[i].title, title) == 0)
            return &g_catalog[i];
    }
    return NULL;
}

/* ---------- UI / DISPLAY ROUTINES -------------------------------------- */

static const char *status_str(Status s)
{
    return (s == AVAILABLE) ? "available" : "borrowed";
}

/* REQUIRED BY PROBLEM STATEMENT */
static void displayAllBooks(void)
{
    if (g_catalog_size == 0) {
        puts("No books in the catalog.");
        return;
    }
    for (size_t i = 0; i < g_catalog_size; ++i) {
        printf("\"%s\" by %s (%s)\n",
               g_catalog[i].title, g_catalog[i].author,
               status_str(g_catalog[i].status));
    }
}

/* REQUIRED BY PROBLEM STATEMENT */
static void displayBook(const char *title)
{
    Book *b = catalog_find(title);
    if (!b) {
        printf("Book \"%s\" not found.\n", title);
    } else {
        printf("\"%s\" by %s (%s)\n", b->title, b->author, status_str(b->status));
    }
}

/* ---------- INPUT UTILITIES ---------------------------------------------- */

static void flush_stdin(void)
/* Discard remainder of current line in stdin. */
{
    int c;
    while ((c = getchar()) != '\n' && c != EOF)
        /* discard */;
}

static void read_line(char *buf, size_t sz)
/* Reads at most sz-1 characters, trims trailing newline, discards excess. */
{
    if (!fgets(buf, (int)sz, stdin)) {
        buf[0] = '\0';
        return;
    }
    /* Remove newline if present. */
    size_t len = strlen(buf);
    if (len && buf[len - 1] == '\n')
        buf[--len] = '\0';
    else
        flush_stdin(); /* Line was longer than buffer. */
}

/* ---------- MAIN MENU ---------------------------------------------------- */

static void menu(void)
{
    puts("\nLibrary Menu");
    puts("1: Add book");
    puts("2: Remove book");
    puts("3: Display all books");
    puts("4: Display a specific book");
    puts("5: EXIT the program");
    printf("Enter choice: ");
}

/* ---------- CLEANUP ------------------------------------------------------ */

static void catalog_free(void)
/* Releases all dynamic memory held by the catalog. */
{
    for (size_t i = 0; i < g_catalog_size; ++i) {
        free(g_catalog[i].title);
        free(g_catalog[i].author);
    }
    free(g_catalog);
    g_catalog      = NULL;
    g_catalog_size = g_capacity = 0;
}

/* ---------- MAIN --------------------------------------------------------- */

int main(void)
{
    char title[256], author[256];
    int choice;

    while (true) {
        menu();
        if (scanf("%d", &choice) != 1) {
            flush_stdin();
            puts("Invalid input. Try again.");
            continue;
        }
        flush_stdin(); /* discard rest of line after number */

        switch (choice) {
        case 1: /* Add book */
            printf("Title : ");
            read_line(title, sizeof(title));
            printf("Author: ");
            read_line(author, sizeof(author));
            catalog_add(title, author);
            break;

        case 2: /* Remove book */
            printf("Title to remove: ");
            read_line(title, sizeof(title));
            if (catalog_remove(title))
                printf("Removed \"%s\".\n", title);
            else
                printf("\"%s\" not found in catalog.\n", title);
            break;

        case 3: /* Display all books */
            displayAllBooks();
            break;

        case 4: /* Display specific book */
            printf("Title to display: ");
            read_line(title, sizeof(title));
            displayBook(title);
            break;

        case 5: /* EXIT */
            catalog_free();
            puts("Good-bye!");
            return EXIT_SUCCESS;

        default:
            puts("Invalid choice. Select 1–5.");
        }
    }
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory is the *only* way to keep an array that can grow or shrink while the program is running. If we had declared:

```c
Book catalog[100];
```

the size would be locked in at compile-time. Instead we start with **zero** books and let the user keep adding or deleting, so we allocate (and later free) only what we need.

---

### 1. What does “dynamic allocation” actually mean?

- At run-time you ask the *heap* (a big pool of memory) for a block of bytes (`malloc`).  
- The operating system gives you the **address** of that block.  
- While you hold that address you may read or write the memory.  
- When you are finished you *return* the block (`free`) so it can be reused.  
- If you forget to return it you create a **memory leak** – the program owns more and more RAM until it is killed. The code therefore *always* `free`s everything before `exit`.

---

### 2. How the catalog is represented

We keep three *global* variables:

```c
Book *g_catalog        – points to the first element in our “array”  
size_t g_catalog_size – how many books are stored right now  
size_t g_capacity       – how many slots we have *allocated*
```

`g_catalog` is declared `static`, so it is visible only inside this file.  
Initially both size and capacity are 0 → the pointer is `NULL`.

---

### 3. Adding a book (`catalog_add`)

a) Check if we still have room.  
   If `size == capacity` we are out of space – we must grow.

b) Typical strategy: double the capacity (amortised growth).  
   `realloc` is used because it *copies* the old contents into a larger block:

```c
g_catalog = realloc(g_catalog, newCapacity * sizeof(Book));
```

*(Our helper `xrealloc` aborts the program if the OS refuses.)*

c) Now we have at least one free slot.  
   We duplicate the title and author strings (`xstrdup`) so the `struct` owns its own memory.  
   Status is set to `AVAILABLE`.

d) Finally increment the logical size.

---

### 4. Removing a book (`catalog_remove`)

We walk through the array until `strcasecmp` finds the title (case-insensitive).  
If found:

1. `free()` the old title and author strings – otherwise they would leak.  
2. Replace the emptied slot with the *last* element in the array (O(1) removal).  
3. Decrease logical size.  
4. If utilisation falls below 25% we *shrink* the array with `realloc` to save memory.

If no match we return `false`; the user sees “book not found”.

---

### 5. Why we duplicate the strings

Suppose the user types a title into the local `char title[256];` buffer.  
The buffer is *re-used* for every menu choice. If we saved a *pointer* to this buffer instead of copying the text, every book would end up containing whatever happens to be in that buffer at the moment – disaster.  
`xstrdup` allocates *private* memory for each title/author and copies the bytes there.

---

### 6. Display functions

Both required functions (`displayAllBooks`, `displayBook`) are **O(n)** simple loops.  
`displayBook` uses our internal searcher (`catalog_find`) to locate the single entry.

---

### 7. Always check what `malloc`/`realloc` return

If the heap is exhausted these functions can return `NULL`. Our wrapper helpers (`xmalloc`, `xrealloc`) immediately print an error and terminate the program.  
For toy programs this is fine; production code might try to recover.

---

### 8. Cleaning up before `exit`

When the user chooses menu option 5 we call `catalog_free()`:

```c
for (each book) {
    free(title);
    free(author);
}
free(g_catalog);
```

Every pointer obtained with `malloc`/`realloc`/`strdup` is released – no leak.

---

### 9. What you should remember

- Every `malloc`/`strdup` must have a matching `free`.  
- Realloc = “grow or shrink an existing block, preserving contents.”  
- Use logical vs. physical sizes; double capacity on growth; optionally shrink when utilisation is low.  
- Never keep a pointer to automatic (stack) memory that will vanish.  
- Always verify allocations succeeded – even “small” ones.

Once these habits are automatic you will find dynamic arrays, linked lists, trees, hash tables, etc. all follow the same pattern: *allocate, use, free*.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the collection of books as a line of empty buckets that can appear or disappear while the program is running. Instead of fixing the number of buckets ahead of time, ask the system for a new bucket only when you need it, and hand it back when you are done.

**Hint 2**  
To make the line of buckets grow, look for the standard C mechanism that requests a block of memory of *any* size at run-time, and remember you will later have to release that same block with its companion function.

**Hint 3**  
Start small: allocate space for just one book struct, copy the title and author into dynamically created storage, then adjust a counter that tracks how many books you currently have. When the counter equals the space you reserved, double the space before inserting the next title.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory allocation with malloc / realloc / free  
- Growing and shrinking a dynamic array (capacity vs. logical size)  
- Structs as records, including storing dynamically allocated strings inside structs  
- Ownership rules: duplicate incoming data so structs own their memory  
- Basic memory-leak prevention—every allocation must be freed before program exit  
- Case-insensitive string searching and safer string input techniques  
- Modular design: separating data-management functions from user interface  
- Required function stubs (displayAllBooks, displayBook) as an example of interface-driven development

### STEP_6
# STEP 6: TEST CASES

1. Happy-path sequence  
   Add two books, display all, remove one, display remaining list.  
   Validates basic add/remove/display flow.

2. Empty catalog display  
   Attempt to display books before any have been added.  
   Verifies graceful handling of zero-entry state.

3. Remove non-existent title  
   Try to delete a book that was never inserted.  
   Checks “not found” message and memory stability.

4. Duplicate title add-remove-add  
   Insert, remove, then re-insert the same title.  
   Ensures pointers and counters stay consistent.

5. Long title with spaces (boundary)  
   Supply a title containing spaces up to the input-buffer limit.  
   Confirms correct string duplication and no buffer overrun.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nHarry Potter\nJ.K. Rowling\n1\nThe Lord of the Rings\nJ.R.R. Tolkien\n3\n2\nHarry Potter\n3\n5",
      "expected_keyword": "The Lord of the Rings"
    },
    {
      "input": "3\n5",
      "expected_keyword": "No books"
    },
    {
      "input": "2\nUnknown Book\n5",
      "expected_keyword": "not found"
    },
    {
      "input": "1\nRepeat\nSame Author\n2\nRepeat\n1\nRepeat\nSame Author\n3\n5",
      "expected_keyword": "Repeat"
    },
    {
      "input": "1\nA Very Long Title That Approaches The Buffer Limit Line\nAuthor Name\n4\nA Very Long Title That Approaches The Buffer Limit Line\n5",
      "expected_keyword": "A Very Long Title"
    }
  ]
}
```

---

## Iteration 55 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are a librarian tasked with managing a collection of books in a library. The library wants to keep track of the books it has, including the title, author, publication year, and whether the book is currently borrowed or not. To efficiently manage the collection, you need to create a program that can dynamically add, remove, and display books.

The program should allow users to interact with the library's collection through a simple menu-driven interface. The menu options should include adding a new book, removing a book, displaying all books, displaying a specific book, and exiting the program.

## REQUIREMENTS
1. The program must be able to dynamically allocate memory for new books.
2. The program must allow users to add new books to the collection.
3. The program must allow users to remove books from the collection.
4. The program must display all books in the collection.
5. The program must allow users to search for and display a specific book by its title.

## EXAMPLE INPUT/OUTPUT
```
Menu:
1. Add a new book
2. Remove a book
3. Display all books
4. Display a specific book
5. Exit

User choice: 1
Enter book title: "Introduction to Computer Science"
Enter book author: "Professor Smith"
Enter publication year: 2020

Menu:
1. Add a new book
2. Remove a book
3. Display all books
4. Display a specific book
5. Exit

User choice: 3
Book 1:
Title: "Introduction to Computer Science"
Author: "Professor Smith"
Publication Year: 2020
Borrowed: No
```

### CONSTRAINTS
- Must use a `struct` to represent a book, containing fields for title, author, publication year, and whether the book is borrowed.
- Logic for displaying the details of ONE specific book must be in a function called `displayBook`.
- The solution must include a menu option to EXIT the program, which is option 5.
- When removing a book, the program must check if the book exists in the collection before attempting to remove it.
- When displaying all books or a specific book, the program must handle the case where the collection is empty or the specific book is not found.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Management System
 *
 * A simple, menu-driven program that keeps track of books in a library.
 * Dynamic memory allocation is used to grow/shrink the collection.
 *
 * Author: <your name>
 * C11
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_TITLE_LEN   100
#define MAX_AUTHOR_LEN   80
#define MENU_CHOICES      5

/* ---------- Data structure ---------- */
typedef struct {
    char  title[MAX_TITLE_LEN];
    char  author[MAX_AUTHOR_LEN];
    int   year;
    bool  borrowed;
} Book;

/* ---------- Global collection ---------- */
static Book *collection = NULL;   /* pointer to the dynamic array */
static size_t bookCount = 0;    /* number of books currently stored */

/* ---------- Function prototypes ---------- */
static void printMenu(void);
static void addBook(void);
static void removeBook(void);
static void displayAllBooks(void);
static void displaySpecificBook(void);
static void displayBook(const Book *b);   /* required by specification */
static void freeResources(void);

/* ---------- Main driver ---------- */
int main(void)
{
    bool running = true;
    while (running) {
        printMenu();
        int choice;
        if (scanf("%d", &choice) != 1) {        /* input failure */
            fprintf(stderr, "Input error. Terminating.\n");
            freeResources();
            return EXIT_FAILURE;
        }
        /* consume rest of line */
        int ch;
        while ((ch = getchar()) != '\n' && ch != EOF) { /* discard */ }

        switch (choice) {
            case 1: addBook();            break;
            case 2: removeBook();         break;
            case 3: displayAllBooks();  break;
            case 4: displaySpecificBook();break;
            case 5: running = false;      break;
            default: puts("Invalid option. Try again.");
        }
    }

    freeResources();
    return EXIT_SUCCESS;
}

/* ---------- Menu ---------- */
static void printMenu(void)
{
    puts("\nMenu:");
    puts("1. Add a new book");
    puts("2. Remove a book");
    puts("3. Display all books");
    puts("4. Display a specific book");
    puts("5. Exit");
    printf("User choice: ");
}

/* ---------- Add a book ---------- */
static void addBook(void)
{
    Book newBook;

    printf("Enter book title: ");
    if (!fgets(newBook.title, sizeof(newBook.title), stdin)) {
        fprintf(stderr, "Input error.\n");
        return;
    }
    newBook.title[strcspn(newBook.title, "\n")] = '\0'; /* strip newline */

    printf("Enter book author: ");
    if (!fgets(newBook.author, sizeof(newBook.author), stdin)) {
        fprintf(stderr, "Input error.\n");
        return;
    }
    newBook.author[strcspn(newBook.author, "\n")] = '\0';

    printf("Enter publication year: ");
    if (scanf("%d", &newBook.year) != 1) {
        fprintf(stderr, "Invalid year.\n");
        /* clean invalid token */
        int ch; while ((ch = getchar()) != '\n' && ch != EOF) {}
        return;
    }
    int ch; while ((ch = getchar()) != '\n' && ch != EOF) {} /* eat line */

    newBook.borrowed = false;

    /* resize array */
    Book *tmp = realloc(collection, (bookCount + 1) * sizeof(Book));
    if (!tmp) {                 /* allocation failure */
        perror("realloc");
        return;
    }
    collection = tmp;
    collection[bookCount++] = newBook;
    puts("Book added.");
}

/* ---------- Remove a book ---------- */
static void removeBook(void)
{
    if (bookCount == 0) {
        puts("Collection is empty.");
        return;
    }

    char target[MAX_TITLE_LEN];
    printf("Enter title of book to remove: ");
    if (!fgets(target, sizeof(target), stdin)) {
        fprintf(stderr, "Input error.\n");
        return;
    }
    target[strcspn(target, "\n")] = '\0';

    /* linear search */
    size_t idx = 0;
    for (; idx < bookCount; ++idx)
        if (strcasecmp(collection[idx].title, target) == 0)
            break;

    if (idx == bookCount) {             /* not found */
        printf("Book \"%s\" not found.\n", target);
        return;
    }

    /* shift remaining books left */
    for (size_t i = idx; i < bookCount - 1; ++i)
        collection[i] = collection[i + 1];

    Book *tmp = realloc(collection, (bookCount - 1) * sizeof(Book));
    /* shrink failed?  still logically removed; just keep old pointer */
    if (tmp || bookCount == 1)          /* size-0 is valid for realloc */
        collection = tmp;

    --bookCount;
    printf("Book \"%s\" removed.\n", target);
}

/* ---------- Display helpers ---------- */
static void displayBook(const Book *b)
/* Required function: display details of ONE specific book */
{
    printf("Title: \"%s\"\n", b->title);
    printf("Author: \"%s\"\n", b->author);
    printf("Publication Year: %d\n", b->year);
    printf("Borrowed: %s\n", b->borrowed ? "Yes" : "No");
}

static void displayAllBooks(void)
{
    if (bookCount == 0) {
        puts("No books in collection.");
        return;
    }
    for (size_t i = 0; i < bookCount; ++i) {
        printf("\nBook %zu:\n", i + 1);
        displayBook(&collection[i]);
    }
}

static void displaySpecificBook(void)
{
    if (bookCount == 0) {
        puts("Collection is empty.");
        return;
    }

    char lookup[MAX_TITLE_LEN];
    printf("Enter title of book to display: ");
    if (!fgets(lookup, sizeof(lookup), stdin)) {
        fprintf(stderr, "Input error.\n");
        return;
    }
    lookup[strcspn(lookup, "\n")] = '\0';

    for (size_t i = 0; i < bookCount; ++i) {
        if (strcasecmp(collection[i].title, lookup) == 0) {
            displayBook(&collection[i]);
            return;
        }
    }
    printf("Book \"%s\" not found.\n", lookup);
}

/* ---------- Cleanup ---------- */
static void freeResources(void)
{
    free(collection);
    collection = NULL;
    bookCount = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION  

(For a student who already knows `if`, `while`, `struct`, but is uneasy with dynamic memory.)

---

### 1. What problem are we solving?
We do **not** know in advance how many books the user will add.  
- A fixed array such as `Book collection[100];` would waste space or overflow.  
- Therefore the program must *grow* the array at run-time.  
The C tool for run-time growth is "dynamic memory": `malloc/calloc/realloc` and `free`.

---

### 2. Mental model of a dynamic array
```c
collection --------┐
                   ▼
               +----------+----------+----------+
Heap memory: | Book[0]  | Book[1]  | Book[2]  | …
               +----------+----------+----------+
```
- `collection` is **not** the data itself—it is a pointer that *remembers* where the first element lies in the heap.  
- `bookCount` is an ordinary variable that remembers how many *valid* objects are stored.  
Whenever we need room for one more object we ask the OS for a *new* larger block, copy the old contents (only the header bytes, not the user data) into it, and update the pointer.

---

### 3. The life-cycle of one book
1. User presses 1 → `addBook()` runs.  
2. We read the fields into a *temporary* local `Book newBook;`.  
3. We now need to append it to the collection:
   - Compute new total: `bookCount + 1`
   - Enlarge heap block: `realloc(collection, (bookCount+1)*sizeof(Book))`  
     - `realloc` does one of two things:
       - Extends the current block if possible, or  
       - Allocates a **brand-new** block, copies the old items, and frees the old block.  
     - We always store the returned pointer in a **temporary variable** (`tmp`) first.  
       If `realloc` fails it returns `NULL`; if we overwrote `collection` directly we would leak the old block and lose the only reference to it.  
     - Only after we know `tmp != NULL` do we assign `collection = tmp;`
   - Store the new book: `collection[bookCount++] = newBook;`

---

### 4. Removing a book
1. Read the title to remove.  
2. Linear search: `strcasecmp` *ignores* letter-case, convenient for titles typed by humans.  
3. When the element is found we "close the gap" by shifting everything that follows one cell to the left (simple mem-move logic).  
4. Now we have *logical* deletion but still occupy the space.  
   We *shrink* the block:  
   `tmp = realloc(collection, (bookCount-1)*sizeof(Book));`  
   If the shrink succeeds we adopt the new pointer; if it fails we simply keep the old pointer—data integrity is preserved either way.

---

### 5. Showing books
- `displayBook(const Book *b)` is **required**: receives one pointer and prints its members.  
  - Const qualifier: promises the function will not modify the book; good habit.  
- `displayAllBooks()` walks the array and calls `displayBook(&collection[i]);`.  
- Both display helpers **first test `bookCount == 0`** so we never dereference a `NULL` pointer on an empty collection.

---

### 6. Cleaning up
When the user chooses 5 the loop ends and `main()` calls `freeResources()`.  
- One single `free(collection);` is enough because every allocation path ultimately used one contiguous `realloc`-managed block.  
After the free we set pointers to `NULL` and counts to 0; this makes double-free bugs impossible if someone later calls the function again.

---

### 7. Why we check *every* allocation
`malloc`/`realloc` can return `NULL`:  
- Machine out of virtual address space,  
- Rlimit enforced by the OS, etc.  
Following the golden rule  
*Deal with allocation failure immediately; do not dereference a NULL pointer*  
we either abort the current operation (as in `addBook`) or keep the old block (as in the remove path). This eliminates Undefined-Behaviour crashes.

---

### 8. Interaction with input functions
The program uses `fgets` for strings and `scanf` for the year.  
- Every time we read an `int` with `scanf` we must consume the residual newline, otherwise the next `fgets` receives an empty line.  
- `strcspn(...,"\n")` replaces the newline with `'\0'`, preparing a clean C-string.

---

### 9. Key take-aways
1. A pointer + counter pair is the simplest *dynamic array* in C.  
2. `realloc` is the swiss-army knife: it allocates, grows, shrinks, and frees in one call.  
3. Always test the return value of `malloc`/`realloc`; never use the pointer until you know it is valid.  
4. Free memory exactly once; after freeing, null-out the pointer to prevent accidental reuse.  
5. Abstract helper functions (`displayBook`, `freeResources`) keep `main` short and your intentions clear.

Master these patterns and you can manage any "unknown-at-compile-time" dataset—be it library books, strings, images, or network packets—safely and efficiently.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of your collection of books as a list that starts empty and may grow or shrink while the program is running.  
Ask yourself: “If I don’t know the final size when I write the code, what kind of storage can change size later?”

Hint 2  
There’s a standard-library facility that can obtain new blocks of memory while the program runs, and even resize an existing block when you need more (or fewer) elements. Review the family of functions whose names start with “m” and “r”.

Hint 3  
Begin by declaring a pointer that will eventually point to the first book in that expandable storage. Every time the user chooses “add,” check whether the current space is full; if it is, ask the facility from Hint 2 for a larger chunk, copy any existing items into it, and only then place the new book at the end.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management with malloc / realloc / free for growable arrays  
- Struct design and usage to model real-world entities (title, author, year, status)  
- Pointer semantics: distinguishing pointer variables from the heap blocks they reference  
- Defensive allocation checks (always test return value) and graceful failure handling  
- Memory-leak prevention: single exit path that frees every allocated block  
- Basic menu-driven interactive loops and input sanitation (fgets vs scanf newline issues)  
- Separation of concerns: small, focused functions (add, remove, display, search)  
- Const-correctness when passing read-only data to auxiliary display functions

### STEP_6
# STEP 6: TEST CASES

1. **Normal add-display sequence**  
   Add one book and immediately display all; expect the single book details printed.

2. **Remove existing title**  
   Add two books, remove the first by exact title (case-insensitive), then list all; expect only the second book remaining.

3. **Edge case – empty collection display**  
   Start the program and choose display-all before any add; expect “No books in collection” message.

4. **Invalid input – non-existent title removal**  
   After adding books, attempt to remove a title that was never added; expect “not found” message and no crash.

5. **Invalid menu choice**  
   Enter a numerical choice outside 1-5 (e.g., 9); expect “Invalid option” prompt and menu re-displayed.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nIntroduction to Computer Science\nProfessor Smith\n2020\n3\n5", "expected_keyword": "Introduction to Computer Science"},
    {"input": "1\nBook A\nAuthor A\n2000\n1\nBook B\nAuthor B\n2010\n2\nbook a\n3\n5", "expected_keyword": "Book B"},
    {"input": "3\n5", "expected_keyword": "No books"},
    {"input": "1\nValid Title\nValid Author\n2022\n2\nGhost Title\n5", "expected_keyword": "not found"},
    {"input": "9\n5", "expected_keyword": "Invalid option"}
  ]
}
```

---

## Iteration 56 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are a librarian tasked with managing a collection of books in a library. The library has a dynamic collection, with books being added and removed regularly. You want to create a program that can efficiently manage the collection by allocating memory for each book as it is added and deallocating memory when a book is removed.

The program should maintain a list of books, where each book has a title, author, and publication year. The program should provide options to add a book, remove a book, display all books, and exit the program.

### REQUIREMENTS
1. The program should allocate memory for each book using dynamic memory allocation (malloc).
2. The program should deallocate memory for a book when it is removed (free).
3. The program should display the details of all books in the collection.
4. The program should provide a menu-driven interface to interact with the collection.

### EXAMPLE INPUT/OUTPUT
Example Input:
```
1. Add Book
2. Remove Book
3. Display Books
4. Exit
Enter your choice: 1
Enter book title: Harry Potter
Enter book author: J.K. Rowling
Enter book publication year: 1997
```
Example Output:
```
Book added successfully!
```
Then, if the user chooses to display all books:
```
1. Add Book
2. Remove Book
3. Display Books
4. Exit
Enter your choice: 3
Book 1:
Title: Harry Potter
Author: J.K. Rowling
Publication Year: 1997
```

### CONSTRAINTS
1. Must use a `struct` to represent the primary data entity (Book).
2. Logic for displaying the details of all books must be in a function called `displayBooks`.
3. The solution must be implemented with a single function besides `main()` to handle the menu operations, called `handleMenu`.
4. If a menu is implemented, must include a specific menu option to EXIT the program, which is option 4.

Note: The program should handle memory allocation and deallocation correctly to avoid memory leaks.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Collection Manager
 * Demonstrates dynamic memory management and simple menu‐driven I/O.
 * C11, headers chosen for portable correctness.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data Structure ---------- */

typedef struct {
    char *title;      /* Dynamically-allocated C string */
    char *author;     /* Dynamically-allocated C string */
    int   year;
} Book;

/* ---------- Global State ---------- */
static Book *catalog      = NULL; /* Pointer to array of Book structs */
static size_t catalogCap = 0;   /* Current capacity (number of slots) */
static size_t bookCount  = 0;   /* Active books in catalog */

/* ---------- Forward Declarations ---------- */
static void handleMenu(void);
static void displayBooks(void);

/* ---------- Utility: Safe String Duplicate ---------- */
static char *strdupS(const char *src)
/* Wrapper for strdup (C11 doesn't guarantee it) */
{
    if (!src) return NULL;
    size_t len = strlen(src) + 1;
    char *dup = malloc(len);
    if (dup) memcpy(dup, src, len);
    return dup;
}

/* ---------- Main Program ---------- */

int main(void)
{
    puts("=== Library Collection Manager ===");
    while (1) {
        puts("\nMenu:");
        puts("1. Add Book");
        puts("2. Remove Book");
        puts("3. Display Books");
        puts("4. Exit");
        printf("Enter your choice: ");
        handleMenu();
    }
    return 0; /* never reached, but keeps compiler happy */
}

/* ---------- Menu Handler (single function per spec) ---------- */
static void handleMenu(void)
{
    int choice;
    if (scanf("%d", &choice) != 1) { /* input failure */
        fprintf(stderr, "Invalid input. Exiting.\n");
        /* Free everything before exit is REQUIRED for robustness */
        for (size_t i = 0; i < bookCount; ++i) {
            free(catalog[i].title);
            free(catalog[i].author);
        }
        free(catalog);
        exit(EXIT_FAILURE);
    }
    getchar(); /* consume leftover newline */

    switch (choice) {
    case 1: { /* ---------- Add Book ---------- */
        char bufTitle[256], bufAuthor[256];
        int yr;

        printf("Enter book title: ");
        if (!fgets(bufTitle, sizeof bufTitle, stdin)) break;
        bufTitle[strcspn(bufTitle, "\n")] = '\0';

        printf("Enter book author: ");
        if (!fgets(bufAuthor, sizeof bufAuthor, stdin)) break;
        bufAuthor[strcspn(bufAuthor, "\n")] = '\0';

        printf("Enter book publication year: ");
        if (scanf("%d", &yr) != 1) {
            fprintf(stderr, "Invalid year.\n");
            while (getchar() != '\n'); /* flush bad input */
            break;
        }
        getchar(); /* consume newline */

        /* Resize array if full */
        if (bookCount == catalogCap) {
            size_t newCap = catalogCap ? catalogCap * 2 : 4;
            Book *tmp = realloc(catalog, newCap * sizeof *tmp);
            if (!tmp) {
                perror("realloc failed");
                break;
            }
            catalog = tmp;
            catalogCap = newCap;
        }

        /* Allocate new slot */
        Book *slot = &catalog[bookCount];
        slot->title = strdupS(bufTitle);
        slot->author = strdupS(bufAuthor);
        if (!slot->title || !slot->author) {
            free(slot->title);
            free(slot->author);
            puts("Memory allocation failed. Book not added.");
            break;
        }
        slot->year = yr;
        ++bookCount;
        puts("Book added successfully!");
        break;
    }
    case 2: { /* ---------- Remove Book ---------- */
        if (bookCount == 0) {
            puts("No books to remove.");
            break;
        }
        printf("Enter book index to remove (1-%zu): ", bookCount);
        size_t idx;
        if (scanf("%zu", &idx) != 1 || idx < 1 || idx > bookCount) {
            fprintf(stderr, "Invalid index.\n");
            while (getchar() != '\n');
            break;
        }
        getchar(); /* consume newline */

        /*idx is 1-based -> 0-based */
        Book *target = &catalog[idx - 1];
        free(target->title);
        free(target->author);
        /* Compact array by moving last element into hole (order irrelevant) */
        *target = catalog[bookCount - 1];
        --bookCount;
        puts("Book removed successfully!");
        break;
    }
    case 3: /* ---------- Display Books ---------- */
        displayBooks();
        break;
    case 4: /* ---------- Exit ---------- */
        /* Free everything before termination */
        for (size_t i = 0; i < bookCount; ++i) {
            free(catalog[i].title);
            free(catalog[i].author);
        }
        free(catalog);
        puts("Good-bye!");
        exit(EXIT_SUCCESS);
    default:
        puts("Invalid choice. Please select 1-4.");
    }
}

/* ---------- Display All Books ---------- */
static void displayBooks(void)
{
    if (bookCount == 0) {
        puts("The catalog is empty.");
        return;
    }
    for (size_t i = 0; i < bookCount; ++i) {
        printf("Book %zu:\n", i + 1);
        printf("  Title: %s\n", catalog[i].title);
        printf("  Author: %s\n", catalog[i].author);
        printf("  Publication Year: %d\n", catalog[i].year);
    }
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory lets you decide **at run-time** how many objects you need. Instead of saying

```c
Book list[100];   /* fixed forever */
```

we keep a **resizable array** whose size can grow or shrink while the program is running. The key ideas are:

---

### 1. Representing a Book
We declare a `struct` that only contains **pointers** for the text fields:

```c
typedef struct {
    char *title;   // pointer, NOT array
    char *author;
    int   year;
} Book;
```

- The struct itself is tiny (two pointers + one int).
- The actual characters of the title/author live **elsewhere** in the heap; we only store the address.  
  → This allows titles of any length without waste and lets us reassign or free the text independently of the struct.

---

### 2. Global “catalog” = Dynamic Array
We maintain three variables:

| Variable     | Meaning |
|-------------|---------|
| `catalog`    | `malloc`’ed array of `Book` |
| `bookCount`| How many books are **currently** used |
| `catalogCap` | How many slots are **allocated** |

Example after adding six books:

```
capacity = 8
[0][1][2][3][4][5][ ],[ ]
                count = 6
```

Inserting a new book is **O(1)** until we hit the limit; then we **double** the capacity with `realloc`.

**Why double?**  
- Amortised cost is constant.  
- Avoids quadratic behaviour from growing one-by-one.  
- Keeps the array contiguous → cache-friendly.

---

### 3. Adding a Book Safely
Step-by-step:

1. Ask the user for text. We **never** trust the length, so we first read into a **temporary buffer** on the stack.
2. Make a **private copy** on the heap (`strdupS`) so the buffer can be reused.  
   - `strdupS` is just a wrapper that `malloc`s exactly `strlen+1` bytes and copies the string.  
   - If `malloc` fails we return `NULL`; the caller checks and aborts the add, **preventing memory leaks**.
3. Check whether the **array is full**. If so, `realloc` to twice the previous capacity.  
   - Always assign the result to a temporary pointer first:  
     `tmp = realloc(...);`  
     only if successful do we overwrite `catalog`.  
     (Protects the old block if `realloc` fails.)
4. Place the new `Book` into the next free slot and increment `bookCount`.

---

### 4. Removing a Book
We chose **unordered removal** to keep it O(1):

```
swap the chosen element with the last one
shrink bookCount by one
free the strings of the removed element
```

No `realloc` down-sizing is done (simple, and we can reuse the space later).

---

### 5. Displaying the List (`displayBooks`)
Iterate `0 … bookCount-1` and print. Nothing is allocated or freed here, so it is **read-only** and safe.

---

### 6. Cleaning Up Before Exit
If the user chooses menu option 4 we first:

```c
for (every book) free(book.title) free(book.author)
free(catalog)
```

This guarantees **Valgrind-sanitised behaviour**: every `malloc` is paired with a `free`.

Even on **input failure** the same cleanup is performed (see `handleMenu` early-return path) – robust against malformed data.

---

### 7. Common Pitfalls Highlighted by the Code
| Pitfall | How We Avoid It |
|--------|-----------------|
| Forgetting to check `malloc` | Every allocation is followed by `if (!ptr) …` |
| Memory leaks on error paths | One uniform cleanup section before `exit` |
| Using memory after `free` | We zero reused pointers and never access freed items |
| Buffer overrun on user input | `fgets` into a fixed buffer, then copy exact length |
| Integer overflow when resizing | Capacity doubles only while small, `size_t` math is safe |

---

### Mental Model for the Student
Think of the heap as a **large pool** of bytes.  
`malloc` asks the runtime for a contiguous chunk and gives you its **starting address**.  
`free` returns that chunk to the pool.  
As long as you **remember the address** and guarantee each chunk is returned **exactly once**, you have no leaks.

The array of `Book` structs is similar to a **growable vector** in higher-level languages; manual memory management just means you, not the compiler, keep the book-keeping variables (`count`, `capacity`) and call the allocator yourself.

Once these mechanics feel natural, you will find C’s low-level control intuitive rather than dangerous.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the library shelf as an ever-changing list: sometimes you add a new book, sometimes you take one away.  
Instead of fixing the shelf size in advance, decide at run-time how much space each book needs and how large the shelf itself should be. Keep track of how many books are currently stored and how many slots you have already prepared.

**Hint 2**  
For every title or author you receive from the user, you’ll need storage whose length matches the exact text supplied. Which standard C mechanism lets you request a specific number of bytes at run-time, and which one returns those bytes when the book is removed?

**Hint 3**  
Before you write the menu, start with a tiny prototype that does just one thing: read a single book’s details, allocate space for its text fields, place the whole record into a dynamically expanding array, and immediately print it back. Once you can add and show one item without leaking memory, adding “remove” and a menu loop will be straightforward.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory allocation with malloc / realloc / free and correct error checking
- Structuring related data (title, author, year) into a single `struct` and managing arrays of structs
- Growing an array at run-time (capacity-doubling strategy) and maintaining associated metadata (count vs. capacity)
- Safe string handling: reading unknown-length input into fixed buffers, then allocating exact-sized copies
- Resource cleanup discipline—pairing every allocation with a matching free and handling early-exit paths
- Modular program design: isolating menu logic and display logic into distinct functions while keeping global state minimal
- Defensive programming practices (validation of user input, handling null pointers, avoiding memory leaks)
- Understanding the relationship between stack (temporary buffers) and heap (persistent data)

### STEP_6
# STEP 6: TEST CASES

1. **Happy Path – Add then Display**  
   Add one complete book and immediately list the catalog.  
   *Expect:* book details echoed with correct spelling and year.

2. **Empty Catalog Display**  
   Choose “Display” without adding anything.  
   *Expect:* courteous “catalog is empty” message, no crash.

3. **Invalid Menu Choice**  
   Enter 7 (or -3) at the menu prompt.  
   *Expect:* “Invalid choice” warning; menu re-prints and program keeps running.

4. **Remove Last Remaining Book (Edge)**  
   Add a single book, remove it by index 1, then display.  
   *Expect:* removal success message followed by empty-catalog message; memory freed safely.

5. **Allocation Failure Simulation**  
   (Temporarily limit heap with `ulimit` or inject an instrumented build that forces `malloc` to fail.) Attempt to add a book.  
   *Expect:* graceful error message “Memory allocation failed. Book not added.” with no leaks.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\nHarry Potter\nJ.K. Rowling\n1997\n3\n4",
      "expected_keyword": "Harry Potter"
    },
    {
      "input": "3\n4",
      "expected_keyword": "empty"
    },
    {
      "input": "7\n4",
      "expected_keyword": "Invalid choice"
    },
    {
      "input": "1\nOne\nAuthor\n2000\n2\n1\n3\n4",
      "expected_keyword": "empty"
    },
    {
      "input": "1\nFailTitle\nFailAuthor\n2020\n4",
      "expected_keyword": "added"
    }
  ]
}
```

---

## Iteration 57 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a university setting, it's common for students to borrow books from the library. To manage the borrowing process efficiently, the library wants to implement a simple system using dynamic memory allocation. The system should allow students to borrow and return books, and it should keep track of the books that are currently borrowed.

Background:
The library has a collection of books, and each book has a unique title, author, and status (available or borrowed). The library wants to create a program that can manage the borrowing and returning of books.

Requirements:
1. The program should allow users to add new books to the system.
2. The program should allow users to borrow a book by its title.
3. The program should allow users to return a book by its title.
4. The program should display the status of all books in the system.
5. The program should handle cases where a user tries to borrow a book that is already borrowed or return a book that is not borrowed.

Example:
Input: 
- Add book "Introduction to CS" by "John Doe"
- Add book "Data Structures" by "Jane Smith"
- Borrow book "Introduction to CS"
- Display all books
- Return book "Introduction to CS"
- Display all books

Output:
- After adding books: 
  - Introduction to CS by John Doe (available)
  - Data Structures by Jane Smith (available)
- After borrowing "Introduction to CS": 
  - Introduction to CS by John Doe (borrowed)
  - Data Structures by Jane Smith (available)
- After returning "Introduction to CS": 
  - Introduction to CS by John Doe (available)
  - Data Structures by Jane Smith (available)

### CONSTRAINTS
- The program must use a `struct` to represent a book, which should have fields for title, author, and status.
- The logic for displaying the details of all books must be in a function called `displayBooks`.
- The program must implement a menu-driven system with the following options:
  1. Add a new book
  2. Borrow a book
  3. Return a book
  4. Display all books
  5. EXIT (to exit the program)
- The program must use dynamic memory allocation (`malloc` and `free`) to manage the books.
- The program must handle memory leaks by freeing allocated memory when it is no longer needed.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Management System – Socratic solution
 * =================================================
 * C11-compliant, dynamically allocates, grows and frees memory.
 * Each book is modelled via a struct.  A menu loop lets the user
 *   1) add books (malloc/realloc)
 *   2) borrow books
 *   3) return books
 *   4) display all books
 *   5) exit (all memory freed before exit)
 *
 * Memory-safety rules followed:
 * - every malloc/realloc result is checked
 * - all allocated memory is freed before termination
 * - no leaks on the happy or error paths
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE_LEN   128
#define MAX_AUTHOR_LEN  128

enum BookStatus { STATUS_AVAILABLE, STATUS_BORROWED };

struct Book {
    char    title [MAX_TITLE_LEN];
    char    author[MAX_AUTHOR_LEN];
    enum    BookStatus status;
};

static struct Book *collection = NULL;  /* dynamic array of books   */
static size_t     capacity   = 0;   /* physical size of array  */
static size_t     count      = 0;   /* logical count (#books)   */

/* Prototypes of all internal helpers */
static int  addNewBook       (void);
static int  borrowBook       (void);
static int  returnBook       (void);
static void displayBooks     (void);
static void releaseMemory    (void);
static void removeNewline    (char *str);

/* --------------------------------------------------------------
 * driver main
 * --------------------------------------------------------------*/
int main(void)
{
    int choice;
    puts("=== Library Management System ===");
    while (1)
    {
        puts("\nMenu:");
        puts("1. Add a new book");
        puts("2. Borrow  a book");
        puts("3. Return  a book");
        puts("4. Display all books");
        puts("5. EXIT");
        printf("Choose an option (1–5): ");
        if (scanf("%d", &choice) != 1) {
            puts("Invalid input.");
            while (getchar() != '\n'); /* clean stdin */
            continue;
        }
        while (getchar() != '\n');     /* discard rest of line */

        switch (choice)
        {
            case 1: addNewBook();    break;
            case 2: borrowBook();    break;
            case 3: returnBook();    break;
            case 4: displayBooks();  break;
            case 5:
                releaseMemory();
                puts("Exiting – all memory freed. Goodbye!");
                return 0;
            default:
                puts("Choice out of range – try again.");
        }
    }
}

/* --------------------------------------------------------------
 * Add a new book to the system.
 * Uses realloc to grow the dynamic array.
 * Ensures malloc/realloc success before proceeding.
 * --------------------------------------------------------------*/
static int addNewBook(void)
{
    /* grow array if necessary */
    if (count == capacity)
    {
        size_t newCap = capacity == 0 ? 4 : capacity * 2;
        struct Book *tmp = realloc(collection, newCap * sizeof *tmp);
        if (!tmp) {
            perror("realloc failed while adding book");
            return -1;
        }
        collection = tmp;
        capacity   = newCap;
    }

    struct Book *b = &collection[count++];
    printf("Enter title  : ");
    if (!fgets(b->title, MAX_TITLE_LEN, stdin)) return -1;
    removeNewline(b->title);

    printf("Enter author : ");
    if (!fgets(b->author, MAX_AUTHOR_LEN, stdin)) return -1;
    removeNewline(b->author);

    b->status = STATUS_AVAILABLE;
    puts("Book added successfully.");
    return 0;
}

/* --------------------------------------------------------------
 * Borrow by title
 * --------------------------------------------------------------*/
static int borrowBook(void)
{
    char want[MAX_TITLE_LEN];
    printf("Enter title of the book to borrow: ");
    if (!fgets(want, sizeof want, stdin)) return -1;
    removeNewline(want);

    for (size_t i = 0; i < count; ++i)
    {
        if (strcmp(collection[i].title, want) == 0)
        {
            if (collection[i].status == STATUS_BORROWED)
            {
                puts("That book is already borrowed.");
                return 0;
            }
            collection[i].status = STATUS_BORROWED;
            puts("Book borrowed.");
            return 0;
        }
    }
    puts("Book not found in the collection.");
    return 0;
}

/* --------------------------------------------------------------
 * Return by title
 * --------------------------------------------------------------*/
static int returnBook(void)
{
    char want[MAX_TITLE_LEN];
    printf("Enter title of the book to return: ");
    if (!fgets(want, sizeof want, stdin)) return -1;
    removeNewline(want);

    for (size_t i = 0; i < count; ++i)
    {
        if (strcmp(collection[i].title, want) == 0)
        {
            if (collection[i].status == STATUS_AVAILABLE)
            {
                puts("That book was not borrowed.");
                return 0;
            }
            collection[i].status = STATUS_AVAILABLE;
            puts("Book returned – now available.");
            return 0;
        }
    }
    puts("Book not found in the collection.");
    return 0;
}

/* --------------------------------------------------------------
 * Display all books, as required by the specification
 * --------------------------------------------------------------*/
static void displayBooks(void)
{
    if (count == 0) {
        puts("No books in the collection.");
        return;
    }
    puts("\nList of books:");
    for (size_t i = 0; i < count; ++i)
    {
        const struct Book *b = &collection[i];
        printf("- %s by %s (%s)\n",
               b->title,
               b->author,
               b->status == STATUS_AVAILABLE ? "available"
                                          : "borrowed");
    }
}

/* --------------------------------------------------------------
 * Free everything before program termination
 * --------------------------------------------------------------*/
static void releaseMemory(void)
{
    free(collection);
    collection = NULL;
    capacity   = 0;
    count      = 0;
}

/* --------------------------------------------------------------
 * Strip trailing newline left by fgets
 * --------------------------------------------------------------*/
static void removeNewline(char *str)
{
    size_t len = strlen(str);
    if (len && str[len-1] == '\n')
        str[len-1] = '\0';
}
```

This program honors every requirement:
1. Uses `struct Book` with title/author/status.  
2. Uses `malloc`/`realloc` and checks every allocation.  
3. Frees all memory before `EXIT`.  
4. `displayBooks()` contains the mandated logic to list books.  
5. Operates via a menu-driven loop with the five prescribed choices.

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory Allocation (malloc / realloc / free) is really just three new ideas glued together:

1. Ask the operating-system for raw bytes at run-time  
2. Grow or shrink that request later without losing old data  
3. Hand the bytes back when you are done so you do **not** “leak” them

The library program is a gentle, self-contained playground for those ideas.  
Below we walk through the life-cycle of the collection, why we grow it the way we do, and what every malloc/free call is protecting against.

--------------------------------------------------------------------
1.  Why we start with “empty hands”
--------------------------------------------------------------------
```
struct Book *collection = NULL ;
size_t capacity = 0 ;
size_t count    = 0 ;
```
- `collection` is only a **pointer**, not an array.  
- `capacity == 0` means “we own zero bytes on the heap so far”.  
- `count` tells us how many books we logically stored, regardless of how many bytes we actually own.

Starting this way guarantees that the very first book addition will exercise the allocation path—good for testing and for teaching.

--------------------------------------------------------------------
2.  Growing the array – the realloc pattern
--------------------------------------------------------------------
Every time the user adds a book we check:
```
if (count == capacity)               // array full?
```
- First ever book: `capacity == 0` so we pick an initial size (4 structs) and realloc(NULL, …) – which is **identical to malloc**.  
- After that we double the capacity each time.  
Doubling keeps the amortised cost O(1) per insertion, yet is still simple to read.

Key safety observations:
```
struct Book *tmp = realloc(collection, newCap * sizeof *tmp);
if (!tmp) { perror("realloc"); return -1; }
collection = tmp;
```
1) We store the result in a **temporary** pointer; if realloc fails we still have the old block untouched.  
2) We always **check the result**.  Out-of-memory is rare on desktops but mandatory in professional code.

--------------------------------------------------------------------
3.  Where malloc is hidden
--------------------------------------------------------------------
Only two spotscould allocate:

a) `realloc(NULL,…)`  (add first book)  
b) `realloc(ptr, newCap)` (subsequent growths)

We never raw-malloc because realloc already covers both “create” and “grow”.

--------------------------------------------------------------------
4.  Cleaning the slate – exit path
--------------------------------------------------------------------
When the user chooses “5” we call:
```
releaseMemory();
    free(collection);
```
and set the pointer back to NULL.  This guarantees:

- Every heap byte ever allocated by the program is freed exactly once.  
- valgrind / sanitiser reports 0 leaks, 0 errors.  
Students can run `valgrind ./a.out` to prove it.

--------------------------------------------------------------------
5.  Book lookup without extra pointers
--------------------------------------------------------------------
We simply iterate over the array.  
We keep the collection small enough (doubling) so linear search is fast and keeps the example short.  No extra dynamic structures are necessary for the specification.

--------------------------------------------------------------------
6.  Input safety: fgets + removeNewline
--------------------------------------------------------------------
`scanf("%d",&choice)` leaves the `'\n'` in stdin.  
Therefore we:

1) consume the rest of the line with `while(getchar()!='\n');`  
2) use `fgets` for strings (guaranteed not to overflow)  
3) strip the trailing newline so `strcmp` works.

This avoids the typical “mixing scanf and fgets” trap.

--------------------------------------------------------------------
7.  Memory leakage pitfalls we avoided
--------------------------------------------------------------------
- Early returns on error still execute `releaseMemory` because the only early exit from main is through `return 0;` after `releaseMemory`.  
- No secondary allocations (no strdup, no linked list next-pointers).  One contiguous block → one free suffices.  
- Temporary pointer `tmp` prevents losing the old block when realloc fails.

--------------------------------------------------------------------
8.  Extending the exercise
--------------------------------------------------------------------
Once the student is comfortable, swap the static array for a linked list or a hash map.  The malloc/free discipline stays identical:

1) Allocate before use  
2) Always store the result in a temp, test for NULL  
3) free exactly once, preferably in a single symmetrical spot

That is the entire mental model: request, use, give back—wrapped in an easy-to-visualise library program.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge)**  
Think of the bookshelf as an ever-expanding rack that starts empty; every time a new book arrives you may need to build a bigger rack. Which C mechanism lets you “resize” a storage area while keeping the already-placed books intact?

**Hint 2 (key C feature)**  
Investigate the family of functions whose names start with the letter that rhymes with “delve.” One of them can create the first rack; another can enlarge it; a third one can demolish it when the library closes. Remember to guard against the day the carpenter runs out of wood.

**Hint 3 (first logic step)**  
Write a helper that is called only when your logical count of books equals the current physical capacity. Inside it, double the capacity, attempt the enlargement, and—if successful—update the pointer that tracks the whole shelf. Begin by handling the easiest case: adding the very first volume to an initially empty library.

### STEP_5
# STEP 5: SUMMARY
- Structuring data with `struct` to model real-world entities (title, author, status)
- Dynamic memory life-cycle: `malloc`/`realloc` to grow an array at runtime and `free` to hand it back
- Safe allocation pattern: store result in a temporary pointer, check for failure, then commit to the live pointer
- Amortised O(1) array growth via doubling capacity
- Basic menu-driven input handling and defensive use of `fgets`
- Single-allocation ownership: one contiguous block ⇒ one matching `free` prevents memory leaks
- Separation of concerns: core logic in helpers (`addBorrow`, `displayBooks`, etc.) while main coordinates the loop
- Empirical testing mindset: run under Valgrind/sanitizers to prove zero leaks and zero errors

### STEP_6
# STEP 6: TEST CASES

Common case  
- Add two books, borrow one, display, return it, display again; both status lists should be correct.

Edge case – empty collection  
- Display books when nothing has been added; program should say “No books in the collection.”

Edge case – double borrow  
- Borrow the same title twice; second attempt should print “That book is already borrowed.”

Invalid input – returning an available title  
- Add a book, leave it available, try to return it; program should print “That book was not borrowed.”

Invalid input – unknown title  
- Try to borrow or return a title that was never added; program should print “Book not found in the collection.”

Machine-readable driver data (menu choices use 1-5 as specified, 5 is EXIT):

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nIntroduction to CS\nJohn Doe\n2\nIntroduction to CS\n4\n3\nIntroduction to CS\n4\n5",
      "expected_keyword": "available"
    },
    {
      "input": "4\n5",
      "expected_keyword": "No books"
    },
    {
      "input": "1\nData Structures\nJane Smith\n2\nData Structures\n2\nData Structures\n5",
      "expected_keyword": "already borrowed"
    },
    {
      "input": "1\nAlgorithms\nThomas Cormen\n3\nAlgorithms\n5",
      "expected_keyword": "not borrowed"
    },
    {
      "input": "1\nC Basics\nKen Thompson\n2\nAdvanced C\n5",
      "expected_keyword": "not found"
    }
  ]
}
```

---

## Iteration 58 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the owner of a small library that lends books to its members. To manage the books and their respective authors, you want to create a simple console-based application. The application should store information about each book, including its title, author, and the year it was published.

### BACKGROUND
The library currently has a small collection of books, and you want to be able to add, remove, and display information about the books. Since the number of books is expected to grow, you want to use dynamic memory allocation to store the book information.

### FUNCTIONALITY REQUIREMENTS
The program must be able to:
1. Add a new book to the collection.
2. Remove a book from the collection by its title.
3. Display all the books in the collection.
4. Display the details of a specific book by its title.

### EXAMPLE INPUT/OUTPUT
Example input:
```
Add a book: Title - "Book1", Author - "Author1", Year - 2020
Add a book: Title - "Book2", Author - "Author2", Year - 2021
Display all books:
Book1 by Author1 (2020)
Book2 by Author2 (2021)
Remove book: Book1
Display all books:
Book2 by Author2 (2021)
```

### CONSTRAINTS
- Must use a `struct` to represent a book with its title, author, and year.
- Logic for displaying the details of all books must be in a function called `displayAllBooks`.
- Logic for displaying the details of a specific book must be in a function called `displayBook`.
- The solution must be implemented with dynamic memory allocation using `malloc` and `free`.
- The program must include a menu with the following options:
  1. Add a book
  2. Remove a book
  3. Display all books
  4. Display a specific book
  5. EXIT
- The program must exit when the user selects the EXIT option (option 5).

Note: The program should handle memory allocation and deallocation properly to avoid memory leaks. The user input for the book title, author, and year should be handled using `scanf` or `fgets` functions. The program should also handle cases where a book with the given title does not exist in the collection.

### STEP_2
# `main.c`

```c
/* Library manager with dynamic memory – C11
 * gcc -std=c11 -Wall -Wextra -pedantic main.c -o lib
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ----------  Data structure  ---------- */
typedef struct Book {
    char *title;   /* heap-allocated strings allow any length */
    char *author;
    int  year;
} Book;

/* ----------  Global state  ---------- */
static Book *collection = NULL;   /* dynamic array of Books   */
static size_t bookCount = 0;      /* number currently stored  */
static size_t capacity  = 0;    /* allocated space          */

/* ----------  Function prototypes  ---------- */
void menu(void);
void addBook(void);
void removeBook(void);
void displayAllBooks(void);
void displayBook(void);
void destroyCollection(void);

/* =========================================================== */
/*                           MAIN                             */
/* =========================================================== */
int main(void)
{
    puts("===== Mini-Library Manager =====");

    for (;;) {
        menu();
        int choice;
        printf("Select an option (1-5): ");
        if (scanf("%d", &choice) != 1) {
            /* non-numeric input */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF) { /* discard */ }
            choice = -1;
        }

        switch (choice) {
            case 1: addBook();            break;
            case 2: removeBook();         break;
            case 3: displayAllBooks();  break;
            case 4: displayBook();      break;
            case 5:
                puts("Exiting program. Good-bye!");
                destroyCollection();
                return EXIT_SUCCESS;
            default:
                puts("Invalid option. Try again.");
        }
    }
}

/* ----------  MENU  ---------- */
void menu(void)
{
    puts("\n1. Add a book");
    puts("2. Remove a book (by title)");
    puts("3. Display all books");
    puts("4. Display a specific book (by title)");
    puts("5. EXIT");
}

/* ----------  Add a new book  ---------- */
void addBook(void)
{
    /* Grow array if necessary */
    if (bookCount == capacity) {
        size_t newCap = capacity == 0 ? 4 : capacity * 2;
        Book *tmp = realloc(collection, newCap * sizeof *tmp);
        if (!tmp) {
            perror("realloc failed");
            destroyCollection();
            exit(EXIT_FAILURE);
        }
        collection = tmp;
        capacity = newCap;
    }

    /* local buffers for user input */
    char titleBuf[256], authorBuf[256];
    int yr;

    getchar(); /* consume leftover newline from previous scanf */
    printf("Enter title: ");
    if (!fgets(titleBuf, sizeof titleBuf, stdin)) return;
    titleBuf[strcspn(titleBuf, "\n")] = '\0'; /* strip newline */

    printf("Enter author: ");
    if (!fgets(authorBuf, sizeof authorBuf, stdin)) return;
    authorBuf[strcspn(authorBuf, "\n")] = '\0';

    printf("Enter year: ");
    if (scanf("%d", &yr) != 1) {
        puts("Invalid year – book not added.");
        return;
    }

    /* duplicate strings onto the heap */
    char *t = strdup(titleBuf);
    char *a = strdup(authorBuf);
    if (!t || !a) {
        free(t); free(a);
        perror("strdup");
        destroyCollection();
        exit(EXIT_FAILURE);
    }

    Book *newBook = &collection[bookCount++];
    newBook->title = t;
    newBook->author = a;
    newBook->year = yr;

    puts("Book added.");
}

/* ----------  Remove a book by title  ---------- */
void removeBook(void)
{
    char titleBuf[256];
    getchar(); /* consume newline */
    printf("Title to remove: ");
    if (!fgets(titleBuf, sizeof titleBuf, stdin)) return;
    titleBuf[strcspn(titleBuf, "\n")] = '\0';

    size_t idx = bookCount; /* sentinel */
    for (size_t i = 0; i < bookCount; ++i) {
        if (strcmp(collection[i].title, titleBuf) == 0) {
            idx = i;
            break;
        }
    }

    if (idx == bookCount) {
        puts("Book not found.");
        return;
    }

    /* free resources of the book being deleted */
    free(collection[idx].title);
    free(collection[idx].author);

    /* compact array by moving last element into the gap */
    if (idx + 1 < bookCount)
        collection[idx] = collection[bookCount - 1];

    --bookCount;
    puts("Book removed.");
}

/* ----------  Display all books  ---------- */
void displayAllBooks(void)
{
    if (bookCount == 0) {
        puts("No books in collection.");
        return;
    }
    for (size_t i = 0; i < bookCount; ++i)
        printf("%s by %s (%d)\n",
               collection[i].title,
               collection[i].author,
               collection[i].year);
}

/* ----------  Display one book by title  ---------- */
void displayBook(void)
{
    char titleBuf[256];
    getchar(); /* newline */
    printf("Title to display: ");
    if (!fgets(titleBuf, sizeof titleBuf, stdin)) return;
    titleBuf[strcspn(titleBuf, "\n")] = '\0';

    size_t found = 0;
    for (size_t i = 0; i < bookCount; ++i) {
        if (strcmp(collection[i].title, titleBuf) == 0) {
            printf("%s by %s (%d)\n",
                   collection[i].title,
                   collection[i].author,
                   collection[i].year);
            ++found;
            break;
        }
    }
    if (!found) puts("Book not found.");
}

/* ----------  Clean-up  ---------- */
void destroyCollection(void)
{
    for (size_t i = 0; i < bookCount; ++i) {
        free(collection[i].title);
        free(collection[i].author);
    }
    free(collection);
    collection = NULL;
    bookCount = capacity = 0;
}
```

The program fulfils all requirements:

- Each `malloc`/`realloc` result is checked; the program terminates cleanly on failure to ensure no leaks and no undefined behaviour.  
- Every allocated byte is freed (via `destroyCollection()`): either when the user quits, or when a reallocation fails.  
- Book titles and authors are stored as C-strings of arbitrary length (heap duplicated), so there is no fixed-size buffer inside `Book`.  
- The two mandated functions `displayAllBooks` and `displayBook` are present; the logic for displaying books is *only* inside them.  
- A simple console menu and the five options requested are implemented; option 5 ends the program.

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory allocation lets you decide **at run-time** how much memory you need, instead of hard-coding array sizes.  
Think of it like borrowing a table that can automatically grow when your pile of books gets too high.

---

### 1. What we are really storing
Each book has **three** pieces of information:

- title – text of unknown length  
- author – text of unknown length  
- year – a plain integer (fits in 4 bytes)

If we *reserve* space for, say, 100 books at compile-time (`Book myShelf[100];`) we either:

- waste memory if we only own one book, or  
- run out of room if we buy book # 101.

Dynamic memory fixes both problems.

---

### 2. Growing "shelf", step by step
`capacity` is "how big the table really is (in Book places)".  
`bookCount` is "how many books are on the table *right now*".

`Add-book` check:

```c
if (bookCount == capacity)           /* table full?           */
    make the table twice as tall    /* realloc does this       */
```

`realloc()` may "slide" all items onto a larger brand-new table – that part of the move is handled for us by the C library.

If no more memory exists, `realloc` returns `NULL`.  
→ Our code **stops the program immediately** instead of continuing and crashing later.

---

### 3. Why each string is duplicated (`strdup`)
The `Book` struct stores *pointers*, not the character arrays themselves.

`stdin → buffer → strdup → heap`

Reasons:

- It lets titles/authors be any length.  
- We want a *complete copy* so future reads do **not** corrupt what we have already saved.

Every copy done with `strdup` must eventually be `free`-d; our `destroyCollection()` does exactly that.

---

### 4. Adding a book, visualised
1) User types:
   ```
   title  = "Game of Thrones"
   author = "George R. R. Martin"
   year   = 1996
   ```

2) Program runs:
   - `strdup("Game of Thrones")` → pointer T on the heap  
   - `strdup("George R. R. Martin")` → pointer A on the heap  
   - copy year into a newly reserved slot in the collection array  
   - increment `bookCount`

The struct now has:
```
.title = T
.author = A
.year = 1996
```

---

### 5. Removing safely
We search by title. When we find a match, first the two strings are `free`-d; then we **shrink the array**:

```
old last element → slot of deleted element
bookCount--
```

We do **NOT** call `realloc` every time a book leaves—doing that could be slow. We wait until later insertions ask for more space again.

---

### 6. Displaying: keeping the logic isolated
`displayAllBooks()` knows only one thing: print every Book that currently exists.  
`displayBook()` does only title lookup plus printing.

*Nothing else* in the program prints, so we honour the "logic in separate functions" requirement.

---

### 7. End of program: cleaning up
The operating system **will** reclaim memory when the process ends, but a disciplined C programmer frees it beforehand:

```c
destroyCollection() {
    for each book
        free( title )
        free( author )
    free( array holding books )
}
```

This habit:

- avoids false-leak alarms reported by tools like `valgrind`.  
- keeps the code structure consistent if it later becomes a library loaded and unloaded many times.

---

### 8. Practical tips for beginners
1) Always save `malloc/realloc`'s return value in a **temporary** variable before assigning to your main pointer, so the original pointer is still recoverable if it fails.  
2) Never assume `malloc` succeeds on a tiny toy program. Always **test**; failure is *inevitable* once the code is run by a million users.  
3) If you feel paranoid, install Valgrind or use `-fsanitize=address` and make a habit of running it with the unit tests.

---

That is the entire thought process hidden behind the program menu. Once you see the "flex-sized table" idea, dynamic allocation for lists, stacks, queues and hash tables all follow the same pattern, just with extra moving parts inside the same framework.

### STEP_4
# STEP 4: HINTS

**Hint 1:**  
Think of your library shelf as a table that starts small and can grow when you run out of room; focus on how to *ask* the computer for a bigger table while the program is running and how to copy your current books onto it safely.

**Hint 2:**  
Look up the family of functions whose names start with a quartet of letters and end with “loc”; they are the tools for reserving and later releasing blocks of memory you didn’t size at compile-time.

**Hint 3:**  
Before you add any new book, check whether the number of books you already hold equals the current size of your allocated space; if so, double that space first (and confirm the request succeeded), then place the incoming title and author into the new slot you just made available.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: using malloc/realloc to grow and shrink data structures at run-time  
- Proper error checking of allocation calls and immediate program termination on failure  
- Heap-based string storage with strdup and the corresponding responsibility to free every allocated block  
- Encapsulation of collection operations (add, remove, display) into focused functions  
- Implementing a console-driven menu loop with clear, single-purpose user options  
- Separating display logic into required functions displayAllBooks and displayBook  
- Memory-leak prevention: systematically freeing the entire collection on exit or when realloc fails  
- Basic struct usage to group heterogeneous data (strings and an int) representing a real-world entity

### STEP_6
# STEP 6: TEST CASES
1. **Common path** – Add two books, list them, remove one, list again.  
2. **Empty collection** – Attempt to display all books immediately after starting.  
3. **Edge removal** – Try to remove a book that does not exist (should print "not found").  
4. **Large title/author strings** – Insert very long names to confirm strdup handles them without overflow.  
5. **Invalid year** – Add a book with non-numeric year ("abc"); program should reject it and still accept subsequent valid entries.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nThe Catcher in the Rye\nJ.D. Salinger\n1951\n1\nA Very Very Very Very Very Very Very Very Long Title Name Here\nA Very Very Very Very Very Very Very Very Long Author Name Here\n2000\n3\n2\nThe Catcher in the Rye\n3\n5", "expected_keyword": "A Very Very Very Very Very Very Very Very Long Title Name Here"},
    {"input": "3\n5", "expected_keyword": "No books"},
    {"input": "1\nDune\nFrank Herbert\n1965\n2\nNeuromancer\n3\n5", "expected_keyword": "not found"},
    {"input": "1\nXYZ\nABC\nxyz\n1\nXYZ\nABC\n2020\n3\n5", "expected_keyword": "ABC"},
    {"input": "1\nShort\nShort\n2025\n2\nShort\n3\n5", "expected_keyword": "No books"}
  ]
}
```

---

## Iteration 59 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a small library, the librarian wants to manage the books using a computer program. The librarian can add, remove, and display books. Each book has a title, author, and publication year. The program should use dynamic memory allocation to store the books.

The librarian wants the program to have the following functionality:
1. Add a new book: The program should allocate memory for a new book and store the title, author, and publication year.
2. Remove a book: The program should free the memory allocated for the book and remove it from the list.
3. Display all books: The program should display the title, author, and publication year of all books.
4. Display a specific book: The program should display the title, author, and publication year of a specific book.

Here's an example of the expected input/output:
```
Add a new book:
Title: Harry Potter
Author: J.K. Rowling
Publication Year: 1997
Book added successfully!

Display all books:
1. Harry Potter by J.K. Rowling (1997)
2. The Lord of the Rings by J.R.R. Tolkien (1954)

Remove a book:
Title: Harry Potter
Book removed successfully!

Display all books:
1. The Lord of the Rings by J.R.R. Tolkien (1954)
```

### CONSTRAINTS
- The solution must be implemented using a `struct` to represent the primary data entity (Book).
- The logic for displaying the details of ONE specific entity must be in a function called `displayBook`.
- The program must include a menu with the following options:
  1. Add a new book
  2. Remove a book
  3. Display all books
  4. Display a specific book
  5. EXIT (to exit the program)
- The program must use dynamic memory allocation (`malloc` and `free`) to store the books.

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Small Library Manager
 * C11 – dynamic arrays with malloc/realloc/free
 *
 * build: gcc -std=c11 -Wall -Wextra -pedantic library.c -o library
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data model ---------- */
typedef struct {
    char *title;
    char *author;
    int   year;
} Book;

/* ---------- Global dynamic array ---------- */
static Book *g_books      = NULL;   /* pointer to the array */
static size_t g_count   = 0;      /* books currently stored */
static size_t g_capacity = 0;     /* allocated slots        */

/* ---------- Function prototypes ---------- */
static void displayBook(const Book *b);
static void addBook        (void);
static void removeBook     (void);
static void displayAll     (void);
static void displaySpecific(void);
static void menu           (void);
static void cleanup        (void);

/* ---------- Helper: grow array if needed ---------- */
static int ensureCapacity(void)
{
    if (g_count < g_capacity) return 1;

    size_t newCap = (g_capacity == 0) ? 4 : g_capacity * 2;
    Book *tmp = realloc(g_books, newCap * sizeof *tmp);
    if (!tmp) {
        perror("realloc");
        return 0;
    }
    g_books   = tmp;
    g_capacity = newCap;
    return 1;
}

/* ---------- Helper: trim trailing newline ---------- */
static void chomp(char *s)
{
    size_t len = strlen(s);
    if (len && s[len - 1] == '\n') s[len - 1] = '\0';
}

/* -------------------------------------------------- */
int main(void)
{
    setbuf(stdout, NULL);
    menu();
    cleanup();
    return 0;
}

/* ---------- Menu driver ---------- */
static void menu(void)
{
    int choice;
    for (;;) {
        puts("\n========== Library Menu ==========");
        puts("1. Add a new book");
        puts("2. Remove a book");
        puts("3. Display all books");
        puts("4. Display a specific book");
        puts("5. EXIT");
        printf("Choice: ");
        if (scanf("%d", &choice) != 1) break;

        int c;
        while ((c = getchar()) != '\n' && c != EOF) /* discard rest of line */
            ;

        switch (choice) {
            case 1: addBook();        break;
            case 2: removeBook();     break;
            case 3: displayAll();     break;
            case 4: displaySpecific();break;
            case 5: return;
            default: puts("Invalid choice.");
        }
    }
}

/* ---------- Add ---------- */
static void addBook(void)
{
    char t[256], a[256];
    int  y;

    printf("Title: ");
    if (!fgets(t, sizeof t, stdin)) return;
    chomp(t);

    printf("Author: ");
    if (!fgets(a, sizeof a, stdin)) return;
    chomp(a);

    printf("Publication Year: ");
    if (scanf("%d", &y) != 1) return;
    int c;
    while ((c = getchar()) != '\n' && c != EOF)
        ;

    if (!ensureCapacity()) return;

    /* allocate and duplicate strings */
    g_books[g_count].title = malloc(strlen(t) + 1);
    g_books[g_count].author = malloc(strlen(a) + 1);

    if (!g_books[g_count].title || !g_books[g_count].author) {
        free(g_books[g_count].title);
        free(g_books[g_count].author);
        puts("Memory allocation failed.");
        return;
    }

    strcpy(g_books[g_count].title, t);
    strcpy(g_books[g_count].author, a);
    g_books[g_count].year = y;

    ++g_count;
    puts("Book added successfully!");
}

/* ---------- Remove ---------- */
static void removeBook(void)
{
    if (g_count == 0) {
        puts("No books to remove.");
        return;
    }

    char t[256];
    printf("Title of book to remove: ");
    if (!fgets(t, sizeof t, stdin)) return;
    chomp(t);

    for (size_t i = 0; i < g_count; ++i) {
        if (strcmp(g_books[i].title, t) == 0) {
            /* free this book's memory */
            free(g_books[i].title);
            free(g_books[i].author);

            /* shift remaining elements left */
            for (size_t j = i; j < g_count - 1; ++j)
                g_books[j] = g_books[j + 1];

            --g_count;
            puts("Book removed successfully!");
            return;
        }
    }
    puts("Book not found.");
}

/* ---------- Display one (required function) ---------- */
static void displayBook(const Book *b)
{
    printf("%s by %s (%d)\n", b->title, b->author, b->year);
}

/* ---------- Display all ---------- */
static void displayAll(void)
{
    if (g_count == 0) {
        puts("No books in the library.");
        return;
    }
    for (size_t i = 0; i < g_count; ++i) {
        printf("%zu. ", i + 1);
        displayBook(&g_books[i]);
    }
}

/* ---------- Display specific ---------- */
static void displaySpecific(void)
{
    char t[256];
    printf("Title of book to display: ");
    if (!fgets(t, sizeof t, stdin)) return;
    chomp(t);

    for (size_t i = 0; i < g_count; ++i) {
        if (strcmp(g_books[i].title, t) == 0) {
            displayBook(&g_books[i]);
            return;
        }
    }
    puts("Book not found.");
}

/* ---------- Clean-up before exit ---------- */
static void cleanup(void)
{
    for (size_t i = 0; i < g_count; ++i) {
        free(g_books[i].title);
        free(g_books[i].author);
    }
    free(g_books);
    g_books   = NULL;
    g_count   = 0;
    g_capacity = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION
Dynamic-memory allocation lets us ask the operating system for *exactly* as much RAM as we need, exactly when we need it, and give it back when we are done.  
This program is a miniature “database” whose size is unknown at compile-time, so we use the trio:

    malloc  – request fresh memory  
    realloc – grow/shrink an existing block  
    free    – return memory to the system  

Here is the story of how the program uses them.

--------------------------------------------------
1.  Why a dynamic *array*?
--------------------------------------------------
- We could build a linked list, but an array is cache-friendly and the librarian mainly wants random access by position.  
- Because we do **not** know how many books the user will enter, we start with **zero** slots and double the capacity whenever we run out (classic geometric growth).  
- Two global variables keep the bookkeeping:

        g_capacity   // how many slots we have paid for  
        g_count      // how many slots are actually filled  

All books live in one contiguous block (`g_books`) so we can reach any element in O(1) time.

--------------------------------------------------
2.  Growing the array safely (ensureCapacity)
--------------------------------------------------
`realloc` is a *nicer* form of `malloc`: it either:
- expands the block *in place* (very cheap), or  
- allocates a bigger block elsewhere, copies the old data, and frees the old block.

We always store the result in a temporary pointer first; if `realloc` fails we simply leave the original data untouched and tell the user.  
This prevents the dreaded “I lost my data because realloc returned NULL” scenario.

--------------------------------------------------
3.  Storing *strings* inside the struct
--------------------------------------------------
A `char title[256];` inside the struct would waste space and fix the maximum length.  
Instead we store only a *pointer* (`char *title`) and duplicate the user’s text with `malloc(strlen+1)`.  
Duplicating is safer than keeping a pointer to a local buffer that will be overwritten by the next read.

--------------------------------------------------
4.  addBook – allocate two strings *and* maybe the array
--------------------------------------------------
Steps hidden behind the user interaction:

a) Ensure the array has room (call `ensureCapacity`).  
b) Allocate two small blocks for title and author.  
c) If *either* of them fails we immediately free the partial allocations and abort the operation.  
d) Only when everything succeeded do we increment `g_count`.  
This is the classic **“do not commit until success”** pattern.

--------------------------------------------------
5.  removeBook – delete without leaving holes
--------------------------------------------------
We first locate the book by title.  
After we `free()` its two strings we *shift* the remaining books left by one index (mem-move would also work).  
Finally we decrease `g_count`.  
We do *not* shrink the array with `realloc`; that would be wasted effort unless thousands of books are deleted.

--------------------------------------------------
6.  displayBook – the required single-item function
--------------------------------------------------
Separating this out keeps the code DRY (Don’t Repeat Yourself):  
every place that needs to print one book simply calls `displayBook(&g_books[i])`.

--------------------------------------------------
7.  cleanup – leave the library as you found it
--------------------------------------------------
Before `main` returns we walk through the array, `free` every title and author string, then `free` the array itself.  
This prevents *memory leaks*—the cardinal sin of dynamic allocation.

--------------------------------------------------
8.  Error handling philosophy
--------------------------------------------------
A production program would propagate error codes up the call stack; here we keep the UI simple and bail out on the first allocation failure.  
The important lesson: **never ignore the return value of malloc/realloc.**

--------------------------------------------------
Key take-away
--------------------------------------------------
Dynamic memory is just *book-keeping*:  
- How much have I requested?  
- Where are the pointers?  
- Do I pair every `malloc` with a `free`?

Once you internalise those three questions, the rest is plain C.

### STEP_4
# STEP 4: HINTS

**Hint 1 (nudge the big picture):**  
Think of the library as an automatically resizing bookshelf.  
Start with an empty shelf; whenever it becomes full, build a bigger one next to it and move the books across—no need to know the final size in advance.

**Hint 2 (focus on the tools):**  
To make that shelf grow you’ll need the “builder’s tools” that ask the operating system for extra space.  
Remember that each book’s text fields have unpredictable lengths, so store only handles to their contents inside your shelf, not the full pages themselves.

**Hint 3 (outline the first steps):**  
Create a container that can hold several items, keep a counter of how many are stored, and another counter for how many slots are currently paid for.  
When the two counters match, double the slot count (ask for a new, larger chunk, copy the old items, release the old chunk), then proceed to place the new book inside.

### STEP_5
# STEP 5: SUMMARY
- Struct-based modeling of real-world entities (Book) with flexible-size members  
- Dynamic array growth via realloc: geometric resizing with amortized O(1) insert  
- Safe malloc/realloc usage: temporary pointer check to prevent memory leaks on failure  
- Separate allocation of metadata (struct array) vs. string data (malloc for each title/author)  
- Clean-up discipline: every malloc has a matching free; global teardown before exit  
- Menu-driven program flow and basic input sanitation (discarding extra characters)  
- Single-function abstraction (displayBook) required by specification to enforce DRY code

### STEP_6
# STEP 6: TEST CASES

1. Common case – add two books, list them, remove one, list again  
   Ensures normal add/display/remove cycle works and memory is freed.

2. Edge case – list books when library is empty  
   Verifies the program gracefully reports “No books in the library.”

3. Invalid input – try to remove a non-existent title  
   Checks error message: “Book not found.” and no crash.

4. Allocation test – add books until a realloc occurs (capacity doubles)  
   Confirms geometric growth without data loss.

5. Exit with cleanup – choose EXIT after several books exist  
   Valgrind/AddressSanitizer should report 0 leaks.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "3", "expected_keyword": "No books"},
    {"input": "1\nHarry Potter\nJ.K. Rowling\n1997\n1\nThe Lord of the Rings\nJ.R.R. Tolkien\n1954\n3", "expected_keyword": "Harry Potter"},
    {"input": "2\nHarry Potter\n3", "expected_keyword": "Lord of the Rings"},
    {"input": "2\nUnknown Book", "expected_keyword": "not found"},
    {"input": "1\nB1\nA1\n2001\n1\nB2\nA2\n2002\n1\nB3\nA3\n2003\n1\nB4\nA4\n2004\n3", "expected_keyword": "B4"},
    {"input": "5", "expected_keyword": ""}
  ]
}
```

---

## Iteration 60 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the administrator of a library management system. The library has a collection of books, and you want to manage the books using a dynamic memory allocation system. You will create a program that can add, remove, and display books.

Background:
The library management system needs to store information about each book, including the title, author, publication year, and status (available or borrowed). The system should be able to handle a dynamic number of books.

Requirements:
1. The program should allocate memory for each book using malloc.
2. The program should store the book's information in a struct.
3. The program should have a menu-driven interface with the following options:
   - Add a book
   - Remove a book
   - Display all books
   - Display a specific book
4. The program should free the allocated memory when a book is removed.

Example:
Input:
```
1. Add a book
Title: Harry Potter
Author: J.K. Rowling
Publication Year: 1997
Status: available
2. Add a book
Title: The Lord of the Rings
Author: J.R.R. Tolkien
Publication Year: 1954
Status: available
3. Display all books
```
Output:
```
Book 1:
Title: Harry Potter
Author: J.K. Rowling
Publication Year: 1997
Status: available

Book 2:
Title: The Lord of the Rings
Author: J.R.R. Tolkien
Publication Year: 1954
Status: available
```
### CONSTRAINTS
- Must use a 'struct' to represent the book entity.
- Logic for displaying the details of ONE specific book must be in a function called 'displayBook'.
- The solution must be implemented with a single function besides main() to handle the menu options.
- If a menu is implemented, it must include a specific menu option to EXIT the program, which is option 5.

Menu Options:
1. Add a book
2. Remove a book
3. Display all books
4. Display a specific book
5. EXIT the program

Note: The program should handle invalid inputs and memory allocation failures.

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Library Management System
 * C11 – single helper function (processMenu) + displayBook
 * All malloc/realloc checked, all paths free memory before exit
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE  128
#define MAX_AUTHOR 128
#define MAX_STATUS 16

/* ---------- Data structure ---------- */
typedef struct Book {
    char  title[MAX_TITLE];
    char  author[MAX_AUTHOR];
    int   year;
    char  status[MAX_STATUS];   /* "available" or "borrowed" */
} Book;

/* ---------- Global state ---------- */
static Book *library     = NULL;   /* dynamic array of Book */
static size_t bookCount  = 0;        /* #books currently stored */
static size_t capacity   = 0;        /* allocated capacity */

/* ---------- Function prototypes ---------- */
void displayBook(const Book *b);          /* single-book printer */
void processMenu(int choice);            /* handles menu logic */

/* ---------- Helper: safer input ---------- */
static int getInt(void) {
    int v;
    if (scanf("%d", &v) != 1) {
        puts("Invalid integer input.");
        exit(EXIT_FAILURE);
    }
    return v;
}

static void getLine(char *buf, size_t sz) {
    if (scanf(" %127[^\n]", buf) != 1) *buf = '\0';
}

/* ---------- Entry point ---------- */
int main(void) {
    for (;;) {
        puts("\n--- Library Menu ---");
        puts("1. Add a book");
        puts("2. Remove a book");
        puts("3. Display all books");
        puts("4. Display a specific book");
        puts("5. EXIT the program");
        printf("Select an option: ");
        int choice = getInt();
        if (choice == 5) break;
        processMenu(choice);
    }

    /* Clean-up before termination */
    free(library);
    puts("Good-bye!");
    return 0;
}

/* ---------- Menu dispatcher ---------- */
void processMenu(int choice) {
    switch (choice) {
    case 1: { /* Add book */
        if (bookCount == capacity) {          /* need more room */
            size_t newCap = (capacity == 0) ? 4 : capacity * 2;
            Book *tmp = realloc(library, newCap * sizeof *tmp);
            if (!tmp) {
                puts("Memory allocation failed – cannot add book.");
                return;
            }
            library  = tmp;
            capacity = newCap;
        }

        Book *slot = &library[bookCount++];
        printf("Title            : ");
        getLine(slot->title, sizeof slot->title);
        printf("Author           : ");
        getLine(slot->author, sizeof slot->author);
        printf("Publication Year : ");
        slot->year = getInt();
        printf("Status (available/borrowed): ");
        getLine(slot->status, sizeof slot->status);
        puts("Book added successfully.");
        break;
    }

    case 2: { /* Remove book */
        if (bookCount == 0) {
            puts("Library is empty – nothing to remove.");
            return;
        }
        printf("Enter book index (1-%zu): ", bookCount);
        size_t idx = (size_t)getInt() - 1;
        if (idx >= bookCount) {
            puts("Invalid index.");
            return;
        }
        /* Shift left by one element */
        memmove(&library[idx], &library[idx + 1],
                (bookCount - idx - 1) * sizeof *library);
        --bookCount;
        puts("Book removed.");
        break;
    }

    case 3: /* Display all books */
        if (bookCount == 0) {
            puts("No books in library.");
            return;
        }
        for (size_t i = 0; i < bookCount; ++i) {
            printf("\nBook %zu:\n", i + 1);
            displayBook(&library[i]);
        }
        break;

    case 4: /* Display specific book */
        if (bookCount == 0) {
            puts("No books in library.");
            return;
        }
        printf("Enter book index (1-%zu): ", bookCount);
        size_t idx = (size_t)getInt() - 1;
        if (idx >= bookCount) {
            puts("Invalid index.");
            return;
        }
        displayBook(&library[idx]);
        break;

    default:
        puts("Unknown option – try again.");
    }
}

/* ---------- Single-book pretty printer ---------- */
void displayBook(const Book *b) {
    printf("Title             : %s\n", b->title);
    printf("Author            : %s\n", b->author);
    printf("Publication Year  : %d\n", b->year);
    printf("Status            : %s\n", b->status);
}
```

### STEP_3
# STEP 3: EXPLANATION

## 1. The Big Picture – Why Dynamic Memory?
The problem says “handle a dynamic number of books”.  
A fixed array (`Book books[100];`) would waste space if we have 3 books and crash if we ever need 101.  
Dynamic memory (`malloc` / `realloc`) lets the array grow **on demand** while the program is running.

## 2. The Hidden Array Behind Three Variables
We keep three global variables:

```c
Book *library     // pointer to the actual array (initially NULL)
size_t bookCount  // how many books we _store right now_
size_t capacity   // how many books we _could_ store before next resize
```
Think of `capacity` as the number of seats already reserved in a theater, and `bookCount` as the seats currently occupied.  
When `bookCount == capacity` the theater is full; we must “buy more land” (`realloc`) before we can add another book.

## 3. Growing the Array – Doubling Strategy
When the array is full we double its size:

```c
size_t newCap = (capacity == 0) ? 4 : capacity * 2;
library = realloc(library, newCap * sizeof *library);
```

- Doubling keeps the **amortised** cost of adding a book O(1).  
- We start with 4, not 1, to avoid too many early reallocations.  
- `realloc` preserves the old content and either returns the same pointer (if there was free space after it) or moves the whole array to a larger, fresh region.  
- **Always** check the return value; if it is `NULL` the allocation failed and we leave the original data untouched so we can still continue (or quit cleanly).

## 4. Adding a Book – Inserting into the Dynamic Array
1. Check fullness (`bookCount == capacity`) → resize if needed.  
2. Use the next free slot: `Book *slot = &library[bookCount++];`  
3. Read user input directly into that slot.  
4. No extra `malloc` per book is needed because the array itself already contains **complete structures**, not pointers.

## 5. Removing a Book – Keeping the Array Tight
We do **not** free an individual book struct; we just erase it from the array by shifting the later elements left:

```c
memmove(&library[idx], &library[idx+1],
        (bookCount-idx-1)*sizeof *library);
--bookCount;
```
`memmove` is like `memcpy` but handles overlapping regions safely.  
After the shift the last slot becomes garbage, but we will reuse or shrink it only when the user exits (we keep it for possible future inserts).

## 6. Freeing Memory – Who, When, How
- **While running** we never shrink the array (simple policy).  
- **On exit** we call `free(library)` once; this releases the **whole** block that `realloc`/`malloc` gave us.  
  No per-book `free` is required because we store **values**, not pointers to separately allocated structs.

## 7. Display Logic – A Function That Works on One Struct
The specification forces us to have:

```c
void displayBook(const Book *b);
```

- Receives a **const pointer** → we promise not to modify the book.  
- Prints the four fields in a fixed format.  
This separation makes the menu code short and readable:

```c
displayBook(&library[i]);   // inside the loop
```

## 8. Menu Dispatcher – Single Helper Function
Only one extra function besides `main` is allowed (`processMenu`).  
It is a giant `switch` that performs the four actions and contains **all** the dynamic-array logic. Centralising keeps `main` clean:

```c
main() → read choice → processMenu(choice) → loop
```

## 9. Defensive Programming – Handling the Worst Cases
- `malloc`/`realloc` can return `NULL`; we check and bail out gracefully.  
- Input sanity:  
  – `getInt()` insists on a valid integer; otherwise it terminates the program instead of entering an infinite loop.  
  – Book indices are validated against the current `bookCount`.  
  – Strings are read with a width limit (`%127[^\n]`) so we never overflow the fixed char arrays inside the struct.

## 10. Memory Leak Detector Test
To convince yourself the program is leak-free, compile and run under Valgrind:

```bash
gcc -std=c11 -Wall -g library.c -o lib
valgrind --leak-check=full ./lib
```

All reachable memory should disappear after the final `free(library)` when you choose option 5.

Once these pieces click, dynamic arrays in C become a mechanical pattern:

- start with `NULL`/0/0  
- grow with `realloc` when full  
- shrink logically by shifting elements  
- free exactly once at the end

### STEP_4
# STEP 4: HINTS

**Hint 1 – “Where do the books live?”**  
Think about the difference between a fixed-sized shelf you build once and a magical shelf that can grow new planks whenever you run out of room.  
Which kind of shelf do you need for a library whose size isn’t known ahead of time?

**Hint 2 – “Growing the shelf”**  
There’s a standard library facility that can *change* the size of an already-allocated block while keeping the old books in place.  
Look up the function whose name starts with “re” and ends with “alloc,” and remember to double-check whether it succeeded before you trust the new shelf.

**Hint 3 – “Add, fill, count”**  
When the user asks to add a book, perform these three steps in order:  
1. Make sure your current shelf has at least one empty slot; if not, make the shelf bigger.  
2. Use the next empty slot (you already know how many books are on the shelf).  
3. Read the user’s data straight into that slot and update your running total of books.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management with malloc/realloc and the importance of checking return values  
- Designing and using a struct to model real-world entities (books)  
- Implementing a dynamically resizing array (vector) that grows on demand  
- Practicing clean-up discipline: freeing every allocated block exactly once  
- Separating concerns: one function to handle menu logic, another for single-item display  
- Defensive programming: validating user input and handling allocation failures gracefully

### STEP_6
# STEP 6: TEST CASES

1. Common case – add two valid books, list them, then exit.  
2. Edge case – immediately list books when the library is empty (should print “No books…”).  
3. Invalid index – try to remove book #5 when only two exist (should print “Invalid index”).  
4. Allocation failure simulation – add books until realloc would be required (test checks graceful failure message).  
5. Invalid menu choice – enter 9 at the menu (should print “Unknown option…”) then continue.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nHarry Potter\nJ.K. Rowling\n1997\navailable\n1\nThe Lord of the Rings\nJ.R.R. Tolkien\n1954\navailable\n3\n5",
      "expected_keyword": "Harry Potter"
    },
    {
      "input": "3\n5",
      "expected_keyword": "No books"
    },
    {
      "input": "1\nA\nB\n2000\navailable\n1\nC\nD\n2001\navailable\n2\n5\n5",
      "expected_keyword": "Invalid index"
    },
    {
      "input": "1\nT1\nA1\n2000\navailable\n1\nT2\nA2\n2001\navailable\n1\nT3\nA3\n2002\navailable\n1\nT4\nA4\n2003\navailable\n1\nT5\nA5\n2004\navailable\n5",
      "expected_keyword": "Book added"
    },
    {
      "input": "9\n5",
      "expected_keyword": "Unknown option"
    }
  ]
}
```

---

## Iteration 61 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the manager of a library that lends books to its members. The library has a collection of books, and each book has a unique title, author, and publication year. You want to create a program to manage the library's collection of books using dynamic memory allocation.

Background:
The library's collection of books is constantly changing, with new books being added and old books being removed. The library wants to keep track of its collection using a program that can handle a dynamic number of books.

Requirements:
1. The program must allow the user to add a new book to the collection.
2. The program must allow the user to remove a book from the collection by its title.
3. The program must allow the user to display all the books in the collection.
4. The program must allow the user to search for a book by its title or author.

Example Input/Output:
```
Menu:
1. Add a book
2. Remove a book
3. Display all books
4. Search for a book
5. Exit

Enter your choice: 1
Enter book title: Harry Potter
Enter book author: J.K. Rowling
Enter book publication year: 1997

Menu:
1. Add a book
2. Remove a book
3. Display all books
4. Search for a book
5. Exit

Enter your choice: 3
Book 1:
Title: Harry Potter
Author: J.K. Rowling
Publication Year: 1997
```

### CONSTRAINTS
1. The program must use a `struct` to represent a book, with members for the title, author, and publication year.
2. The logic for displaying the details of all books must be in a function called `displayBooks`.
3. The solution must be implemented with a single function besides `main()` to handle the menu options, called `handleMenuOption`.
4. The program must include a specific menu option to EXIT the program, which is option 5.

Note: The program must use dynamic memory allocation (`malloc` and `free`) to manage the collection of books. The program must also handle memory leaks by freeing the allocated memory when it is no longer needed.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Manager – Dynamic Collection
 * -----------------------------------
 * A self-contained, single-file program that lets a user
 * add / remove / display / search books in a dynamically
 * resized array.  All memory is allocated with malloc/
 * realloc and is freed before the process terminates.
 *
 * Language: ISO C11
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structures ---------- */
typedef struct {
    char *title;   /* dynamically allocated */
    char *author;  /* dynamically allocated */
    int   year;    /* publication year */
} Book;

typedef struct {
    Book  *data;   /* pointer to dynamic array */
    size_t size;   /* current number of books */
    size_t capacity;/* allocated slots */
} Library;

/* ---------- Function prototypes ---------- */
int  handleMenuOption(Library *lib, int choice);
void displayBooks(const Library *lib);
void freeLibrary(Library *lib);
char *myStrDup(const char *s);

/* ---------- Helper: duplicate a C string with malloc ---------- */
char *myStrDup(const char *s)
{
    if (!s) return NULL;
    size_t len = strlen(s) + 1;
    char *dup  = malloc(len);
    if (!dup) {                /* safeguard against allocation failure */
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    memcpy(dup, s, len);
    return dup;
}

/* ---------- Free complete library including all strings ---------- */
void freeLibrary(Library *lib)
{
    if (!lib) return;
    for (size_t i = 0; i < lib->size; ++i) {
        free(lib->data[i].title);
        free(lib->data[i].author);
    }
    free(lib->data);
    lib->data = NULL;
    lib->size = lib->capacity = 0;
}

/* ---------- Display all books ---------- */
void displayBooks(const Library *lib)
{
    if (!lib || lib->size == 0) {
        puts("No books in the collection.");
        return;
    }
    for (size_t i = 0; i < lib->size; ++i) {
        printf("Book %zu:\n", i + 1);
        printf("Title: %s\n", lib->data[i].title);
        printf("Author: %s\n", lib->data[i].author);
        printf("Publication Year: %d\n\n", lib->data[i].year);
    }
}

/* ---------- Handle single menu option ---------- */
int handleMenuOption(Library *lib, int choice)
{
    if (!lib) return 0;          /* safety */

    switch (choice) {
    case 1: {                    /* Add a book */
        /* Ensure capacity */
        if (lib->size == lib->capacity) {
            size_t newCap = lib->capacity ? lib->capacity * 2 : 4;
            Book *tmp   = realloc(lib->data, newCap * sizeof(*tmp));
            if (!tmp) {
                perror("realloc");
                exit(EXIT_FAILURE);
            }
            lib->data     = tmp;
            lib->capacity = newCap;
        }

        char titleBuf[256], authorBuf[256];
        int  year;
        printf("Enter book title: ");
        fflush(stdout);
        if (!fgets(titleBuf, sizeof(titleBuf), stdin)) break;
        titleBuf[strcspn(titleBuf, "\n")] = '\0';

        printf("Enter book author: ");
        fflush(stdout);
        if (!fgets(authorBuf, sizeof(authorBuf), stdin)) break;
        authorBuf[strcspn(authorBuf, "\n")] = '\0';

        printf("Enter book publication year: ");
        fflush(stdout);
        if (scanf("%d", &year) != 1) {
            puts("Invalid year – book not added.");
            while (getchar() != '\n'); /* clear rest of line */
            break;
        }
        while (getchar() != '\n'); /* consume newline */

        Book *slot = &lib->data[lib->size++];
        slot->title  = myStrDup(titleBuf);
        slot->author = myStrDup(authorBuf);
        slot->year   = year;
        puts("Book added.");
        break;
    }

    case 2: {                    /* Remove by title */
        char titleBuf[256];
        printf("Enter title to remove: ");
        fflush(stdout);
        if (!fgets(titleBuf, sizeof(titleBuf), stdin)) break;
        titleBuf[strcspn(titleBuf, "\n")] = '\0';

        int found = 0;
        for (size_t i = 0; i < lib->size; ++i) {
            if (strcmp(lib->data[i].title, titleBuf) == 0) {
                /* free the strings of the element to be deleted */
                free(lib->data[i].title);
                free(lib->data[i].author);

                /* shift subsequent elements left */
                lib->data[i] = lib->data[--lib->size];
                found = 1;
                break;
            }
        }
        if (found)
            puts("Book removed.");
        else
            puts("Book not found.");
        break;
    }

    case 3:                      /* Display all */
        displayBooks(lib);
        break;

    case 4: {                    /* Search by title or author */
        char key[256];
        printf("Enter title or author to search: ");
        fflush(stdout);
        if (!fgets(key, sizeof(key), stdin)) break;
        key[strcspn(key, "\n")] = '\0';

        int found = 0;
        for (size_t i = 0; i < lib->size; ++i) {
            if (strstr(lib->data[i].title, key) ||
                strstr(lib->data[i].author, key)) {
                printf("Book %zu:\n", i + 1);
                printf("Title: %s\n", lib->data[i].title);
                printf("Author: %s\n", lib->data[i].author);
                printf("Publication Year: %d\n\n", lib->data[i].year);
                found = 1;
            }
        }
        if (!found)
            puts("No matching books.");
        break;
    }
    default:                     /* Unknown or Exit */
        break;
    }
    return choice == 5;          /* return 1 if user wants to exit */
}

/* ---------- Main interactive loop ---------- */
int main(void)
{
    Library lib = { NULL, 0, 0 };

    for (;;) {
        puts("\nMenu:");
        puts("1. Add a book");
        puts("2. Remove a book");
        puts("3. Display all books");
        puts("4. Search for a book");
        puts("5. Exit");

        printf("Enter your choice: ");
        fflush(stdout);

        int choice;
        if (scanf("%d", &choice) != 1) {
            while (getchar() != '\n'); /* discard bad input */
            puts("Invalid choice.");
            continue;
        }
        while (getchar() != '\n'); /* consume newline */

        if (handleMenuOption(&lib, choice))
            break;               /* user elected to exit */
    }

    /* ---- Clean up ---- */
    freeLibrary(&lib);
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory allocation is the big idea here.  
Every time the program needs to store something that can change size at run-time (number of books, length of a title, length of an author name, etc.) we cannot use fixed-size arrays, so we allocate the exact amount of memory we need while the program is running.

Below are the key ideas you must understand to follow the code without getting lost in the details.

--------------------------------------------------
1.  What is a “Book” and why are half its members pointers?
--------------------------------------------------
We declared

    typedef struct {
        char *title;
        char *author;
        int  year;
    } Book;

- `int year` is fine; an integer’s size is fixed (4 bytes).  
- `char title[50]` or similar is **not** OK, because a book title might be short or very long.  
- Therefore we store only a pointer (`char *`).  The pointer itself occupies 8 bytes (on a 64-bit machine); the actual characters live somewhere on the heap.  
This is a very common C idiom: keep a fixed-size handle in the struct, allocate the variable-size data elsewhere.

--------------------------------------------------
2.  Managing the “Library” – a resizable array of Books
--------------------------------------------------
The second struct:

    typedef struct {
        Book  *data;
        size_t size;
        size_t capacity;
    } Library;

Think of it as a “vector” or “dynamic array”:

- `data`: a pointer to the first element of a malloc’d block that can hold `capacity` books.  
- `size`: how many books are currently stored (`size ≤ capacity`).  
- `capacity`: how many books can fit before we must enlarge the block.

Initially we set `data = NULL`, `size = capacity = 0`.  
Every `push_back` (here “add book”) follows the textbook strategy:

```
if size == capacity        // full
    new_capacity = old_capacity * 2   (or 4 when starting from 0)
    data = realloc(data, new_capacity * sizeof(Book))
```

Why double instead of “add one”?  `realloc` may copy everything to a new address; by doubling we guarantee **amortized O(1)** time instead of O(n²) for many insertions.

--------------------------------------------------
3.  Duplicating a string – a tiny utility
--------------------------------------------------
We read titles and authors with `fgets` into a *temporary* local buffer of 256 bytes.  We then allocate exactly the right amount of memory, copy the string into it, and return a pointer to that freshly allocated block:

    char *myStrDup(const char *s)
    {
        size_t len = strlen(s) + 1;  // +1 for '\0'
        char *dup = malloc(len);
        if (!dup) { perror("malloc"); exit(EXIT_FAILURE); }
        memcpy(dup, s, len);
        return dup;
    }

The caller (the “add book” branch) stores these two pointers into the new Book.  We have transferred ownership of the memory from the temporary buffer to the heap.

--------------------------------------------------
4.  Adding a book – the workflow
--------------------------------------------------
1. Make sure we have enough capacity (expand if necessary).  
2. Read title, author, year.  
3. Allocate title and author strings (`myStrDup`).  
4. Increment `size`.  
5. Insert values into the *last* slot.

Because `data[size-1]` is now “live”, all the pointers we just copied were heap pointers, so nothing is dangling.

--------------------------------------------------
5.  Removing (by title) – a delete in a dynamic array
--------------------------------------------------
To erase element at index `i` we could shift every element left and shrink capacity, but here we chose the simpler “swap with last element and decrement size”:

```
free(lib->data[i].title);
free(lib->data[i].author);
lib->data[i] = lib->data[--lib->size];
```

- We first release the two dynamic strings we own.  
- We copy the *last* book into slot `i`, then decrement size.  
This keeps the array contiguous and runs in O(1) time, at the small cost of destroying the original order.

--------------------------------------------------
6.  Searching – no ownership issues
--------------------------------------------------
The search routine never allocates; it simply scans each title/author with `strstr` (substring match) and prints the matching books.  
Because the Library still owns the memory, printing is safe and we do not leak anything.

--------------------------------------------------
7.  Cleaning up – the opposite of *malloc* is *free*
--------------------------------------------------
`freeLibrary()` walks through the array:

    for every book
        free(title)
        free(author)
    free(data)

This is the mirror image of what we did while building the library.  If we forget any step we leak memory.

--------------------------------------------------
8.  Where is the memory allocation actually happening?
--------------------------------------------------
Only **three** places allocate:

1. Inside `myStrDup()` for every title/author string.  
2. The initial `malloc` (via `realloc` with `NULL`) that creates the first `data` block.  
3. Subsequent `realloc` that enlarges `data`.

All other pointers (indices, local buffers, loop variables, etc.) live on the stack and vanish when the function returns.

--------------------------------------------------
9.  Error checking with allocation failure
----------------------------------------------------
`malloc` / `realloc` can return `NULL` when the system is out of RAM.  Each call is followed by:

    if (!ptr) { perror("malloc"); exit(EXIT_FAILURE); }

This teaches good practice: never proceed if an allocation fails, or you will dereference `NULL` and crash later in an unrelated part of the program.

--------------------------------------------------
10.  Putting it together – the lifetime of one book
----------------------------------------------------
- Title read → temporary stack buffer  
- `myStrDup` ⇒ heap copy #1 (malloc)  
- Author read → temporary stack buffer  
- `myStrDup` ⇒ heap copy #2 (malloc)  
- Book array contains pointers to those two heap copies.  
- When the book is deleted OR at program termination:  
  free(title) – frees copy #1  
  free(author) – frees copy #2  
- Finally `free(data)` frees the array of Books themselves.  

No leaks, no dangling pointers, no undefined behaviour.

--------------------------------------------------
Key take-away
--------------------------------------------------
The program’s structure is a miniature version of every dynamic container in professional code:

1. Fixed header holding pointers + bookkeeping.  
2. Growth strategy that keeps performance sane while never losing track of allocated blocks.  
3. Clear ownership rules: who allocates, who frees, and exactly when.

You can scale this idea from a toy library to millions of records, database pages, or even operating-system buffers—the concept never changes.

### STEP_4
# STEP 4: HINTS

**Hint 1 – Big-Picture Nudge**  
Think of your collection of books as something that can shrink and grow while the program is running.  
Instead of trying to decide on “the biggest it will ever be,” give yourself a way to ask the operating system for only the space you need right now, and to hand that space back when you’re done with it.

**Hint 2 – Where the Pieces Live**  
Look at each piece of information a book holds: its title, its author, its year.  
One of those pieces has a length you can’t predict ahead of time.  
Which C-standard tool lets you request a block of bytes just big enough to hold something whose size you discover only after the program starts?

**Hint 3 – First Concrete Step**  
Start small: write the skeleton of a function that can add exactly one book.  
Inside that function, allocate space for the title string first; if that request succeeds, allocate space for the author string; if either request fails, undo everything you’ve done so far before signalling failure.  
Once that “add-one” path is leak-proof, growing the array to hold many books is only a matter of asking for a bigger basket when the current one gets full.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory life-cycle: malloc / realloc / free, ownership, and leak avoidance  
- Structuring data with flexible-size members (fixed pointer + heap-allocated payload)  
- Implementing a resizeable vector (capacity, size, and growth-doubling strategy)  
- Safe string handling: reading input with fgets, duplicating unknown-length strings  
- Defensive allocation checks and graceful failure handling  
- Resource cleanup: freeing every allocated block before program termination  
- Modular program design: separating menu logic (handleMenuOption) from low-level display (displayBooks) and cleanup (freeLibrary)

### STEP_6
# STEP 6: TEST CASES

1. Happy-path addition & display  
   Add a single book and immediately display the collection; output must list that book.

2. Empty collection display  
   Start the program and choose the display option without adding anything; the program must print “No books in the collection.”

3. Remove non-existent title  
   Try to delete a book whose title is not present; the program must respond “Book not found.”

4. Add after full deletion  
   Add two books, remove both (one by one), then add a new book and display; the list must contain only the newly added item.

5. Invalid menu choice  
   Enter a letter instead of an integer when prompted for a menu option; the program must re-prompt without crashing.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nHarry Potter\nJ.K. Rowling\n1997\n3\n5", "expected_keyword": "Harry Potter"},
    {"input": "3\n5", "expected_keyword": "No books"},
    {"input": "1\nBookA\nAuthA\n2000\n2\nNoSuchBook\n5", "expected_keyword": "not found"},
    {"input": "1\nFirst\nAuth1\n1999\n1\nSecond\nAuth2\n2000\n2\nFirst\n2\nSecond\n1\nOnly\nAuthOnly\n2025\n3\n5", "expected_keyword": "Only"},
    {"input": "x\n5", "expected_keyword": "Invalid choice"}
  ]
}
```

---

## Iteration 62 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are a librarian tasked with managing a collection of books in a library. The library uses a dynamic system to store information about each book, including its title, author, and publication year. Your task is to design a program that allows the librarian to add, remove, and display books in the collection.

The program should have the following functionality:
1. **Add a Book**: The user should be able to add a new book to the collection by providing its title, author, and publication year.
2. **Remove a Book**: The user should be able to remove a book from the collection by providing its title.
3. **Display All Books**: The user should be able to view all the books in the collection.
4. **Display a Specific Book**: The user should be able to view the details of a specific book by providing its title.

### EXAMPLE
Input:
```
Add a book with title "Book1", author "Author1", and publication year 2020.
Add a book with title "Book2", author "Author2", and publication year 2021.
Display all books.
Remove the book with title "Book1".
Display all books.
```
Output:
```
Book1 by Author1, published in 2020
Book2 by Author2, published in 2021
Book2 by Author2, published in 2021
```

### CONSTRAINTS
* The solution must use a `struct` to represent a book, with members for title, author, and publication year.
* The logic for displaying the details of all books must be in a function called `displayAllBooks`.
* The logic for displaying the details of a specific book must be in a function called `displayBook`.
* The program must use dynamic memory allocation (`malloc` and `free`) to store and manage the collection of books.
* A menu must be implemented with the following options:
	1. Add a book
	2. Remove a book
	3. Display all books
	4. Display a specific book
	5. EXIT (to exit the program)
* The program must handle invalid inputs and memory allocation errors.

Note: The program should be implemented in C, and the `struct` definition, function prototypes, and main function should be clearly defined.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 *  Library Book‐Collection Manager
 *  C11, ISO/IEC 9899:2011
 *
 *  This program demonstrates:
 *      – dynamic memory allocation (malloc/realloc/free)
 *      – struct usage
 *      – simple menu‐driven interface
 *      – defensive programming (input validation, allocation checks)
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TITLE_LEN 100
#define AUTHOR_LEN 100
#define MENU_EXIT 5

/* ---------- DATA STRUCTURES ---------- */
typedef struct {
    char title[TITLE_LEN];
    char author[AUTHOR_LEN];
    int  year;
} Book;

/* ---------- GLOBAL STATE ---------- */
static Book *library     = NULL;   /* dynamic array of Books */
static size_t capacity   = 0;      /* allocated slots      */
static size_t count      = 0;      /* books currently used */

/* ---------- FUNCTION PROTOTYPES ---------- */
int  menu(void);
void addBook    (void);
void removeBook (void);
void displayAllBooks(void);
void displayBook     (void);

/* helper: resize library if full; returns 0 on success, -1 on failure */
static int growIfNeeded(void);

/* helper: remove trailing newline from fgets input */
static void stripNewline(char *str);

/* ---------- MAIN ---------- */
int main(void)
{
    int choice;
    while ((choice = menu()) != MENU_EXIT) {
        switch (choice) {
            case 1: addBook();      break;
            case 2: removeBook();   break;
            case 3: displayAllBooks(); break;
            case 4: displayBook();     break;
            default: puts("Invalid choice. Try again.");
        }
    }

    /* release all heap memory before termination */
    free(library);
    puts("Good-bye!");
    return 0;
}

/* ---------- FUNCTION DEFINITIONS ---------- */

/* print menu and return user selection */
int menu(void)
{
    puts("\nLibrary Menu");
    puts("1. Add a book");
    puts("2. Remove a book");
    puts("3. Display all books");
    puts("4. Display a specific book");
    printf("5. EXIT\nChoice: ");

    int c;
    if (scanf("%d", &c) != 1) {        /* consume invalid chars */
        while (getchar() != '\n') { /* discard rest of line   */
        }
        return -1;
    }
    return c;
}

/* grow array by doubling its capacity when full */
static int growIfNeeded(void)
{
    if (count < capacity) return 0;          /* enough room */

    size_t newCap = (capacity == 0) ? 2 : capacity * 2;
    Book *tmp = realloc(library, newCap * sizeof(*tmp));
    if (!tmp) {
        perror("realloc");
        return -1;
    }
    library   = tmp;
    capacity  = newCap;
    return 0;
}

/* add a book interactively */
void addBook(void)
{
    if (growIfNeeded() == -1) return;

    Book b;
    printf("Title (max %d chars): ", TITLE_LEN - 1);
    if (!fgets(b.title, sizeof(b.title), stdin)) return;
    stripNewline(b.title);

    printf("Author (max %d chars): ", AUTHOR_LEN - 1);
    if (!fgets(b.author, sizeof(b.author), stdin)) return;
    stripNewline(b.author);

    printf("Publication year: ");
    if (scanf("%d", &b.year) != 1) {
        while (getchar() != '\n') {}
        puts("Invalid year.");
        return;
    }
    while (getchar() != '\n') {}  /* consume rest of line */

    /* append to array */
    library[count++] = b;
    puts("Book added.");
}

/* remove first book whose title matches (case-insensitive) */
void removeBook(void)
{
    if (count == 0) {
        puts("Collection is empty.");
        return;
    }
    char target[TITLE_LEN];
    printf("Title to remove: ");
    if (!fgets(target, sizeof(target), stdin)) return;
    stripNewline(target);

    for (size_t i = 0; i < count; ++i) {
        if (strcasecmp(library[i].title, target) == 0) {
            /* shift remaining elements left */
            memmove(&library[i], &library[i + 1],
                    (count - i - 1) * sizeof(Book));
            --count;
            puts("Book removed.");
            return;
        }
    }
    puts("Book not found.");
}

/* display every book in collection */
void displayAllBooks(void)
{
    if (count == 0) {
        puts("Collection is empty.");
        return;
    }
    for (size_t i = 0; i < count; ++i) {
        printf("%s by %s, published in %d\n",
               library[i].title, library[i].author, library[i].year);
    }
}

/* display one book by exact title (case-insensitive) */
void displayBook(void)
{
    char target[TITLE_LEN];
    printf("Title to display: ");
    if (!fgets(target, sizeof(target), stdin)) return;
    stripNewline(target);

    for (size_t i = 0; i < count; ++i) {
        if (strcasecmp(library[i].title, target) == 0) {
            printf("%s by %s, published in %d\n",
                   library[i].title,
                   library[i].author,
                   library[i].year);
            return;
        }
    }
    puts("Book not found.");
}

static void stripNewline(char *str)
{
    str[strcspn(str, "\n")] = '\0';
}
```

Key implementation notes (already embedded as comments):
1. All memory allocations are checked; failure prints an error and leaves the program in a safe state.
2. The dynamic array doubles in capacity when full, guaranteeing amortized O(1) insertion cost.
3. Before `exit`, the entire array is freed exactly once.
4. Menus and user input are protected against invalid characters and buffer overflows.
5. The solution strictly adheres to the required function names (`displayAllBooks`, `displayBook`) and uses a `struct` for `Book`.

### STEP_3
# STEP 3: EXPLANATION

Imagine your bookshelf at home.  
When you only have two or three books you can keep them on a small desk.  
When the collection grows you buy a *bigger* shelf, move every book to the new shelf, and throw the old one away.  
That everyday act of “getting a bigger shelf” is exactly what **dynamic memory allocation** is doing in C—only the “shelf” is the *heap* and the “books” are `struct Book` elements.

Below we walk through the program in five conceptual steps.  
Whenever we say “memory” we mean **heap memory** obtained with `malloc`/`realloc`.  
The automatic variables (`int choice`, `char target[100]`, …) live on the **stack** and disappear when the function returns, so we never store the *collection* there.

-------------------------------------------------
1.  Starting with an *empty* collection
-------------------------------------------------
```c
Book *library = NULL;
size_t count  = 0;
size_t capacity = 0;
```
- `library` is just a **pointer** that will one day aim at a *contiguous* block of `struct Book`.  
- `capacity` tells us how many `Book` slots we have *paid for* (how long the block is).  
- `count` tells us how many of those slots are *occupied*.  
Initially we own zero bytes—no call to `malloc` has happened yet. We do **not** allocate one slot for free because the user might quit immediately; we delay allocation until the first book is added (lazy allocation).

-------------------------------------------------
2.  Adding the first book – entering the heap world
-------------------------------------------------
The user picks menu item `1`. Function `addBook()` runs:

a.  `growIfNeeded()` notices `count == capacity` (both 0).  
    It chooses a small initial request:
    ```c
    size_t newCap = (capacity == 0) ? 2 : capacity * 2;
    Book *tmp = realloc(library, newCap * sizeof(Book));
    ```
    `realloc(NULL, size)` is **legal** and behaves exactly like `malloc(size)`.  
    So on the very first call we really `malloc` space for two books.  
    If `tmp` is `NULL` we print an error and **abort the operation**—the original `library` pointer is still valid (`realloc` does not touch it on failure).

b.  Now we have room. We read the title, author and year from the keyboard into a *temporary* local `Book b`. When we are sure all fields are valid we **copy** the structure into the array:
    ```c
    library[count++] = b;
    ```
    The **whole struct is copied byte-by-byte** (a cheap, safe operation).  
    No pointers inside the struct need extra allocation because the members are fixed-size arrays (`char title[TITLE_LEN]`).

-------------------------------------------------
3.  Growing the shelf – doubling strategy
-------------------------------------------------
After the second book `count == capacity`. When the user adds a third book `growIfNeeded()` doubles the capacity again:
- allocates `4 * sizeof(Book)` bytes  
- copies the existing two books to the new block  
- `free`s the old 2-slot block automatically (this is done by `realloc`)  

Doubling is a **classic time/space trade-off**:  
- Each book is copied O(log n) times, so the *amortised* cost per insertion is O(1).  
- We never copy more than a constant factor of the data, keeping runtime fast.  
- We waste at most 50 % of the allocated space (one extra unused slot after the last double).

-------------------------------------------------
4.  Removing a book – keeping the array contiguous
-------------------------------------------------
Arrays are great for *random access* but terrible for *holes*.  
Therefore we **compress** the array by shifting everything left:
```c
memmove(&library[i], &library[i+1],
        (count - i - 1) * sizeof(Book));
--count;
```
`memmove` is safe for overlapping regions; after the shift the last slot is simply considered *free*—no call to `free` for an individual `Book` is necessary because we never `malloc`-ed inside the struct.  
The physical memory stays allocated (`capacity` unchanged) so the next insertion will reuse the empty slot without involving `realloc`.

-------------------------------------------------
5.  Giving memory back – cleanup and lifetime rules
-------------------------------------------------
- Every path that leaves the program (the user chooses 5 or we fail to allocate) reaches the same single statement:
  ```c
  free(library);
  ```
  That releases the *entire* block acquired by `malloc`/`realloc`.  
  After `free(library)` the pointer value is **indeterminate**; we immediately return from `main`, so we never dereference it again.

- Inside `addBook` we **never** keep a direct pointer to a single `Book`.  
  If we allocated each book separately (`Book *b = malloc(sizeof(Book))`) we would have to `free` every element individually before we `free` the array that holds the pointers. By keeping the books *inside* one chunk we turn **n+1 allocations** (n books + 1 array of pointers) into **1 allocation** and **1 de-allocation**, dramatically simplifying the program and reducing fragmentation.

-------------------------------------------------
6.  Why not use the stack?
-------------------------------------------------
Stack variables vanish when the function returns. If we wrote
```
Book collection[100];
```
inside `main` we would be limited to 100 books forever and would waste the memory even when the librarian owns zero books.  
Dynamic allocation lets the collection **grow on demand** and stay alive until we explicitly `free` it—exactly what a real-world program needs.

-------------------------------------------------
7.  Summary of dynamic memory ideas shown
-------------------------------------------------
1.  Start with `NULL`, allocate only when necessary.  
2.  Always check the result of `malloc`/`realloc`; on failure leave the program in a consistent state (here we simply abort the operation).  
3.  Use `realloc(ptr,0)` as a “grow-in-place” strategy; doubling keeps amortised cost constant.  
4.  Keep the number of allocations small; copy structs, not pointers, when the data is tiny.  
5.  Provide a single, reliable cleanup path—`free` the root pointer exactly once.

With these principles you can implement any resizable container (vector, stack, queue) in C without leaking memory or crashing on out-of-memory conditions.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of the collection as a shelf that starts out empty and has to expand whenever new books arrive; in C you must ask the operating system for the “shelf space” yourself and later hand it back when the library shuts down.

Hint 2  
To make the shelf grow smoothly, look for a standard library call that can both create the very first plank and, later, replace the entire plank with a longer one without you having to copy the books manually.

Hint 3  
Begin by creating the smallest possible shelf (room for just two books) the first time a book is added; when that shelf fills up, double its length each time—this keeps the number of rebuilds low and the program simple.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management with malloc / realloc / free  
- Struct design for grouping related data (title, author, year)  
- Resize-on-demand arrays and amortized O(1) growth strategy  
- Defensive programming: checking every allocation result  
- Single-point cleanup to prevent memory leaks  
- Menu-driven program flow and basic user-input validation

### STEP_6
# STEP 6: TEST CASES

1.  **Common flow**  
    Add two books, list them, remove one, list again to confirm correct deletion and compact storage.

2.  **Empty collection display**  
    Ask to display all books when none have been added; the program must say “Collection is empty.”

3.  **Lookup non-existent title**  
    Attempt to display a book whose title is not in the library; expect “Book not found.”

4.  **Remove from empty collection**  
    Attempt to remove any title when count is zero; expect “Collection is empty.”

5.  **Invalid menu choice**  
    Type a letter or a number outside 1-5; program must reprompt without crashing.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nBook1\nAuthor1\n2020\n1\nBook2\nAuthor2\n2021\n3\n2\nBook1\n3\n5", "expected_keyword": "Book2 by Author2"},
    {"input": "3\n5", "expected_keyword": "empty"},
    {"input": "4\nMissingBook\n5", "expected_keyword": "not found"},
    {"input": "2\nAnyBook\n5", "expected_keyword": "empty"},
    {"input": "x\n9\n5", "expected_keyword": "Invalid"}
  ]
}
```

---

## Iteration 63 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the administrator of a library management system. The library has a collection of books, and you need to manage the inventory using dynamic memory allocation. The program should allow users to add, remove, and display book details.

The library has the following requirements for the program's functionality:
1. The program should be able to store and manage a dynamic list of books.
2. Each book should have a unique ID, title, author, and publication year.
3. Users should be able to add a new book to the inventory by providing the required details.
4. Users should be able to remove a book from the inventory by providing the book's ID.
5. Users should be able to display all the books in the inventory.
6. Users should be able to search for a book by its ID and display its details.

Here is a simple example of expected input/output:
```
Menu:
1. Add a book
2. Remove a book
3. Display all books
4. Search for a book
5. Exit

User chooses option 1:
Enter book ID: 1
Enter book title: Introduction to CS
Enter book author: John Doe
Enter publication year: 2020

User chooses option 3:
Book 1:
ID: 1
Title: Introduction to CS
Author: John Doe
Publication Year: 2020

User chooses option 5:
Exiting the program...
```

### CONSTRAINTS
- The solution must be implemented using a `struct` to represent a book.
- Logic for displaying the details of all books must be in a function called `displayAllBooks`.
- The solution must include a menu with the following options:
  1. Add a book
  2. Remove a book
  3. Display all books
  4. Search for a book
  5. Exit
- The program must exit when the user chooses option 5 (Exit).
- The `displayBookDetails` function should be used to display the details of a single book.
- The program should handle memory allocation and deallocation using `malloc` and `free` functions.

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Library Management System – Dynamically-Allocated Inventory
 * C11, ISO/IEC 9899:2011
 *
 * Author: Prof. Socratic Tutor
 * Date  : 2024
 *
 * Compile: gcc -std=c11 -Wall -Wextra -pedantic library.c -o library
 * Run    : ./library
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structure definitions ---------- */

typedef struct {
    int  id;          /* unique identifier for the book */
    char *title;      /* dynamically-allocated string */
    char *author;     /* dynamically-allocated string */
    int  year;        /* publication year */
} Book;

/* Collection of books managed as a growable, contiguous array */
typedef struct {
    Book *data;       /* pointer to the first book */
    size_t size;      /* number of books currently stored */
    size_t capacity;  /* total number of books that can fit before next grow */
} Inventory;

/* ---------- Function prototypes ---------- */

/* Memory helpers */
Inventory *createInventory(size_t initialCapacity);
void freeInventory(Inventory *inv);

/* Book management */
int addBook(Inventory *inv, int id,
            const char *title, const char *author, int year);
int removeBookById(Inventory *inv, int id);

/* Display helpers */
void displayBookDetails(const Book *b);
void displayAllBooks(const Inventory *inv);

/* Search */
Book *searchBookById(const Inventory *inv, int id);

/* ---------- Main menu ---------- */

int main(void)
{
    Inventory *library = createInventory(4); /* start small */
    if (!library) {
        fprintf(stderr, "Fatal: could not allocate inventory\n");
        return EXIT_FAILURE;
    }

    while (1) {
        puts("\nMenu:");
        puts("1. Add a book");
        puts("2. Remove a book");
        puts("3. Display all books");
        puts("4. Search for a book");
        puts("5. Exit");

        printf("Choose an option: ");

        int choice;
        if (scanf("%d", &choice) != 1) {
            /* Non-numeric input: flush stdin and try again */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF)
                /* void */;
            puts("Invalid input. Please enter a number 1-5.");
            continue;
        }

        switch (choice) {
        case 1: {
            int id, year;
            char titleBuf[256], authorBuf[256];

            printf("Enter book ID: ");
            scanf("%d", &id);
            getchar(); /* consume newline left by scanf */

            printf("Enter book title: ");
            if (!fgets(titleBuf, sizeof(titleBuf), stdin)) {
                puts("Input error.");
                break;
            }
            titleBuf[strcspn(titleBuf, "\n")] = '\0'; /* strip newline */

            printf("Enter book author: ");
            if (!fgets(authorBuf, sizeof(authorBuf), stdin)) {
                puts("Input error.");
                break;
            }
            authorBuf[strcspn(authorBuf, "\n")] = '\0';

            printf("Enter publication year: ");
            scanf("%d", &year);

            if (addBook(library, id, titleBuf, authorBuf, year) == 0)
                puts("Book added successfully.");
            else
                puts("Error adding book (duplicate ID or memory failure).");
            break;
        }

        case 2: {
            int id;
            printf("Enter book ID to remove: ");
            scanf("%d", &id);
            if (removeBookById(library, id) == 0)
                puts("Book removed.");
            else
                puts("Book not found.");
            break;
        }

        case 3:
            displayAllBooks(library);
            break;

        case 4: {
            int id;
            printf("Enter book ID to search: ");
            scanf("%d", &id);
            Book *b = searchBookById(library, id);
            if (b)
                displayBookDetails(b);
            else
                puts("Book not found.");
            break;
        }

        case 5:
            puts("Exiting the program...");
            freeInventory(library);
            return EXIT_SUCCESS;

        default:
            puts("Invalid choice. Please enter 1-5.");
        }
    }

    /* Never reached, but ensures cleanup in complex refactorings */
    freeInventory(library);
    return EXIT_SUCCESS;
}

/* ---------- Memory helpers ---------- */

Inventory *createInventory(size_t initialCapacity)
{
    Inventory *inv = malloc(sizeof(*inv));
    if (!inv) return NULL;

    inv->size = 0;
    inv->capacity = initialCapacity ? initialCapacity : 1;

    inv->data = malloc(inv->capacity * sizeof(Book));
    if (!inv->data) {
        free(inv);
        return NULL;
    }
    return inv;
}

/* Deallocate every dynamically-allocated string inside each Book,
 * then free the array itself, and finally the Inventory struct. */
void freeInventory(Inventory *inv)
{
    if (!inv) return;

    for (size_t i = 0; i < inv->size; ++i) {
        free(inv->data[i].title);
        free(inv->data[i].author);
    }
    free(inv->data);
    free(inv);
}

/* ---------- Book management ---------- */

/* Internal: grow the underlying array to at least newCap entries.
 * Returns 0 on success, -1 on realloc failure. */
static int growInventory(Inventory *inv, size_t newCap)
{
    if (!inv || newCap <= inv->capacity) return 0;

    Book *tmp = realloc(inv->data, newCap * sizeof(Book));
    if (!tmp) return -1;

    inv->data     = tmp;
    inv->capacity = newCap;
    return 0;
}

/* Adds a book after checking for duplicate ID.
 * Returns 0 on success, -1 on failure (duplicate ID or malloc failure). */
int addBook(Inventory *inv, int id,
            const char *title, const char *author, int year)
{
    if (!inv || !title || !author) return -1;

    /* Duplicate check */
    for (size_t i = 0; i < inv->size; ++i)
        if (inv->data[i].id == id) return -1;

    /* Grow if necessary */
    if (inv->size == inv->capacity)
        if (growInventory(inv, inv->capacity * 2) != 0) return -1;

    /* Allocate and copy strings */
    char *t = malloc(strlen(title) + 1);
    char *a = malloc(strlen(author) + 1);
    if (!t || !a) {
        free(t);
        free(a);
        return -1;
    }
    strcpy(t, title);
    strcpy(a, author);

    /* Insert new book */
    Book *slot = &inv->data[inv->size++];
    slot->id     = id;
    slot->title  = t;
    slot->author = a;
    slot->year   = year;
    return 0;
}

/* Removes a book by ID if it exists.
 * Returns 0 on success, -1 if ID not found. */
int removeBookById(Inventory *inv, int id)
{
    if (!inv) return -1;

    ssize_t idx = -1;
    for (size_t i = 0; i < inv->size; ++i) {
        if (inv->data[i].id == id) {
            idx = (ssize_t)i;
            break;
        }
    }
    if (idx == -1) return -1;

    /* Free the strings of the victim */
    free(inv->data[idx].title);
    free(inv->data[idx].author);

    /* Shift the rest left by one element */
    memmove(&inv->data[idx],
            &inv->data[idx + 1],
            (inv->size - idx - 1) * sizeof(Book));
    inv->size--;
    return 0;
}

/* ---------- Display helpers ---------- */

void displayBookDetails(const Book *b)
{
    if (!b) return;
    printf("Book %d:\n", b->id);
    printf("ID: %d\n", b->id);
    printf("Title: %s\n", b->title);
    printf("Author: %s\n", b->author);
    printf("Publication Year: %d\n", b->year);
}

void displayAllBooks(const Inventory *inv)
{
    if (!inv || inv->size == 0) {
        puts("No books in inventory.");
        return;
    }
    for (size_t i = 0; i < inv->size; ++i)
        displayBookDetails(&inv->data[i]);
}

/* ---------- Search ---------- */

Book *searchBookById(const Inventory *inv, int id)
{
    if (!inv) return NULL;
    for (size_t i = 0; i < inv->size; ++i)
        if (inv->data[i].id == id)
            return &inv->data[i];
    return NULL;
}
```

### STEP_3
# STEP 3: EXPLANATION

## 1. Why Dynamic Memory?
Imagine we ask the user at compile-time:  
“How many books will you add?”  
He can’t know.  
Therefore we can’t use:
```c
Book books[100];   /* fixed size – either waste space or run out */
```
Dynamic memory lets the array **grow on demand** by asking the OS for more bytes while the program is running.  
The C tools for that are:
- `malloc`  – allocate raw bytes
- `realloc` – grow/shrink an existing allocation
- `free`    – give the memory back (prevent leaks)

## 2. The Two-Level Picture
In our program:
```
Inventory (struct)
├─ capacity      ← how many slots we have
├─ size        ← how many slots are currently used
└─ data        ← pointer to the first Book in a *contiguous* array
```
Each `Book` itself holds two *pointers* (`title`, `author`) that point to *other* heap blocks.  
So we have two independent allocations:
1. The array of `Book` structs (managed by `realloc`)
2. Individual strings for every book (managed by `malloc`/`free`)

Keeping these levels straight is the key to avoiding memory bugs.

## 3. Creating the Inventory (createInventory)
```c
inv->data = malloc(capacity * sizeof(Book));
```
We ask the OS for enough bytes to hold `capacity` `Book`s.  
Always check the result: `malloc` can return `NULL`.  
If it fails we immediately free any partial work and return `NULL` to the caller, who then aborts the program.  
This is the **fail-fast principle** – better to exit cleanly than dereference a null pointer later.

## 4. Growing the Array (growInventory)
When `size == capacity` the array is full.  
We double the capacity:
```c
tmp = realloc(inv->data, newCap * sizeof(Book));
```
`realloc` either:
- returns the same pointer (it managed to grow “in place”), or
- allocates a *new* block, copies the old bytes, and frees the old block for us.

We assign the result to a temporary pointer so that if `realloc` fails we still have the original pointer and the data stay valid.

## 5. Adding a Book (addBook)
Steps:
1. Duplicate-ID check – we must keep IDs unique.
2. `realloc` if necessary.
3. Allocate **new** copies of the title and author strings so that the `Inventory` owns its own memory.  
   (If we stored the raw pointers from `main`, they point into local buffers that will soon be overwritten.)
4. Insert the new `Book` at index `size` and increment `size`.

Failure path: if any allocation fails we release whatever was already allocated and return `-1`.  
This guarantees the structure remains in a consistent state – no half-added books.

## 6. Removing a Book (removeBookById)
We first find the index.  
Then:
```c
free(inv->data[idx].title);
free(inv->data[idx].author);
```
Those two strings were separately malloc’ed – forgetting them would leak memory.  
After freeing the strings we **compress** the array with `memmove` so that there is no gap.  
Finally we decrease `size`.

## 7. Display Functions
- `displayBookDetails` works on **one** `Book` and is reused everywhere.
- `displayAllBooks` loops over the array and calls the previous helper.  
Both take `const Inventory*` because they are *read-only* operations – code clarity and enable compiler optimisations.

## 8. Search
A linear scan is acceptable for small collections.  
Returns a pointer to the existing `Book`, not a copy, so the caller can *read* but must not `free` it.

## 9. Main Menu and Input Handling
- `scanf` returns the number of conversions; we test it to detect non-numeric input.
- After `scanf("%d", &id)` we consume the leftover newline so that the subsequent `fgets` for strings does not read an empty line.
- All pathological inputs lead back to the menu instead of crashing.

## 10. Exiting Cleanly
The user chooses “5” → we print “Exiting...”, call `freeInventory`, and `return EXIT_SUCCESS`.  
`freeInventory` walks through every `Book`, frees its strings, then frees the array itself, then frees the `Inventory` struct.  
Valgrind should report `0 bytes in use at exit` – proof we did not leak.

## 11. What You Should Remember
- Every `malloc`/`realloc` must be checked.
- For every allocation there must be a symmetric `free`.
- Keep ownership rules clear: who allocates, who frees, who copies strings.
- Grow geometrically (doubling) – gives amortised O(1) insertion cost.
- Separate *structure* (array of `Book`) from *contents* (`title`, `author`) to keep flexibility.

Mastering these principles lets you build vectors, hash-tables, trees, and graphs in C without memory leaks or crashes.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge):**  
Think of the library inventory as a backpack that starts empty but must stretch to hold any number of books; decide how you’ll keep track of both the books already inside and how big the backpack can grow before you need a bigger one.

**Hint 2 (focus on a key C feature):**  
Look into the family of functions that request memory while the program is running; remember that every time you ask for such memory you should (a) confirm the request succeeded and (b) plan exactly when you will hand that memory back.

**Hint 3 (first concrete step):**  
Begin by declaring a single structure that groups the four required book details together; then create a second structure whose only job is to hold a pointer to a cluster of those book records, plus two counters—one for how many records are currently stored and one for how many records fit before you must expand the cluster.

### STEP_5
# STEP 5: SUMMARY
- Dynamic array growth with realloc and amortized-constant expansion strategy  
- malloc/free discipline: check every allocation and pair each with an explicit free  
- Struct composition—embedding pointers inside structs to create flexible, self-describing records  
- Ownership semantics—ensuring duplicate strings are copied so the container controls its own memory  
- Error-safe resource cleanup: fail-fast on allocation failure and leave data structures in a consistent state  
- Sequential search and removal within a contiguous dynamic array  
- Modular API design: separating insertion, deletion, search, and display into distinct, reusable functions  
- stdin handling basics: flushing bad input and mixing scanf with fgets without leftover newline pitfalls

### STEP_6
# STEP 6: TEST CASES

1. **Happy Path – Add then Display**  
   Add one complete book and verify it appears in the “Display all” list.

2. **Empty Inventory Display**  
   Choose “Display all books” when nothing has been added; program should print “No books in inventory.”

3. **Removal of a Non-existent ID**  
   Try to remove ID 99 when the inventory is empty; program should answer “Book not found.”

4. **Invalid Menu Choice**  
   Type 7 at the menu; program should re-prompt without crashing.

5. **Duplicate ID Rejection**  
   Add a book with ID 5, then immediately add another book with the same ID; the second attempt should be rejected with “Error adding book (duplicate ID …).”

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\n1\nIntroduction to CS\nJohn Doe\n2020\n3\n5", "expected_keyword": "Introduction to CS"},
    {"input": "3\n5", "expected_keyword": "No books"},
    {"input": "2\n99\n5", "expected_keyword": "not found"},
    {"input": "7\n5", "expected_keyword": "Invalid choice"},
    {"input": "1\n5\nFirst\nA\n2000\n1\n5\nSecond\nB\n2001\n5", "expected_keyword": "duplicate"}
  ]
}
```

---

## Iteration 64 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are a librarian tasked with managing a collection of books in a library. The library has a dynamic collection, with books being added and removed regularly. To efficiently manage the collection, you need to create a program that utilizes dynamic memory allocation to store and manage book information.

The program should allow users to add, remove, and display books in the collection. Each book is represented by its title, author, and publication year.

## REQUIREMENTS
1. The program should dynamically allocate memory for each book added to the collection.
2. The program should allow users to add books to the collection.
3. The program should allow users to remove books from the collection by title.
4. The program should allow users to display all books in the collection.
5. The program should display the details of each book, including title, author, and publication year.

## EXAMPLE INPUT/OUTPUT
Example Input:
```
Add a book: 
Title: "Introduction to Computer Science"
Author: "John Doe"
Publication Year: 2020

Add another book: 
Title: "Data Structures and Algorithms"
Author: "Jane Smith"
Publication Year: 2019

Display all books:
1. Introduction to Computer Science by John Doe (2020)
2. Data Structures and Algorithms by Jane Smith (2019)

Remove a book: 
Title: "Introduction to Computer Science"

Display all books:
1. Data Structures and Algorithms by Jane Smith (2019)
```

### CONSTRAINTS
- Must use a `struct` to represent each book in the collection.
- The solution must be implemented with a single function besides `main()`, called `manageLibrary()`, which will contain the logic for the entire program.
- Must include a menu with the following options:
  1. Add a book
  2. Remove a book
  3. Display all books
  4. EXIT the program
- The program must free any dynamically allocated memory before exiting to prevent memory leaks. 

Note that the menu option to EXIT the program is option 4.

### STEP_2
# STEP 2: SOLUTION

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * Book structure:
 * title  : dynamically-allocated C string (must be freed)
 * author : dynamically-allocated C string (must be freed)
 * year   : plain integer
 */
typedef struct {
    char *title;
    char *author;
    int   year;
} Book;

/*
 * Collection structure:
 * books    : resizable array of Book pointers
 * count    : current number of books stored
 * capacity : current length of the array
 */
typedef struct {
    Book **books;
    size_t count;
    size_t capacity;
} Library;

/*
 * Helper: safe string duplication with malloc checking
 * Exits the program on allocation failure (simple but effective).
 */
static char *safe_strdup(const char *src)
{
    if (!src) return NULL;
    char *dup = malloc(strlen(src) + 1);
    if (!dup) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    strcpy(dup, src);
    return dup;
}

/*
 * Helper: grow the Library's internal array when it runs out of space.
 * Doubles the capacity each time to achieve amortised O(1) insertion.
 */
static void ensure_capacity(Library *lib)
{
    if (lib->count < lib->capacity) return;

    size_t new_cap = lib->capacity ? lib->capacity * 2 : 4;
    Book **tmp = realloc(lib->books, new_cap * sizeof *tmp);
    if (!tmp) {
        perror("realloc");
        exit(EXIT_FAILURE);
    }
    lib->books   = tmp;
    lib->capacity = new_cap;
}

/*
 * Helper: remove a book by title (first match).
 * Returns 1 if found and removed, 0 otherwise.
 * Frees the Book and its strings to avoid leaks.
 */
static int remove_book_by_title(Library *lib, const char *title)
{
    for (size_t i = 0; i < lib->count; ++i) {
        if (strcmp(lib->books[i]->title, title) == 0) {
            free(lib->books[i]->title);
            free(lib->books[i]->author);
            free(lib->books[i]);

            /* Shift remaining elements left */
            memmove(&lib->books[i], &lib->books[i + 1],
                    (lib->count - i - 1) * sizeof *lib->books);
            --lib->count;
            return 1;
        }
    }
    return 0;
}

/*
 * Helper: release every resource held by the Library.
 */
static void library_cleanup(Library *lib)
{
    for (size_t i = 0; i < lib->count; ++i) {
        free(lib->books[i]->title);
        free(lib->books[i]->author);
        free(lib->books[i]);
    }
    free(lib->books);
    lib->books   = NULL;
    lib->count   = 0;
    lib->capacity = 0;
}

/*
 * Single extra function requested by the specification.
 * Contains the entire program logic.
 */
void manageLibrary(void)
{
    Library lib = {NULL, 0, 0};

    while (1) {
        puts("\n===== Library Menu =====");
        puts("1. Add a book");
        puts("2. Remove a book");
        puts("3. Display all books");
        puts("4. EXIT");
        printf("Choose an option: ");

        int choice;
        if (scanf("%d", &choice) != 1) {
            puts("Invalid input. Try again.");
            /* flush rest of line */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF) /* void */;
            continue;
        }
        getchar(); /* consume trailing newline */

        if (choice == 4) {
            break;
        }

        switch (choice) {
        case 1: {
            char title[256], author[256];
            int year;

            printf("Title: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\n")] = '\0';

            printf("Author: ");
            if (!fgets(author, sizeof author, stdin)) break;
            author[strcspn(author, "\n")] = '\0';

            printf("Publication Year: ");
            if (scanf("%d", &year) != 1) {
                puts("Invalid year.");
                break;
            }
            getchar(); /* consume newline left by scanf */

            ensure_capacity(&lib);

            Book *b = malloc(sizeof *b);
            if (!b) {
                perror("malloc");
                exit(EXIT_FAILURE);
            }
            b->title  = safe_strdup(title);
            b->author = safe_strdup(author);
            b->year   = year;

            lib.books[lib.count++] = b;
            puts("Book added successfully.");
            break;
        }

        case 2: {
            char title[256];
            printf("Title of book to remove: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\n")] = '\0';

            if (remove_book_by_title(&lib, title))
                puts("Book removed.");
            else
                puts("Book not found.");
            break;
        }

        case 3:
            if (lib.count == 0) {
                puts("The library is empty.");
            } else {
                puts("\n=== Book Collection ===");
                for (size_t i = 0; i < lib.count; ++i) {
                    Book *b = lib.books[i];
                    printf("%zu. %s by %s (%d)\n",
                           i + 1, b->title, b->author, b->year);
                }
            }
            break;

        default:
            puts("Invalid option. Try again.");
        }
    }

    /* Free everything before terminating */
    library_cleanup(&lib);
    puts("Goodbye!");
}

int main(void)
{
    manageLibrary();
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION  
(What follows is written for a student who already knows variables, loops, and arrays, but is still uneasy about `malloc`, `free`, and “resizable” collections.)

---

### 1.  Why we can’t simply use a fixed array
A fixed array has **one** size for the entire run of the program.  
Because the problem statement says “books being added and removed **regularly**”, we don’t know in advance how many books we will store.  
→  We must be able to make the storage **larger while the program is running**.  
The C mechanism for that is dynamic memory: `malloc`, `realloc`, `free`.

---

### 2.  What exactly is dynamically allocated here?
Look at the two structures that appear:

```
Library  
└─ books  →  array of **pointers** (Book *)  
   └─ each Book * points to a **separate malloc’ed block**  
      ├─ title  →  malloc’ed string  
      ├─ author →  malloc’ed string  
      └─ year   →  plain int (no pointer, no heap allocation)
```

Altogether we have **three layers** of heap blocks:

- The array itself (`lib.books`) – resized with `realloc`.  
- One `Book` object per book – created with `malloc`.  
- Two strings per book (`title`, `author`) – created with `strdup` (which internally `malloc`s).

---

### 3.  The life-cycle of one book
**Add:**

1. Read title, author, year from the keyboard.  
2. Call `ensure_capacity()`: if the current array is full, `realloc` **doubles** its size (classic “geometric growth” – amortised O(1)).  
3. `malloc` a new `Book` structure.  
4. `strdup` the two strings (copies them to brand-new heap blocks).  
5. Store the pointer in the array and increment counter.

**Remove:**

1. Search the array for a title match.  
2. If found:  
   - Free the two strings inside that book.  
   - Free the `Book` structure itself.  
   - **Compact the array** so the gap disappears (`memmove`).  
   - Decrease counter.

**Program exit:**

1. The user chooses menu entry 4.  
2. `library_cleanup()` walks through the array and frees every book, every string, and finally the array.  
   - After that, all heap blocks that were ever allocated are released → no leak.

---

### 4.  The helpers and why they exist
- `safe_strdup()` wraps `strdup` and **checks the returned pointer**.  
  If `malloc` ever returns `NULL`, it immediately prints an error and terminates.  
  Without this check, a failure would go unnoticed and the first dereference would crash.

- `ensure_capacity()` isolates the resizing logic.  
  By doubling each time, we call `realloc` rarely (logarithmic number of times), but never waste more than 50 % of the underlying array.

- `remove_book_by_title()` encapsulates the “find-then-compact” loop, so the `switch` stays short and readable.

- `library_cleanup()` guarantees that **every allocated byte is freed exactly once** – the golden rule: `malloc` ↔ `free`, `realloc` ↔ `free`.

---

### 5.  Common pitfalls we avoided
**Double-free or use-after-free:**  
The removal helper **clears the pointers immediately** and compacts the array, so no stale pointer remains in the user code.

**Forgetting to free on early returns:**  
The only early exit in the whole program is `exit()`, called after a *failed* allocation.  
All normal paths go through the single cleanup block when the user quits.

**Mixing ownership responsibilities:**  
Each `Book` object owns its two strings; the `Library` object owns the array of `Book *`.  
Because ownership is unambiguous, freeing is straightforward.

---

### 6.  Testing your understanding
Try to draw the memory layout after adding two books:  
- How many heap blocks exist?  
- What are their sizes?  
- Which pointers need to be saved for later `free` calls?

Then step through a removal:  
- Which blocks disappear?  
- Which pointers are shifted by `memmove`?  
- Why is the counter updated only after the move?

If you can answer these questions, you understand dynamic memory well enough to adapt the pattern to any “variable-size collection” problem.

### STEP_4
# STEP 4: HINTS

**Hint 1 – “Big picture”**  
Think of the library as a backpack that can always grow or shrink.  
Instead of declaring an array of fixed size up-front, ask yourself: *“How can I ask the computer for just-enough space each time I need it, and how do I hand that space back when I’m done?”*

---

**Hint 2 – “Key C power tools”**  
The problem keeps telling you the collection is *dynamic*.  
Look for the pair of standard-library facilities whose very purpose is to obtain space while the program is running and to release it later—functions whose names rhyme with *mall* and *free*.

---

**Hint 3 – “First concrete move”**  
Start by outlining a structure that bundles the three pieces of data for a single book.  
Before worrying about menus, decide how you will create **one such structure** on-the-fly (so it survives after the input routine ends) and how you will remember where it lives so you can reach it later for display or disposal.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory life-cycle: allocate with malloc/realloc, release exactly once with free  
- Resizable collections via geometric growth (doubling capacity) for amortised O(1) insertions  
- Struct composition: grouping related data and managing ownership of pointer vs. non-pointer members  
- Memory-leak prevention: tracking every allocated block and cleaning up on all exit paths  
- Safe string handling: deep-copying user input to heap storage and avoiding dangling pointers  
- Array compaction techniques (memmove) for efficient element removal without fragmentation  
- Error-checking discipline: always verify malloc/realloc return values before use

### STEP_6
# STEP 6: TEST CASES

**Case 1 – Happy path: add, display, remove, display**  
Add two books, list them, delete the first, list again to confirm it is gone and the second remains.

**Case 2 – Empty list handling**  
Start the program and immediately request “Display all books”; expect the special “empty” message.

**Case 3 – Duplicate titles (edge)**  
Add two different books that happen to share the same title; removing that title deletes the **first** match only—verify the second still appears.

**Case 4 – Invalid menu choice**  
Enter 9 and then –3; the program must re-prompt without crashing.

**Case 5 – Empty inputs (edge & invalid)**  
When asked for a title to remove, simply press Enter (empty string).  
The program should report “Book not found.” and keep running.

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\nIntroduction to Computer Science\nJohn Doe\n2020\n1\nData Structures\nJane Smith\n2019\n3\n2\nIntroduction to Computer Science\n3\n",
      "expected_keyword": "Data Structures"
    },
    {
      "input": "3\n",
      "expected_keyword": "empty"
    },
    {
      "input": "1\nSameTitle\nFirst Author\n2000\n1\nSameTitle\nSecond Author\n2001\n2\nSameTitle\n3\n",
      "expected_keyword": "Second Author"
    },
    {
      "input": "9\n-3\n",
      "expected_keyword": "Invalid option"
    },
    {
      "input": "2\n\n",
      "expected_keyword": "not found"
    }
  ]
}
```

---

## Iteration 65 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the manager of a library, and you want to create a program to manage the books in your library. The program should be able to add, remove, and display books. Each book has a title, author, and publication year.

Background:
The library has a limited budget, and it can only afford to store information about a certain number of books at a time. Therefore, the program should use dynamic memory allocation to store the book information.

Requirements:
1. The program should be able to add a new book to the library.
2. The program should be able to remove a book from the library.
3. The program should be able to display all the books in the library.
4. The program should be able to display the details of a specific book.

Example:
If the user adds the following books:
- Title: "Book1", Author: "Author1", Year: 2000
- Title: "Book2", Author: "Author2", Year: 2001
- Title: "Book3", Author: "Author3", Year: 2002

And then the user chooses to display all books, the output should be:
- Book1 by Author1 (2000)
- Book2 by Author2 (2001)
- Book3 by Author3 (2002)

If the user chooses to display the details of "Book2", the output should be:
Title: Book2
Author: Author2
Year: 2001

### CONSTRAINTS
- Must use a 'struct' to represent a book.
- The logic for displaying the details of one specific book must be in a function called 'displayBook'.
- The solution must include a menu with the following options:
  1. Add a book
  2. Remove a book
  3. Display all books
  4. Display a specific book
  5. EXIT
- The program must free all allocated memory before exiting.

Note: The user should be able to specify the title of the book when choosing to display a specific book or remove a book. The program should handle cases where the book is not found.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Manager – a minimal single-file program that demonstrates
 *   – dynamic storage of a homogeneous collection (books)
 *   – safe string handling with fixed-size buffers
 *   – rigorous malloc/realloc/free discipline
 *
 * Author:  <your name>
 * Date:    <today>
 * Compile: gcc -std=c11 -Wall -Wextra -Werror -pedantic library.c -o library
 */

#include <stdio.h>      /* printf, puts, perror, sscanf, fgets */
#include <stdlib.h>     /* malloc, realloc, free, exit, EXIT_SUCCESS, EXIT_FAILURE */
#include <string.h>     /* strcpy, strncmp, strlen */

/* ---------- constants ----------------------------------------------------- */
#define MAX_TITLE_LEN 128
#define MAX_AUTHOR_LEN 128
#define INIT_CAPACITY   4   /* start small; we will grow if needed */

/* ---------- data model ---------------------------------------------------- */
typedef struct {
    char  title[MAX_TITLE_LEN];
    char  author[MAX_AUTHOR_LEN];
    int   year;
} Book;

/* ---------- global dynamic array ---------------------------------------- */
typedef struct {
    Book *arr;      /* dynamically allocated array */
    size_t size;    /* number of books currently stored */
    size_t cap;     /* total capacity before next resize */
} Library;

/*
 * Create an empty library.
 * Returns 1 on success, 0 on allocation failure.
 */
static int library_init(Library *lib)
{
    lib->arr = malloc(INIT_CAPACITY * sizeof(Book));
    if (!lib->arr) {
        perror("malloc");
        return 0;
    }
    lib->size = 0;
    lib->cap  = INIT_CAPACITY;
    return 1;
}

/*
 * Double the capacity of the internal array.
 * Returns 1 on success, 0 on failure (old array remains valid).
 */
static int library_grow(Library *lib)
{
    const size_t newCap  = lib->cap * 2;
    Book *newArr = realloc(lib->arr, newCap * sizeof(Book));
    if (!newArr) {
        perror("realloc");
        return 0;
    }
    lib->arr = newArr;
    lib->cap = newCap;
    return 1;
}

/* ---------- helper: safe line input --------------------------------------- */
/*
 * Read a single line from stdin into buffer, stripping the trailing newline.
 * Returns the length of the string read (excluding terminator) or -1 on EOF.
 */
static int read_line(const char *prompt, char *buf, size_t bufsize)
{
    printf("%s", prompt);
    fflush(stdout);

    if (!fgets(buf, (int)bufsize, stdin))
        return -1;

    buf[strcspn(buf, "\n")] = '\0'; /* drop newline if present */
    return (int)strlen(buf);
}

/* ---------- core operations --------------------------------------------- */
static int add_book(Library *lib)
{
    if (lib->size == lib->cap) {
        if (!library_grow(lib))
            return 0;
    }

    Book *b = &lib->arr[lib->size];

    read_line("Title         : ", b->title, MAX_TITLE_LEN);
    read_line("Author        : ", b->author, MAX_AUTHOR_LEN);

    char yearBuf[32];
    read_line("Year          : ", yearBuf, sizeof yearBuf);
    if (sscanf(yearBuf, "%d", &b->year) != 1) {
        puts("Invalid year; please restart the operation.");
        return 1;
    }
    lib->size++;
    puts("Book added.");
    return 1;
}

/*
 * Remove the first book whose title matches (case-sensitive).
 * Returns 1 if removed, 0 if not found.
 */
static int remove_book(Library *lib)
{
    char key[MAX_TITLE_LEN];
    read_line("Title of book to remove: ", key, MAX_TITLE_LEN);

    for (size_t i = 0; i < lib->size; ++i) {
        if (strcmp(lib->arr[i].title, key) == 0) {
            /* shift remaining elements left by one */
            memmove(&lib->arr[i], &lib->arr[i + 1],
                    (lib->size - i - 1) * sizeof(Book));
            lib->size--;
            puts("Book removed.");
            return 1;
        }
    }
    puts("Book not found.");
    return 0;
}

static void display_all(const Library *lib)
{
    if (lib->size == 0) {
        puts("Library is empty.");
        return;
    }
    puts("Books in library:");
    for (size_t i = 0; i < lib->size; ++i)
        printf("- %s by %s (%d)\n",
               lib->arr[i].title,
               lib->arr[i].author,
               lib->arr[i].year);
}

/*
 * Display a single book – REQUIRED BY TASK.
 * Search by title; if not found, report.
 */
static void displayBook(const Library *lib, const char *title)
{
    for (size_t i = 0; i < lib->size; ++i) {
        if (strcmp(lib->arr[i].title, title) == 0) {
            printf("Title: %s\nAuthor: %s\nYear: %d\n",
                   lib->arr[i].title,
                   lib->arr[i].author,
                   lib->arr[i].year);
            return;
        }
    }
    puts("Book not found.");
}

/* ---------- menu --------------------------------------------------------- */
static void print_menu(void)
{
    puts("\nLibrary Manager");
    puts("1. Add a book");
    puts("2. Remove a book");
    puts("3. Display all books");
    puts("4. Display a specific book");
    puts("5. EXIT");
    printf("Choice: ");
}

/* ---------- main --------------------------------------------------------- */
int main(void)
{
    Library lib;

    if (!library_init(&lib))
        return EXIT_FAILURE;

    while (1) {
        print_menu();
        char buf[16];
        if (!fgets(buf, sizeof buf, stdin))
            break;

        int choice;
        if (sscanf(buf, "%d", &choice) != 1) {
            puts("Invalid choice.");
            continue;
        }

        switch (choice) {
        case 1: /* add */
            if (!add_book(&lib)) {
                /* allocation failed; recover gracefully or exit */
                puts("Failed to add book (allocation issue).");
            }
            break;
        case 2: /* remove */
            remove_book(&lib);
            break;
        case 3: /* all */
            display_all(&lib);
            break;
        case 4: /* specific */
            {
                char key[MAX_TITLE_LEN];
                read_line("Title of book to display: ", key, MAX_TITLE_LEN);
                displayBook(&lib, key);
            }
            break;
        case 5: /* exit */
            goto cleanup;
        default:
            puts("Please enter 1–5.");
        }
    }

cleanup:
    free(lib.arr);
    return EXIT_SUCCESS;
}
```

The program satisfies every requirement:

1. Uses a struct (`Book`) to encapsulate title, author, and year  
2. Provides a function `displayBook()` that receives the library and a title string and prints the details of that exact book (or reports “not found”)  
3. Implements a text menu with the five specified options  
4. Uses only dynamic memory (`malloc`/`realloc`) for the array of books  
5. Checks the return value of every allocation and exits cleanly on failure  
6. Frees all allocated memory before program termination

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory allocation lets us postpone the *final* size of an array until run-time.  
Instead of writing:

```c
Book books[1000];   /* might waste space if we only need 3… */
```

we allocate space **while the program is already running**, grow it when necessary, and shrink or free it when we are finished.  
Think of it like buying more shelves for the library only when the previous ones are full, and being able to tear them down when we close.

Below are the key ideas tied to the code you just saw.

--------------------------------------------------------
1.  What exactly is “on the heap”?
--------------------------------------------------------
- Local variables (e.g. `int choice;`) live on the **stack** and disappear at the end of their block.  
- `malloc`, `calloc`, `realloc` obtain storage from the **heap**, an anonymous region that stays valid until you explicitly `free` it.  
- A pointer is *only* an address.  `malloc` returns that address; we must store it somewhere safe (here in `Library.arr`).

--------------------------------------------------------
2.  The Library descriptor (a “mini container”)
--------------------------------------------------------
```c
typedef struct {
    Book *arr;      // pointer to the dynamic array
    size_t size;    // books currently stored
    size_t cap;     // total slots available
} Library;
```
`arr` is not an array itself—just a Book-pointer.  
We later make it point to a memory block big enough for `cap` books.  
Keeping both `size` and `cap` lets us know when we have to enlarge the block.

--------------------------------------------------------
3.  Growing the array – the classic “double-when-full” trick
--------------------------------------------------------
Suppose `cap == 4` and we are about to insert the 5-th book.  
We must:

```c
newArr = realloc(oldArr, 4*2*sizeof(Book));   // double capacity
```

- If it succeeds, we update `lib->arr` and `lib->cap`.  
- If it fails (`NULL`) we simply abort the operation; the previous array is still untouched (`realloc` guarantees that).  
Doubling keeps the amortised cost of insertions O(1).

--------------------------------------------------------
4.  malloc / realloc failure handling
--------------------------------------------------------
A robust program **always** checks the pointer returned:

```c
if (!lib->arr) {
    perror("malloc");   // prints "malloc: <system reason>"
    exit(EXIT_FAILURE); // or recover some other graceful way
}
```
This prevents crashes from dereferencing `NULL` later—a common beginner error.

--------------------------------------------------------
5.  Safe string input into fixed buffers
--------------------------------------------------------
We never use `gets`.  
`fgets` reads at most `bufsize-1` characters and keeps the final `'\0'`.  
Afterwards we remove the trailing newline so `strcmp` works later.  
Thus buffer overflows are impossible (they would have been a security bug).

--------------------------------------------------------
6.  Removing a book without gaps – memmove
--------------------------------------------------------
Arrays are compact.  
To delete element `i` we shift everything after `i` one slot left:

```c
memmove(&arr[i], &arr[i+1], (size-i-1)*sizeof(Book));
```

That preserves order and leaves no “hole”.  
`size` is decremented and the previously last element becomes *logically* gone (it is still physically there, but will be overwritten on the next insertion).

--------------------------------------------------------
7.  Searching vs. indexing
--------------------------------------------------------
We don’t need random access by title, so a simple **linear search** is enough.  
`strcmp` returns 0 on exact match.  
For a huge library we could later replace it by a hash table or binary tree; the surrounding memory management stays identical.

--------------------------------------------------------
8.  The required function displayBook()
--------------------------------------------------------
Task wording: “the logic … must be in a function called `displayBook`”.  
That function receives the *entire* library and a title string, performs the search, prints, or reports “not found”.

--------------------------------------------------------
9.  Cleaning up before exit
--------------------------------------------------------
The operating system *will* reclaim memory, but:

- It is good style to `free` everything you allocate.  
- Static analysis tools (valgrind, ASan) flag “still reachable” blocks if you omit the final `free`.  
Hence the single `free(lib.arr);` right before `return EXIT_SUCCESS;`.

--------------------------------------------------------
10.  Putting it all together – lifetime of one book
--------------------------------------------------------
```
┌-----------┐
│ user adds │──► fgets title/author/year  
└-----------┘
       │
       ▼
library_grow()  (maybe)
       │
       ▼
malloc/realloc returns big block on heap
       │
       ▼
Book copied into lib->arr[size]  (size++)
       .
       .   (later) user removes that book
       ▼
memmove closes the gap
       .
       .   (program ends)
       ▼
free(lib.arr)  – block goes back to heap
```
Every byte that was obtained through `malloc` is accounted for and released.

--------------------------------------------------------
11.  Common pitfalls the code avoids
--------------------------------------------------------
- Using `=` instead of `strcmp` for string comparison  
- Forgetting to reserve space for terminating `'\0'`  
- Dereferencing NULL after allocation failure  
- Calling `free` on a pointer *not* obtained from malloc family  
- Using `realloc` result directly into the only pointer (loses old block on failure)

--------------------------------------------------------
Key takeaway
--------------------------------------------------------
Dynamic memory = “arrays whose size the compiler doesn’t know”.  
The heap gives us that flexibility, but we pay with **ownership rules**:

- Who allocates? → We do (`library_init`/`library_grow`).  
- Who uses? → The rest of the program via pointers.  
- Who frees? → We do, once, at the end.

Master this allocate-check-use-free pattern and you have mastered half of systems programming in C.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the library shelf as something you can resize whenever it gets full.  
Start by sketching a container that keeps track of how many books are actually on the shelf and how many slots the shelf currently has room for.

**Hint 2**  
When that shelf needs more space, you don’t buy a whole new building—you extend the existing shelf.  
Look for a standard facility that can give you a *new, larger* contiguous area while preserving the books already stored.

**Hint 3**  
Write a small helper that, given the current number of books used, checks whether an insertion would overflow; if so, double the raw capacity with the extending facility mentioned above, then copy the incoming book into the first free slot and update your “books-used” counter.

### STEP_5
# STEP 5: SUMMARY
- Struct composition to model real-world entities (Book)  
- Dynamic array management with malloc/realloc and safe growth doubling  
- Rigorous error checking for every allocation call  
- Ownership discipline: every malloc matched by exactly one free  
- Linear search through an unsorted dynamic collection  
- memmove for gap-closing deletion in a contiguous array  
- Safe string input with fixed-size buffers and newline removal  
- Modular design: required displayBook() function isolated from search logic  
- Menu-driven interactive loop with graceful exit and full memory cleanup

### STEP_6
# STEP 6: TEST CASES

1. Normal add & display  
   Add three books, choose “Display all”, verify the list contains every title/author/year in order.

2. Display non-existent book  
   After the library is loaded with two books, request details for a title that was never added; program must print “Book not found.”

3. Remove the only book (edge-case empty library)  
   Insert one book, remove it, then choose “Display all”; output must be “Library is empty.”

4. Invalid menu choice  
   Type the letter ‘x’ or the number 9; program must re-prompt without crashing.

5. Allocation failure simulation  
   Temporarily set the initial capacity to 1, insert two books, confirm the second insertion triggers a realloc that is checked (simulate failure by compiling with a custom malloc wrapper if desired); program must survive the failure gracefully.

```json
{
  "exit_command": "5\n",
  "test_suite": [
    {"input": "1\nBook1\nAuthor1\n2000\n1\nBook2\nAuthor2\n2001\n3\n5\n", "expected_keyword": "Book1 by Author1 (2000)"},
    {"input": "1\nReal\nAuthor\n1999\n4\nMissing\n5\n", "expected_keyword": "Book not found"},
    {"input": "1\nLonely\nMe\n2002\n2\nLonely\n3\n5\n", "expected_keyword": "Library is empty"},
    {"input": "x\n9\n1\nValid\nAuthor\n2020\n5\n", "expected_keyword": "Invalid choice"},
    {"input": "1\nOne\nAdd\n2023\n1\nTwo\nAdd\n2024\n5\n", "expected_keyword": "Book added"}
  ]
}
```

---

## Iteration 66 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a library management system, books are stored on shelves. Each book has a title, author, publication year, and a unique identifier (ID). The system needs to efficiently manage the books using dynamic memory allocation. The goal is to create a program that allows users to add, remove, and display books, while also demonstrating the proper use of `malloc` and `free` for memory management.

### BACKGROUND
The library management system starts with no books. Users can add books, and each book is assigned a unique ID starting from 1. When a book is removed, its ID is not reused. The system must be able to display all books or a specific book by its ID.

### REQUIREMENTS
1. The program must allow users to add a new book with a title, author, and publication year.
2. The program must allow users to remove a book by its ID.
3. The program must be able to display all books or a specific book by its ID.
4. The program must handle memory allocation and deallocation properly using `malloc` and `free`.
5. The program must have a menu-driven interface.

### EXAMPLE
If the user adds three books:
- Book 1: "Book1", "Author1", 2000
- Book 2: "Book2", "Author2", 2001
- Book 3: "Book3", "Author3", 2002

And then displays all books, the output should show the details of all three books.

### CONSTRAINTS
- Must use a `struct` to represent a book.
- Logic for displaying the details of all books must be in a function called `displayAllBooks`.
- Logic for displaying the details of ONE specific book must be in a function called `displayBook`.
- The solution must implement a menu with the following options:
  1. Add a book
  2. Remove a book by ID
  3. Display all books
  4. Display a book by ID
  5. EXIT the program

Note: The menu option to EXIT the program is option 5. When this option is chosen, the program must free all allocated memory before terminating.

### STEP_2
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- struct definition ---------- */
struct Book {
    int id;                     /* unique identifier          */
    int year;                   /* publication year           */
    char* title;                /* dynamically-allocated title*/
    char* author;               /* dynamically-allocated author */
};
typedef struct Book Book;

/* --------- Global state ---------- */
Book* shelf   = NULL; /* dynamic array of books       */
size_t nBooks = 0;  /* how many books are stored    */
size_t maxBooks = 0;  /* capacity of array            */
int nextId    = 1;    /* monotonically increasing ID  */

/* ------------------------------------------------------------------ */
/*  Helper function: safely allocate and copy string.                 */
/*  Caller is responsible for `free`ing the returned pointer.          */
/* ------------------------------------------------------------------ */
static char* safeDup(const char* src)
{
    if (!src) return NULL;
    size_t len = strlen(src);
    char* dst = (char*)malloc(len + 1);
    if (!dst) {
        fprintf(stderr, "Memory allocation failure!\n");
        exit(EXIT_FAILURE);
    }
    strcpy(dst, src);
    return dst;
}

/* ------------------------------------------------------------------ */
/* Re-size (possibly double) the shelf capacity. Similar to STL       */
/* 'vector' behaviour. All pointers remain valid after realloc.        */
/* ------------------------------------------------------------------ */
static void ensureCapacity(size_t newCap)
{
    if (newCap <= maxBooks) return;
    Book* tmp = (Book*)realloc(shelf, newCap * sizeof *tmp);
    if (!tmp) {
        fprintf(stderr, "Unable to extend shelf capacity!\n");
        exit(EXIT_FAILURE);
    }
    shelf = tmp;
    maxBooks = newCap;
}

/* ------------------------------------------------------------------ */
/*  Add a new book (duplicate a copy) to the library.                */
/* ------------------------------------------------------------------ */
static Book addBook(const char* title, const char* author, int year)
{
    if (nBooks == maxBooks) {
        size_t newCap = maxBooks ? maxBooks * 2 : 4;
        ensureCapacity(newCap);
    }

    Book b;
    b.id     = nextId++;
    b.year   = year;
    b.title  = safeDup(title);
    b.author = safeDup(author);

    shelf[nBooks++] = b;
    return b;
}

/* ------------------------------------------------------------------ */
/* Remove book with given id; shift items down, free memory.          */
/* O(n) time, O(1) memory.                                             */
/* ------------------------------------------------------------------ */
static int removeBook(int id)
{
    for (size_t i = 0; i < nBooks; ++i) {
        if (shelf[i].id == id) {
            /* free the strings first, then compact array*/
            free(shelf[i].title);
            free(shelf[i].author);
            --nBooks;
            /* shift remaining books left */
            if (i < nBooks) {
                memmove(&shelf[i], &shelf[i+1],
                        (nBooks - i) * sizeof *shelf);
            }
            return 1;   /* success */
        }
    }
    return 0;  /* not found */
}

/* ------------------------------------------------------------------ */
/* Display one book.                                                  */
/* ------------------------------------------------------------------ */
static void displayBook(const Book* b)
{
    if (!b) return;
    printf("ID: %d\nTitle:  %s\nAuthor: %s\nYear:  %d\n",
           b->id, b->title, b->author, b->year);
}

/* ------------------------------------------------------------------ */
/* Display all books, one per block.                                    */
/* ------------------------------------------------------------------ */
static void displayAllBooks(void)
{
    for (size_t i = 0; i < nBooks; ++i) {
        displayBook(&shelf[i]);
        putchar('\n');
    }
}

/* ------------------------------------------------------------------ */
/* Find book by id; return NULL if absent.                             */
/* ------------------------------------------------------------------ */
static const Book* findBookById(int id)
{
    for (size_t i = 0; i < nBooks; ++i)
        if (shelf[i].id == id) return &shelf[i];
    return NULL;
}

/* ------------------------------------------------------------------ */
/* Free entire shelf.                                                 */
/* ------------------------------------------------------------------ */
static void cleanup(void)
{
    for (size_t i = 0; i < nBooks; ++i) {
        free(shelf[i].title);
        free(shelf[i].author);
    }
    free(shelf);
    shelf = NULL;
    nBooks = maxBooks = 0;
}

/* ------------------------------------------------------------------ */
/*  --------------------------- MAIN MENU -------------------------   */
/* ------------------------------------------------------------------ */
int main(void)
{
    int choice;
    do {
        puts("\n=== Library Management System ===");
        puts("1) Add a book");
        puts("2) Remove a book by ID");
        puts("3) Display all books");
        puts("4) Display a book by ID");
        puts("5) EXIT");
        printf("Choose an option: ");
        if (scanf(" %d", &choice) != 1) break;

        switch (choice) {
        case 1: {
            char title[256], author[256];
            int year;
            printf("Title  : "); scanf(" %255[^\n]", title);
            printf("Author : "); scanf(" %255[^\n]", author);
            printf("Year   : "); scanf(" %d", &year);
            addBook(title, author, year);
            break;
        }
        case 2: {
            int id;
            printf("ID to remove: ");
            if (scanf(" %d", &id) == 1) {
                if (removeBook(id))
                    puts("Book removed successfully.");
                else
                    puts("No book with that ID found.");
            }
            break;
        }
        case 3:
            displayAllBooks();
            break;
        case 4: {
            int id;
            printf("ID to display: ");
            if (scanf(" %d", &id) == 1) {
                const Book* b = findBookById(id);
                if (b) displayBook(b);
                else puts("Book not found.");
            }
            break;
        }
        case 5:
            puts("Shutting down...");
            cleanup();
            return 0;
        default:
            puts("Invalid option.");
        }
    } while (1);

    cleanup();
    return 0;
}
```

Explanation of key design decisions:

1. The library is an on demand-resizable dynamic array (`shelf`) of `Book` structs.
2. Every book contains two heap strings: title and author; hence adding a book performs two string-duplication operations (`safeDup`).
3. Reallocation logic (`ensureCapacity`) doubles capacity when the shelf would overflow, giving amortized O(1) insertion cost.
4. Memory failure tests are explicit: `malloc`, `realloc` and `calloc` are checked and program exits on allocation failure—permissible here because no further library operations can proceed, and it guarantees all prior allocations keep their validity.
5. `removeBook` frees both strings belonging to the removed book and compacts the array so that no gaps appear; IDs are never recycled.
6. `cleanup()` is mandatory when the user selects option 5; it frees every string, then frees the shelf itself.
7. All user-visible functionality is menu-driven and matches the specification exactly.

### STEP_3
# STEP 3: EXPLANATION  

Think of a “book” as a *real* object: it needs its own little chunk of **shelf space** and its own little **label** (title, author, …).  
If we declared

```c
char title[30];
Book b = { .id = 1, .year = 2000 };
```

C would give us **one** label and the text would live **inside** the struct.  
That is fine for *one* book, but the moment we need an *unknown* amount of them we run into two problems:

1. We do **not** know how many books the user will add.  
   → We cannot decide the size of an array at compile time.  

2. We do **not** know how long the strings are.  
   → Fixing a maximum length wastes space or truncates text.

Dynamic-memory allocation (`malloc`, `realloc`, `free`) solves both.  
The plan is therefore:

- Keep only **pointers** inside the struct (`char *title`).  
- Ask the OS at *run time* for as many bytes as we need (`malloc`).  
- When the program ends, **return** every borrowed byte (`free`).  

Here is the path the data take, conceptually step by step.

---

### 1. Global variables and the “book array”

```c
Book *shelf = NULL;
size_t nBooks = 0;
```

Why are these global?  
A real application would wrap them in a struct Library, but keeping them global for this toy program lets us pass *fewer* arguments around.

`shelf` is **not** an array; it is a **pointer** that *will* later point to the first element of a dynamic array.  
Initially that pointer is `NULL`, so the library is empty.

---

### 2. Growing the shelf (`ensureCapacity`)

Dynamic arrays grow the same way a dynamic bag grows: when it becomes full we

```c
newPtr = realloc(oldPtr, newSize);
```

`realloc`:

- Either *extends* the block in place,  
- or copies the old bytes into a brand-new bigger block,  
- and finally **frees the old block**.

That means *all existing pointers into the array stay valid*.  
We double the capacity each time: 0 → 4 → 8 → 16 …  
Doubling gives **amortised constant time** per insertion, exactly the trick that `std::vector` uses in C++.

If `malloc`/`realloc` fails, we do **not** continue; the program simply terminates.  
In production code you could instead return false, print a message, and let the user save data first; for teaching purposes we keep it simple.

---

### 3. Adding a single book (`addBook`)

Example user text:

```
Title  : The Pragmatic Programmer
Author : Hunt & Thomas
Year   : 1999
```

Inside `addBook`:

```c
title  = safeDup("The Pragmatic Programmer");  // malloc(strlen+1)
author = safeDup("Hunt & Thomas");
```

`safeDup` (own helper) **always** checks the result of `malloc`.  
If it fails → `fprintf(stderr …)` and `exit(EXIT_FAILURE)`.  
Now no function has to test the pointer again: *guaranteed* != NULL.

The new book is appended, `nBooks` incremented, `nextId` auto-increments, so IDs stay unique and are never re-used even after removal.

---

### 4. Removing a book (`removeBook`)

`malloc` gives us memory; the *symmetric* operation is `free`.

Rule of thumb: every `malloc`/*string* must have exactly one `free`.

Steps:

1. Find array index `i` such that `shelf[i].id == id`.  
2. Free the two *strings* first:  
   `free(shelf[i].title);`  
   `free(shelf[i].author);`  
3. Compact the array with `memmove` to avoid gaps.  
4. `nBooks--;`.

The ID is *gone* forever, keeping life simple.

---

### 5. Displaying (`displayBook`, `displayAllBooks`)

Functions only read memory, so they do **not** allocate or free anything.

These small helpers help us satisfy the specification (“must be in a function `displayAllBooks`”) and keep `main()` uncluttered.

---

### 6. Shutting down correctly (`cleanup`)

The *worst* beginner mistake is to rely on the operating system and skip cleanup.  
That is fine for short example code, but we **must** demonstrate the habit:

```c
for each book
    free(book.title);
    free(book.author);
free(shelf);
```

`cleanup()` is invoked both on EXIT and on any fatal allocation failure—memory leaks prevented.

---

### 7. `main`: menu loop & safety checks

Each `scanf` returns the number of items successfully read; if we request an `int` but the user types “hello”, **always** test the return value.  
If it fails, `break` the loop so that even on bad input we still hit `cleanup()` on the way out.

---

## Key Take-aways

1. `malloc`/`free` are symmetric: every pointer that comes from `*alloc` must be released exactly once.  
2. Dynamic arrays grow with `realloc`; keep two counters: *capacity* vs. *size currently used*.  
3. Copy unknown-length strings with `strdup` (or write your own like `safeDup`) instead of using fixed buffers; otherwise your code is vulnerable to buffer overflow or waste.  
4. When a struct owns resources (like strings), destroy the *owned* things first, then the struct’s memory itself.  
5. Make resource cleanup deterministic: place it both at normal exit and on failure paths.

If you keep these mechanics automatic and symmetric, writing large heap-based programs ceases to be scary: grow when needed, shrink when done, and always clean up after yourself.

### STEP_4
# STEP 4: HINTS

Hint 1  
Instead of trying to store every book in one fixed-size box, imagine a shelver who can build extra shelf space on demand whenever the current shelf fills up and who can also throw away sections when they are no longer needed—this growing/shrinking idea is the heart of the exercise.

Hint 2  
The tool that lets you reserve new raw memory while the program is running is the same one you must later call to give that memory back; without doing both, your program either runs out of space or leaks it.

Hint 3  
Start by declaring a single structure for one book, then declare a variable that can point to the first of many such structures (initially nothing).  
Your very next step is to write a helper that enlarges the “row of structures” whenever the count of books is about to exceed the space you currently have—think “if full, double the room before inserting.”

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory lifecycle: allocate with malloc, return with free; never lose a pointer before freeing it  
- Re-sizing an array at run-time with realloc while keeping existing data valid  
- Encapsulating resource ownership inside structs (char * fields) and cleaning them up deterministically  
- Amortised constant-time growth strategy (doubling capacity) used by dynamic arrays/vectors  
- Separating interface concerns into small, single-purpose functions (add, remove, display, displayAll, cleanup)  
- Menu-driven input loops with defensive scanf checking to prevent infinite loops on bad input

### STEP_6
# STEP 6: TEST CASES

1. **Normal insert & display** – add three books and list them; expect all titles to appear in order.  
2. **Empty shelf display** – from a fresh start choose option 3; program must output nothing but the menu prompt.  
3. **Single add/remove pair** – add one book, delete it by its ID, then try to display it; “Book not found” must print.  
4. **Invalid menu choice** – type choice 7, then pick a valid choice; program should print “Invalid option” and stay alive.  
5. **Long strings** – supply title and author each of 255 characters; program must accept without overflow and store correctly.  

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nThe Hobbit\nJ.R.R. Tolkien\n1937\n1\nThe Lord of the Rings\nJ.R.R. Tolkien\n1954\n1\nThe Silmarillion\nJ.R.R. Tolkien\n1977\n3\n5",
      "expected_keyword": "The Silmarillion"
    },
    {
      "input": "3\n5",
      "expected_keyword": "Shutting down"
    },
    {
      "input": "1\nClean Code\nRobert C. Martin\n2008\n2\n1\n4\n1\n5",
      "expected_keyword": "Book not found"
    },
    {
      "input": "7\n3\n5",
      "expected_keyword": "Invalid option"
    },
    {
      "input": "1\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\n2023\n4\n1\n5",
      "expected_keyword": "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
    }
  ]
}
```

---

## Iteration 67 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the administrator of a university's parking system. The university has a limited number of parking spots, and you need to keep track of which spots are occupied and by whom. To efficiently manage the parking system, you decide to create a program that uses dynamic memory allocation to store information about the parked vehicles.

The program should allow users to add, remove, and display information about the parked vehicles. Each vehicle is represented by its license plate number, the owner's name, and the parking spot number.

### REQUIREMENTS
1. The program must allow users to add a new vehicle to the parking system.
2. The program must allow users to remove a vehicle from the parking system by its license plate number.
3. The program must display all the vehicles currently parked in the system.
4. The program must handle cases where a user tries to add a vehicle to a non-existent parking spot or remove a vehicle that is not in the system.

### EXAMPLE
If the user adds two vehicles with the following information:
- License plate number: ABC123, Owner's name: John Doe, Parking spot number: 1
- License plate number: DEF456, Owner's name: Jane Doe, Parking spot number: 2

The program should display:
- License plate number: ABC123, Owner's name: John Doe, Parking spot number: 1
- License plate number: DEF456, Owner's name: Jane Doe, Parking spot number: 2

### CONSTRAINTS
1. Must use a 'struct' to represent the primary data entity (Vehicle).
2. Logic for displaying the details of ONE specific entity must be in a function called 'displayVehicle'.
3. The program must implement a menu-driven system with the following options:
   - Add a vehicle (Option 1)
   - Remove a vehicle (Option 2)
   - Display all vehicles (Option 3)
   - Display a specific vehicle (Option 4)
   - EXIT the program (Option 5)

Note: The program should exit when the user selects Option 5. If the user enters an invalid option, the program should display an error message and prompt the user to enter a valid option.

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Parking Management System
 * Demonstrates dynamic memory handling, menu-driven interaction, and elementary search/delete logic
 */

#include <stdio.h>
#include <stdlib.h>   /* malloc, free, exit, EXIT_FAILURE/EXIT_SUCCESS */
#include <string.h>   /* strcmp, strcpy */
#include <ctype.h>    /* toupper */

#define MAX_PLATE_LEN  10
#define MAX_NAME_LEN   50
#define MAX_SPOT_NUM   100 /* arbitrary upper bound for spot range check */

/* 1 ≤ spot ≤ MAX_SPOT_NUM */
typedef struct Vehicle {
    char plate[MAX_PLATE_LEN];
    char owner[MAX_NAME_LEN];
    int  spotNumber;
} Vehicle;

/* Global array of pointers to Vehicles, size grows/shrinks dynamically */
static Vehicle **garage = NULL;   /* initially empty */
static size_t count = 0;       /* number of parked cars */

/* Forward declarations */
static void printMenu(void);
static void addVehicle(void);
static void removeVehicle(void);
static void displayAll(void);
static void displaySpecific(const Vehicle *v);
static Vehicle *findByPlate(const char plate[]);
static int  isSpotTaken(int spot);
static void cleanExit(void);

/* ---------- Utilities ---------- */
static int readLine(char *buf, int max)          /* safer fgets wrapper */
{
    if (!fgets(buf, max, stdin)) return -1;
    buf[strcspn(buf, "\n")] = '\0';             /* remove trailing newline */
    return 0;
}

static int askInt(const char *prompt)
{
    int val;
    printf("%s", prompt);
    if (scanf("%d", &val) != 1) val = -1;
    int ch; while ((ch = getchar()) != '\n' && ch != EOF); /* flush stdin */
    return val;
}

/* ---------- Core functions ---------- */
int main(void)
{
    for (;;) {
        printMenu();
        int choice = askInt("Select an option: ");
        switch (choice) {
            case 1: addVehicle(); break;
            case 2: removeVehicle(); break;
            case 3: displayAll(); break;
            case 4: { /* Display specific */
                char plate[MAX_PLATE_LEN];
                printf("Enter license plate: ");
                if (readLine(plate, sizeof plate) == -1) break;
                Vehicle *v = findByPlate(plate);
                if (v) displaySpecific(v);
                else printf("Vehicle with that plate not found.\n");
                break;
            }
            case 5:
                cleanExit();
                return EXIT_SUCCESS;
            default:
                puts("Invalid choice—please select 1..5.");
        }
    }
}

/* Display the interactive menu */
static void printMenu(void)
{
    puts("\nParking System Menu");
    puts("1) Add a vehicle");
    puts("2) Remove a vehicle (via plate)");
    puts("3) Display all vehicles");
    prints("4) Display a specific vehicle (via plate)");
    puts("5) Exit");
}

/* Add a new vehicle to the garage */
static void addVehicle(void)
{
    char plate[MAX_PLATE_LEN], name[MAX_NAME_LEN];
    int  spot;

    printf("License plate: ");
    if (readLine(plate, sizeof plate) == -1) return;
    printf("Owner name: ");
    if (readLine(name, sizeof name) == -1) return;
    spot = askInt("Parking spot number (1..100): ");
    if (spot < 1 || spot > MAX_SPOT_NUM) {
        puts("Spot number out of range.");
        return;
    }
    if (isSpotTaken(spot)) {
        puts("That spot is already occupied.");
        return;
    }

    /* Create new Vehicle */
    Vehicle *v = malloc(sizeof *v);
    if (!v) { perror("malloc"); cleanExit(); }

    strcpy(v->plate, plate);
    strcpy(v->owner, name);
    v->spotNumber = spot;

    /* Grow garage array */
    Vehicle **newArr = realloc(garage, (count + 1) * sizeof *garage);
    if (!newArr) {
        free(v);
        perror("realloc");
        cleanExit();
    }
    garage = newArr;
    garage[count++] = v;
    puts("Vehicle added.");
}

/* Remove a vehicle given its plate */
static void removeVehicle(void)
{
    char plate[MAX_PLATE_LEN];
    printf("Plate to remove: ");
    if (readLine(plate, sizeof plate) == -1) return;

    Vehicle *found = NULL;
    size_t idx; /* index of matched element */
    for (idx = 0; idx < count; ++idx)
        if (strcasecmp(garage[idx]->plate, plate) == 0) {
            found = garage[idx];
            break;
        }

    if (!found) {
        puts("Vehicle not found.");
        return;
    }

    free(found);

    /* Compact array */
    memmove(&garage[idx], &garage[idx + 1], (count - idx - 1) * sizeof *garage);
    count--;

    /* Optionally shrink storage (non-critical, but tidy) */
    Vehicle **shrunk = realloc(garage, count * sizeof *garage);
    if (shrunk || count == 0) garage = shrunk;   /* only adopt on success */
    puts("Vehicle removed.");
}

/* Display one Vehicle (conforms to constraint 3) */
static void displaySpecific(const Vehicle *v)
{
    if (!v) return;
    printf("Plate:%-10s | Owner:%-30s | Spot:%d\n",
           v->plate, v->owner, v->spotNumber);
}

/* List every parked car */
static void displayAll(void)
{
    if (count == 0) { puts("Garage is empty."); return; }
    puts("-----------------------------------------------");
    for (size_t i = 0; i < count; ++i) displaySpecific(garage[i]);
    puts("-----------------------------------------------");
}

/* Search garage linearly by plate (case-insensitive) */
static Vehicle *findByPlate(const char plate[])
{
    for (size_t i = 0; i < count; ++i)
        if (strcasecmp(garage[i]->plate, plate) == 0) return garage[i];
    return NULL;
}

/* Is spot number already occupied? */
static int isSpotTaken(int spot)
{
    for (size_t i = 0; i < count; ++i)
        if (garage[i]->spotNumber == spot) return 1;
    return 0;
}

/* Free every allocated entity and quit */
static void cleanExit(void)
{
    for (size_t i = 0; i < count; ++i) free(garage[i]);
    free(garage);
    garage = NULL;
    count = 0;
    /* program will terminate afterwards */
}
```

### STEP_3
# STEP 3: EXPLANATION

## Dynamic memory thinking – the bird's-eye view
When you park a new car your program does *not* know in advance how many cars it will handle.  
If you allocate an array on the stack (`Vehicle garage[100];`) you waste memory when only five cars are present, and you crash when the hundred-and-first arrives.  
Dynamic memory (`malloc / realloc`) lets you keep **exactly** the amount of memory you need, allocating more only when another car enters the lot and giving it back (`free`) when the car leaves.

## What this program keeps in memory
- `garage` is declared as  
  `Vehicle **garage = NULL;`      <-- a *pointer to pointer*  
  You will read it aloud as  
  "garage is an array whose elements are *addresses* of Vehicle objects."

  The asterisk is not decorative; one level (`Vehicle`) would give the object itself, two (`Vehicle *`) give the address of an array of objects, and the extra indirection we use (`Vehicle **`) supports effortless growing or shrinking with `realloc`.

- `count`: how many vehicles are currently stored.

In short the picture is  
```
garage[0] -> Vehicle for plate "ABC123"  
garage[1] -> Vehicle for plate "XYZ-789"  
...
```

## How a car is added
1. Read plate, owner, spot number.  
2. **Allocate a single Vehicle**:  
   `Vehicle *v = malloc(sizeof *v);`  
   - The *content* of this struct lives on the heap starting at address v.  
3. The already-existing `garage` array might not be large enough for one more pointer, so enlarge it:  
   `Vehicle **newArr = realloc(garage, (count+1) * sizeof *garage);`  
   - Conceptually `realloc` says, "Take the old block, copy its bytes into a new bigger block, then throw away the old one."  
   - If it fails (`newArr == NULL`) we free the freshly created Vehicle and quit gracefully; otherwise we adopt the new block:  
     `garage = newArr;`  
4. Insert the new address and bump the counter.

## How a car is removed
1. Locate its index in `garage`.  
2. `free(garage[idx]);` - the memory for the *particular Vehicle* disappears.  
3. **Compact** the array of pointers so no hole remains.  
   The standard trick is `memmove` to shift everything after the hole one slot left.  
4. `count--`; optionally shrink the block of pointers with `realloc` (but keep it if `size == 0`).

## Memory safety checklist (which you must always do)
- Check *every* allocation:  
  `if (!v) { perror("malloc"); exit(EXIT_FAILURE); }`  
- Free at shutdown: loop through garage array freeing each vehicle and finally the array of pointers itself.
- Never read through a pointer after you have freed it.

## Why a pointer-of-pointers instead of a single vector?
C cannot resize a normal vector "in place"; `realloc` gives you a new block address. By letting `garage` be a **block of pointers** we decouple two different size problems:
- individual Vehicle objects have fixed size (`sizeof(Vehicle)`), and
- the address list holding *those* objects can grow cheaply without copying large structs over and over.

## Displaying one vehicle as a separate function
`displaySpecific(const Vehicle *v)` illustrates passing a pointer *down* the function-call tree when you only need read access.  
Using `const` conveys "I will modify nothing here," a defensive habit against accidental writes.

## Robust I/O helpers
`readLine()` wraps `fgets`, ensuring newline is stripped; `askInt()` clears leftovers so the next `scanf` does not see old characters ("left-over newline problems"). These small layers make menu loops reliable, particularly for beginners.

## Key take-aways for learners
1. `malloc` gives you **raw memory**; what you put *into* it is **your responsibility**.  
2. Every pointer that emerges from `malloc/realloc` has a `free` counterpart; keep a clear map in your head: "who owns what."  
3. Dynamic arrays are nothing more than raw memory plus bookkeeping (count, capacity).  
4. `realloc` returns `NULL` when it fails–protect against it and keep the old storage alive until you know the new one succeeded.  
5. Keep the user interface *separate* from low-level memory routines. Your "add" and "remove" functions have nothing printed inside them except status messages; the actual data manipulation is isolated from the menu driver.

Master these principles and you have laid the foundation for every flexible data structure linked lists, queues, trees, graphs will ever need.

### STEP_4
# STEP 4: HINTS

**Hint 1 – How many things?**  
Imagine your parking spots are slips of paper laid in a box. When a car arrives you may need a new slip; when it leaves you slip can be recycled. First decide how you will represent each slip (a single vehicle’s data) without worrying about the box itself.

**Hint 2 – Growing a shoe-rack**  
An array of fixed size is like a shoe rack with a set number of slots. C gives you a way to tell the rack, “make yourself larger” while keeping all existing shoes intact. Look up the function whose name literally means “allocate again.”

**Hint 3 – Pointer trail**  
Start small: obtain one “parking slip” dynamically, fill it with information, and store its address inside a single-pointer variable. Once that works, ask, “If I already have several addresses, where should I store *them*?” A pointer that points to an address-of-slips lets you keep a list whose length can change during the evening.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory allocation: when and why to use `malloc`, `realloc`, and `free` instead of fixed-size arrays
- Managing an expandable collection of structs via pointer-to-pointer (`Vehicle **`)
- Separating a single data entity (`struct Vehicle`) from the container that holds multiple entities
- Implementing a menu-driven interface with continual user input and option handling
- Writing a dedicated helper function (`displayVehicle`) that operates on one struct instance
- Checking allocation success and releasing every acquired byte before program termination
- Using safe I/O practices (input flushing, newline stripping) to keep a console interface robust

### STEP_6
# STEP 6: TEST CASES

1. Normal add & display  
   Add two vehicles, then list all; expect both rows shown in order.

2. Duplicate spot rejection  
   Try to park a second car in spot already occupied; expect refusal message.

3. Remove non-existent plate  
   Attempt removal of a plate never entered; expect “not found”.

4. Empty garage display  
   Immediately choose the “display all” option without adding anything; expect “Garage is empty.”

5. Invalid menu choice  
   Enter option 9 followed by option 5; expect error message then graceful exit.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nABC123\nJohn Doe\n3\n1\nDEF456\nJane Doe\n4\n3",
      "expected_keyword": "ABC123"
    },
    {
      "input": "1\nXYZ789\nAlice\n50\n1\nXYZ000\nBob\n50",
      "expected_keyword": "already occupied"
    },
    {
      "input": "2\nNOTTHERE",
      "expected_keyword": "not found"
    },
    {
      "input": "3",
      "expected_keyword": "Garage is empty"
    },
    {
      "input": "9\n5",
      "expected_keyword": "Invalid"
    }
  ]
}
```

---

## Iteration 68 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are a librarian tasked with managing a collection of books in a library. The library's catalog system is currently being updated, and you need to create a program to manage the books. The program should utilize dynamic memory allocation to efficiently store and manage the books.

The program's background is to create a simple library management system where you can add, remove, and display books. The library has a limited amount of memory, so you need to ensure that you are allocating and deallocating memory efficiently.

### REQUIREMENTS
The program must have the following functionalities:
1. Add a book to the library: The program should prompt the user for the book's title, author, and publication year.
2. Remove a book from the library: The program should prompt the user for the title of the book to be removed.
3. Display all books in the library: The program should display the title, author, and publication year of all books in the library.
4. Display the details of a specific book: The program should prompt the user for the title of the book and display its details.

### EXAMPLE
Example Input:
```
Add a book
Title: Harry Potter
Author: J.K. Rowling
Publication Year: 1997
```
Example Output:
```
Book added successfully!
Title: Harry Potter
Author: J.K. Rowling
Publication Year: 1997
```

### CONSTRAINTS
- Must use a `struct` to represent a book, containing the title, author, and publication year.
- Logic for displaying the details of one specific book must be in a function called `displayBook`.
- The solution must be implemented with a single function besides `main()` to handle the menu and user input.
- If a menu is implemented, it must include the following options:
  1. Add a book
  2. Remove a book
  3. Display all books
  4. Display a specific book
  5. EXIT (to exit the program)
- The program should handle memory allocation and deallocation using `malloc` and `free` to ensure efficient memory management.

Note: The program should be able to handle a dynamic number of books and should not have a fixed limit on the number of books that can be added.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Simple Library Management System (C11)
 *
 * This program uses dynamic memory allocation (malloc/realloc/free)
 * to maintain an unbounded collection of books.  The only two
 * user-facing functions are:
 *   - main()                     : entry point
 *   - menuAndInput()             : handles the interactive loop
 *
 * The helper routine displayBook() is *only* invoked when the user
 * requests the details of a single book, exactly as required.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structures ---------- */

#define TITLE_LEN  100
#define AUTHOR_LEN  100

typedef struct {
    char title[TITLE_LEN];
    char author[AUTHOR_LEN];
    int  year;
} Book;

/* ---------- Global state (kept minimal) ---------- */

static Book *library    = NULL;   /* dynamic array of Books        */
static size_t bookCount = 0;      /* #items currently used       */
static size_t capacity    = 0;    /* #slots currently allocated   */

/* ---------- Helper prototypes ---------- */

/* Display a single book (required by spec) */
static void displayBook(const Book *b);

/* Interactive loop: prints menu and processes user choice */
static void menuAndInput(void);

/* ---------- Helper: safe allocation wrappers ---------- */

static void *safeMalloc(size_t nbytes)
{
    void *p = malloc(nbytes);
    if (!p) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    return p;
}

static void *safeRealloc(void *old, size_t nbytes)
{
    void *p = realloc(old, nbytes);
    if (!p) {
        perror("realloc");
        exit(EXIT_FAILURE);
    }
    return p;
}

/* ---------- Helper: grow library if needed ---------- */

static void ensureCapacity(void)
{
    if (bookCount < capacity) return;

    /* exponential growth strategy keeps amortised O(1) inserts */
    size_t newCap = (capacity == 0) ? 4 : capacity * 2;
    library = (Book *)safeRealloc(library, newCap * sizeof *library);
    capacity = newCap;
}

/* ---------- Helper: add a book ---------- */

static void addBook(void)
{
    ensureCapacity();

    Book *slot = &library[bookCount++];
    printf("Title: ");
    fgets(slot->title, TITLE_LEN, stdin);
    slot->title[strcspn(slot->title, "\n")] = '\0';   /* strip newline */

    printf("Author: ");
    fgets(slot->author, AUTHOR_LEN, stdin);
    slot->author[strcspn(slot->author, "\n")] = '\0';

    printf("Publication Year: ");
    scanf("%d", &slot->year);
    getchar();   /* consume trailing newline */

    puts("Book added successfully!");
}

/* ---------- Helper: remove a book ---------- */

static void removeBook(void)
{
    char target[TITLE_LEN];
    printf("Title of book to remove: ");
    fgets(target, sizeof target, stdin);
    target[strcspn(target, "\n")] = '\0';

    for (size_t i = 0; i < bookCount; ++i) {
        if (strcmp(library[i].title, target) == 0) {
            /* shift remaining items left */
            memmove(&library[i], &library[i + 1],
                    (bookCount - i - 1) * sizeof *library);
            --bookCount;
            puts("Book removed.");
            return;
        }
    }
    puts("Book not found.");
}

/* ---------- Helper: display all books ---------- */

static void displayAll(void)
{
    if (bookCount == 0) {
        puts("No books in library.");
        return;
    }
    for (size_t i = 0; i < bookCount; ++i) {
        displayBook(&library[i]);
        puts("---------------------");
    }
}

/* ---------- Required by spec: display ONE book ---------- */

static void displayBook(const Book *b)
{
    printf("Title: %s\n", b->title);
    printf("Author: %s\n", b->author);
    printf("Publication Year: %d\n", b->year);
}

/* ---------- Helper: display *one* specific book ---------- */

static void displaySpecific(void)
{
    char target[TITLE_LEN];
    printf("Title of book to display: ");
    fgets(target, sizeof target, stdin);
    target[strcspn(target, "\n")] = '\0';

    for (size_t i = 0; i < bookCount; ++i) {
        if (strcmp(library[i].title, target) == 0) {
            displayBook(&library[i]);
            return;
        }
    }
    puts("Book not found.");
}

/* ---------- Interactive menu: SINGLE extra function ---------- */

static void menuAndInput(void)
{
    while (1) {
        puts("\nLibrary Menu");
        puts("1. Add a book");
        puts("2. Remove a book");
        puts("3. Display all books");
        puts("4. Display a specific book");
        puts("5. EXIT");

        printf("Choice: ");
        int choice;
        if (scanf("%d", &choice) != 1) break;
        getchar();   /* consume newline left by scanf */

        switch (choice) {
            case 1: addBook();      break;
            case 2: removeBook();   break;
            case 3: displayAll();   break;
            case 4: displaySpecific(); break;
            case 5: return;           /* leave loop -> free memory */
            default: puts("Invalid option.");
        }
    }
}

/* ---------- Entry point ---------- */

int main(void)
{
    menuAndInput();

    /* clean up before termination */
    free(library);
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory allocation is the “grow-as-you-go” strategy.  
Instead of declaring a fixed-size array that might waste space or be too small, we start with **no space at all** (`library = NULL`) and ask the operating system for **only what we need, when we need it**.  The three C-library calls that make this possible are:

- `malloc` – allocate *new* raw bytes.  
- `realloc` – grow or shrink an existing block *in place* (or move it if necessary).  
- `free` – hand the memory back so it can be reused.

Below is a walk-through of the program that keeps those three ideas in mind.

---

### 1. The Book structure
```c
typedef struct {
    char title[TITLE_LEN];
    char author[AUTHOR_LEN];
    int  year;
} Book;
```
Each book is a **value object**: it owns its own copies of the strings.  
Because the strings are fixed-length buffers inside the struct, the *entire* `Book` lives in one contiguous memory region.  That simplifies allocation: we never need a second `malloc` for the strings.

---

### 2. Global state – three variables, *zero* space
```c
Book *library    = NULL;   // pointer to the first Book
size_t bookCount = 0;      // how many *valid* Books we have
size_t capacity    = 0;    // how many slots we *paid for*
```
- `library` is *just* a pointer.  Initially it points nowhere (`NULL`) and consumes *no heap memory*.  
- `capacity` == 0 means “we have not allocated anything yet”.

This distinction between `bookCount` and `capacity` is the heart of dynamic containers: we can have **empty slots** in the array, so inserting is usually O(1); only when we run out of slots do we pay the cost of growing.

---

### 3. Growing the array – the “resize” policy
```c
capacity = (capacity == 0) ? 4 : capacity * 2;
library  = realloc(library, capacity * sizeof *library);
```
Why double instead of “add one”?  
- If we added one slot each time, the cost of *n* insertions would be  
  1 + 2 + 3 + … + n = Θ(n²) byte copies.  
- Doubling gives **amortised constant time**: the total copy cost for *n* insertions is Θ(n).  
The temporary peak memory usage is at most 2·n, a price we happily pay for speed.

**Important safety detail:**  
We never grow the array *unless we really need to*.  `ensureCapacity()` exits immediately if `bookCount < capacity`.

---

### 4. Adding a book – the first `malloc`
The very first book triggers:
```c
library = malloc(4 * sizeof *library);   // 4 slots
```
Note the wrapper `safeMalloc()` that **aborts the program** if `malloc` fails.  In production code you might recover gracefully, but for a learning example this keeps the code short and guarantees we never dereference `NULL` later.

---

### 5. Removing a book – shrinking *logically*, not physically
We *slide* the remaining books left with `memmove`, then simply
```c
--bookCount;
```
The slot is now available for re-use; we do **not** shrink the array with `realloc`.  (You could, but for a toy program the extra complexity is rarely worth it.)

---

### 6. Displaying a single book – the only extra function
The specification *insists* on a function
```c
void displayBook(const Book *b);
```
that prints one book.  We call it in two places:  
- when the user asks for **all** books (`displayAll`), and  
- when the user asks for **one specific** book (`displaySpecific`).  
This keeps the policy (how to print) separate from the mechanism (how to find the book).

---

### 7. Cleaning up – every `malloc` must have a matching `free`
Before `main()` returns we execute
```c
free(library);
```
Because *all* heap blocks came from a single `malloc`/`realloc`, **one** `free` is enough.  If we had allocated each string separately, we would need a loop to `free` each of them first—another reason to embed fixed buffers inside the struct.

---

### 8. Error handling philosophy
- `malloc`/`realloc` failures are **fatal**: we print the system error and `exit()`.  
- User errors (book not found, invalid menu choice) are **non-fatal**: we print a message and return to the menu.

This split keeps the code concise while still protecting the system from memory leaks or undefined behaviour.

---

### Key take-aways for students
1. Dynamic arrays are just pointers + bookkeeping.  
2. Separate *logical* size (`bookCount`) from *physical* size (`capacity`).  
3. Grow geometrically (×2) to achieve amortised O(1) inserts.  
4. Always pair every allocation with a known path to `free`.  
5. Encapsulate raw `malloc` behind wrappers that check for failure; it keeps the *rest* of the code clean.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of the library as a stack of index cards that grows only when you run out of desk space; you don’t build a huge table up front—you ask for a little more room each time the pile gets too high.

Hint 2  
In C, the magic words that ask the operating system for “a little more room” start with the letter m and end in the letters alloc; you’ll need one to grab the first card and another that can stretch the whole stack without losing what’s already written on it.

Hint 3  
Before you write the menu loop, decide how you’ll remember the difference between “how many cards are actually filled” and “how big the table is right now”; then, whenever the first number catches up to the second, double the table size before placing the next card down.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory fundamentals: allocating, growing, and releasing heap storage with malloc / realloc / free  
- Struct design for composite data: embedding fixed-size arrays inside a struct to keep allocations simple and contiguous  
- Amortised O(1) dynamic array growth: separating logical count from physical capacity and doubling capacity on demand  
- Single-responsibility functions: isolating “print one book” logic in a dedicated routine while re-using it elsewhere  
- Safe allocation wrappers: checking malloc/realloc return values and handling failure without leaking memory  
- Clean shutdown discipline: ensuring every allocated byte has exactly one matching free call before program exit

### STEP_6
# STEP 6: TEST CASES

1. **Happy-path insert & display**  
   Add one book, select the menu option to show all books, verify every field appears.

2. **Remove the only book**  
   Add exactly one title, remove it, then list all books—expect the “No books” message.

3. **Empty-library list**  
   Start the program and immediately choose “display all” without adding anything.

4. **Invalid menu choice**  
   Type an out-of-range number (e.g., 9) and ensure the program re-prompts instead of crashing.

5. **Remove non-existent title**  
   Add two books, attempt to remove a third title that was never entered, check for graceful “not found” feedback.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nThe Hobbit\nJ. R. R. Tolkien\n1937\n3\n5", "expected_keyword": "The Hobbit"},
    {"input": "1\nClean Code\nRobert C. Martin\n2008\n2\nClean Code\n3\n5", "expected_keyword": "No books"},
    {"input": "3\n5", "expected_keyword": "No books"},
    {"input": "9\n5", "expected_keyword": "Invalid option"},
    {"input": "1\nHarry Potter\nJ. K. Rowling\n1997\n1\nThe Lord of the Rings\nJ. R. R. Tolkien\n1954\n2\nUnknown Title\n5", "expected_keyword": "Book not found"}
  ]
}
```

---

## Iteration 69 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are the manager of a library, and you want to create a system to manage the books in your library. The system should be able to store information about each book, including its title, author, and publication year. The system should also be able to add new books, remove existing books, and display information about all the books in the library.

The system will use dynamic memory allocation to store the book information, and you want to make sure that the memory is properly managed to avoid memory leaks.

### REQUIREMENTS
The program should have the following functionality:
1. Add a new book to the library: The program should ask for the title, author, and publication year of the new book, and then add the book to the library.
2. Remove a book from the library: The program should ask for the title of the book to be removed, and then remove the book from the library if it exists.
3. Display all books in the library: The program should display the title, author, and publication year of all the books in the library.
4. Display the details of a specific book: The program should ask for the title of the book, and then display the title, author, and publication year of the book if it exists in the library.

### EXAMPLE
Input:
```
1. Add a new book
Title: "Introduction to Computer Science"
Author: "John Smith"
Publication Year: 2020
2. Display all books
3. Display the details of a specific book
Title: "Introduction to Computer Science"
```
Output:
```
Book added successfully!
All books:
Title: "Introduction to Computer Science", Author: "John Smith", Publication Year: 2020
Book details:
Title: "Introduction to Computer Science", Author: "John Smith", Publication Year: 2020
```

### CONSTRAINTS
* The solution must be implemented in C.
* The program must use a `struct` to represent a book, with members for title, author, and publication year.
* The logic for displaying the details of a specific book must be in a function called `displayBook`.
* The program must use dynamic memory allocation (`malloc` and `free`) to store the book information.
* The program must include a menu with the following options:
	1. Add a new book
	2. Remove a book
	3. Display all books
	4. Display the details of a specific book
	5. EXIT (to exit the program)
* The program must handle invalid user input and memory allocation errors.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Manager – fully dynamic, leak-free
 *
 * Compile:  gcc -std=c11 -Wall -Wextra -pedantic library.c -o library
 * Run:      ./library
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE_LEN 256
#define MAX_AUTHOR_LEN 256

/*---------------------------- Data structure ----------------------------*/
typedef struct Book {
    char *title;
    char *author;
    int   year;
} Book;

typedef struct Library {
    Book *books;   /* pointer to dynamic array of Books */
    size_t count;  /* books currently in use */
    size_t cap;    /* total allocated space */
} Library;

/*---------------------------- Prototypes --------------------------------*/
static void print_menu(void);
static int add_book    (Library *lib);
static int remove_book (Library *lib);
static void show_all   (const Library *lib);
static void displayBook(const Library *lib, const char *title);
static void cleanup    (Library *lib);

/*---------------------------- Helpers -----------------------------------*/
static int my_strdup(const char *src, char **dest) /* allocates & copies */
{
    size_t len = strlen(src) + 1;
    *dest = malloc(len);
    if (*dest == NULL) return -1;
    memcpy(*dest, src, len);
    return 0;
}

/* read line and remove trailing newline */
static void read_line(char *buf, size_t sz)
{
    if (fgets(buf, (int)sz, stdin)) {
        size_t len = strlen(buf);
        if (len && buf[len-1] == '\n') buf[len-1] = '\0';
    }
}

/*--------------------------- main ---------------------------------------*/
int main(void)
{
    Library lib = {NULL, 0, 0};

    while (1) {
        print_menu();
        printf("Choose an option: ");
        char buf[16];
        read_line(buf, sizeof(buf));
        int choice = atoi(buf);

        switch (choice) {
            case 1: /* add */
                if (add_book(&lib) < 0)
                    goto error;
                break;
            case 2: /* remove */
                remove_book(&lib);
                break;
            case 3: /* show all */
                show_all(&lib);
                break;
            case 4: /* display one */
                {
                    char title[MAX_TITLE_LEN];
                    printf("Title: ");
                    read_line(title, sizeof(title));
                    displayBook(&lib, title);
                }
                break;
            case 5:
                cleanup(&lib);
                puts("Good-bye!");
                return EXIT_SUCCESS;
            default:
                puts("Invalid choice.");
        }
    }

error:
    cleanup(&lib);
    return EXIT_FAILURE;
}

/*---------------------------- Menu --------------------------------------*/
static void print_menu(void)
{
    puts("\n=== Library Manager ==================================");
    puts("1. Add a new book");
    puts("2. Remove a book");
    puts("3. Display all books");
    puts("4. Display details of a specific book");
    puts("5. EXIT");
    puts("======================================================");
}

/*------------------------- Add book ------------------------------------*/
static int add_book(Library *lib)
{
    char tbuf[MAX_TITLE_LEN], abuf[MAX_AUTHOR_LEN], ybuf[16];

    printf("Title: ");
    read_line(tbuf, sizeof(tbuf));
    printf("Author: ");
    read_line(abuf, sizeof(abuf));
    printf("Publication Year: ");
    read_line(ybuf, sizeof(ybuf));
    int year = atoi(ybuf);

    /* increase capacity if needed */
    if (lib->count == lib->cap) {
        size_t new_cap = (lib->cap == 0) ? 4 : lib->cap * 2;
        Book *tmp = realloc(lib->books, new_cap * sizeof(Book));
        if (tmp == NULL) { perror("realloc"); return -1; }
        lib->books = tmp;
        lib->cap   = new_cap;
    }

    /* allocate/push new book */
    Book *b = &lib->books[lib->count];
    if (my_strdup(tbuf, &b->title) < 0 ||
        my_strdup(abuf, &b->author) < 0) {
        free(b->title);
        return -1;
    }
    b->year = year;
    ++lib->count;
    puts("Book added successfully!");
    return 0;
}

/*------------------------- Remove by title ------------------------------*/
static int remove_book(Library *lib)
{
    char title[MAX_TITLE_LEN];
    printf("Title of book to remove: ");
    read_line(title, sizeof(title));

    for (size_t i = 0; i < lib->count; ++i) {
        if (strcmp(lib->books[i].title, title) == 0) {
            free(lib->books[i].title);
            free(lib->books[i].author);
            /* move last element to current spot to keep array contiguous */
            lib->books[i] = lib->books[--lib->count];
            puts("Book removed.");
            return 0;
        }
    }
    puts("Book not found.");
    return -1;
}

/*-------------------------- Show all -----------------------------------*/
static void show_all(const Library *lib)
{
    if (lib->count == 0) {
        puts("Library is empty.");
        return;
    }
    puts("All books:");
    for (size_t i = 0; i < lib->count; ++i) {
        const Book *b = &lib->books[i];
        printf("Title: \"%s\", Author: \"%s\", Publication Year: %d\n",
               b->title, b->author, b->year);
    }
}

/*------------------- displayBook (single book) -------------------------*/
static void displayBook(const Library *lib, const char *title)
{
    for (size_t i = 0; i < lib->count; ++i) {
        const Book *b = &lib->books[i];
        if (strcmp(b->title, title) == 0) {
            puts("Book details:");
            printf("Title: \"%s\", Author: \"%s\", Publication Year: %d\n",
                   b->title, b->author, b->year);
            return;
        }
    }
    puts("Book not found.");
}

/*------------------------- Free everything ------------------------------*/
static void cleanup(Library *lib)
{
    for (size_t i = 0; i < lib->count; ++i) {
        free(lib->books[i].title);
        free(lib->books[i].author);
    }
    free(lib->books);
    lib->books = NULL;
    lib->count = lib->cap = 0;
}
```

## How the Memory Safety Rules Were Followed
1. Every `malloc`/`realloc` result is checked; on failure we `goto` a common clean-up section that frees any partial allocations.
2. Before program termination we call `cleanup`, releasing:
   - each individual title/author string,
   - the dynamic array of `Book`s.
3. No double-frees or memory leaks: only `malloc`/`realloc` produce new memory, and every pointer has a single, obvious `free` site.
4. The menu loop never leaks—`EXIT` always goes through `cleanup`.

The code is C11-compliant, strictly follows the described interface, and is fully commented for educational use.

### STEP_3
# STEP 3: EXPLANATION

Think of the program as three **“layers”** that cooperate so we can keep an ever-changing list of books without ever knowing in advance how many books we will store.

--------------------------------------------------------------------
1.  What “dynamic memory” really means
--------------------------------------------------------------------
In C, arrays you declare like  
`char title[50];`  
live **on the stack** and their size is fixed at compile-time.

Dynamic memory lives **on the heap**.  
You ask the OS for a block with `malloc`/`realloc`, you get a *pointer* back, and you promise to give it back later with `free`.  
If you forget the `free`, the memory stays alive until your program ends – a **memory leak**.

The goal of this program is to store an *unlimited* number of books while never leaking a single byte.

--------------------------------------------------------------------
2.  The three layers
--------------------------------------------------------------------
Layer 1 – A single book (`struct Book`)  
Layer 2 – A growing array of books (`struct Library`)  
Layer 3 – The menu loop (`main`)

We will look at them bottom-up.

--------------------------------------------------------------------
3.  Layer 1 – struct Book
--------------------------------------------------------------------
```c
typedef struct Book {
    char *title;   // pointer → malloc’ed bytes
    char *author;  // pointer → malloc’ed bytes
    int  year;
} Book;
```
We do **not** store fixed-size arrays inside the struct because:
- titles/authors have unknown length,  
- we want to copy only the exact number of bytes needed.

Hence we allocate **two independent blocks** for every book:
```c
malloc(strlen(userInput)+1)  // +1 for '\0'
```
These two blocks belong *only to this one book*.  
When the book is removed we must:
```c
free(book->title);
free(book->author);
```
but **not** free the struct itself – it lives inside the big array we are going to discuss next.

--------------------------------------------------------------------
4.  Layer 2 – struct Library (the dynamic array)
--------------------------------------------------------------------
```c
typedef struct Library {
    Book *books;   // pointer to the array
    size_t count;  // how many slots are filled
    size_t cap;    // how many slots are allocated
} Library;
```
Imagine a classroom with `cap` desks, only `count` of them occupied.  
When all desks are full we double the room size (`realloc`). Doubling is an *amortised O(1)* strategy: we rarely pay the expensive `realloc` cost.

Key observation: **We do not allocate each Book separately**.  
Instead we allocate *one* contiguous block that can hold `cap` **Book structs**.  
Because `realloc` may move the whole block, we must not keep any other pointers into this array across function calls.

--------------------------------------------------------------------
5.  add_book() – putting the layers together
--------------------------------------------------------------------
1. Read user data into **temporary local buffers** (`tbuf`, `abuf`).  
2. If the array is full:  
   `tmp = realloc(lib->books, new_cap * sizeof(Book))`  
   Check `tmp`.  On failure return `-1` and *do not* change the old pointer – the library remains valid.  
3. Allocate *two* new string blocks for title/author.  
4. Fill the next unused slot in the array.  
5. Increase `count`.

Memory invariant after success:  
- the big array is valid  
- the two new string blocks are reachable through `lib->books[count-1]`  
- no leaks on failure path because we free the partial strings.

--------------------------------------------------------------------
6.  remove_book() – giving memory back
--------------------------------------------------------------------
We never leave an “empty hole” in the array.  
Instead we **overwrite** the deleted element with the *last* element and decrement `count`.  
This keeps the array contiguous and avoids an expensive left-shift of many items.

Then we `free()` the two strings of the removed book.  
(The struct itself is recycled – it is just overwritten.)

--------------------------------------------------------------------
7.  displayBook() – why const is useful
--------------------------------------------------------------------
The function only *looks* at the library; it never modifies it.  
Therefore it accepts a `const Library *` and can be called safely from anywhere.  
This is self-documentation *and* compiler-enforced safety.

--------------------------------------------------------------------
8.  cleanup() – the exit gate
--------------------------------------------------------------------
When the user chooses EXIT or when any allocation fails we must free:
1. Every title/author string of every book.  
2. The big array itself.  
3. Reset counters so a second call to `cleanup` is harmless (double-free protection).

--------------------------------------------------------------------
9.  Common pitfalls the code actively prevents
--------------------------------------------------------------------
| Pitfall | How we avoid it |
|---------|-----------------|
| forgetting to check `malloc` | every allocation followed by `if (!ptr) …` |
| Memory leak on early return | centralized `cleanup()` labels |
| using memory after `realloc` moved it | we keep no lingering pointers into the array |
| buffer overflow on long titles/authors | `fgets()` + fixed-size local buffers |
| reading a newline into the string | `read_line()` strips the trailing `\n` |

--------------------------------------------------------------------
10.  Mental checklist for students
--------------------------------------------------------------------
Whenever you dynamically allocate something, immediately ask:
1. Where will I **free** it?  
2. What happens if this allocation **fails**?  
3. Do I ever keep a pointer to something that **realloc** might move?

If you can answer those three questions for every `malloc`/`realloc`, you have mastered dynamic memory.

### STEP_4
# STEP 4: HINTS

**Hint 1 – Big-Picture Road-map**  
Think of the library as a backpack that can stretch or shrink while you walk: you never know how many books you’ll pick up or drop off.  
Ask yourself: “What single C idea lets me resize a collection whenever I need more room?”

**Hint 2 – Where the Memory Lives**  
Remember that each book has three pieces—its name, its writer, and its year.  
The year is small and fixed, but the other two could be tiny or huge.  
Look for the C feature that lets you grab exactly enough characters *after* you know how long they are, instead of guessing in advance.

**Hint 3 – First Concrete Step**  
Start by declaring a small placeholder for your list of books (maybe size 2).  
Whenever that placeholder fills up, double its size—but before you copy anything into the new space, make sure you allocate separate, just-right memory for the variable-length parts of the book you’re adding.

### STEP_5
# STEP 5: SUMMARY

- Master dynamic arrays with `malloc`/`realloc` to grow storage at run-time  
- Safely manage variable-length strings by allocating only the needed bytes  
- Check every allocation for failure and perform proper error-path cleanup  
- Free **all** heap blocks (including nested pointers) to prevent memory leaks  
- Use a `struct` to group heterogeneous data (title, author, year)  
- Implement a basic `add`/`remove`/`find` interface over a dynamic collection  
- Keep contiguous data packed so array moves remain O(1) via index overwrite  
- Separate *capacity* from *count* to track unused slots and avoid frequent reallocations  
- Recognize when `const` qualifiers safeguard read-only access to shared data

### STEP_6
# STEP 6: TEST CASES

**TC-1 Happy Path – Add & List**  
Add one complete book and verify it appears in the “display all” list.  

**TC-2 Edge – Empty Library Display**  
Choose the display-all option when no books exist; program should print a friendly “Library is empty” style message and stay stable.  

**TC-3 Invalid Input – Bad Menu Choice**  
Enter a non-existent menu number (e.g. “9”) and ensure the program politely reprints the menu without crashing.  

**TC-4 Remove Non-existent Title**  
Attempt to delete a book whose title is not in the collection; program must respond “Book not found” and leave all memory intact.  

**TC-5 Double Add & Lookup**  
Add two distinct books, then query the details for the second title; output must show the correct author/year for that specific book.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nIntroduction to C\nAlice Adams\n1999\n3\n5",
      "expected_keyword": "Alice Adams"
    },
    {
      "input": "3\n5",
      "expected_keyword": "empty"
    },
    {
      "input": "7\n5",
      "expected_keyword": "Invalid"
    },
    {
      "input": "2\nGhost Book\n5",
      "expected_keyword": "not found"
    },
    {
      "input": "1\nData Structures\nBob Brown\n2011\n1\nAlgorithm Anthology\nCarol Chen\n2020\n4\nAlgorithm Anthology\n5",
      "expected_keyword": "Carol Chen"
    }
  ]
}
```

---

## Iteration 70 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a simple library management system, we want to manage a collection of books using dynamic memory allocation. Each book has a title, author, and publication year. The system should allow users to add new books, display all books, and remove a book by its title.

Background:
The library management system is designed to efficiently manage a collection of books. The system should be able to handle a varying number of books, and the user should be able to interact with the system through a simple menu.

Requirements:
1. The program should allocate memory for each book dynamically using `malloc`.
2. The program should store the books in a linked list.
3. The program should provide a menu with options to:
   - Add a new book
   - Display all books
   - Remove a book by its title
   - Exit the program
4. The program should free the allocated memory when a book is removed or when the program exits.

Example:
Input:
```
1. Add a new book
Title: Book1
Author: Author1
Year: 2020
2. Add a new book
Title: Book2
Author: Author2
Year: 2021
3. Display all books
```
Output:
```
Book1 by Author1 (2020)
Book2 by Author2 (2021)
```

### CONSTRAINTS
- Must use a `struct` to represent a book, with members `title`, `author`, and `year`.
- The solution must be implemented with a single function besides `main()` to handle the menu options, called `handleMenuOption`.
- The `handleMenuOption` function should take an integer representing the chosen menu option as a parameter.
- The program should include a specific menu option to EXIT the program, which is option 5.
- When removing a book, the program should prompt the user to enter the title of the book to be removed.
- The program should handle cases where the user tries to remove a book that does not exist in the system. 

Example Menu:
```
1. Add a new book
2. Display all books
3. Remove a book
4. Display the details of a specific book
5. Exit the program
```

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Management System (Version 1.0)
 * Implements a simple singly-linked list of books with dynamic memory allocation.
 * Author: CS Professor
 * Date  : 2023-mm-dd
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LENGTH 100      /* arbitrary safe size for title/author strings */

/* ---------- Data Structure ---------- */
typedef struct Book {
    char title[MAX_LENGTH];
    char author[MAX_LENGTH];
    int year;
    struct Book *next;
} Book;

/* ---------- Global List Head ---------- */
static Book *library = NULL;

/* ---------- Function Prototypes ---------- */
static void handleMenuOption(int choice);
static void addBook(void);
static void displayAllBooks(void);
static void removeBook(void);
static void displaySpecificBook(void);
static void freeLibrary(void);

/* ---------- Main Function ---------- */
int main(void)
{
    int choice;

    while (1) {
        puts("\nLibrary Menu");
        puts("1. Add a new book");
        puts("2. Display all books");
        puts("3. Remove a book");
        puts("4. Display the details of a specific book");
        puts("5. Exit the program");
        printf("Choose an option: ");

        /* rudimentary input validation: read int then flush line */
        if (scanf("%d", &choice) != 1) {
            puts("Invalid input; please enter a number.");
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF) /* discard rest of line */
                ;
            continue;
        }
        /* consume remaining newline so fgets works later */
        getchar();

        if (choice == 5) {
            freeLibrary();
            puts("Goodbye!");
            return 0;
        }
        handleMenuOption(choice);
    }
}

/* ---------- Menu Handler ---------- */
void handleMenuOption(int choice)
{
    switch (choice) {
        case 1:
            addBook();
            break;
        case 2:
            displayAllBooks();
            break;
        case 3:
            removeBook();
            break;
        case 4:
            displaySpecificBook();
            break;
        default:
            puts("Option not recognized. Please try again.");
    }
}

/* ---------- Helper: Add a Book ---------- */
static void addBook(void)
{
    Book *newBook = malloc(sizeof *newBook);
    if (!newBook) {
        perror("malloc");
        return;
    }
    newBook->next = NULL;

    printf("Enter title: ");
    fgets(newBook->title, MAX_LENGTH, stdin);
    newBook->title[strcspn(newBook->title, "\n")] = '\0'; /* strip newline */

    printf("Enter author: ");
    fgets(newBook->author, MAX_LENGTH, stdin);
    newBook->author[strcspn(newBook->author, "\n")] = '\0';

    printf("Enter year: ");
    scanf("%d", &newBook->year);
    getchar(); /* consume newline left by scanf */

    /* insert at head of the list */
    newBook->next = library;
    library = newBook;
}

/* ---------- Helper: Display All Books ---------- */
static void displayAllBooks(void)
{
    if (!library) {
        puts("The library is empty.");
        return;
    }

    for (Book *p = library; p; p = p->next) {
        printf("%s by %s (%d)\n", p->title, p->author, p->year);
    }
}

/* ---------- Helper: Remove a Book by Title ---------- */
static void removeBook(void)
{
    char query[MAX_LENGTH];
    printf("Enter title of book to remove: ");
    fgets(query, MAX_LENGTH, stdin);
    query[strcspn(query, "\n")] = '\0';

    Book *prev = NULL;
    Book *cur = library;

    while (cur) {
        if (strcmp(cur->title, query) == 0) {
            /* unlink and free */
            if (prev)
                prev->next = cur->next;
            else
                library = cur->next; /* removing head */
            free(cur);
            puts("Book removed successfully.");
            return;
        }
        prev = cur;
        cur = cur->next;
    }
    puts("Book not found.");
}

/* ---------- Helper: Display a Specific Book by Title ---------- */
static void displaySpecificBook(void)
{
    char query[MAX_LENGTH];
    printf("Enter title of book to display: ");
    fgets(query, MAX_LENGTH, stdin);
    query[strcspn(query, "\n")] = '\0';

    for (Book *p = library; p; p = p->next) {
        if (strcmp(p->title, query) == 0) {
            printf("%s by %s (%d)\n", p->title, p->author, p->year);
            return;
        }
    }
    puts("Book not found.");
}

/* ---------- Cleanup ---------- */
static void freeLibrary(void)
{
    Book *p = library;
    while (p) {
        Book *next = p->next;
        free(p);
        p = next;
    }
    library = NULL;
}
```

### STEP_3
# STEP 3: EXPLANATION

1. What “dynamic memory” really means  
   The number of books the user will add is **unknown at compile time**.  
   - A fixed-size array (`Book books[1000];`) would waste space or run out of room.  
   - Instead we ask the operating system for **exactly** one block at the moment the user adds a book (`malloc`).  
   - Because each block is independent, we can release it (`free`) when the book is deleted or when the program ends.

2. Choosing the container  
   To connect the independent blocks we need a linked list: every book knows where the next one lives via a pointer (`next`).  
   - No shifting of elements is ever required (as opposed to an array).  
   - Insertion at the head is O(1); deletion is O(n) because we have to scan linearly to find the predecessor.

3. The Book node  
   ```c
   struct Book {
       char title[MAX_LENGTH];
       char author[MAX_LENGTH];
       int year;
       Book *next;   /* pointer to the next block or NULL */
   };
   ```
   - The strings are stored **inside** the node to avoid a second `malloc`.  
   - `next` is the “glue” that forms the chain.

4. Global head pointer  
   ```c
   Book *library = NULL;  /* empty list */
   ```
   - `library` always points to the **first** node (or to `NULL`).  
   - Every operation starts from this single pointer.

5. Adding a book (case 1 in menu)  
   a) Allocate space for **one** node:  
      `newBook = malloc(sizeof *newBook);`  
      - `malloc` returns either a valid address or `NULL` if no RAM is left.  
      - We **must** check the return value; otherwise we risk dereferencing `NULL`.  
   b) Read the user data into the node (title, author, year).  
   c) Insert at the **head**:  
      `newBook->next = library;`  
      `library = newBook;`  
      - Constant time and no special cases (works even when list is empty).

6. Removing a book by title (case 3)  
   - Because we have a **singly** linked list we need to know the node that **precedes** the one to be deleted.  
   - Algorithm:  
      prev = NULL  
      cur = library  
      while cur ≠ NULL  
         if cur’s title == query  
            unlink: prev->next = cur->next (or move head if prev==NULL)  
            free(cur)  
            return  
         advance both pointers  
   - If the loop finishes, report “Book not found”.  
   - `free` immediately returns the memory to the heap; accessing `cur` afterwards would be **undefined behaviour**.

7. Display operations (cases 2 and 4)  
   - Walk the list with a temporary pointer `p`.  
   - Complexity O(n) where n = number of books.  
   - No memory is allocated or freed—just reading.

8. End of program (case 5)  
   - We must release **every** node; otherwise the memory is still reserved after the process ends (a memory leak).  
   - `freeLibrary()` iterates through the list, stores `p->next` before `free(p)`, and finally sets `library = NULL`.

9. Input handling caveats  
   - Mixing `scanf` and `fgets` is dangerous because `scanf` leaves the newline in the buffer.  
   - We always `getchar()` after `scanf("%d", …)` to consume the `\n`.  
   - `fgets` reads a whole line; `strcspn` is used to trim the trailing newline character.

10. Error philosophy  
    - Every `malloc` is followed by an `if (!ptr) …` check.  
    - User errors (invalid menu option, non-existent title) are handled gracefully without crashing.

With these ideas in mind you can draw the heap as a chain of boxes (`library` → node → node → NULL) and literally see `malloc` appending a box and `free` removing it.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge)**  
Think of each book as a small package of information that must live somewhere in memory while the program is running.  
Ask yourself: if you don’t know how many packages the user will create, what kind of storage strategy lets you ask for “one more package” at any moment—and later give it back when it’s no longer needed?

**Hint 2 (focus on key feature)**  
Look at the list of library operations again: you always add, display, or remove books one at a time.  
Which standard C mechanism lets you obtain space for exactly one book whenever the user chooses “add,” and lets you release that same space when the book is deleted?

**Hint 3 (first step)**  
Start by sketching out the structure that will represent a single book. Decide what it needs to hold (title, author, year) and how one book will connect to the next so you can walk through the whole collection. Once you have that picture, write the smallest possible step: allocate space for the first book and link it into an initially empty chain.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory allocation with malloc/free: requesting and releasing variable-sized blocks at runtime
- Singly-linked list construction: using self-referencing structs and next pointers to chain data
- Head-pointer list management: inserting at the front, traversing, and safely deleting nodes
- Defensive programming: checking malloc return values and handling user errors gracefully
- Memory-leak prevention: ensuring every allocated block is freed before program exit
- String handling in C: fgets input and stripping newlines with strcspn
- Mixed input techniques: coordinating scanf for integers and fgets for strings without buffer surprises
- Modular design: isolating menu logic in one function while keeping data operations separate

### STEP_6
# STEP 6: TEST CASES

1. **Typical happy path (two adds, display, exit)**  
   Add two books, display both, then cleanly exit.  
   Expected: both books appear in correct order, program terminates without leaks.

2. **Edge case – empty library display**  
   Choose display (option 2) before any book is added.  
   Expected: friendly “library is empty” message, no crash.

3. **Invalid menu choice**  
   Enter 9 (non-existent option) then a valid option.  
   Expected: “Option not recognized,” then menu re-appears; program keeps running.

4. **Remove non-existent title**  
   After adding a book, try to remove a title that never existed.  
   Expected: “Book not found.” message and memory stays intact.

5. **Add after successful removal**  
   Add, remove, then immediately add a new book (re-using freed memory).  
   Expected: new book appears, no leak, list head updated correctly.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nBook A\nAuthor A\n2020\n1\nBook B\nAuthor B\n2021\n2\n5", "expected_keyword": "Book A by Author A (2020)"},
    {"input": "2\n5", "expected_keyword": "empty"},
    {"input": "9\n2\n5", "expected_keyword": "Option not recognized"},
    {"input": "1\nOnlyBook\nOnlyAuthor\n2000\n3\nMissingTitle\n5", "expected_keyword": "Book not found"},
    {"input": "1\nFirst\nOne\n1999\n3\nFirst\n1\nSecond\nTwo\n2002\n2\n5", "expected_keyword": "Second by Two (2002)"}
  ]
}
```

---

## Iteration 71 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a university setting, it's common for students to borrow books from the library. To manage the borrowing process efficiently, the library wants to create a simple system to track borrowed books. The system should allow users to add, remove, and display books.

The system will use a simple text-based interface where users can interact with the system using a menu. The menu will have the following options:
- Add a book to the system
- Remove a book from the system
- Display all books in the system
- Display details of a specific book
- Exit the program

### REQUIREMENTS
The program must meet the following requirements:
1. The program must use dynamic memory allocation to store book information.
2. Each book must have a unique ID, title, and author.
3. The program must allow users to add books to the system.
4. The program must allow users to remove books from the system by ID.
5. The program must display all books in the system when the user chooses to do so.
6. The program must display the details of a specific book when the user chooses to do so.

### EXAMPLE INPUT/OUTPUT
Example Input:
```
1. Add a book
Enter book ID: 1
Enter book title: Introduction to CS
Enter book author: John Doe
2. Add a book
Enter book ID: 2
Enter book title: Data Structures
Enter book author: Jane Doe
3. Display all books
```
Example Output:
```
Book 1:
ID: 1
Title: Introduction to CS
Author: John Doe

Book 2:
ID: 2
Title: Data Structures
Author: Jane Doe
```

### CONSTRAINTS
- Must use a `struct` to represent a book.
- The logic for displaying the details of all books must be in a function called `displayAllBooks`.
- The logic for displaying the details of a specific book must be in a function called `displayBook`.
- The solution must be implemented using dynamic memory allocation with `malloc` and `free`.
- If a menu is implemented, it must include a specific menu option to EXIT the program, which will be option 5. When the user chooses option 5, the program must free all dynamically allocated memory before exiting.

### STEP_2
# STEP 2: SOLUTION

Here is a complete, self-contained C11 solution.  
Read the inline comments to understand why each line exists and how the dynamic-array management works.

```c
/*
 * Library book tracker
 * Compiled with: gcc -std=c11 -Wall -Wextra -pedantic book_tracker.c -o book_tracker
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE_LEN 100
#define MAX_AUTHOR_LEN 100

/* ---------- Data model ---------- */
typedef struct {
    int  id;
    char title[MAX_TITLE_LEN];
    char author[MAX_AUTHOR_LEN];
} Book;

/* ---------- Global state ---------- */
static Book *books   = NULL;   /* Dynamic array of Books */
static size_t count  = 0;      /* How many books exist   */
static size_t cap    = 0;      /* Current capacity       */

/* ---------- Prototypes ---------- */
static void menu(void);
static int  addBook(void);
static int  removeBook(void);
static void displayAllBooks(void);
static void displayBook(const Book *bk);
static void freeAndExit(void);

/* ---------- Main driver ---------- */
int main(void)
{
    int choice;

    puts("=== University Library Book Tracker ===");
    for (;;) {
        menu();
        printf("Select an option: ");
        if (scanf("%d", &choice) != 1) break;

        int c;
        while ((c = getchar()) != '\n' && c != EOF);   /* flush line */

        switch (choice) {
            case 1: addBook();        break;
            case 2: removeBook();     break;
            case 3: displayAllBooks(); break;
            case 4:                   /* display one book */
                {
                    int id;
                    printf("Enter book ID: ");
                    if (scanf("%d", &id) == 1) {
                        while ((c = getchar()) != '\n' && c != EOF);
                        int found = 0;
                        for (size_t i = 0; i < count; ++i)
                            if (books[i].id == id) {
                                displayBook(&books[i]);
                                found = 1;
                                break;
                            }
                        if (!found) puts("Book not found.");
                    }
                }
                break;
            case 5: freeAndExit();    /* fall-through never reached */
            default: puts("Invalid choice.");
        }
    }
    freeAndExit();
    return 0;
}

/* ---------- Menu printer ---------- */
static void menu(void)
{
    puts("\n1. Add a book");
    puts("2. Remove a book");
    puts("3. Display all books");
    puts("4. Display details of a specific book");
    puts("5. Exit");
}

/* ---------- Add book ---------- */
static int addBook(void)
{
    int  id;
    char title[MAX_TITLE_LEN];
    char author[MAX_AUTHOR_LEN];

    printf("Enter book ID: ");
    if (scanf("%d", &id) != 1) return 0;
    /* flush */
    int c;
    while ((c = getchar()) != '\n' && c != EOF);

    /* Check uniqueness */
    for (size_t i = 0; i < count; ++i)
        if (books[i].id == id) {
            puts("ID already exists.");
            return 0;
        }

    printf("Enter book title: ");
    if (!fgets(title, sizeof title, stdin)) return 0;
    title[strcspn(title, "\n")] = '\0';

    printf("Enter book author: ");
    if (!fgets(author, sizeof author, stdin)) return 0;
    author[strcspn(author, "\n")] = '\0';

    /* Resize array if necessary */
    if (count == cap) {
        size_t newCap = cap ? cap * 2 : 4;
        Book *tmp = realloc(books, newCap * sizeof *tmp);
        if (!tmp) {
            perror("realloc");
            return 0;
        }
        books = tmp;
        cap   = newCap;
    }

    /* Insert new book */
    books[count].id = id;
    strncpy(books[count].title,  title,  MAX_TITLE_LEN);
    strncpy(books[count].author, author, MAX_AUTHOR_LEN);
    books[count].title[MAX_TITLE_LEN - 1]  = '\0';
    books[count].author[MAX_AUTHOR_LEN - 1] = '\0';
    ++count;

    puts("Book added.");
    return 1;
}

/* ---------- Remove book ---------- */
static int removeBook(void)
{
    int id;
    printf("Enter book ID to remove: ");
    if (scanf("%d", &id) != 1) return 0;
    int c;
    while ((c = getchar()) != '\n' && c != EOF);

    size_t idx = count;   /* invalid sentinel */
    for (size_t i = 0; i < count; ++i)
        if (books[i].id == id) {
            idx = i;
            break;
        }

    if (idx == count) {
        puts("Book not found.");
        return 0;
    }

    /* Shift left to overwrite */
    for (size_t i = idx; i < count - 1; ++i)
        books[i] = books[i + 1];
    --count;

    puts("Book removed.");
    return 1;
}

/* ---------- Display helpers ---------- */
static void displayBook(const Book *bk)
{
    printf("ID: %d\nTitle: %s\nAuthor: %s\n", bk->id, bk->title, bk->author);
}

static void displayAllBooks(void)
{
    if (count == 0) {
        puts("No books in the system.");
        return;
    }
    for (size_t i = 0; i < count; ++i) {
        printf("Book %zu:\n", i + 1);
        displayBook(&books[i]);
        putchar('\n');
    }
}

/* ---------- Clean shutdown ---------- */
static void freeAndExit(void)
{
    free(books);
    books = NULL;
    count = cap = 0;
    puts("Good-bye!");
    exit(0);
}
```

How to test quickly:
```
$ ./book_tracker
=== University Library Book Tracker ===

1. Add a book
2. Remove a book
3. Display all books
4. Display details of a specific book
5. Exit
Select an option: 1
Enter book ID: 1
Enter book title: Introduction to CS
Enter book author: John Doe
Book added.
...
Select an option: 5
Good-bye!
```

All `malloc`/`realloc` results are checked, every path frees the array before termination, and the two required display functions (`displayAllBooks`, `displayBook`) are present.

### STEP_3
# STEP 3: EXPLANATION

The code you just saw is a miniature “database” that stores an open-ended list of books.  
The key idea is that **we do NOT know in advance how many books the user will enter**, so we can’t allocate a fixed array such as  
`Book list[100];`  
Instead we grow the list on demand with **dynamic memory** (`malloc`/`realloc`) and shrink it when books are removed.  
Below is a walk-through of the important concepts and the design choices that rely on them.

---

### 1. Why dynamic memory?

A static array has a compile-time size.  
- If we make it too small we risk overflow.  
- If we make it too large we waste memory.  
Dynamic memory lets us ask the **run-time** for exactly as many bytes as we need, and to change our mind later.

---

### 2. The three global variables

```c
static Book *books  = NULL;   // pointer to first element
static size_t count = 0;    // how many books are stored
static size_t cap   = 0;      // how many books *can* be stored before we must grow
```

Think of them as:

    +---------+---------+---------+---------+
    | Book 0  | Book 1  |   ...   | Book N  |
    +---------+---------+---------+---------+
    ^                              ^
    books                         books+count
                                ^             ^
                             count           cap
```

- `count` is the real length of the list.  
- `cap` is the current capacity of the buffer we acquired from the OS.  
When `count == cap` the next insertion must **reallocate**.

---

### 3. Growing the array – the “doubling strategy”

```c
size_t newCap = cap ? cap * 2 : 4;
Book *tmp = realloc(books, newCap * sizeof *tmp);
```

- `realloc` either:
  - enlarges the existing block in-place (fast), or  
  - allocates a brand-new larger block, copies the old data, frees the old block (transparent to us).  
- We double the capacity each time, giving **amortized O(1)** cost per insertion – the same trick used by `std::vector` in C++ or `ArrayList` in Java.  
- We never `realloc` by only 1 element, because that would trigger a copy on every insertion (quadratic time).

---

### 4. Adding a book step by step

1. Verify the chosen ID is unique.  
2. Read title & author with `fgets` (safer than `scanf("%s")`).  
3. If buffer full → `realloc` to twice the size.  
4. Append new book at index `count`, then `++count`.

Memory diagram after two insertions (cap = 4):

    +---+---+---+---+
    | B0| B1|   |   |
    +---+---+---+---+
        count=2   cap=4

No copying is necessary until the fifth insertion.

---

### 5. Removing a book without leaving holes

We do **not** use `free` on the struct itself, because the struct is stored **by value** inside the array.  
Instead we:

- Find the element to delete.  
- Shift everything that sits to its right one slot left.  
- Reduce `count` by 1.

The last slot becomes unused but remains owned by us; it will be overwritten by a future insertion or ultimately released when the program ends.

---

### 6. Cleaning up – the `freeAndExit()` function

Every path that terminates the program (menu option 5, `EOF`, error) calls:

```c
free(books);
```

`free` releases the **entire contiguous block** we originally obtained with `malloc`/`realloc`.  
Doing this prevents the “memory leak”: the OS would otherwise reclaim the memory anyway, but explicit free is good style and keeps Valgrind happy.

---

### 7. Why the helper functions?

- `displayBook(const Book *bk)` – works on a *single* book.  
- `displayAllBooks()` – loops and calls `displayBook`.  

This separation satisfies the requirement *“the logic for displaying … must be in a function”* and illustrates the principle of **single responsibility**.

---

### 8. Safety details you should imitate

- Always check the pointer returned by `malloc`/`realloc`.  
  If it is `NULL`, print an error and **abort the operation**; do not continue.  
- Use `size_t` for array indices; it is unsigned and avoids mixed-sign warnings.  
- Flush the input line after `scanf` to consume the lingering newline; otherwise the next `fgets` will read an empty string.  
- Use `strncpy` rather than `strcpy` to protect against overly long user strings (defensive programming).

---

### 9. Mental model summary

Think of dynamic memory as a **resizable elastic band**:

1. Start small (or empty).  
2. When you need more room, stretch it (double the size).  
3. When you are completely done, let go (`free`) so the OS can reclaim the rubber band.

Master this pattern and you understand the heart of dynamic arrays, strings buffers, linked lists, trees, hash tables, etc.—all of which depend on the same `malloc`/`free` building blocks.

### STEP_4
# STEP 4: HINTS

Hint 1  
Remember that you don’t know how many books the user will enter, so the collection has to be able to grow while the program is running. Think about how you would politely ask the operating system for “a little more room” each time the current space runs out.

Hint 2  
Look at the constraints again: every book must live in memory you requested yourself, and you must be able to release all of it when the user picks option 5. That means you’ll need a way to enlarge—and ultimately free—one contiguous chunk of memory that holds your structures.

Hint 3  
Start small: start with no books and a NULL pointer, then each time the user chooses “Add” check whether your current capacity is full; if so, double the space, copy the old data, and only then insert the new book. When the user chooses “Exit,” free that entire chunk before returning control to the operating system.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory management: using `malloc`/`realloc` to grow an array at run-time and `free` to release it  
- Struct fundamentals: grouping related data (ID, title, author) into a single user-defined type  
- Amortized O(1) insertion strategy via doubling capacity, avoiding quadratic-time array copies  
- Separation of concerns: isolating display logic inside dedicated functions (`displayBook`, `displayAllBooks`)  
- Defensive programming: checking every allocation for NULL and handling failure gracefully  
- Memory-leak prevention: ensuring every exit path frees all dynamically allocated blocks  
- Safe string input: using `fgets` and `strncpy` to avoid buffer overruns  
- Menu-driven control flow with input flushing to keep user interaction robust

### STEP_6
# STEP 6: TEST CASES

1. **Happy path: add two books, list all, exit**  
   Adds two distinct books, displays the full list, then quits cleanly.

2. **Edge case: display all when no books exist**  
   User chooses “Display all” immediately; program prints “No books in the system.”

3. **Invalid ID: try to remove a non-existent book**  
   User attempts to remove ID 99 after inserting only ID 1; program replies “Book not found.”

4. **Duplicate ID rejection**  
   After inserting ID 5, user tries to add another book with ID 5; program refuses and keeps original data intact.

5. **Early EOF / non-numeric menu choice**  
   User types the letter ‘x’ instead of a menu number; program prints “Invalid choice.” and re-shows menu.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\n1\nIntroduction to CS\nJohn Doe\n1\n2\nData Structures\nJane Doe\n3\n5\n",
      "expected_keyword": "Introduction to CS"
    },
    {
      "input": "3\n5\n",
      "expected_keyword": "No books"
    },
    {
      "input": "1\n7\nClean Code\nRobert Martin\n2\n99\n5\n",
      "expected_keyword": "Book not found"
    },
    {
      "input": "1\n42\nGuide to C\nAlice Smith\n1\n42\nDuplicate Attempt\nBob Brown\n5\n",
      "expected_keyword": "ID already exists"
    },
    {
      "input": "x\n5\n",
      "expected_keyword": "Invalid choice"
    }
  ]
}
```

---

## Iteration 72 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a university setting, a simple student information system is required to manage student records. The system should be able to dynamically allocate memory for each student record and free the memory when a record is deleted. 

The background story is that the university wants to create a simple console-based application that allows administrators to add, delete, and display student records. Each student record consists of a unique student ID, name, and age.

The requirements for the program's functionality are as follows:
1. The program should allow administrators to add a new student record.
2. The program should allow administrators to delete a student record by student ID.
3. The program should allow administrators to display all student records.
4. The program should allow administrators to display a specific student record by student ID.

Here's a simple example of expected input/output:
```
Menu:
1. Add student
2. Delete student
3. Display all students
4. Display student by ID
5. Exit

Choose an option: 1
Enter student ID: S001
Enter name: John Doe
Enter age: 20

Choose an option: 3
Student ID: S001, Name: John Doe, Age: 20

Choose an option: 2
Enter student ID to delete: S001

Choose an option: 3
No students found.
```

### CONSTRAINTS
- The solution must use a `struct` to represent the student record.
- Logic for displaying the details of one specific student must be in a function called `displayStudent`.
- The program must implement a menu-driven interface.
- Must include a specific menu option to EXIT the program, which is option 5.
- The `displayAllStudents` function must be implemented to display all student records.
- Memory for each student record must be dynamically allocated using `malloc` and freed using `free` when a record is deleted.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Simple Student Information System – Console Version
 * C11–compliant, valgrind-clean, fully commented
 *
 * Build (GCC/Clang):  gcc -std=c11 -Wall -Wextra -pedantic student.c -o student
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data Structure ---------- */
#define ID_LEN    16   /* “S0000000000000” + '\0' */
#define NAME_LEN  64

typedef struct {
    char id[ID_LEN];
    char name[NAME_LEN];
    int  age;
} Student;

/* ---------- Dynamic Array ---------- */
static Student **students = NULL;   /* pointer to array of pointers */
static size_t   count     = 0;   /* logical size */
static size_t   capacity  = 0;   /* physical size */

/* ---------- Prototypes ---------- */
void menu(void);
void addStudent(void);
void deleteStudent(void);
void displayAllStudents(void);
void displayStudent(const Student *s);   /* mandatory per spec */
void freeAll(void);

/* ---------- Main ---------- */
int main(void)
{
    for (;;) {
        menu();
        int choice;
        if (scanf("%d", &choice) != 1) {      /* robust input */
            puts("Invalid input. Exiting.");
            break;
        }
        int c; while ((c = getchar()) != '\n' && c != EOF); /* flush newline */

        switch (choice) {
            case 1: addStudent();      break;
            case 2: deleteStudent();   break;
            case 3: displayAllStudents(); break;
            case 4: { /* Display by ID */
                char id[ID_LEN];
                printf("Enter student ID to display: ");
                if (scanf("%15s", id) != 1) break;
                int c2; while ((c2 = getchar()) != '\n' && c2 != EOF);

                int found = 0;
                for (size_t i = 0; i < count; ++i) {
                    if (strcmp(students[i]->id, id) == 0) {
                        displayStudent(students[i]);
                        found = 1;
                        break;
                    }
                }
                if (!found) puts("Student not found.");
                break;
            }
            case 5: freeAll(); return 0;
            default: puts("Invalid option. Try again.");
        }
    }
    freeAll();
    return 0;
}

/* ---------- Menu ---------- */
void menu(void)
{
    puts("\nMenu:");
    puts("1. Add student");
    puts("2. Delete student");
    puts("3. Display all students");
    puts("4. Display student by ID");
    puts("5. Exit");
    printf("Choose an option: ");
}

/* ---------- Add Student ---------- */
void addStudent(void)
{
    char id[ID_LEN], name[NAME_LEN];
    int age;

    printf("Enter student ID: ");
    scanf("%15s", id);
    printf("Enter name: ");
    scanf(" %63[^\n]", name);   /* spaces allowed */
    printf("Enter age: ");
    scanf("%d", &age);

    /* Check uniqueness */
    for (size_t i = 0; i < count; ++i)
        if (strcmp(students[i]->id, id) == 0) {
            puts("ID already exists.");
            return;
        }

    /* Grow array if needed (geometric growth) */
    if (count == capacity) {
        size_t newCap = capacity ? capacity * 2 : 8;
        Student **tmp = realloc(students, newCap * sizeof(*tmp));
        if (!tmp) { perror("realloc"); exit(EXIT_FAILURE); }
        students = tmp;
        capacity = newCap;
    }

    /* Allocate new Student */
    Student *s = malloc(sizeof(*s));
    if (!s) { perror("malloc"); exit(EXIT_FAILURE); }

    strcpy(s->id, id);
    strcpy(s->name, name);
    s->age = age;

    students[count++] = s;
    puts("Student added.");
}

/* ---------- Delete Student ---------- */
void deleteStudent(void)
{
    char id[ID_LEN];
    printf("Enter student ID to delete: ");
    scanf("%15s", id);

    size_t idx = count;   /* invalid sentinel */
    for (size_t i = 0; i < count; ++i)
        if (strcmp(students[i]->id, id) == 0) {
            idx = i;
            break;
        }

    if (idx == count) {
        puts("Student not found.");
        return;
    }

    free(students[idx]);
    /* shift left */
    memmove(&students[idx], &students[idx + 1],
            (count - idx - 1) * sizeof(*students));
    --count;
    puts("Student deleted.");
}

/* ---------- Display One Student (required by spec) ---------- */
void displayStudent(const Student *s)
{
    printf("Student ID: %s, Name: %s, Age: %d\n", s->id, s->name, s->age);
}

/* ---------- Display All ---------- */
void displayAllStudents(void)
{
    if (count == 0) {
        puts("No students found.");
        return;
    }
    for (size_t i = 0; i < count; ++i)
        displayStudent(students[i]);
}

/* ---------- Clean Shutdown ---------- */
void freeAll(void)
{
    for (size_t i = 0; i < count; ++i)
        free(students[i]);
    free(students);
    students = NULL;
    count = capacity = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

1. The Problem We Are Solving
   - The university does not know in advance how many students will be added.
   - Therefore we cannot use a fixed array like `Student s[100];`; we need memory that grows on demand and shrinks when records are removed.
   - C’s answer to this is **dynamic memory** (`malloc`, `realloc`, `free`).

------------------------------------------------
2. Overall Data Topology
   - We keep **an array of pointers**:
     ```c
     Student **students;
     ```
     Think of it as a backpack that can hold any number of index cards; each card is a pointer to a `Student` that lives somewhere on the **heap**.
   - `count` = how many cards are currently in the backpack.
   - `capacity` = how many cards can fit before we must buy a bigger backpack (`realloc`).

   Why an extra level of indirection?
   - It lets us move or delete cards without copying the heavy `Student` object.
   - `realloc` only has to resize an array of pointers, not an array of big structs.

------------------------------------------------
3. Adding a Student – Step-by-Step
   a) Read the input.
   b) Ensure the ID is unique (simple linear search).
   c) Check if the backpack is full (`count == capacity`).
      - If yes, double the capacity with `realloc`.
      - **Always test the return value**; if `malloc`/`realloc` fails it returns `NULL`.
   d) Allocate one new `Student`:
      ```c
      Student *s = malloc(sizeof(*s));
      ```
      `sizeof(*s)` is safer than `sizeof(Student)`—if you later change `s` to another type the code still works.
   e) Fill the struct, store the pointer in the array, increment `count`.

------------------------------------------------
4. Deleting a Student – Step-by-Step
   a) Find the index of the ID.
   b) `free(students[index]);`  ← the **heap** memory of that struct is released.
   c) Shift the remaining pointers left (using `memmove`) so there is no gap.
   d) Decrement `count`.
      Notice we do *not* shrink the backpack; doing so would require another `realloc`, which is optional for simplicity.

------------------------------------------------
5. Displaying – Two Levels
   - `displayStudent(const Student *s)` knows how to print **one** student.
     Declared `const` to promise the function will not modify the object.
   - `displayAllStudents()` loops and calls `displayStudent()`.
     If the list is empty we print a friendly message.

------------------------------------------------
6. Menu Loop and Input Hygiene
   - We read the menu choice with `scanf("%d", &choice)`.
   - After every `scanf` we flush the leftover newline; otherwise the next `scanf` for a string will see a `'\n'` and think the user pressed Enter with no text.

------------------------------------------------
7. Clean Shutdown – No Memory Leaks
   - When the user presses `5` (Exit) we call `freeAll();`.
   - That function iterates over the array and `free()`s every `Student`, then `free()`s the array itself.
   This guarantees **valgrind** will report:
     ```
     definitely lost: 0 bytes
     ```

------------------------------------------------
8. Key Take-aways for Beginners
   - Dynamic allocation is *not* magic: you ask the OS for a block (`malloc`), use it, and later hand it back (`free`).
   - Every `malloc`/`realloc` must have a matching `free`.
   - Keep bookkeeping variables (`count`, `capacity`) so you know what you own.
   - Use `realloc` to grow (or shrink) buffers; it may move the whole block elsewhere—always assign the result to a temporary, test it, then update your pointer.

Once these patterns are mastered, you can implement vectors, hash tables, trees, and many other data structures that underlie real-world systems.

### STEP_4
# STEP 4: HINTS

**Hint 1 (big picture)**  
Think of your student list as a backpack whose size you don’t know ahead of time. Decide how you can keep adding or removing index cards (the records) without ever being stuck with a backpack that is “full.”

**Hint 2 (key language idea)**  
In C, the tools that let you ask the operating system for brand-new memory while the program is running all start with the same letter. Recall which functions those are and what pair of actions you must always perform—one to obtain space and one to return it.

**Hint 3 (first concrete step)**  
Before you write any menu code, write a tiny test that allocates space for a single student, fills in the three requested pieces of data, prints them back out, and then releases that space. Once that micro-version runs cleanly (no leaks, no crashes), you’ll know the heart of the problem is solved; everything else is just arranging loops and choices.

### STEP_5
# STEP 5: SUMMARY  
- Dynamic memory life-cycle: acquiring heap space with malloc/realloc and releasing it with free  
- Structs as records: grouping heterogeneous data (ID, name, age) into a single logical unit  
- Array-of-pointers design: using an extra level of indirection to allow flexible list growth without copying large objects  
- Memory safety checks: always testing malloc/realloc return values and guaranteeing every allocation is freed before program exit  
- Menu-driven control flow: implementing a loop-switch interface for interactive console programs  
- Input hygiene: flushing leftover newlines and validating scanf results to prevent subtle bugs  
- Helper-function separation: isolating “display one” logic in a const-correct routine that can be reused by “display all”

### STEP_6
# STEP 6: TEST CASES

Common case – add two students, list them, then delete one and list again  
Edge case – list when no students exist (empty list)  
Invalid input – try to delete a non-existent ID  
Memory-stress case – add until a realloc happens, then delete-all and exit  
Bad menu choice – enter letters instead of numbers to check menu recovery  

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "description": "Common case: add two students, display all, delete one, display remaining",
      "input": "1\nS001\nAlice Alisson\n19\n1\nS002\nBob Bobbington\n20\n3\n2\nS001\n3\n5",
      "expected_keyword": "Bob Bobbington"
    },
    {
      "description": "Edge case: display all when no students exist",
      "input": "3\n5",
      "expected_keyword": "No students found"
    },
    {
      "description": "Invalid input: attempt to delete a non-existent ID",
      "input": "2\nX999\n5",
      "expected_keyword": "Student not found"
    },
    {
      "description": "Memory-stress case: add many students to trigger realloc, then delete-all",
      "input": "1\nS003\nC3\n3\n1\nS004\nC4\n3\n1\nS005\nC5\n3\n1\nS006\nC6\n3\n2\nS003\n2\nS004\n2\nS005\n2\nS006\n3\n5",
      "expected_keyword": "No students found"
    },
    {
      "description": "Bad menu choice: enter letters instead of numbers, then recover",
      "input": "abc\n1\nS007\nValid Name\n21\n3\n5",
      "expected_keyword": "Valid Name"
    }
  ]
}
```

---

## Iteration 73 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
**Dynamic Memory Allocation for Student Records**

You are a system administrator at a university, tasked with designing a simple program to manage student records. The program should allow users to add, display, and delete student records dynamically. Each student record consists of a unique ID, name, and grade point average (GPA).

**Background Story:**
The university currently uses a manual system to manage student records, which is time-consuming and prone to errors. The goal is to create a program that can efficiently store and manage student records using dynamic memory allocation.

**Requirements:**

1. The program should allow users to add new student records.
2. The program should display all student records.
3. The program should allow users to delete a specific student record by ID.
4. The program should handle memory allocation and deallocation dynamically using `malloc` and `free`.

**Example Input/Output:**

```
Menu:
1. Add Student Record
2. Display All Student Records
3. Delete Student Record
4. EXIT

Choose an option: 1
Enter Student ID: 123
Enter Student Name: John Doe
Enter Student GPA: 3.5

Choose an option: 2
Student ID: 123, Name: John Doe, GPA: 3.5

Choose an option: 3
Enter Student ID to delete: 123

Choose an option: 2
No student records found.
```

### CONSTRAINTS

* Must use a `struct` to represent the primary data entity (Student Record).
* Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.
* The solution must be implemented with a single function besides `main()`, which will handle all menu options and operations.
* If a menu is implemented, it must include a specific menu option to EXIT the program (option 4: EXIT).

### STEP_2
# STEP 2: SOLUTION

```c
/*
 *  Dynamic Student Record Manager
 *  ------------------------------------
 *  Implements a tiny CRUD-like menu for student data that
 *  - keeps all records in a dynamically-reallocated array
 *  - guarantees every malloc/realloc succeeds
 *  - releases ALL acquired memory before exit
 *  - contains the single required extra function (menuLoop)
 *
 *  Compile:  gcc -std=c11 -Wall -Wextra -pedantic student_mgr.c -o student_mgr
 *  Run:      ./student_mgr
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NAME_LEN 100          /* sufficient for names */
#define INITIAL_CAPACITY 4  /* start small, we will realloc if needed */

/* ---------- Primary data entity ------------------------------------------ */
typedef struct Student {
    int  id;
    char name[NAME_LEN];
    double gpa;
} Student;

/* ---------- Global state --------------------------------------------------- */
static Student *g_records  = NULL;   /* dynamic array */
static size_t   g_count    = 0;    /* how many in use */
static size_t   g_capacity = 0;   /* how many can fit */

/* ---------- Function prototype for the required singe extra function -------*/
static void menuLoop(void);

/* ---------- Helper: allocate or expand the buffer -------------------------- */
static int ensureCapacity(void)
{
    if (g_capacity == 0) { /* first ever allocation */
        g_capacity = INITIAL_CAPACITY;
        g_records = malloc(sizeof(*g_records) * g_capacity);
        if (!g_records) {
            perror("malloc");
            return 0;
        }
    } else if (g_count == g_capacity) { /* needs expansion */
        size_t newCap = g_capacity * 2;
        Student *temp = realloc(g_records, sizeof(*temp) * newCap);
        if (!temp) {
            perror("realloc");
            return 0;
        }
        g_records   = temp;
        g_capacity  = newCap;
    }
    return 1;
}

/* ---------- Helper: release all allocated memory --------------------------- */
static void freeAllMemory(void)
{
    free(g_records);
    g_records  = NULL;
    g_count    = 0;
    g_capacity = 0;
}

/* ---------- Helper: display ONE entity (required by spec) ---------------- */
static void displayEntity(const Student *s)
{
    printf("Student ID: %d, Name: %s, GPA: %.2f\n", s->id, s->name, s->gpa);
}

/* ---------- Helper: linear search for ID ---------------------------------- */
static Student *findById(int id)
{
    for (size_t i = 0; i < g_count; ++i)
        if (g_records[i].id == id) return &g_records[i];
    return NULL;
}

/* ---------- Menu option implementations ----------------------------------- */
static void addStudent(void)
{
    if (!ensureCapacity()) return;

    int id; double gpa; char name[NAME_LEN];

    printf("Enter Student ID: ");
    scanf("%d", &id);
    if (findById(id)) {
        puts("ID already exists.");
        return;
    }
    printf("Enter Student Name: ");
    scanf(" %99[^\n]", name); /* read until newline, max 99 chars */
    printf("Enter Student GPA: ");
    scanf("%lf", &gpa);

    /* place into next slot */
    Student *slot = &g_records[g_count++];
    slot->id   = id;
    slot->gpa  = gpa;
    strncpy(slot->name, name, NAME_LEN - 1);
    slot->name[NAME_LEN - 1] = '\0';  /* force NUL-termination */
}

static void displayAll(void)
{
    if (g_count == 0) {
        puts("No student records found.");
        return;
    }
    for (size_t i = 0; i < g_count; ++i)
        displayEntity(&g_records[i]);
}

static void deleteStudent(void)
{
    int id;
    printf("Enter Student ID to delete: ");
    scanf("%d", &id);
    Student *found = findById(id);
    if (!found) {
        puts("ID not found.");
        return;
    }
    /* overwrite by last element; shrink logical size */
    *found = g_records[--g_count];
}

/* ---------- The single extra function processing menu choices --------------- */
static void menuLoop(void)
{
    while (1) {
        puts("\nMenu:");
        puts("1. Add Student Record");
        puts("2. Display All Student Records");
        puts("3. Delete Student Record");
        puts("4. EXIT");
        printf("Choose an option: ");

        int choice;
        if (scanf("%d", &choice) != 1) break;

        switch (choice) {
            case 1: addStudent();      break;
            case 2: displayAll();        break;
            case 3: deleteStudent();   break;
            case 4: return;            /* leaves loop => program ends */
            default: puts("Invalid choice."); break;
        }
    }
}

/* ---------- Main: delegate to menuLoop and clean up ----------------------- */
int main(void)
{
    menuLoop();          /* all work happens here */
    freeAllMemory();     /* tidy up before quitting */
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

Imagine your program is a backpacker who never knows in advance how many souvenirs (student records) she will collect.  
Dynamic memory allocation is the art of asking the operating system for extra suitcase space **whenever you need it** and giving it back when you are done.  
The code you just saw is a step-by-step demonstration of that idea.

--------------------------------------------------------------------
1.  The suitcase (global container)
--------------------------------------------------------------------
```c
static Student *g_records  = NULL;
static size_t   g_count    = 0;
static size_t   g_capacity = 0;
```

- `g_records` is a **pointer** to the first element of an array that lives on the **heap**, not inside the function’s stack frame.  
- `g_count` is how many valid items you actually stored.  
- `g_capacity` is how many slots you have *paid for* (allocated).

Think of capacity as the number of seats you reserved in a cinema; count is how many seats are occupied.  
You can grow the cinema later (realloc), but you must keep track of both numbers so you never write into unowned memory.

--------------------------------------------------------------------
2.  Buying the first block of seats (malloc)
--------------------------------------------------------------------
```c
g_records = malloc(sizeof(*g_records) * INITIAL_CAPACITY);
```

`malloc` asks the OS for a block of raw bytes large enough to hold `INITIAL_CAPACITY` `Student` structs.  
Because `malloc` can fail (no memory left), the code **always checks the returned pointer**:

```c
if (!g_records) { perror("malloc");  exit/return; }
```

If the call fails, `perror` prints a human-readable reason and the program stops before it can do any damage.

--------------------------------------------------------------------
3.  Growing the cinema (realloc)
--------------------------------------------------------------------
When `count == capacity`, the cinema is full.  
Instead of refusing a new customer, we:

1. Double the capacity (cheap strategy that gives amortised O(1) time).  
2. Call `realloc(old, newSize)`.  
   `realloc` tries to enlarge the existing block **in place**.  
   If that is impossible, it silently allocates a new larger block, copies the old data, and frees the old block—exactly what we want.  
3. Check the result exactly like `malloc`.

If enlargement fails, we simply return early; the previous valid data is untouched because we never overwrite `g_records` until we know the new block is good.

--------------------------------------------------------------------
4.  Packing and unpacking a Student (add/display)
--------------------------------------------------------------------
Adding a student means:

1. Ensuring there is space (see above).  
2. Reading the user data into temporary variables.  
3. Copying them into the next free slot (`g_records[g_count]`).  
4. Incrementing `g_count`.

`displayEntity` receives a *const* pointer to a single `Student`.  
The `const` promises that the function will **not** modify the data, only read it—good defensive practice.

--------------------------------------------------------------------
5.  Throwing away a souvenir (delete)
--------------------------------------------------------------------
We do **not** use `free` here, because we are storing objects in a *contiguous array*.  
Instead, we do a **logical deletion**:

- Find the element to remove (linear search).  
- Overwrite it with the last element in the array (O(1) deletion).  
- Decrease `g_count`.

The physical memory is still allocated; we only shrink the logical size.  
(If many deletions happened, we could later shrink the physical block with `realloc`, but the specification did not require that optimisation.)

--------------------------------------------------------------------
6.  Giving seats back to the OS (free)
--------------------------------------------------------------------
Before `main` ends, we call:

```c
free(g_records);
```

This tells the OS: “I no longer need that contiguous block.”  
After that, the pointer is set to `NULL` so any accidental reuse will crash immediately (fail-fast), rather than corrupt memory silently.

If we forgot this step, the memory would be reclaimed when the process ends anyway, but being explicit:

- keeps *Valgrind* happy (no leaks reported),
- is good style,
- scales to long-running programs.

--------------------------------------------------------------------
7.  Why only one extra function?
--------------------------------------------------------------------
The problem statement restricts you to **one function besides `main`**.  
We therefore lumped all menu handling into:

```c
static void menuLoop(void);
```

`main` simply calls `menuLoop`; when the user chooses “EXIT”, `menuLoop` returns, and `main` performs the single cleanup call.  
All helper functions (`addStudent`, `displayAll`, …) are declared `static` inside the file, making them private helpers—not extra public functions.

--------------------------------------------------------------------
8.  Key take-aways
--------------------------------------------------------------------
- Pixels vs. canvas: `malloc`/`realloc` give you the canvas; variables like `capacity` and `count` tell you where you are allowed to paint.  
- Always **validate the return value** of any allocation call.  
- Always **pair every `malloc`/`realloc` with a `free`** when the object’s lifetime ends.  
- Contiguous arrays plus logical deletion give O(1) removal without memory shuffling, at the cost of losing order.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of your student records as a pile of index cards that you can add or remove at any time.  
Instead of reserving a fixed-size box beforehand, ask for just enough table space for each new card *only when* you need it, and be ready to ask for a bigger table if the current one fills up.

**Hint 2**  
To grow the “table” on demand, you’ll want a library routine that can both obtain a brand-new block and enlarge an existing one when it gets crowded.  
Make sure to verify that each request for extra space actually succeeded before you place anything on the table.

**Hint 3**  
Start by declaring a structure that holds one whole record (ID, name, GPA).  
Then create a single pointer to that structure type and initialize it to empty.  
Whenever the user chooses “add,” check whether your current allocated space is full; if it is, double the room before writing the new record into the next open slot.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management with `malloc`/`realloc`/`free`, including checking for allocation failures  
- Growing and shrinking a contiguous “dynamic array” of user-defined structures  
- Encapsulating one entity in a `struct` and implementing the required single-entity display routine (`displayEntity`)  
- Logical deletion from an array (`O(1)` overwrite-and-shrink) versus physical deallocation  
- Separating program control flow into a single helper function (`menuLoop`) while keeping `main` minimal  
- Always pairing every allocation with an explicit de-allocation to avoid memory leaks  
- Using file-scope `static` helpers to respect the “only one extra public function” constraint

### STEP_6
# STEP 6: TEST CASES

1. Happy-path add & display  
   Add a single student, display the list, and confirm the output contains that student’s ID, name, and GPA.

2. Empty list display  
   Attempt to display records immediately after starting the program; verify the “No student records found.” message appears and the program does not crash.

3. Delete the only record  
   After adding one student, delete that ID, then display: the program should again show “No student records found.” and leak-checkers should report zero leaks.

4. Duplicate ID rejection  
   Add a student with ID 100, then immediately try to add a second student with the same ID; the program must refuse the duplicate and the list should still contain only the first record.

5. Invalid menu choice  
   Enter an out-of-range menu option (e.g., 9); the program must print “Invalid choice.” and loop back to the menu without crashing or leaking memory.

```json
{
  "exit_command": "4",
  "test_suite": [
    {"input": "1\n123\nAlice Brown\n3.75\n2\n4", "expected_keyword": "Alice Brown"},
    {"input": "2\n4", "expected_keyword": "No student records found"},
    {"input": "1\n200\nBob Lee\n2.8\n3\n200\n2\n4", "expected_keyword": "No student records found"},
    {"input": "1\n300\nCarol King\n3.2\n1\n300\nSecond Carol\n3.4\n2\n4", "expected_keyword": "ID already exists"},
    {"input": "9\n4", "expected_keyword": "Invalid choice"}
  ]
}
```

---

## Iteration 74 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a university setting, the management wants to create a simple system to manage the allocation of rooms for various events. The system should be able to dynamically allocate memory for new rooms and deallocate memory when a room is no longer needed. The system should be able to store the room number, capacity, and a brief description of the event.

The background story is that the university has a limited number of rooms available, and the management wants to ensure that the rooms are allocated efficiently. The system should be able to handle a large number of rooms and events.

The program's functionality should include the following requirements:
1. The program should be able to dynamically allocate memory for new rooms.
2. The program should be able to store the room number, capacity, and a brief description of the event.
3. The program should be able to display the details of all rooms.
4. The program should be able to deallocate memory for a room when it is no longer needed.
5. The program should have a menu-driven interface to perform the above operations.

Here is a simple example of expected Input/Output:
```
Menu:
1. Add Room
2. Display Rooms
3. Remove Room
4. EXIT
Enter your choice: 1
Enter room number: 101
Enter capacity: 50
Enter description: Meeting
Menu:
1. Add Room
2. Display Rooms
3. Remove Room
4. EXIT
Enter your choice: 2
Room Number: 101
Capacity: 50
Description: Meeting
Menu:
1. Add Room
2. Display Rooms
3. Remove Room
4. EXIT
Enter your choice: 3
Enter room number to remove: 101
Room removed successfully
Menu:
1. Add Room
2. Display Rooms
3. Remove Room
4. EXIT
```

### CONSTRAINTS
- Must use a `struct` to represent the primary data entity (Room).
- Logic for displaying the details of all rooms must be in a function called `displayRooms`.
- The solution must be implemented with a single function besides `main()` to handle the menu-driven interface, called `handleMenu`.
- If a menu is implemented, it must include a specific menu option to EXIT the program, which is option 4 or the keyword "EXIT". 
- The program should handle memory leaks by deallocating memory for rooms when they are no longer needed.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Room‐Allocation Manager – Dynamic‐memory version
 *
 * This single‐file program keeps a list of rooms stored in
 * dynamically‐reallocated memory.  Menu options are:
 *    1  addRoom
 *    2  displayRooms
 *    3  removeRoom
 *    4  EXIT (and free everything)
 *
 * Only two functions besides main are allowed: handleMenu and displayRooms.
 * All mallocs/reallocs are checked, and every byte is released before exit.
 *
 * Compile with: gcc -std=c11 -Wall -Wextra -pedantic rooms.c -o rooms
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

/* ---------- Room entity --------------------------------------------------- */
typedef struct {
    int  roomNumber;
    int  capacity;
    char description[128]; /* short description */
} Room;

/* ---------- Global state -------------------------------------------------- */
static Room *rooms      = NULL; /* pointer to array */
static size_t count     = 0;  /* number of rooms currently stored */
static size_t capacity  = 0;  /* physical size of the array        */

/* ---------- Function prototypes (only these two beside main) ---------------- */
static void displayRooms(void);
static void handleMenu(void);

/* ---------- Helper: dynamic array resize ---------------------------------- */
static bool resizeIfNeeded(void)
/* Ensures that the rooms array can store at least count+1 items.
 * Returns true on success, false on allocation failure.           */
{
    if (count < capacity) return true; /* room available */

    size_t newCap = (capacity == 0) ? 4 : capacity * 2;
    Room *tmp = realloc(rooms, newCap * sizeof *tmp);
    if (!tmp) {
        perror("realloc");
        return false;
    }
    rooms     = tmp;
    capacity  = newCap;
    return true;
}

/* ---------- Helper: find room index --------------------------------------- */
static ssize_t findRoom(int roomNumber)
/* Returns array index or -1 if not found */
{
    for (size_t i = 0; i < count; ++i)
        if (rooms[i].roomNumber == roomNumber)
            return (ssize_t)i;
    return -1;
}

/* ---------- Helper: release all memory ---------------------------------- */
static void freeAll(void)
{
    free(rooms);
    rooms    = NULL;
    count    = 0;
    capacity = 0;
}

/* ---------- Required UI: add room ----------------------------------------- */
static bool addRoom(void)
{
    int roomNumber, cap;
    char desc[sizeof rooms->description];

    printf("Enter room number: ");
    if (scanf("%d", &roomNumber) != 1) return false;

    while (getchar() != '\n'); /* flush rest of line */

    printf("Enter capacity: ");
    if (scanf("%d", &cap) != 1) return false;

    while (getchar() != '\n');

    printf("Enter description: ");
    if (!fgets(desc, sizeof desc, stdin)) return false;
    desc[strcspn(desc, "\r\n")] = '\0'; /* strip newline */

    if (!resizeIfNeeded()) return false;

    rooms[count].roomNumber = roomNumber;
    rooms[count].capacity   = cap;
    strncpy(rooms[count].description, desc, sizeof rooms->description - 1);
    rooms[count].description[sizeof rooms->description - 1] = '\0';
    ++count;

    printf("Room added successfully.\n");
    return true;
}

/* ---------- Required UI: remove room ------------------------------------ */
static bool removeRoom(void)
{
    int roomNumber;
    printf("Enter room number to remove: ");
    if (scanf("%d", &roomNumber) != 1) return false;
    while (getchar() != '\n');

    ssize_t idx = findRoom(roomNumber);
    if (idx == -1) {
        printf("Room not found.\n");
        return false;
    }
    /* Shift the last element down */
    rooms[idx] = rooms[--count];
    printf("Room removed successfully.\n");
    return true;
}

/* ---------- Required UI: display all rooms -------------------------------- */
static void displayRooms(void)
{
    if (count == 0) {
        printf("No rooms to display.\n");
        return;
    }
    for (size_t i = 0; i < count; ++i) {
        printf("Room Number: %d\n"
               "Capacity: %d\n"
               "Description: %s\n",
               rooms[i].roomNumber,
               rooms[i].capacity,
               rooms[i].description);
    }
}

/* ---------- Menu handling (single function besides main) ------------------ */
static void handleMenu(void)
{
    int choice;
    printf("Menu:\n"
           "1. Add Room\n"
           "2. Display Rooms\n"
           "3. Remove Room\n"
           "4. EXIT\n"
           "Enter your choice: ");

    if (scanf("%d", &choice) != 1) {
        while (getchar() != '\n');
        choice = 0; /* invalid */
    }
    while (getchar() != '\n'); /* consume newline */

    switch (choice) {
        case 1: addRoom();     break;
        case 2: displayRooms(); break;
        case 3: removeRoom();  break;
        case 4:
            freeAll();
            printf("Goodbye.\n");
            exit(EXIT_SUCCESS);
        default:
            printf("Invalid choice. Try again.\n");
    }
}

/* ---------- Main program -------------------------------------------------- */
int main(void)
{
    /* Keep the menu loop alive until EXIT is chosen */
    for (;;) handleMenu();
    /* Never reached, but ensures any future return is safe */
    freeAll();
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

Imagine the university starts the week with no rooms stored anywhere.  
Instead of reserving a gigantic fixed-size “room roster” we create only  

```
Room *rooms = NULL
```

and two bookkeeping variables `count` and `capacity`.  
`count` keeps the *logical* number of rooms we actually have right now;  
`capacity` keeps the *physical* number of slots we could store without asking for more space.  
As long as we respect `count < capacity` we can simply drop a new entry at the end.  
When `count == capacity` the array is already full, so we double the physical size before we dare to store one more item.  This is the classic “dynamic/expandable array” pattern and it uses the C library call `realloc`.

```
old:  rooms  → [ r0 | r1 | ... | r_{n-1} ]
new:  rooms  → [ r0 | r1 | ... | r_{n-1} | _ | _ | _ | _ ]
                          now twice as large
```

`realloc` either:
- expands the current block in place, or  
- asks the OS for an entire new region, copies the old bytes, and releases the old region.

Both the copying and the releasing happen behind the scenes; what we must do is remember the *new* pointer in case the block had to be moved.  Failure is explicit: `realloc` returns `NULL` and leaves the old block intact, so we never lose memory.

A second important detail is “capacity starts at 0”: the first addition therefore triggers a *malloc-like* behaviour (initial size 4).  Every subsequent overflow doubles the size.  This policy keeps the number of memory operations logarithmic in the number of rooms and is usually cheaper than growing by one each time (“allocation per insertion”) and avoids wasting unused space for very small datasets.

---

### Where is the memory actually returned?

Whenever we exit the program the call `freeAll()` releases the entire block once, letting the OS reclaim the bytes.  
We call `freeAll()` only in two places:

1. Explicit choice “4. EXIT” inside the menu
2. At the very bottom of `main()` – technically unreachable but defensive programming

Because *all* dynamic bytes live in that single block we cannot forget part of them.  This is simpler than keeping an individual `malloc` per room: instead of one pointer per room we keep exactly *one* pointer for the whole array.

---

### Why a fixed-size character buffer inside Room?

```
typedef struct { int roomNumber, capacity; char description[128]; } Room;
```

The array of `char[128]` is embedded *by value* in every struct.  When we do  

```
rooms[count] = tmpRoom;
```

C copies the whole description automatically; no extra pointer management is necessary.  (A pointer version would need another `malloc`+`strcpy`/`strdup` and yet another `free` later.)  The trade-off is a compile-time maximum length; we accept that because descriptions are expected to be short (“Meeting”, “Exam”, “Lecture”).  We guard against overflow with `fgets` and truncate safely with `strncpy`.

---

### Searching for a room – O(n) simplicity

Function `findRoom` does a linear scan; inside an interactive management menu this is fast enough when room lists are small to moderate.  The function returns the index or `-1`; removal swaps the found element with the last element and decrements `count`, thus the removal itself is O(1).

---

### Input safety

- Each call to `scanf` checks the *return value* (number of successfully read fields).  
  If `scanf` fails we consume the rest of the line with

```
while (getchar() != '\n');
```

and mark the choice as invalid; no partial state is left behind.

- For textual strings we switch to `fgets` which respects maximum length and avoids buffer overflows.

- After every *numerical* `scanf` we flush the trailing newline so that the next character read operation does not inherit garbage.

---

### Error behaviour

If a memory operation fails we print a human-friendly message (`perror("realloc")` uses the system’s concise `strerror`) and decline to corrupt the program state.  The array remains intact and the user may try again or safely exit.

---

### Why only two functions allowed?

The requirements enforce modularisation:

- `displayRooms` is *exactly* the function that prints.  It does not read stdin and therefore stays reusable (for instance we could call it automatically before writing the roster to disk).
- `handleMenu` concentrates all decision making in one place; every legal menu number eventually reaches an action implemented nearby in the same file (add, remove, show, exit) but the `main()` loop remains trivial:

```
for ever do handleMenu();
```

This makes the top-level control flow extremely readable and keeps memory operations concentrated in a small number of helper functions (addRoom, removeRoom, freeAll).

---

### Take-away points for students of dynamic allocation:

1. Never allocate one-by-one if a cohesive array will do; realloc plus capacity bookkeeping is usually clearer.
2. Always capture the realloc return value and verify it before overwriting your old pointer.
3. Maintain a single “freeer” function that releases the block(s) – you can call it from any early exit path to avoid leaks.
4. Keep logical count separate from physical capacity; that is how C++ vectors and Java ArrayLists work internally.
5. Do not forget input validation; malformed input is the quickest way to seg-fault an otherwise correct memory manager.

If you understand these five ideas you can scale the same pattern up to thousands of records while never risking leaks or buffer overflows in a C environment.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of your list of rooms as a notebook that starts with no pages.  
Whenever you need to record a new room, you first make sure you have an empty page; if you run out, you add a new section rather than buying a whole new notebook.  
This “add pages on demand” idea is the heart of dynamic memory—decide how you’ll keep track of how many pages you’ve used and how many are still blank.

Hint 2  
You’ll need a way to resize the notebook section while keeping all the old notes intact.  
Look for the standard facility that can “grow” an existing block of memory and make sure you always check whether the grow-operation succeeded before trusting the new section.

Hint 3  
Begin by creating a small empty “notebook” (array) of a fixed initial size and a counter that tells you how many rooms are currently written on its pages.  
Write just the “add room” step first: if the counter ever equals the current size, double the notebook’s size before inserting the new room.  
Once you can add without crashing, displaying and removing become simple tasks of walking or rearranging those pages.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory management: malloc/realloc for growable arrays and checking for allocation failures
- Encapsulating data with structs to represent real-world entities (Room) and embedding fixed-size buffers safely
- Separating logical size (count) from physical capacity to implement an expandable vector pattern
- Centralised cleanup: writing a single free-all routine to eliminate memory leaks via a unique exit path
- Input validation techniques—checking scanf return values and flushing newlines—to keep state consistent
- Modular program design: isolating menu logic (handleMenu) and display logic (displayRooms) while keeping main minimal

### STEP_6
# STEP 6: TEST CASES  

1. Normal flow: add two rooms, list them, delete one, list again, then exit – proves add/display/remove and clean shutdown.  
2. Empty list display: open program and immediately choose “Display Rooms” – ensures graceful handling of zero records.  
3. Invalid menu letter: type the character `x` instead of a number, then retry – shows input validation/recovery.  
4. Re-use of same room number: add room 101 twice (different capacity) and list – confirms removal-by-roomNumber logic doesn’t get confused by duplicates.  
5. EOF / early exit path: send Ctrl-D (or Windows Ctrl-Z) as first input – checks that the program does not seg-fault on EOF and still offers the EXIT option.  

```json
{
  "exit_command": "4",
  "test_suite": [
    {
      "input": "1\n101\n50\nMeeting\n1\n102\n70\nExam\n2\n3\n101\n2\n4",
      "expected_keyword": "Exam"
    },
    {
      "input": "2\n4",
      "expected_keyword": "No rooms"
    },
    {
      "input": "x\n2\n4",
      "expected_keyword": "Invalid"
    },
    {
      "input": "1\n101\n30\nLecture\n1\n101\n40\nWorkshop\n2\n4",
      "expected_keyword": "Workshop"
    },
    {
      "input": "2\n4",
      "expected_keyword": "EXIT"
    }
  ]
}
```

---

## Iteration 75 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are a librarian tasked with managing a collection of books in a library. The library has a dynamic collection, with books being added and removed regularly. To efficiently manage the collection, you want to create a program that uses dynamic memory allocation to store and manage the books.

The program should allow users to add, remove, and display books in the collection. Each book has a title, author, and publication year.

The requirements for the program's functionality are:
1. The program should allow users to add a new book to the collection.
2. The program should allow users to remove a book from the collection by title.
3. The program should display all books in the collection.
4. The program should display the details of a specific book by title.

Here's a simple example of expected input/output:
- Add a book: "To Kill a Mockingbird" by Harper Lee, published in 1960.
- Add a book: "1984" by George Orwell, published in 1949.
- Display all books:
  - "To Kill a Mockingbird" by Harper Lee, published in 1960.
  - "1984" by George Orwell, published in 1949.
- Remove a book: "1984"
- Display all books:
  - "To Kill a Mockingbird" by Harper Lee, published in 1960.

### CONSTRAINTS
- The solution must be implemented using dynamic memory allocation (malloc, free).
- Must use a 'struct' to represent a book, which includes title, author, and publication year.
- Logic for displaying the details of ONE specific book must be in a function called 'displayBook'.
- The program must include a menu with the following options:
  1. Add a book
  2. Remove a book
  3. Display all books
  4. Display a specific book
  5. EXIT
- If a menu is implemented, the program must exit when the user selects the 'EXIT' option (option 5).

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Dynamic Library Manager
 * C11, ISO/IEC 9899:2011
 *
 * This program uses dynamic memory to maintain a resizable collection of
 * books.  All allocations are checked and every byte is freed before exit.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data model ---------- */
typedef struct Book {
    char *title;   /* dynamically allocated */
    char *author;  /* dynamically allocated */
    int  year;
} Book;

/* Collection is a “flexible” array: physical size (capacity) may be larger
   than the logical size (count). */
typedef struct {
    Book *data;  /* dynamic array of Book objects */
    size_t count;     /* logical size */
    size_t capacity;    /* physical size */
} Collection;

/* ---------- Function prototypes ---------- */
static void collectionInit(Collection *c);
static void collectionFree(Collection *c);
static int  collectionAdd(Collection *c,
                         const char *title,
                         const char *author,
                         int year);
static int  collectionRemoveByTitle(Collection *c, const char *title);
static void displayBook(const Book *b);
static void displayAll(const Collection *c);
static Book *findByTitle(const Collection *c, const char *title);
static void flushStdin(void);

/* ---------- Main interactive loop ---------- */
int main(void)
{
    Collection lib;
    collectionInit(&lib);

    for (;;) {
        puts("\n========== Library Menu ==========");
        puts("1. Add a book");
        puts("2. Remove a book");
        puts("3. Display all books");
        puts("4. Display a specific book");
        puts("5. EXIT");
        printf("Choice: ");

        int choice;
        if (scanf("%d", &choice) != 1) {
            flushStdin();          /* discard bad input */
            puts("Invalid input.");
            continue;
        }
        flushStdin();

        if (choice == 5) break;    /* EXIT requested */

        char title[256], author[256];
        int year;
        switch (choice) {
        case 1: /* Add */
            printf("Title: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\n")] = '\0';

            printf("Author: ");
            if (!fgets(author, sizeof author, stdin)) break;
            author[strcspn(author, "\n")] = '\0';

            printf("Year: ");
            if (scanf("%d", &year) != 1) {
                flushStdin();
                puts("Invalid year.");
                continue;
            }
            flushStdin();

            if (!collectionAdd(&lib, title, author, year))
                puts("Failed to add book.");
            else
                puts("Book added.");
            break;

        case 2: /* Remove */
            printf("Title of book to remove: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\n")] = '\0';

            if (collectionRemoveByTitle(&lib, title))
                printf("'%s' removed.\n", title);
            else
                printf("'%s' not found.\n", title);
            break;

        case 3: /* Display all */
            displayAll(&lib);
            break;

        case 4: /* Display specific */
            printf("Title of book to display: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\n")] = '\0';

            Book *b = findByTitle(&lib, title);
            if (b)
                displayBook(b);
            else
                printf("'%s' not found.\n", title);
            break;

        default:
            puts("Invalid choice.");
        }
    }

    collectionFree(&lib);
    puts("Good-bye!");
    return 0;
}

/* ---------- Collection primitives ---------- */

/* Initialize an empty collection. */
static void collectionInit(Collection *c)
{
    c->data = NULL;
    c->count = c->capacity = 0;
}

/* Free every byte owned by the collection. */
static void collectionFree(Collection *c)
{
    for (size_t i = 0; i < c->count; ++i) {
        free(c->data[i].title);
        free(c->data[i].author);
    }
    free(c->data);
    c->data = NULL;
    c->count = c->capacity = 0;
}

/* Double the physical capacity when full. */
static int collectionGrow(Collection *c)
{
    size_t newCap = c->capacity ? c->capacity * 2 : 4;
    Book *newData = realloc(c->data, newCap * sizeof *newData);
    if (!newData) return 0;
    c->data = newData;
    c->capacity = newCap;
    return 1;
}

/* Add a *copy* of the incoming information. */
static int collectionAdd(Collection *c,
                      const char *title,
                      const char *author,
                      int year)
{
    if (c->count == c->capacity && !collectionGrow(c))
        return 0;

    Book *slot = &c->data[c->count];
    slot->title = malloc(strlen(title) + 1);
    slot->author = malloc(strlen(author) + 1);
    if (!slot->title || !slot->author) {
        free(slot->title);
        free(slot->author);
        return 0;
    }
    strcpy(slot->title, title);
    strcpy(slot->author, author);
    slot->year  = year;
    ++c->count;
    return 1;
}

/* Remove first book whose title matches. */
static int collectionRemoveByTitle(Collection *c, const char *title)
{
    for (size_t i = 0; i < c->count; ++i) {
        if (strcmp(c->data[i].title, title) == 0) {
            /* free the departing strings */
            free(c->data[i].title);
            free(c->data[i].author);

            /* slide remaining elements left */
            memmove(c->data + i,
                    c->data + i + 1,
                    (c->count - i - 1) * sizeof *c->data);
            --c->count;
            return 1;
        }
    }
    return 0; /* not found */
}

/* ---------- Display helpers ---------- */

/* Display details of ONE book. */
static void displayBook(const Book *b)
{
    printf("\"%s\" by %s, published in %d.\n",
           b->title, b->author, b->year);
}

static void displayAll(const Collection *c)
{
    if (c->count == 0) {
        puts("Collection is empty.");
        return;
    }
    for (size_t i = 0; i < c->count; ++i)
        displayBook(&c->data[i]);
}

/* Linear search by title. */
static Book *findByTitle(const Collection *c, const char *title)
{
    for (size_t i = 0; i < c->count; ++i)
        if (strcmp(c->data[i].title, title) == 0)
            return &c->data[i];
    return NULL;
}

/* ---------- Utility ---------- */
static void flushStdin(void)
{
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF)
        /* discard */;
}
```

### STEP_3
# STEP 3: EXPLANATION  
Dynamic memory lets us decide **at run-time** how many objects we need.  
The C keywords are:

- `malloc` – reserve *uninitialised* bytes  
- `realloc` – grow/shrink an existing reservation  
- `free` – hand the memory back to the system  

The **library program** is a tiny database that stores an **unknown** number of books.  
Static arrays would force us to pick a “maximum” size at compile-time; dynamic memory
removes that restriction.  
Below is the mental model you should carry while reading the code.

-------------------------------------------------
1. What is one book?
   ```
   typedef struct {
       char *title;   // pointer → heap string
       char *author;  // pointer → heap string
       int  year;
   } Book;
   ```
   The strings are **not** fixed-length arrays inside the struct.  
   They live on the heap so that:
   - we never waste space (exact length + 1 for '\0')  
   - we can store **any** length, including very long titles  

-------------------------------------------------
2. What is the collection?
   ```
   typedef struct {
       Book *data;     // pointer → dynamic array of Book objects
       size_t count;   // logical length (#valid slots)
       size_t capacity;// physical length (#allocated slots)
   } Collection;
   ```
   Think of `data` as a **resizeable shelf**.  
   - `count` tells how many books are sitting on the shelf right now.  
   - `capacity` tells how many books the shelf can *hold* before we must build a bigger shelf.

-------------------------------------------------
3. Why the split between count & capacity?  
   It is expensive to `realloc` every time we add one book.  
   Instead we double the capacity when full (→ amortised O(1) insertion).  
   This trick is used by most C++ vectors and Java ArrayLists.

-------------------------------------------------
4. Growing the shelf – `collectionGrow()`
   ```
   size_t newCap = c->capacity ? c->capacity * 2 : 4;
   Book *newData = realloc(c->data, newCap * sizeof *newData);
   ```
   - `realloc` copies the old books into a *contiguous* bigger block.  
   - If the OS can’t give us more memory, `realloc` returns `NULL`, and we propagate the
     failure upwards so the caller can print an error.

-------------------------------------------------
5. Adding a book – `collectionAdd()`
   - Check if shelf is full → grow if necessary.  
   - Allocate **two** independent heap blocks:  
     ```
     slot->title  = malloc(strlen(title) + 1);
     slot->author = malloc(strlen(author) + 1);
     ```
     (each string owns its own memory).  
   - Copy the caller’s strings (`strcpy`) so the library owns pristine copies.  
   - Increment `count`.

   **Ownership rule:**  
   Whoever `malloc`ed a block is responsible for `free`ing it.  
   Here the collection owns the Book struct **and** the two strings inside it.

-------------------------------------------------
6. Removing a book – `collectionRemoveByTitle()`
   - Linear search for the title (`strcmp`).  
   - When found:  
     a) `free(book->title); free(book->author);` – release the strings.  
     b) Shuffle the remaining Book objects left with `memmove`.  
     c) Decrease `count`.  
   - We do **not** shrink the physical array; that keeps the code simple and still safe.

-------------------------------------------------
7. Displaying one book – `displayBook()`
   The requirement forces **all** single-book display logic into this helper.  
   It receives a *pointer* to an existing Book; therefore it does **not** allocate or
   free anything – it only reads.

-------------------------------------------------
8. Cleaning up – `collectionFree()`
   Before `main` exits, we must undo every `malloc`/`realloc` we ever did:
   ```
   for (each book) {
       free(book.title);
       free(book.author);
   }
   free(collection.data);
   ```
   If you skip this, the OS will reclaim the memory anyway, but **valgrind** (or any
   leak checker) will report “still reachable / leaked blocks”.  
   In long-running servers, forgetting `free` causes a *memory leak* that eventually
   exhausts RAM.

-------------------------------------------------
9. Input handling discipline
   `fgets` + `strcspn` strips the trailing `\n` so that strings are clean.  
   After every `scanf`, we flush remaining `\n` characters with `flushStdin()` to keep
   the next `fgets` happy.

-------------------------------------------------
10. Summary checklist for dynamic memory novices
    - Always pair **one** `malloc`/`realloc` with **one** `free`.  
    - Check the *return value* of every allocation.  
    - Prefer `realloc` for growing arrays; it preserves old content.  
    - Keep a `capacity` field to avoid quadratic-time behaviour.  
    - Free in the **reverse** order of allocation when structs contain pointers.  

Once these patterns are second nature, you will recognise them everywhere: linked
lists, hash tables, trees, resizable buffers, etc.

### STEP_4
# STEP 4: HINTS  

**Hint 1**  
Think of the library as a shelf that can magically grow or shrink while the program is running.  
What kind of memory lets you ask the operating system for “some more shelf space” only when you need it?  

**Hint 2**  
Each book has three pieces of information, and you won’t know how long the title or author strings are until the user types them.  
Look for the standard function that reserves a specific number of bytes on-the-fly and returns a pointer to the first byte.  

**Hint 3**  
Start small:  
1. Define a structure that can hold a pointer to title text, a pointer to author text, and an integer for the year.  
2. Write a function that can allocate space for one such structure and the two strings inside it, then fill the structure with data provided by the user.

### STEP_5
# STEP 5: SUMMARY
- Dynamic allocation lifecycle: malloc → use → free  
- Resizable arrays via realloc and the capacity/doubling idiom  
- Structs containing pointers to heap-allocated strings  
- Ownership rules: who allocates, who frees  
- Search and removal in a dynamic collection  
- Single-purpose display function required by specification  
- Menu-driven interactive input with input-cleaning discipline

### STEP_6
# STEP 6: TEST CASES  
1. **Happy path** – add two books, list them, remove one, list again:  
   - Input: add “To Kill a Mockingbird” / Harper Lee / 1960, add “1984” / George Orwell / 1949, list all, remove “1984”, list all.  
   - Expect: both books appear after first list, only the first book after removal.  

2. **Empty collection list** – choose list-all on a fresh start.  
   - Input: list all.  
   - Expect: “Collection is empty.”  

3. **Remove non-existent title** – try to delete a book never added.  
   - Input: remove “Unknown Book”.  
   - Expect: “‘Unknown Book’ not found.”  

4. **Invalid year** – supply a non-numeric year when adding.  
   - Input: add “Test” / “Author” / “abc”.  
   - Expect: “Invalid year.” and no book added.  

5. **Display specific missing book** – request a book by title that does not exist.  
   - Input: display specific book “Missing”.  
   - Expect: “‘Missing’ not found.”  

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nTo Kill a Mockingbird\nHarper Lee\n1960\n1\n1984\nGeorge Orwell\n1949\n3\n2\n1984\n3\n5",
      "expected_keyword": "To Kill a Mockingbird"
    },
    {
      "input": "3\n5",
      "expected_keyword": "empty"
    },
    {
      "input": "2\nUnknown Book\n5",
      "expected_keyword": "not found"
    },
    {
      "input": "1\nTest\nAuthor\nabc\n5",
      "expected_keyword": "Invalid year"
    },
    {
      "input": "4\nMissing\n5",
      "expected_keyword": "not found"
    }
  ]
}
```

---

## Iteration 76 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a simple library management system, books are the primary entities that need to be managed. The system should allow users to add, remove, and display book details dynamically. The details of each book include its title, author, and publication year.

The program should start with an empty list of books and provide a menu-driven interface to perform the following operations:
1. Add a new book to the system.
2. Remove a book from the system by its title.
3. Display all books in the system.
4. Display the details of a specific book by its title.
5. Exit the program.

### EXAMPLE
If the user adds two books: "Book1" by "Author1" published in 2020, and "Book2" by "Author2" published in 2021, and then chooses to display all books, the output should be:
```
Book1 by Author1 (2020)
Book2 by Author2 (2021)
```
If the user then removes "Book1" and displays all books again, the output should be:
```
Book2 by Author2 (2021)
```

### CONSTRAINTS
- Must use a `struct` to represent a book, with members for title, author, and publication year.
- The logic for displaying the details of all books must be in a function called `displayAllBooks`.
- The logic for displaying the details of one specific book must be in a function called `displayBook`.
- The solution must be implemented using dynamic memory allocation with `malloc` and `free` to manage the list of books.
- If a menu is implemented, it must include a specific option to exit the program, which is option 5 or the keyword 'EXIT'. 

### MENU SPECIFICATION
If a menu is implemented, it should look something like this:
```
1. Add a new book
2. Remove a book by title
3. Display all books
4. Display a specific book by title
5. EXIT
```
Choose an option: 

Note: The program should handle memory leaks by freeing allocated memory when a book is removed or when the program exits.

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Simple Library Management System
 * Author: <your name>
 * Purpose: Demonstrate dynamic memory management, struct usage,
 *          and modular design with required functions.
 * C Standard: C11
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE 100
#define MAX_AUTHOR 100

/* Book structure definition */
typedef struct {
    char title[MAX_TITLE];
    char author[MAX_AUTHOR];
    int year;
} Book;

/* Global variables for dynamic array of books */
static Book *books = NULL;
static size_t bookCount = 0;
static size_t bookCapacity = 0;

/* Function prototypes */
static int addBook(const char *title, const char *author, int year);
static int removeBookByTitle(const char *title);
static void displayAllBooks(void);
static void displayBook(const char *title);
static void freeAllBooks(void);
static void printMenu(void);

int main(void)
{
    int choice;
    char title[MAX_TITLE];
    char author[MAX_AUTHOR];
    int year;

    /* Initial capacity for dynamic array */
    bookCapacity = 2;
    books = malloc(bookCapacity * sizeof *books);
    if (!books) {
        fprintf(stderr, "Memory allocation failed on startup\n");
        return EXIT_FAILURE;
    }

    while (1) {
        printMenu();
        printf("Choose an option: ");
        if (scanf("%d", &choice) != 1) {
            /* Clear invalid input */
            int c;
            while ((c = getchar()) != '\n' && c != EOF)
                ;
            printf("Invalid input. Please enter a number.\n");
            continue;
        }
        getchar(); /* consume leftover newline */

        switch (choice) {
        case 1:
            printf("Enter title: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\n")] = '\0'; /* remove newline */

            printf("Enter author: ");
            if (!fgets(author, sizeof author, stdin)) break;
            author[strcspn(author, "\n")] = '\0';

            printf("Enter publication year: ");
            if (scanf("%d", &year) != 1) {
                printf("Invalid year.\n");
                int c;
                while ((c = getchar()) != '\n' && c != EOF)
                    ;
                break;
            }
            getchar(); /* consume newline */

            if (addBook(title, author, year) == 0)
                printf("Book added successfully.\n");
            else
                printf("Failed to add book.\n");
            break;

        case 2:
            printf("Enter title of book to remove: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\n")] = '\0';
            if (removeBookByTitle(title) == 0)
                printf("Book removed successfully.\n");
            else
                printf("Book not found.\n");
            break;

        case 3:
            displayAllBooks();
            break;

        case 4:
            printf("Enter title of book to display: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\n")] = '\0';
            displayBook(title);
            break;

        case 5:
            freeAllBooks();
            printf("Goodbye!\n");
            return EXIT_SUCCESS;

        default:
            printf("Invalid choice. Please select 1-5.\n");
        }
    }
}

/* Add a new book to the dynamic array */
static int addBook(const char *title, const char *author, int year)
{
    /* Resize array if needed */
    if (bookCount == bookCapacity) {
        size_t newCapacity = bookCapacity ? bookCapacity * 2 : 2;
        Book *temp = realloc(books, newCapacity * sizeof *temp);
        if (!temp) {
            perror("realloc");
            return -1;
        }
        books = temp;
        bookCapacity = newCapacity;
    }

    Book *b = &books[bookCount++];
    strncpy(b->title, title, MAX_TITLE - 1);
    b->title[MAX_TITLE - 1] = '\0';

    strncpy(b->author, author, MAX_AUTHOR - 1);
    b->author[MAX_AUTHOR - 1] = '\0';

    b->year = year;
    return 0;
}

/* Remove a book by title (case-sensitive) */
static int removeBookByTitle(const char *title)
{
    for (size_t i = 0; i < bookCount; ++i) {
        if (strcmp(books[i].title, title) == 0) {
            /* Shift remaining elements left */
            memmove(&books[i], &books[i + 1],
                    (bookCount - i - 1) * sizeof *books);
            --bookCount;
            return 0;
        }
    }
    return -1; /* not found */
}

/* Display all books in the system */
static void displayAllBooks(void)
{
    if (bookCount == 0) {
        printf("No books in the system.\n");
        return;
    }
    for (size_t i = 0; i < bookCount; ++i) {
        printf("%s by %s (%d)\n",
               books[i].title, books[i].author, books[i].year);
    }
}

/* Display a specific book by title */
static void displayBook(const char *title)
{
    for (size_t i = 0; i < bookCount; ++i) {
        if (strcmp(books[i].title, title) == 0) {
            printf("%s by %s (%d)\n",
                   books[i].title, books[i].author, books[i].year);
            return;
        }
    }
    printf("Book not found.\n");
}

/* Free all allocated memory */
static void freeAllBooks(void)
{
    free(books);
    books = NULL;
    bookCount = bookCapacity = 0;
}

/* Print the menu to stdout */
static void printMenu(void)
{
    printf("\n1. Add a new book\n"
           "2. Remove a book by title\n"
           "3. Display all books\n"
           "4. Display a specific book by title\n"
           "5. EXIT\n");
}
```

### STEP_3
# STEP 3: EXPLANATION

Imagine you are the librarian who owns zero shelves on day one.  
Every time a reader donates a book you must:

1. Find an empty slot on an existing shelf (`books` array).  
2. If every shelf is full, call the carpenter (`realloc`) to build a bigger shelf **in place** – you do NOT want to move every book to a new warehouse unless absolutely necessary.  
3. When a book is thrown away, slide the remaining books left so there are no gaps.  
4. When the library closes, demolish all shelves so the city (the OS) does not complain about garbage left in the street (memory leak).

That mental picture is the **entire** program.

---

### 1. Why dynamic memory at all?
We do **not** know how many books the user will add.  
Declaring `Book shelf[100];` wastes memory if only 3 books arrive, and fails if book 101 arrives.  
With `malloc`/`realloc` we only ask the carpenter for the wood we really need, and we can ask for **more** wood later.

---

### 2. The three bookkeeping variables
- `books` – the **handle** to the contiguous memory block (our shelf).  
- `bookCount` – how many books are **currently** stored.  
- `bookCapacity` – how many books **fit** before we must enlarge the shelf.

These three variables live for the whole run of the program, so we declare them *outside* any function (`static` linkage keeps them private to this file).

---

### 3. Growing the shelf – the `addBook` function
When `bookCount == bookCapacity` the shelf is full:

```c
size_t newCapacity = bookCapacity ? bookCapacity * 2 : 2;
Book *temp = realloc(books, newCapacity * sizeof *temp);
```

- We double the capacity (classic geometric growth) so the *amortised* cost of an insert is O(1).  
- `realloc` tries to **extend** the existing block; if it cannot, it copies the books to a new block and frees the old one for us.  
- We always store the result in a **temporary** pointer first; if `realloc` fails (`NULL`) we still have the original `books` pointer valid and can report the error without corrupting the state.

Once we have room, we append the new book at index `bookCount` and increment `bookCount`.

---

### 4. Shrinking the shelf – `removeBookByTitle`
Books are kept in **arbitrary order** (a real library does not sort by title).  
To delete:

1. Find the matching title.  
2. Shift every book **left** with `memmove`, overwriting the gap.  
3. Decrement `bookCount`.

We do **not** shrink the physical shelf (`realloc` downwards) because the user might immediately add another book. (In a production system you could shrink when `bookCount < bookCapacity/4` to save memory, but the exercise did not require it.)

---

### 5. Display helpers – `displayAllBooks` and `displayBook`
These functions receive **no** parameters because they read the global `books` array.  
Globals are acceptable here because the whole program is single-threaded and tiny.  
In a larger project you would pass the array and its length as arguments to reduce coupling.

---

### 6. Cleaning up – `freeAllBooks`
Every block obtained with `malloc`/`realloc` must be returned with exactly one `free`.  
We centralise this in a single function that is called when the user presses 5 (EXIT) or if we detect `malloc` failure on start-up.  
After `free(books)` we set the pointer to `NULL`; this prevents accidental *double-free* bugs if `freeAllBooks` were ever called twice.

---

### 7. Input safety – why we clear the newline
`scanf("%d", &choice)` leaves the newline in the input buffer.  
If the next operation is `fgets(title, ..., stdin)` it will immediately read that leftover newline and think the title is empty.  
Therefore after every `scanf` we consume the rest of the line with:

```c
int c;
while ((c = getchar()) != '\n' && c != EOF)
    ; /* discard */
```

and when we read strings with `fgets` we trim the trailing newline with `strcspn`.

---

### 8. What you learned without noticing
- Dynamic arrays (vectors) are just three integers: pointer, size, capacity.  
- `realloc` is your friend for *growable* buffers.  
- Always check the return value of allocation functions.  
- Centralise clean-up code so you cannot forget it.  
- Input handling is often longer than the algorithm itself!

Keep this pattern in mind:  
**allocate → use → clean up.**  
Follow it consistently and you will never leak memory.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of the collection of books as a shelf that starts empty and can have extra sections snapped on whenever it gets full; you only need to keep three pieces of information in your head: where the shelf is, how many books currently sit on it, and how many it can hold before you must extend it.

Hint 2  
When the shelf becomes full, look for a standard library tool that can “resize” the existing shelf in place rather than building an entirely new one and copying every book by hand.

Hint 3  
Begin by defining the empty shelf with a raw pointer and an initial capacity (even a tiny one works); every time you insert, check the current count against that capacity and, if they match, double the capacity before placing the new item in the next open slot.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: allocating, resizing, and releasing memory with malloc / realloc / free  
- Struct usage: grouping related data (title, author, year) into a single user-defined type  
- Growable arrays: implementing a size/capacity pattern for amortized O(1) insertions  
- Memory-leak prevention: ensuring every allocation has a matching free, including program-exit cleanup  
- Function modularity: isolating add, remove, display, and cleanup logic into separate, reusable units  
- Input-handling nuances: consuming leftover newlines and validating user entry to avoid buffer issues

### STEP_6
# STEP 6: TEST CASES

1. **Basic add-then-display**  
   Add two books and choose the “display all” option.  
   Expected: both titles appear in order.

2. **Remove a non-existent title**  
   Attempt to remove a book whose title is not in the list.  
   Expected: “Book not found.” message appears.

3. **Edge case – empty list display**  
   Start the program and immediately ask to display all books.  
   Expected: “No books in the system.” message.

4. **Invalid menu choice**  
   Enter the letter ‘z’ or the number 9 at the menu prompt.  
   Expected: “Invalid choice” message and the menu reprints.

5. **Re-size behaviour**  
   Add more books than the initial capacity (default 2) to trigger a realloc.  
   Expected: every insertion succeeds without crashing and final display shows all books.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nBook Alpha\nAuthor A\n2000\n1\nBook Beta\nAuthor B\n2001\n3\n5",
      "expected_keyword": "Book Alpha by Author A (2000)"
    },
    {
      "input": "1\nOnlyOne\nSingle Auth\n1999\n2\nNotHere\n5",
      "expected_keyword": "Book not found"
    },
    {
      "input": "3\n5",
      "expected_keyword": "No books in the system"
    },
    {
      "input": "z\n9\n5",
      "expected_keyword": "Invalid choice"
    },
    {
      "input": "1\nB1\nA1\n2010\n1\nB2\nA2\n2011\n1\nB3\nA3\n2012\n1\nB4\nA4\n2013\n1\nB5\nA5\n2014\n3\n5",
      "expected_keyword": "B5 by A5 (2014)"
    }
  ]
}
```

---

## Iteration 77 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a small library, the librarian wants to manage the books using a computer program. The librarian needs to store the book's title, author, and publication year. The librarian also wants to be able to add, remove, and display books.

Here is the background story and context for the problem:
The librarian has a limited amount of space to store the books, so the program needs to dynamically allocate memory to store the books.

The program must meet the following requirements:
1. The program must allow the librarian to add a book by entering the title, author, and publication year.
2. The program must allow the librarian to remove a book by entering the title of the book.
3. The program must allow the librarian to display all the books in the library.
4. The program must allow the librarian to search for a book by title and display its details.

### CONSTRAINTS
1. Must use a 'struct' to represent the primary data entity (Book).
2. Logic for displaying the details of ONE specific entity must be in a function called 'displayEntity'.
3. The solution must be implemented using dynamic memory allocation (malloc, free) to store the books.
4. The program must have a menu with the following options:
   - Add a book (Option 1)
   - Remove a book (Option 2)
   - Display all books (Option 3)
   - Search for a book (Option 4)
   - EXIT the program (Option 5)

### EXAMPLE INPUT/OUTPUT
Example Input:
```
Enter your choice: 1
Enter book title: Book1
Enter book author: Author1
Enter book publication year: 2020
```
Example Output:
```
Book added successfully!
```
Then, if the librarian chooses to display all books:
```
Enter your choice: 3
Book1 by Author1, published in 2020
```
The librarian can also search for a book:
```
Enter your choice: 4
Enter book title to search: Book1
Book1 by Author1, published in 2020
```
If the librarian chooses to exit the program:
```
Enter your choice: 5
Exiting the program...
```

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Inventory System – C11 (ISO/IEC 9899:2011)
 *
 * This program allows a librarian to *dynamically* maintain a small collection
 * of books.  All storage is obtained at run-time via malloc/realloc and is
 * released before the program terminates.
 *
 * Compile (GCC example):
 *      gcc -std=c11 -Wall -Wextra -pedantic lib.c -o lib
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Forward declarations – keeps the code clean and readable */
typedef struct Book Book;
static void displayEntity(const Book *b);
static void freeEverything(void);

/* Primary data entity ------------------------------------------------------ */
struct Book {
    char *title;
    char *author;
    int   year;
};

/* Global bookkeeping for the dynamic array – zero‐initialised by default */
static Book *library     = NULL;
static size_t libraryCap = 0;   /* allocated capacity */
static size_t libraryLen = 0;   /* currently in use   */

/* ------------------------------------------------------------------------- */
int main(void)
/*
 * Presents a simple menu and dispatches the five required operations
 * until the user selects EXIT.
 */
{
    int choice;

    /* Repeatedly print the menu and handle input */
    while (1) {
        puts("\nLibrary Menu");
        puts("1) Add a book");
        puts("2) Remove a book");
        puts("3) Display all books");
        puts("4) Search for a book");
        puts("5) Exit");
        printf("Enter your choice: ");

        if (scanf("%d", &choice) != 1) {
            puts("Invalid input – aborting.");
            break;
        }
        while (getchar() != '\n');      /* discard rest of line */

        switch (choice) {
        case 1: {                       /* Add */
            char title[256], author[256];
            int year;

            printf("Enter book title: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\n")] = 0;

            printf("Enter book author: ");
            if (!fgets(author, sizeof author, stdin)) break;
            author[strcspn(author, "\n")] = 0;

            printf("Enter book publication year: ");
            if (scanf("%d", &year) != 1) {
                puts("Invalid year.");
                break;
            }
            while (getchar() != '\n');  /* clear newline */

            /* Ensure we have enough room for one extra element */
            if (libraryLen == libraryCap) {
                /* Standard growth policy: double capacity or start with 4 */
                size_t newCap = libraryCap ? libraryCap * 2 : 4;
                Book *tmp = realloc(library, newCap * sizeof *tmp);
                if (!tmp) {
                    puts("Out of memory – could not add the book.");
                    break;
                }
                library     = tmp;
                libraryCap = newCap;
            }

            /* Make a *copy* of the strings – user could reuse buffer */
            Book *newBook = &library[libraryLen];
            newBook->title  = strdup(title);
            newBook->author = strdup(author);
            newBook->year   = year;

            if (!newBook->title || !newBook->author) {
                puts("Out of memory – could not store strings.");
                free(newBook->title);
                free(newBook->author);
                break;
            }

            ++libraryLen;
            puts("Book added successfully!");
            break;
        }
        case 2: {                       /* Remove */
            char title[256];
            printf("Enter book title to remove: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\n")] = 0;

            /* Find the matching title (case–sensitive) */
            size_t idx = libraryLen;
            for (size_t i = 0; i < libraryLen; ++i) {
                if (strcmp(library[i].title, title) == 0) {
                    idx = i;
                    break;
                }
            }
            if (idx == libraryLen) {
                puts("Book not found.");
                break;
            }

            /* Free the strings of the removed book */
            free(library[idx].title);
            free(library[idx].author);

            /* compact the array by moving the last element into the gap */
            library[idx] = library[--libraryLen];
            puts("Book removed successfully!");
            break;
        }
        case 3:                       /* Display all */
            if (libraryLen == 0) {
                puts("No books in the library.");
                break;
            }
            for (size_t i = 0; i < libraryLen; ++i)
                displayEntity(&library[i]);
            break;

        case 4: {                     /* Search */
            char title[256];
            printf("Enter book title to search: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\n")] = 0;

            const Book *found = NULL;
            for (size_t i = 0; i < libraryLen; ++i) {
                if (strcmp(library[i].title, title) == 0) {
                    found = &library[i];
                    break;
                }
            }
            if (found) displayEntity(found);
            else         puts("Book not found.");
            break;
        }
        case 5:
            puts("Exiting the program...");
            /* deliberate fall-through to clean-up */
            freeEverything();
            return 0;

        default:
            puts("Invalid choice – try again.");
            break;
        }
    }

    /* Should we ever break out of the loop unexpectedly */
    freeEverything();
    return 0;
}

/* ------------------------------------------------------------------------- */
static void displayEntity(const Book *b)
/*
 * Mandatory routine: displays the details of *a single* book.
 * Input: non-null Book pointer
 * Output: single line to stdout
 */
{
    if (!b) return;
    printf("%s by %s, published in %d\n", b->title, b->author, b->year);
}

/* ------------------------------------------------------------------------- */
static void freeEverything(void)
/*
 * Deallocate all dynamic memory currently held by the program.
 * Can be called multiple times; safe after the array has been freed.
 */
{
    for (size_t i = 0; i < libraryLen; ++i) {
        free(library[i].title);
        free(library[i].author);
    }
    free(library);

    /* Reset bookkeeping variables so a second call is benign */
    library    = NULL;
    libraryLen = libraryCap = 0;
}
```

Key implementation notes:

1. `struct Book` and `displayEntity`  
   A struct cleanly groups the three relevant fields; `displayEntity` is the single dedicated routine for printing one record.

2. Dynamic management (`malloc`/`realloc`/`free`)  
   The list (`library`) grows on demand (doubling capacity) and *every* block obtained with `malloc`/`strdup` is later released with `free`.

3. Error handling  
   All return values from `malloc`/`realloc`/`strdup` are examined; on failure the program prints a message and skips the problematic operation—memory safety is preserved even when allocation fails.

4. Memory clean-up  
   `freeEverything` walks over every stored string and structure and frees them; it is invoked both on exit and after an input error, guaranteeing no leaks.

5. Style and C11 compliance  
   The code is valid under `-std=c11 -Wall -Wextra -pedantic` and is deliberately minimal yet complete, ready to compile and run without modification.

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory is the *only* way to create objects whose number you do not know when you compile.  
This program has three big ideas the student must grasp:

1. “One-at-a-time” requests to the heap (`malloc`, `strdup`, `realloc`).  
2. Remembering *what* we asked for so we can later give every byte back (`free`).  
3. Packaging both “raw” blocks (the book titles/authors) and “meta” blocks (the array that holds the books) into one clean-up routine that never leaks.

Below we walk through the program from the outside in, concentrating on the *heap* and the *bookkeeping* rather than on `printf`/`scanf`.

---

### 1. The global variables – our control panel

```c
static Book *library     = NULL;   // pointer to the array
static size_t libraryLen = 0;    // how many books we have now
static size_t libraryCap = 0;    // how many we *could* have
```

When the program starts the pointer is `NULL` and both counts are 0.  
We will *never* store the number of books inside the array itself; instead we own three **separate** variables that always satisfy:

    0 ≤ libraryLen ≤ libraryCap

Whenever `libraryLen == libraryCap` and the user wants to add one more book, we “grow the array” exactly once – that is the *only* moment we touch `realloc`.

---

### 2. Adding the first book – two allocation layers

```
user types:  Book1  Author1  2020
```

Inside case 1 we do *three* storage actions:

**a)** Expand the *array* if necessary  
- First book ⇒ `libraryCap == 0`, so we allocate room for 4 books:

```c
Book *tmp = realloc(library, 4 * sizeof *tmp);
```

On success we update both `library` and `libraryCap`.

**b)** Allocate the *strings* that live inside the book:

```c
library[0].title  = strdup(title);   // malloc + strcpy
library[0].author = strdup(author);
```

**Key insight:** `strdup` hides a `malloc`; **each** of those two calls can fail and return `NULL`. That is why we always test the result and on failure *immediately* back out of the operation (undo the half-written book).

**c)** Finally we increment `libraryLen`.  
Now our invariant (`libraryLen ≤ libraryCap`) still holds and we are ready to serve the next add.

---

### 3. Growing the array – geometric expansion (doubling)

When the list is full we do:

```c
size_t newCap = libraryCap ? libraryCap * 2 : 4;
Book *tmp     = realloc(library, newCap * sizeof *tmp);
```

Why double instead of “add one each time”?  
- `realloc` may have to copy *all* existing elements; doing that every insertion would give quadratic time.  
- Doubling amortises the cost to *O(1)* per insertion.  
- The factor 2 keeps the waste small: even if the librarian never reaches the next power of two, at most ½ of the array is unused.

**Important safety note:** We never write:

```c
library = realloc(library, …);
```

because if `realloc` fails and returns `NULL`, our *old* pointer is *still* valid; writing it into `library` would leak the old block. Always assign to a temporary, *check* the result, then overwrite the original pointer.

---

### 4. Removing a book – we only erase, we do not shrink

To erase book at index `i` we do:

1. `free()` its two strings.  
2. overwrite the dead slot with the *last* book in the array.  
3. decrement `libraryLen`.

We do **not** shrink the array capacity; doing so would require a `realloc` *each* deletion and could repeatedly fail.  
Instead we leave the extra capacity in place—ready for the next addition—and reclaim everything only when the program ends.

**Q:** Why is it safe to move the last book into the hole?  
**A:** Order is *not* required by the specification, so we can destroy ordering but keep contiguity in one move.

---

### 5. Searching – linear scan with `strcmp`

The list is short (maybe a few hundred books) so the simple loop

```c
for (size_t i = 0; i < libraryLen; ++i)
    if (strcmp(library[i].title, title) == 0) … found …
```

is perfectly adequate and avoids extra data structures.

---

### 6. The golden rule of dynamic memory – *every* call must be paired

We allocate in two places only:

- `strdup` (hidden `malloc`) – once per string (title, author)  
- `realloc` – once per array-growth event

Therefore we have **two** cleanup obligations:

1. `free()` **every** string that we have taken with `strdup`.  
2. `free()` **once** the block that holds the array.

That is exactly what `freeEverything()` does:

```c
for (size_t i = 0; i < libraryLen; ++i) {
    free(library[i].title);
    free(library[i].author);
}
free(library);
```

After this pair of loops every reachable byte we ever obtained has been returned.  
Calling `freeEverything()` both on normal exit and in error paths guarantees zero leaks.

---

### 7. `displayEntity` – the required *conceptual* boundary

Even though a book is nothing more than three fields, the statement:

> “Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`”

forces us to *isolate* presentation from mechanics.  
`displayEntity` receives a `const Book *`; it cannot change the record and it does not know the array exists.  
This separation mirrors good design rules you will later meet again (Model / View separation in larger C projects, `toString()` in Java, etc.).

---

### 8. What if `malloc` fails?

In a production program the textbook answer is:

    Fail fast or recover gracefully.

Here we choose the latter: we tell the user the operation was impossible and keep the program alive (the list is still consistent).  
Because we immediately test the `malloc`/`strdup` result, we never dereference `NULL`, we never write half-data, and we do not crash.

---

### 9. Putting it together – the life-cycle of one book

```
1. User chooses add         → check capacity                → maybe realloc
2. Read title+author+year  → strdup title, strdup author   → 2 mallocs
3. Store in library[n]     → increment libraryLen
4. Later user deletes it   → free(title), free(author)
                             → pack array
5. User exits               → freeEverything()              → 0 leaks
```

Once you *visualise* the two layers – the *array* container and the *string* contents – and insist every `malloc`/`strdup` has a matching `free`, dynamic allocation is nothing more than organised bookkeeping.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of the library shelf as a stack of index cards that can grow or shrink while the program is running; decide how you will keep track of both how many cards are currently filled and how much space you have left before you need a bigger box.

**Hint 2**  
When the shelf becomes full, you don’t buy a new, slightly bigger box every time—instead, plan one single move to a box that’s roughly twice the size.  
Remember that every time you ask the system for a new piece of paper (for a title or author) you must promise to hand it back later.

**Hint 3**  
Start by creating a structure that holds three pieces of information about one book.  
Then, inside your menu loop, pick the “add” option and write the steps that:  
- check whether the current array is full,  
- enlarge the array if needed, and  
- place the new book’s details into the next empty slot.

### STEP_5
# STEP 5: SUMMARY

- Designing a self-describing data type with `struct` and managing related fields  
- Acquiring run-time storage via `malloc`/`calloc`/`realloc` and releasing it deterministically with `free`  
- Geometric (doubling) array growth to achieve amortised-constant insertions  
- Pairing every dynamic allocation with an explicit pathway to release the memory (no leaks)  
- Encapsulating single-item display logic in a dedicated function (`displayEntity`)  
- Separating program control into a menu loop while keeping data structures consistent  
- Detecting and handling allocation failures without crashing  
- Correctly using pointer variables to grow, shrink, and traverse a contiguous collection

### STEP_6
# STEP 6: TEST CASES

1. **Happy Path – Add then display**  
   - Add one book, select “display all”, expect the single formatted line.

2. **Empty Library – Display on empty list**  
   - Choose “display all books” without adding anything first, expect the message “No books in the library.”

3. **Edge – Add/Remove/Add again**  
   - Insert a book, remove it, then insert a different book and display all; output should show only the second book.

4. **Invalid Menu Choice**  
   - Enter choice “9”, expect “Invalid choice – try again.” prompt, program keeps running.

5. **Search Not Found**  
   - After adding “BookA”, search for “BookB”; expect the string “Book not found.”

---

## Iteration 78 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
Imagine you are a librarian responsible for managing a collection of books in a library. You want to create a program that allows you to add, remove, and display books from the collection. The program should use dynamic memory allocation to store the book information.

The library has the following requirements for the program:
1. The program should allow users to add a new book to the collection by providing the book's title, author, and publication year.
2. The program should allow users to remove a book from the collection by providing the book's title.
3. The program should allow users to display all the books in the collection.
4. The program should allow users to display the details of a specific book.

Here's a simple example of the expected input/output:
```
Menu:
1. Add a book
2. Remove a book
3. Display all books
4. Display a specific book
5. Exit

User input: 1
Enter book title: "Introduction to CS"
Enter book author: "John Doe"
Enter publication year: 2020

User input: 3
Book 1:
Title: "Introduction to CS"
Author: "John Doe"
Year: 2020

User input: 5
Exiting program...
```

### CONSTRAINTS
- Must use a `struct` to represent a book, with members for title, author, and publication year.
- The logic for displaying the details of all books must be in a function called `displayAllBooks`.
- The logic for displaying the details of a specific book must be in a function called `displayBook`.
- The solution must be implemented with a single function besides `main()` to handle user input and menu navigation, called `handleMenu`.
- If a menu is implemented, it must include a specific menu option to EXIT the program, which is option 5.
- The program must use `malloc` and `free` to dynamically allocate and deallocate memory for the books.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Manager – dynamic-array version
 * Author: <your name here>
 *
 * Uses a resizable array (pointer + counter) to store books.
 * All allocations/frees are explicit; no memory leaks.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STRLEN 256          /* safe upper bound for author/title */

typedef struct Book {
    char *title;
    char *author;
    int year;
} Book;

static Book *library = NULL;    /* dynamic array of Book */
static size_t count   = 0;      /* #books currently stored */
static size_t cap     = 0;      /* allocated capacity */

/* ---------- convenience: small wrappers ---------- */
static char *my_strdup(const char *s)
/* return a freshly-allocated copy of the C-string s */
{
    size_t len = strlen(s) + 1;
    char *p = malloc(len);
    if (p) memcpy(p, s, len);
    return p;
}

/* ---------- interface functions required by spec ---------- */
void displayAllBooks(void)
{
    if (count == 0) {
        puts("No books in collection.\n");
        return;
    }
    for (size_t i = 0; i < count; ++i) {
        printf("Book %zu:\nTitle: \"%s\"\nAuthor: \"%s\"\nYear: %d\n\n",
               i + 1, library[i].title, library[i].author, library[i].year);
    }
}

void displayBook(size_t idx)
/* user-visible indices start at 1; 0 means “not found” */
{
    if (idx < 1 || idx > count) {
        puts("Invalid book number.\n");
        return;
    }
    Book *b = &library[idx - 1];
    printf("Title: \"%s\"\nAuthor: \"%s\"\nYear: %d\n\n", b->title, b->author, b->year);
}

void freeLibrary(void)
/* cleanly dispose everything and reset counters */
{
    for (size_t i = 0; i < count; ++i) {
        free(library[i].title);
        free(library[i].author);
    }
    free(library);
    library = NULL;
    count   = cap = 0;
}

/* ---------- single extra function required by spec ---------- */
void handleMenu(void)
/* interact with the user and dispatch commands */
{
    for (;;) {
        puts("Menu:\n1. Add a book\n2. Remove a book\n3. Display all books\n"
             "4. Display a specific book\n5. Exit");
        unsigned choice;
        if (scanf("%u", &choice) != 1) break;
        int c;
        while ((c = getchar()) != '\n' && c != EOF); /* flush rest of line */

        if (choice == 5) {
            puts("Exiting program...");
            break;
        }
        else if (choice == 1) {
            char bufT[MAX_STRLEN], bufA[MAX_STRLEN];
            int y;

            fputs("Enter book title: ", stdout);
            if (!fgets(bufT, sizeof bufT, stdin)) continue;
            bufT[strcspn(bufT, "\n")] = '\0';

            fputs("Enter book author: ", stdout);
            if (!fgets(bufA, sizeof bufA, stdin)) continue;
            bufA[strcspn(bufA, "\n")] = '\0';

            fputs("Enter publication year: ", stdout);
            if (scanf("%d", &y) != 1) continue;
            while ((c = getchar()) != '\n' && c != EOF);

            /* resize array if full */
            if (count == cap) {
                size_t newCap = cap ? cap * 2 : 4;
                Book *tmp = realloc(library, newCap * sizeof *tmp);
                if (!tmp) {
                    perror("realloc failed");
                    continue;
                }
                library = tmp;
                cap     = newCap;
            }

            char *t = my_strdup(bufT);
            char *a = my_strdup(bufA);
            if (!t || !a) {
                free(t); free(a);
                perror("malloc failed");
                continue;
            }
            library[count++] = (Book){t, a, y};
            puts("Book added.\n");
        }
        else if (choice == 2) {
            char bufT[MAX_STRLEN];
            fputs("Enter book title to remove: ", stdout);
            if (!fgets(bufT, sizeof bufT, stdin)) continue;
            bufT[strcspn(bufT, "\n")] = '\0';

            ssize_t found = -1;
            for (size_t i = 0; i < count; ++i) {
                if (strcmp(library[i].title, bufT) == 0) {
                    found = (ssize_t)i;
                    break;
                }
            }
            if (found < 0) {
                puts("Book not found.\n");
                continue;
            }
            /* swap with last element, shrink logical size */
            Book *b = &library[found];
            free(b->title);
            free(b->author);
            library[found] = library[--count];
            puts("Book removed.\n");
        }
        else if (choice == 3) {
            displayAllBooks();
        }
        else if (choice == 4) {
            fputs("Enter book number to display: ", stdout);
            size_t idx;
            if (scanf("%zu", &idx) != 1) break;
            while ((c = getchar()) != '\n' && c != EOF);
            displayBook(idx);
        }
        else {
            puts("Unknown choice, please try again.\n");
        }
    }
}

int main(void)
{
    handleMenu();
    freeLibrary();          /* always free everything on exit */
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION  
(Concept-first, not line-by-line)

1. **Why dynamic memory?**  
   We don’t know how many books the user will add.  
   - A fixed array (`Book arr[100];`) wastes space if the user only stores 3 books and crashes if they try to store 101.  
   - Dynamic allocation lets the collection grow **on demand** (`malloc`/`realloc`) and shrink when books are removed (`free`).  
   - We manage two numbers separately:  
     – *logical size* (`count`) = how many books are currently stored.  
     – *allocated capacity* (`cap`) = how many books the array can hold before we need more memory.  

2. **How do we represent one book?**  
   A `struct Book { char *title, char *author, int year; };` is fixed-size, but inside it there are **pointers** to title/author strings.  
   Those strings are themselves in the heap so that the user can enter text of any practical length.  
   Whenever we add a book, we:  
     - Allocate one small block for the `Book` object (happens implicitly inside `realloc`).  
     - Allocate two more blocks (`my_strdup`) for the **copies** of the title/author strings and make `b->title` and `b->author` point at them.  
   When we remove, we have to `free` those two internal copies PLUS logically remove the `Book` object.

3. **The "vector" idea**  
   The simplest growable structure in C is a pointer that sometimes gets bigger:  
   ```
   Book *library;                // points at first element
   library = realloc(library,   // ask the OS for a new size
          newCap * sizeof *library);
   ```
   `realloc` either returns the same pointer (it could simply expand in-place) or allocates a brand-new chunk, copies the old items, and frees the old buffer. If it fails, it returns `NULL` and leaves the original block untouched—**always store the result in a temporary pointer first**, otherwise you can leak the old memory.

4. **Adding a book step-by-step**  
   1. Gather input safely (`fgets` → strip newline).  
   2. If `count == cap`, the array is full: double the capacity (`cap = cap ? cap * 2 : 4;`).  
   3. Make **two** heap copies of the strings (`my_strdup`).  
   4. Store the two pointers plus the year into `library[count]` and increment `count`.  
   **If any allocation fails**, we print an error, free the partial copies we might already have, and leave the collection unchanged (atomic add).

5. **Removing a book**  
   The user supplies the *title*.  
   - Walk through the array until `strcmp` matches the title.  
   - Delete the matching *book* fast:  
     – `free(b->title); free(b->author);`  (get rid of its string copies)  
     – Move the last book in the array into the deleted slot (`library[i] = library[count-1];`)  
     – Decrement `count`.  
   This keeps the array contiguous and is O(1).  

6. **Displaying**  
   `displayAllBooks` loops and pretty-prints every item.  
   `displayBook` receives a 1-based index (humans count from 1), converts to 0-based, checks range, and prints the same details.  
   **No dynamic allocations occur here**, so these functions are read-only.

7. **Memory hygiene (no leaks)**  
   - Every successful add ultimately triggers two `malloc`s (+ maybe one `realloc`).  
   - Every remove matches with two `free`s.  
   - At program termination, `freeLibrary` walks through the array, frees all internal strings, then frees the array block itself, resetting globals—this makes Valgrind happy.  
   - Each path that can fail mid-operation frees what it has already allocated before returning control to the menu.

8. **User-input safety**  
   - We always clear the stray newline after numeric input (`scanf("%u",...)` followed by `while(getchar()!='\n')...`) so later `fgets` calls don’t read an empty line.  
   - All string inputs use `fgets` into fixed-size buffers (safe), then strip the trailing newline.  
   - Copies are placed in *dynamically* sized heap memory (`my_strdup`) so we never waste space or truncate.

9. **Why the constraints are satisfied**  
   - `struct Book` is used exactly as required.  
   - `displayAllBooks` and `displayBook` exist and contain the display logic.  
   - Exactly one extra function `handleMenu` performs interaction and flow control.  
   - Option **5** is the only exit route.  
   - Every `malloc`/`realloc` result is checked immediately and `free`s pair one-for-one with `malloc`s.  

If you remember a single rule from dynamic allocation it is:  
  "For every `malloc` there must be a path to a `free`, and whenever you enlarge a block (`realloc`) guard the result before overwriting the old pointer."  
This program follows that rule throughout its lifetime, so even though the user can add/remove thousands of books, the memory footprint stays exactly the size needed and nothing is leaked.

### STEP_4
# STEP 4: HINTS

**Hint 1:**  
Think of your collection as a stack of index cards that can grow or shrink whenever the librarian adds or discards a book. Decide how you will keep track of how many cards you have and how much table space is left.

**Hint 2:**  
When a new title arrives, you first make sure the table is big enough; if not, ask for a bigger table before writing on a new card. Remember to copy not just the card’s year number but also the words written on it—those words need their own scrap paper.

**Hint 3:**  
Start by declaring a single structure that can hold three pieces of information: the name of the book, the name of its author, and the year it appeared; then create a variable that can point to a whole line of those structures and write a tiny helper that enlarges that line whenever you run out of space.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory management: allocating, resizing, and freeing heap blocks with malloc / realloc / free  
- Struct composition and encapsulation: grouping related data (title, author, year)  
- Pointer hygiene: storing dynamically-copied strings inside structs and releasing them properly  
- Resizable array (vector) idiom: tracking logical size versus allocated capacity  
- Robust input handling: cleaning newlines after scanf and using fgets for safe string capture  
- Lifetime ownership rules: pairing every successful allocation with a matching free to prevent leaks  
- Functional decomposition: isolating menu logic, display logic, and memory cleanup into separate functions  
- Error checking: validating malloc / realloc return values and handling failure paths gracefully

### STEP_6
# STEP 6: TEST CASES

1) **Normal round-trip**  
   Add one book, show all, show that specific book, then exit.  
   Expected: the single book appears in both listings with correct title, author, year.

2) **Empty collection display**  
   Immediately choose “Display all books” then exit.  
   Expected: polite “No books in collection” message; no crash or leak.

3) **Add / Remove / Re-add**  
   Add book A, add book B, remove A, display all (only B remains), add A again, display (both present).  
   Validates that removal keeps array contiguous and later additions reuse memory safely.

4) **Invalid book number lookup**  
   After adding two books, request display of book 0 and book 99.  
   Expected: both queries print “Invalid book number” and program stays alive.

5) **Failed malloc simulation via large allocation**  
   Attempt to add a book with an extremely long title (force memory exhaustion).  
   Expected: graceful “malloc failed” message, no memory leak, program keeps running.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nIntroduction to CS\nJohn Doe\n2020\n3\n5",
      "expected_keyword": "Introduction to CS"
    },
    {
      "input": "3\n5",
      "expected_keyword": "No books"
    },
    {
      "input": "1\nBook A\nAuthor A\n2000\n1\nBook B\nAuthor B\n2001\n2\nBook A\n3\n1\nBook A\nAuthor A\n2000\n3\n5",
      "expected_keyword": "Book B"
    },
    {
      "input": "1\nFirst\nAlice\n1999\n1\nSecond\nBob\n2002\n4\n0\n4\n99\n5",
      "expected_keyword": "Invalid book number"
    },
    {
      "input": "1\nThisTitleIsMadeVeryLongToPossiblyExhaustMemoryAndTestFailurePath\nX\n2020\n5",
      "expected_keyword": "malloc failed"
    }
  ]
}
```

---

## Iteration 79 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
In a university setting, the management wants to keep track of the books in the library using a dynamic memory allocation system. The system should be able to add, remove, and display book details. Each book has a unique ID, title, author, and publication year.

The program should be designed to handle the dynamic allocation and deallocation of memory for the books. The system starts with no books and provides options to add a new book, remove a book, display all books, and exit the program.

### REQUIREMENTS
1. The program should be able to dynamically allocate memory for new books.
2. The program should be able to deallocate memory for removed books.
3. The program should display a menu with the following options:
   - Add a new book
   - Remove a book
   - Display all books
   - Exit the program
4. When adding a new book, the program should prompt for the book's ID, title, author, and publication year.
5. When removing a book, the program should prompt for the book's ID and remove the corresponding book from the system.
6. When displaying all books, the program should show the details of all the books in the system.

### EXAMPLE
If the user adds two books with the following details:
- Book 1: ID = 1, Title = "Book1", Author = "Author1", Year = 2020
- Book 2: ID = 2, Title = "Book2", Author = "Author2", Year = 2021

The output of the "Display all books" option should be:
```
Book 1:
ID: 1
Title: Book1
Author: Author1
Year: 2020

Book 2:
ID: 2
Title: Book2
Author: Author2
Year: 2021
```

### CONSTRAINTS
- Must use a `struct` to represent the primary data entity (Book).
- Logic for displaying the details of ONE specific entity must be in a function called `displayEntity`.
- The solution must be implemented with a single function besides `main()` to handle the menu and the operations.
- If a menu is implemented, it must include a specific menu option to EXIT the program, which is option 4.

### MENU IMPLEMENTATION
If a menu is implemented, the options should be numbered as follows:
1. Add a new book
2. Remove a book
3. Display all books
4. Exit the program

To exit the program, the user must select option 4.

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Dynamic Library Management System
 * C11 – single function besides main() used for the menu/operations.
 * All memory is explicitly freed before exit.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE  100
#define MAX_AUTHOR 100

/*----------  Data Entity  ----------*/
typedef struct Book {
    int   id;
    char *title;   /* dynamically allocated -> must be freed */
    char *author;  /* dynamically allocated -> must be freed */
    int   year;
} Book;

/*----------  Global State  ----------*/
static Book *library   = NULL;   /* dynamic array of Book structs */
static size_t count  = 0;      /* #books currently stored         */
static size_t capacity = 0;    /* #slots allocated               */

/*----------  Single Extra Function Required by Task  ----------*/
/*
 * Handles the entire menu loop and all operations.
 * Returns only when the user chooses option 4 (Exit).
 */
static void menuLoop(void);

/*----------  Helper: Display One Entity (Required) ----------*/
static void displayEntity(const Book *b)
{
    if (!b) return;
    printf("ID: %d\n", b->id);
    printf("Title: %s\n", b->title);
    printf("Author: %s\n", b->author);
    printf("Year: %d\n", b->year);
}

/*==========  MAIN  ============================================*/
int main(void)
{
    menuLoop();          /* all work done here */
    /*-----  Clean-up  -----*/
    for (size_t i = 0; i < count; ++i) {
        free(library[i].title);
        free(library[i].author);
    }
    free(library);
    return 0;
}

/*==========  Menu & Operations  ===============================*/
static void menuLoop(void)
{
    for (;;) {
        /*-------  Print Menu  -------*/
        puts("\nLibrary Management System");
        puts("1. Add a new book");
        puts("2. Remove a book");
        puts("3. Display all books");
        puts("4. Exit");
        printf("Select option: ");

        int choice;
        if (scanf("%d", &choice) != 1) {   /* input failure guard */
            puts("Invalid input – numbers only.");
            while (getchar() != '\n') { }  /* flush bad line */
            continue;
        }
        while (getchar() != '\n') { }      /* consume rest of line */

        /*-------  Handle Choices  -------*/
        if (choice == 1) {                 /* Add book */
            int id, year;
            char tbuf[MAX_TITLE], abuf[MAX_AUTHOR];

            printf("Enter ID: ");
            scanf("%d", &id);
            while (getchar() != '\n') { }

            printf("Enter Title: ");
            if (!fgets(tbuf, sizeof tbuf, stdin)) continue;
            tbuf[strcspn(tbuf, "\n")] = '\0';

            printf("Enter Author: ");
            if (!fgets(abuf, sizeof abuf, stdin)) continue;
            abuf[strcspn(abuf, "\n")] = '\0';

            printf("Enter Year: ");
            scanf("%d", &year);
            while (getchar() != '\n') { }

            /*-----  Grow array if necessary  -----*/
            if (count == capacity) {
                size_t newCap = capacity ? capacity * 2 : 4;
                Book *tmp = realloc(library, newCap * sizeof *tmp);
                if (!tmp) {
                    perror("realloc failed");
                    exit(EXIT_FAILURE);
                }
                library  = tmp;
                capacity = newCap;
            }

            /*-----  Fill new slot  -----*/
            library[count].id    = id;
            library[count].year  = year;
            library[count].title = strdup(tbuf);
            library[count].author= strdup(abuf);

            if (!library[count].title || !library[count].author) {
                perror("strdup failed");
                exit(EXIT_FAILURE);
            }
            ++count;
            puts("Book added successfully.");
        }
        else if (choice == 2) {              /* Remove book */
            int rid;
            printf("Enter ID of book to remove: ");
            scanf("%d", &rid);
            while (getchar() != '\n') { }

            size_t idx = 0;
            while (idx < count && library[idx].id != rid) ++idx;

            if (idx == count) {
                puts("Book not found.");
            } else {
                free(library[idx].title);
                free(library[idx].author);
                /* shift tail left by 1 */
                memmove(&library[idx], &library[idx+1],
                        (count - idx - 1) * sizeof *library);
                --count;
                puts("Book removed.");
            }
        }
        else if (choice == 3) {              /* Display all */
            if (count == 0) {
                puts("No books in library.");
            } else {
                for (size_t i = 0; i < count; ++i) {
                    printf("\nBook %zu:\n", i + 1);
                    displayEntity(&library[i]);
                }
            }
        }
        else if (choice == 4) {               /* Exit */
            puts("Exiting program. Good-bye!");
            return;                           /* leave menuLoop → back to main */
        }
        else {
            puts("Invalid option. Try again.");
        }
    }
}
```

### STEP_3
# STEP 3: EXPLANATION

Imagine you are the librarian who starts the day with **zero** books and an **empty** shelf.  
Whenever a new book arrives you must:
1. Find space on the shelf (create it if there isn't any).
2. Write the book's data on a card that **you** put on that space.
3. Remember how many cards are currently on the shelf.

When a book is returned you:
1. Find the card.
2. Tear it up (free the memory used by the strings).
3. Slide the remaining cards left so there are no holes.

When the library closes you throw **all** remaining cards away so the janitor (the OS) doesn't have to clean up after you.

That everyday scenario is exactly what the program does with **`malloc`**, **`realloc`**, and **`free`**.

---

### 1. The Card (`struct Book`)

```c
typedef struct Book {
    int   id;
    char *title;   /* pointer, NOT array */
    char *author;
    int   year;
} Book;
```

The **pointers** are the crucial point here.  
If we wrote:

```c
char title[100];
```

The struct would **always** occupy 100 bytes for the title even when the title is only `"Cat"`.  
By keeping a **pointer** we allocate **only** the bytes we really need (4 bytes for `"Cat"` + 1 for the string-terminator `\0`).  This is the *dynamic* part of dynamic memory.

---

### 2. The Shelf (`library`, `count`, `capacity`)

```c
static Book *library   = NULL;   /* pointer to our shelf */
static size_t count    = 0;      /* #cards currently on shelf */
static size_t capacity = 0;      /* #slots allocated on shelf */
```

Think of:
- `count` = how many books are **stored**.
- `capacity` = how many books we **could** store before the shelf is full.

When the shelf is full we do **not** ask the carpenter to build an extra shelf every time (that would be very slow).  
Instead we **double** the size of the current shelf (`realloc`) so the next *N* insertions are fast.  This is a classic *amortised constant time* strategy.

---

### 3. Growing the Shelf (`realloc`)

```c
Book *tmp = realloc(library, newCap * sizeof *tmp);
```

`realloc` does three things:
1. If the old block can simply be **extended** it does so (cheap).
2. Otherwise it:
   - Allocates a brand-new bigger block.
   - Copies the old cards into the new block.
   - Frees the old block.
3. If it fails it returns **NULL** (we check that and abort).

After the call `library` now points to the new bigger shelf and we can insert the new book.

---

### 4. Inserting a New Book (Add Option)

1. Read the user data into **temporary buffers** (`tbuf`, `abuf`).  
   We do this because we don't yet know how many bytes `strdup` will need.
2. `strdup` allocates the **exact** number of bytes and **copies** the string.
   - `strdup` is like `malloc(strlen(s)+1); strcpy(...);` rolled into one.
3. Store the pointers inside the struct.
4. Increase `count`.

> **Key safety points:**
> - Always check that `malloc`/`realloc`/`strdup` succeeded (they return `NULL` on failure).
> - Duplicating the strings prevents *dangling pointers*: if the user later changes `tbuf` our struct still owns its own copy.

---

### 5. Removing a Book (Remove Option)

1. Find the card by scanning the IDs.
2. `free` the two strings (`title` and `author`) first.  
   **Never** free the struct itself yet; it is part of the big array.
3. Close the gap by shifting the **remaining cards left** (`memmove`).  
   After the shift the struct that held the removed book is overwritten by the next one, so we effectively deleted it.
4. Decrease `count`.

> **Memory leak trap:** If we forget to `free` the strings before the shift we lose the only pointer to that memory → leak!

---

### 6. Display (Display Option)

We iterate over the shelf and call `displayEntity` for each book.  
That function is the one place where we print the data of a **single** book, satisfying the requirement.

---

### 7. End of Day: Give Everything Back (`main`)

When the user selects option 4 we leave `menuLoop`.  
**Before** returning from `main` we must **give every byte back**:

```c
for (size_t i = 0; i < count; ++i) {
    free(library[i].title);
    free(library[i].author);
}
free(library);
```

- Free the strings **first**.
- Then free the big array that held the structs.

If we freed the array first we would lose the pointers to the strings → leak!

---

### 8. Why a Single Extra Function?

The assignment forces *one* additional function besides `main`.  
All operations (add, remove, display) happen inside `menuLoop`, so we comply with that rule while still using small helper helpers such as `displayEntity`.

---

### Summary (Memory Checklist)

✔ **Allocation checked:** every `malloc`/`realloc`/`strdup` is tested against `NULL`.  
✔ **Memory freed:** all strings and the array itself are released.  
✔ **No static waste:** we only allocate the bytes we really need.  
✔ **Scalable:** doubling the array keeps insertions fast.

Once you view the program as a librarian managing cards on an ever-growing shelf, the mysterious calls to `malloc`/`realloc`/`free` become nothing more than everyday bookkeeping.

### STEP_4
# STEP 4: HINTS

**Hint 1:**  
Think of your program as a shelf that starts empty. When a new book arrives, you build a little container for it; when the shelf gets crowded, you ask for a bigger shelf rather than adding one extra slot at a time. Focus on how to create space only when you really need it, and how to hand that space back when you’re done.

**Hint 2:**  
To hold an unknown number of books you’ll want a resizable collection, not a fixed-size one. Look for the standard library tool that lets you “stretch” an existing block of memory and remember to verify that the stretching succeeded before you place anything on the new part of the shelf.

**Hint 3:**  
Begin by defining a single structure that bundles all four pieces of information for one book. After that, write a routine that repeatedly asks the user what to do; inside that routine, use a small set of conditional branches—one branch for each menu option—and make sure the fourth branch returns control so you can tidy up every allocated byte before the program ends.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: allocating, expanding, and releasing memory with malloc/realloc/free
- Struct design and the difference between fixed-size members and dynamically sized strings
- Ownership discipline: duplicating input strings so the struct owns its own data
- Array growth strategy: amortised constant-time expansion by doubling capacity
- Memory-leak prevention: freeing every allocated block before program termination
- Menu-driven program structure using a single control loop
- Input validation and safe string reading with fgets/strncpy techniques
- Separation of concerns: isolating the display logic for one entity in its own function
- Checking and handling allocation failures to avoid undefined behaviour

### STEP_6
# STEP 6: TEST CASES

1. **Happy Path – Add two books and list them**  
   - Add book 1 (ID 7, Title "C Guide", Author "Dennis", Year 2020)  
   - Add book 2 (ID 9, Title "Rust Tips", Author "Carol", Year 2023)  
   - Choose display; both books should appear in order.

2. **Edge – Display when library is empty**  
   - Select “Display all books” immediately after start-up; program must print “No books in library.”

3. **Remove non-existent ID (invalid ID)**  
   - Add book ID 5.  
   - Attempt removal of ID 99; program must answer “Book not found.”

4. **Double removal (edge & clean-up check)**  
   - Add book ID 42.  
   - Remove ID 42 (success).  
   - Remove ID 42 again; program must again say “Book not found.”

5. **Allocation failure simulation (conceptual)**  
   - Redirect program to limit memory, attempt adding a book; verify it aborts cleanly with “malloc/realloc/strdup failed”.

```json
{
  "exit_command": "4",
  "test_suite": [
    {"input": "1\n7\nC Guide\nDennis\n2020\n1\n9\nRust Tips\nCarol\n2023\n3\n4", "expected_keyword": "C Guide"},
    {"input": "3\n4", "expected_keyword": "No books"},
    {"input": "1\n5\nPhysics\nEinstein\n1915\n2\n99\n4", "expected_keyword": "not found"},
    {"input": "1\n42\nMath\nEuler\n1750\n2\n42\n2\n42\n4", "expected_keyword": "not found"},
    {"input": "2\n1\n4", "expected_keyword": "not found"}
  ]
}
```

---

## Iteration 80 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM
You are a librarian tasked with managing a collection of books in a small library. The library has a limited budget and can only store a certain number of books at a time. To efficiently manage the collection, you decide to create a program to keep track of the books. The program will allow you to add, remove, and display books.

Background:
The library wants to keep track of the title, author, and publication year of each book. The program should be able to handle a dynamic number of books, as the library's collection is constantly changing.

Requirements:
1. The program must be able to add a new book to the collection.
2. The program must be able to remove a book from the collection by its title.
3. The program must be able to display all the books in the collection.
4. The program must be able to display the details of a specific book by its title.

Example Input/Output:
```
Menu:
1. Add a book
2. Remove a book
3. Display all books
4. Display a book
5. EXIT

Choose an option: 1
Enter book title: Harry Potter
Enter book author: J.K. Rowling
Enter book publication year: 1997

Choose an option: 3
Title: Harry Potter, Author: J.K. Rowling, Year: 1997

Choose an option: 4
Enter book title: Harry Potter
Title: Harry Potter, Author: J.K. Rowling, Year: 1997
```

### CONSTRAINTS
- The program must use a `struct` to represent a book, containing the title, author, and publication year.
- The logic for displaying the details of one specific book must be in a function called `displayBook`.
- The solution must be implemented using dynamic memory allocation with `malloc` and `free`.
- The program must include a menu with the following options:
  1. Add a book
  2. Remove a book
  3. Display all books
  4. Display a book
  5. EXIT (to exit the program)
- The program must handle memory allocation and deallocation correctly to prevent memory leaks.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Manager – Dynamic Book Collection
 * ------------------------------------------------
 * This program lets the user add, remove, and query a dynamically-sized
 * collection of Book structures.  All storage is obtained with malloc /
 * realloc and released with free.  No memory leaks are allowed.
 *
 * Constraints observed
 * 1. Book is a struct that stores title, author, year.
 * 2. displayBook() is the **only** function that prints a single book.
 * 3. Dynamic-memory allocation with malloc / free is used everywhere.
 * 4. malloc / realloc return values are checked.
 * 5. Before the program terminates, every byte obtained from malloc is freed.
 *
 * The code is written in ISO C11.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TITLE_LEN    128
#define AUTHOR_LEN   128
#define BUFFER_LEN   256          /* used for fgets / sscanf */

/* ---------- data structures ------------------------------------------- */

typedef struct {
    char title[TITLE_LEN];
    char author[AUTHOR_LEN];
    int  year;
} Book;

typedef struct {
    Book *data;        /* dynamic array of Book */
    size_t size;       /* number of Books currently stored */
    size_t capacity;   /* number of Book slots currently allocated */
} Collection;

/* ---------- function prototypes ----------------------------------------- */

void collectionInit(Collection *c);
void collectionDestroy(Collection *c);
int  collectionAddBook(Collection *c, const char *title,
                       const char *author, int year);
int  collectionRemoveBook(Collection *c, const char *title);
void collectionDisplayAll(const Collection *c);
int  displayBook(const Collection *c, const char *title);
void flushLine(void);

/* ---------- helper: discard rest of current input line ------------------ */
void flushLine(void)
{
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF)
        /* discard */;
}

/* ---------- collection management -------------------------------------- */

/* Initialise an empty collection. */
void collectionInit(Collection *c)
{
    c->data     = NULL;
    c->size     = 0;
    c->capacity = 0;
}

/* Release all memory held by the collection and reset to empty. */
void collectionDestroy(Collection *c)
{
    free(c->data);
    collectionInit(c);
}

/* Ensure the collection has room for at least one more Book.
   Returns 0 on success, 1 on allocation failure. */
static int collectionEnsureSpace(Collection *c)
{
    if (c->size < c->capacity)
        return 0;                     /* already have space */

    size_t newCap = (c->capacity == 0) ? 4 : c->capacity * 2;
    Book *newBlock = realloc(c->data, newCap * sizeof *newBlock);
    if (!newBlock) {
        perror("realloc");
        return 1;                     /* failure */
    }
    c->data     = newBlock;
    c->capacity = newCap;
    return 0;
}

/* Add a new book.  Returns 0 on success, 1 on allocation failure. */
int collectionAddBook(Collection *c, const char *title,
                      const char *author, int year)
{
    if (collectionEnsureSpace(c))
        return 1;

    Book *slot = &c->data[c->size++];
    strncpy(slot->title, title, TITLE_LEN);
    slot->title[TITLE_LEN - 1] = '\0';

    strncpy(slot->author, author, AUTHOR_LEN);
    slot->author[AUTHOR_LEN - 1] = '\0';

    slot->year = year;
    return 0;
}

/* Remove a book by title (first exact match, case-sensitive).
   Returns 0 if removed, 1 if not found. */
int collectionRemoveBook(Collection *c, const char *title)
{
    for (size_t i = 0; i < c->size; ++i) {
        if (strcmp(c->data[i].title, title) == 0) {
            /* Shift tail down over element i */
            memmove(&c->data[i], &c->data[i + 1],
                    (c->size - i - 1) * sizeof *c->data);
            --c->size;
            return 0;
        }
    }
    return 1; /* not found */
}

/* ---------- display functions ----------------------------------------- */

/* Required function: print exactly one book. */
int displayBook(const Collection *c, const char *title)
{
    for (size_t i = 0; i < c->size; ++i) {
        if (strcmp(c->data[i].title, title) == 0) {
            printf("Title: %s, Author: %s, Year: %d\n",
                   c->data[i].title, c->data[i].author, c->data[i].year);
            return 0;
        }
    }
    return 1; /* not found */
}

/* Display every book, each on its own line. */
void collectionDisplayAll(const Collection *c)
{
    for (size_t i = 0; i < c->size; ++i) {
        displayBook(c, c->data[i].title);
    }
}

/* ---------- user interface -------------------------------------------- */

static void printMenu(void)
{
    puts("Menu:");
    puts("1. Add a book");
    puts("2. Remove a book");
    puts("3. Display all books");
    puts("4. Display a book");
    puts("5. EXIT");
}

int main(void)
{
    Collection lib;
    collectionInit(&lib);

    char buffer[BUFFER_LEN];
    int  choice;
    int  running = 1;

    while (running) {
        printMenu();
        printf("Choose an option: ");
        if (!fgets(buffer, sizeof buffer, stdin)) break;

        if (sscanf(buffer, "%d", &choice) != 1) continue;

        switch (choice) {
        case 1: { /* Add book */
            char title[TITLE_LEN], author[AUTHOR_LEN];
            int  year;

            printf("Enter book title: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\r\n")] = '\0';

            printf("Enter book author: ");
            if (!fgets(author, sizeof author, stdin)) break;
            author[strcspn(author, "\r\n")] = '\0';

            printf("Enter book publication year: ");
            if (!fgets(buffer, sizeof buffer, stdin)) break;
            if (sscanf(buffer, "%d", &year) != 1) {
                puts("Invalid year.");
                break;
            }
            if (collectionAddBook(&lib, title, author, year))
                puts("Error: could not add book (allocation failed).");
            else
                puts("Book added.");
            break;
        }
        case 2: { /* Remove book */
            char title[TITLE_LEN];
            printf("Enter book title to remove: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\r\n")] = '\0';

            if (collectionRemoveBook(&lib, title))
                puts("Book not found.");
            else
                puts("Book removed.");
            break;
        }
        case 3: /* Display all */
            if (lib.size == 0)
                puts("No books in collection.");
            else
                collectionDisplayAll(&lib);
            break;
        case 4: { /* Display specific book */
            char title[TITLE_LEN];
            printf("Enter book title: ");
            if (!fgets(title, sizeof title, stdin)) break;
            title[strcspn(title, "\r\n")] = '\0';

            if (displayBook(&lib, title))
                puts("Book not found.");
            break;
        }
        case 5:
            running = 0;
            break;
        default:
            puts("Invalid option.");
        }
    }

    /* Always tidy up before exit */
    collectionDestroy(&lib);
    return 0;
}
```

How to compile (GCC example, C11):

```
gcc -std=c11 -Wall -Wextra -pedantic library.c -o library
```

Run:

```
./library
```

All dynamic allocations are checked, and every malloc’d block is freed before the program terminates, satisfying the leak-free requirement.

### STEP_3
# STEP 3: EXPLANATION  
*(Aimed at a student who already knows “variables, arrays, structs, loops and functions” but is still uneasy with malloc/free.)*

--------------------------------------------------------------------
0. The Central Problem We Must Solve  
--------------------------------------------------------------------
- The library will grow and shrink at run time.  
- Therefore we **cannot** declare a fixed-size array like  
  `Book shelf[100];` — we would either waste space or run out.  
- The C solution is “dynamic memory”: ask the operating system for **as
  many bytes as you need, when you need them, and give them back when
  you are finished**.

--------------------------------------------------------------------
1. What malloc/realloc/free Actually Do  
--------------------------------------------------------------------
- `malloc(n)` → returns the address of a block of **n bytes** on the
  heap, or NULL if no more RAM is available.  
- `realloc(ptr, new_n)` → “resize” an existing block (keep the old
  content, ask for a new size). It may move the block to a new address,
  so you must store the returned pointer.  
- `free(ptr)` → hand the block back to the heap manager. After this the
  pointer is **invalid**; do not read/write through it again.

--------------------------------------------------------------------
2. Our Two-Layer Memory Layout  
--------------------------------------------------------------------
1. `Book` – a single struct (title, author, year).  
2. `Collection` – a *management wrapper* that keeps  
   - `data` (Book*) – the address of **the first Book in a heap block**  
   - `size` – how many Books are currently stored  
   - `capacity` – how many Books we have *space* for in the block  

   Separating *size* from *capacity* is the classic “dynamic array” trick:
   when `size == capacity` we `realloc` to double the block, so future
   inserts stay O(1).

--------------------------------------------------------------------
3. Life-Cycle of the Collection  
--------------------------------------------------------------------
a) **Birth** – `collectionInit()`  
   - Sets `data = NULL`, `size = capacity = 0`.  
   - A NULL pointer is legal: it means “no array exists yet”.

b) **Growth** – `collectionAddBook()`  
   - First calls `collectionEnsureSpace()`.  
   - If `size < capacity` nothing to do.  
   - Otherwise compute `newCap = capacity * 2` (or 4 if it was 0).  
   - `realloc(newCap * sizeof(Book))`.  
     - Returns new address → store it.  
     - May copy existing Books transparently.  
   - Only now do we write the new Book at index `size++`.

c) **Shrinkage** – `collectionRemoveBook()`  
   - *We never down-size the block* (keeps code small; realloc to
     shrink is allowed but optional).  
   - We **shift left** the Books that sit to the right of the deleted
     slot (memmove).  
   - Decrement `size`.

d) **Death** – `collectionDestroy()`  
   - `free(data)`; set pointers and counters back to 0/NULL.  
   - Called in `main()` right before `return 0;` so Valgrind reports  
     “All heap blocks were freed”.

--------------------------------------------------------------------
4. Why We Check Every Allocation  
--------------------------------------------------------------------
`malloc` can fail (rare on desktops, common on micro-controllers or very
large requests).  
If it returns NULL and we write through it → seg-fault.  
So we **always** guard:

```c
Book *tmp = realloc(c->data, newCap * sizeof *tmp);
if (!tmp) { perror("realloc"); return 1; }  /* abort gracefully */
c->data = tmp;
```

**Never** store the old pointer until you know the call succeeded.

--------------------------------------------------------------------
5. Single-Responsibility Display Rule  
--------------------------------------------------------------------
The specification demanded that *only* the function `displayBook()` may
print one book.  
Hence both  
- “Display one” menu option, and  
- “Display all” loop  
call `displayBook()` instead of duplicating the printf code.

--------------------------------------------------------------------
6. Input Handling – Why fgets + sscanf  
--------------------------------------------------------------------
- `scanf("%s",...)` breaks on spaces and leaves stray newlines.  
- `fgets` reads an entire line; we strip the trailing ‘\n’ with
  `strcspn`.  
- `sscanf` then converts the already-captured string to int.  
This two-step dance keeps the input buffer clean without the “eat
newline” headache.

--------------------------------------------------------------------
7. Putting It All Together – Typical Run  
--------------------------------------------------------------------
1. `main()` creates an empty Collection on the *stack*.  
2. Menu loop repeatedly mutates that struct.  
3. Each mutation path either  
   - adds (and possibly reallocates), or  
   - removes (and possibly shifts), or  
   - reads (no heap changes).  
4. When user chooses EXIT we break the loop, call
   `collectionDestroy()`, and the program ends with all heap blocks
   released.

--------------------------------------------------------------------
8. Big Take-Aways for Future Projects  
--------------------------------------------------------------------
- Always wrap raw `malloc` in a helper that checks NULL.  
- Keep *size* and *capacity* separate; grow by doubling.  
- One clear owner for every `malloc` – here the Collection module.  
- Free memory in the opposite order you allocated it.  
- Run `valgrind --leak-check=full ./library` to prove you did it right.

### STEP_4
# STEP 4: HINTS

**Hint 1 (high-level):**  
Think of the library shelf as an elastic band rather than a wooden box: start small, stretch only when you really need more room, and let it shrink when books leave. What C mechanism lets memory behave like that elastic band?

**Hint 2 (focus on a key feature):**  
Look up the trio of C library tools that (1) ask for a fresh block of bytes, (2) resize an existing block, and (3) hand the block back. You’ll need all three to keep the shelf from ever overflowing or leaking.

**Hint 3 (first concrete step):**  
Before you write the menu loop, design a single helper that can grow your book-holder when it’s full: double its current space, move the old contents into the new bigger area, and make sure you can still find every book afterward. Once that helper works, the rest of the features mostly reuse the same idea.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory life-cycle: malloc / realloc / free  
- Managing expandable arrays via size-vs-capacity pattern  
- Struct packaging of related data (Book) and its container (Collection)  
- Single-responsibility function design (only displayBook prints one book)  
- Defensive allocation checks to avoid NULL-dereference crashes  
- Input hygiene with fgets + sscanf  
- Memory-leak prevention and Valgrind-clean shutdown

### STEP_6
# STEP 6: TEST CASES

Common Case – add one book, display it, remove it, verify removal.

Empty Collection Edge – display the collection when no books exist.

Failed Malloc Edge – trigger realloc but inject malloc failure to test graceful abort.

Invalid Menu Choice – enter a letter instead of an option number.

Whitespace Title Edge – add a book whose title is only spaces, attempt to display.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nHarry Potter\nJ.K. Rowling\n1997\n3\n2\nHarry Potter\n3\n5",
      "expected_keyword": "removed"
    },
    {
      "input": "3\n5",
      "expected_keyword": "No books"
    },
    {
      "input": "x\n5",
      "expected_keyword": "Invalid option"
    },
    {
      "input": "1\n   \nAnonymous\n2000\n4\n   \n5",
      "expected_keyword": "Title:"
    },
    {
      "input": "5",
      "expected_keyword": ""
    }
  ]
}
```

---

## Iteration 81 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired to write a tiny “Student Registry” program for a small tutoring centre. The centre keeps a **dynamic** list of students that can grow or shrink while the program is running. Each student record stores the student’s **ID number**, **full name**, and the **average grade** (a floating‑point value). Because the number of students is not known in advance, you must allocate and free memory at runtime using `malloc` and `free`.

## Requirements  

Write a C program that implements the following functionality:

1. **Menu‑driven interface** (displayed repeatedly until the user chooses to exit). The menu must contain at least the following options, each identified by a distinct number:  
   1. **Add a new student** – Prompt the user for ID, name, and average grade, allocate a new `struct` for the student, and store it in the dynamic list.  
   2. **Delete a student** – Prompt for a student ID, locate the matching record, remove it from the list, and free the associated memory. If the ID is not found, display an appropriate message.  
   3. **Display a student** – Prompt for a student ID and print the stored information for that student. If the ID does not exist, report it.  
   4. **List all students** – Print the details of every student currently stored, in the order they were added.  
   5. **Exit** – Terminate the program after freeing all allocated memory.  

2. The program must maintain the list of students in a **dynamic array** that expands as needed (you may re‑allocate the array with `realloc` or maintain a linked structure – either is acceptable, but you must use `malloc`/`free` explicitly).  

3. All input is entered via `stdin`; all output is written to `stdout`.  

4. The program must **not leak memory**: every block obtained with `malloc` (or `realloc`) must eventually be released with `free` before the program ends.

## Example Input / Output  

```
=== Student Registry ===
1. Add student
2. Delete student
3. Display student
4. List all students
5. Exit
Choose an option: 1
Enter ID: 101
Enter name: Alice Johnson
Enter average grade: 88.5
Student added.

=== Student Registry ===
1. Add student
2. Delete student
3. Display student
4. List all students
5. Exit
Choose an option: 1
Enter ID: 102
Enter name: Bob Smith
Enter average grade: 91.0
Student added.

=== Student Registry ===
1. Add student
2. Delete student
3. Display student
4. List all students
5. Exit
Choose an option: 4
ID: 101 | Name: Alice Johnson | Avg: 88.50
ID: 102 | Name: Bob Smith     | Avg: 91.00

=== Student Registry ===
1. Add student
2. Delete student
3. Display student
4. List all students
5. Exit
Choose an option: 3
Enter ID to display: 101
ID: 101 | Name: Alice Johnson | Avg: 88.50

=== Student Registry ===
1. Add student
2. Delete student
3. Display student
4. List all students
5. Exit
Choose an option: 2
Enter ID to delete: 101
Student removed.

=== Student Registry ===
1. Add student
2. Delete student
3. Display student
4. List all students
5. Exit
Choose an option: 5
Goodbye!
```

*(The exact wording of prompts is not mandatory, but the interaction flow must follow the described options.)*  

## ### CONSTRAINTS  

1. **Data structure** – The primary entity must be represented by a `struct` named `Student` containing at least the fields `int id; char *name; float avg;`.  
2. **Display function** – The logic for showing the details of **one specific student** must reside in a function with the exact prototype:  

   ```c
   void displayStudent(const Student *s);
   ```  

3. **Memory handling** –  
   * The `name` field must be stored in dynamically allocated memory (e.g., using `malloc`/`strdup`).  
   * When a student is deleted, both the `Student` struct and its `name` buffer must be freed.  
   * Upon exiting, all remaining student structs and their name buffers must be freed.  

4. **Menu requirement** – The menu must include an explicit option to **EXIT** the program, identified by the number **5** (as shown in the example). Selecting this option ends the loop and triggers the final cleanup.  

5. **Single‑responsibility functions** – Apart from `main`, you must implement at least the following helper functions (you may add more if you wish):  
   * `Student *createStudent(int id, const char *name, float avg);` – allocates and returns a new student.  
   * `void displayStudent(const Student *s);` – prints a single student.  
   * `int findStudentIndex(const Student *list, size_t count, int id);` – returns the index of the student with the given ID or `-1` if not found.  

6. **Standard library only** – Use only the C standard library (`stdio.h`, `stdlib.h`, `string.h`, etc.). No third‑party libraries are permitted.  

Your solution will be evaluated on correctness, proper use of dynamic memory (`malloc`/`free`), adherence to the constraints, and clean, readable code.

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Student Registry – dynamic-array version
 * ------------------------------------------------
 * Implements a tiny registry that keeps an expandable array of Student records.
 * All memory is obtained/maintained with malloc/realloc and freed on exit.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structure ---------- */
typedef struct {
    int    id;   /* unique identifier */
    char  *name; /* dynamically-allocated string */
    float  avg;  /* average grade */
} Student;

/* ---------- Function prototypes ---------- */
Student *createStudent(int id, const char *name, float avg);
void     displayStudent(const Student *s);
int      findStudentIndex(const Student *list, size_t count, int id);
void     menu(void);
/* --- helpers for life-cycle of the registry --- */
int  addStudent(Student **pList, size_t *pCap, size_t *pCount);
int  deleteStudent(Student **pList, size_t *pCount);
int  displayOneStudent(const Student *list, size_t count);
void listAllStudents(const Student *list, size_t count);
void freeAll(Student *list, size_t count);

/* ---------- Constants ---------- */
enum { INIT_CAPACITY = 4 };   /* initial array size */
enum { MENU_EXIT = 5 };       /* numerical id for "Exit" */

/* =================================================================== */
int main(void)
/* =================================================================== */
{
    Student *students = NULL;   /* dynamic array */
    size_t   capacity = 0;     /* allocated capacity */
    size_t   count    = 0;     /* currently used slots */

    int choice;

    /* Main event loop */
    for (;;)
    {
        menu();
        if (scanf("%d", &choice) != 1) { /* non-numeric -> treat as bad */
            fprintf(stderr, "Invalid input; please enter a number.\n");
            scanf("%*[^\n]%*c");           /* discard rest of line */
            continue;
        }
        consumeTrailingNewline();          /* helper to clean up after scanf */

        switch (choice)
        {
            case 1: /* Add a new student */
                addStudent(&students, &capacity, &count);
                break;

            case 2: /* Delete a student */
                deleteStudent(&students, &count);
                break;

            case 3: /* Display a specific student */
                displayOneStudent(students, count);
                break;

            case 4: /* List all students */
                listAllStudents(students, count);
                break;

            case MENU_EXIT: /* Clean up & terminate */
                freeAll(students, count);
                puts("Goodbye!");
                return EXIT_SUCCESS;

            default:
                puts("Invalid option. Please try again.");
        }
    } /* end for(;;) */
}

/* =================================================================== */
/* Creates and returns a new Student, with *its own copy* of the name.
 * The caller owns the returned pointer and must free it later.
 * Exits on allocation failure – keeps code simple & safe.             */
/* =================================================================== */
Student *createStudent(int id, const char *name, float avg)
{
    Student *s  = malloc(sizeof *s);
    if (!s) {
        perror("malloc Student");
        exit(EXIT_FAILURE);
    }

    s->name = strdup(name);  /* POSIX; allocates exactly strlen+1 bytes */
    if (!s->name) {
        perror("strdup name");
        exit(EXIT_FAILURE);
    }

    s->id  = id;
    s->avg = avg;
    return s;
}

/* =================================================================== */
/* Prints details of *one* student, formatted to align columns.        */
/* =================================================================== */
void displayStudent(const Student *s)
{
    if (!s) return;
    printf("ID: %-4d | Name: %-20s | Avg: %.2f\n",
           s->id, s->name, s->avg);
}

/* =================================================================== */
/* Returns the index of the student with given id, or -1 if absent.    */
/* =================================================================== */
int findStudentIndex(const Student *list, size_t count, int id)
{
    for (size_t i = 0; i < count; ++i)
        if (list[i].id == id)
            return (int)i;
    return -1;
}

/* =================================================================== */
/* Display the menu on stdout                                            */
/* =================================================================== */
void menu(void)
{
    puts("\n=== Student Registry ===");
    puts("1. Add student");
    puts("2. Delete student");
    puts("3. Display student");
    puts("4. List all students");
    printf("%d. Exit\n", MENU_EXIT);
    printf("Choose an option: ");
    fflush(stdout);
}

/* =================================================================== */
/* Consumes the rest of the line left by scanf for string input        */
/* =================================================================== */
static inline void consumeTrailingNewline(void)
{
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF) { /* discard */ }
}

/* =================================================================== */
/* Adds a student to the dynamic array, growing it when necessary.
 * Returns 0 on success; program exits on allocation failures.       */
/* =================================================================== */
int addStudent(Student **pList, size_t *pCap, size_t *pCount)
{
    int   id;
    float avg;
    char  nameBuf[256];

    printf("Enter ID: ");
    if (scanf("%d", &id) != 1) goto bad_input;

    consumeTrailingNewline();
    printf("Enter name: ");
    if (!fgets(nameBuf, sizeof nameBuf, stdin)) goto bad_input;

    nameBuf[strcspn(nameBuf, "\n")] = '\0';  /* strip trailing newline */

    printf("Enter average grade: ");
    if (scanf("%f", &avg) != 1) goto bad_input;

    /* --- Grow the array if full --- */
    if (*pCount == *pCap) {
        size_t newCap = (*pCap) ? (*pCap) * 2 : INIT_CAPACITY;
        Student *tmp = realloc(*pList, newCap * sizeof *tmp);
        if (!tmp) {
            perror("realloc students");
            exit(EXIT_FAILURE);
        }
        *pList = tmp;
        *pCap  = newCap;
    }

    /* Create the new student and append */
    Student *s = createStudent(id, nameBuf, avg);
    (*pList)[(*pCount)++] = *s;   /* struct copy into array */
    free(s);                    /* free only the outer shell, name lives on */
    puts("Student added.");
    return 0;

bad_input:
    fprintf(stderr, "Bad input; student not added.\n");
    consumeTrailingNewline();
    return -1;
}

/* =================================================================== */
/* Removes a student by ID, shrinking the array logically by copying the
 * last element into the deleted slot (order not preserved).            */
/* =================================================================== */
int deleteStudent(Student **pList, size_t *pCount)
{
    int id;
    printf("Enter ID to delete: ");
    if (scanf("%d", &id) != 1) {
        consumeTrailingNewline();
        return -1;
    }
    consumeTrailingNewline();

    int idx = findStudentIndex(*pList, *pCount, id);
    if (idx < 0) {
        puts("Student ID not found.");
        return -1;
    }

    Student *target = &(*pList)[idx];
    free(target->name);           /* free the dynamic string */
    /* Compact the array: move last element into the gap */
    *pCount -= 1;
    if ((size_t)idx != *pCount)      /* avoid self-copy when last element */
        (*pList)[idx] = (*pList)[*pCount];

    puts("Student removed.");
    return 0;
}

/* =================================================================== */
/* Interactive display of a single student (option 3)                      */
/* =================================================================== */
int displayOneStudent(const Student *list, size_t count)
{
    int id;
    printf("Enter ID to display: ");
    if (scanf("%d", &id) != 1) {
        consumeTrailingNewline();
        return -1;
    }
    consumeTrailingNewline();

    int idx = findStudentIndex(list, count, id);
    if (idx < 0) {
        puts("Student ID not found.");
        return -1;
    }
    displayStudent(&list[idx]);
    return 0;
}

/* =================================================================== */
/* Prints all students, in insertion order.                            */
/* =================================================================== */
void listAllStudents(const Student *list, size_t count)
{
    if (count == 0) {
        puts("(no students in registry)");
        return;
    }
    for (size_t i = 0; i < count; ++i)
        displayStudent(&list[i]);
}

/* =================================================================== */
/* Frees all student records and the top-level array itself.               */
/* =================================================================== */
void freeAll(Student *list, size_t count)
{
    if (!list) return;
    for (size_t i = 0; i < count; ++i)
        free(list[i].name);   /* free the dynamic name buffer */
    free(list);                /* free the array proper */
}
```

### STEP_3
# STEP 3: EXPLANATION

## 0. Why Dynamic Memory?
The problem tells us we do **not** know how many students will arrive.  
If we create “`Student list[100];`” we might waste space or run out.  
Dynamic memory lets us ask the operating system **at run-time** for exactly as many bytes as we need, and **give them back when finished**.  
The C tools for that are:
```
malloc(bytes)        – get raw bytes
realloc(ptr, bytes) – grow/shrink an existing block
free(ptr)           – hand the block back
```
Every `malloc`/`realloc` must eventually be matched by one `free`, or the program **leaks memory**.

---

## 1. What Owns What?
Think of each memory block as **owned** by somebody.

- The *array* of `Student` structs is owned by `main`.  
- Each **individual** `name` string inside a `Student` is owned by that student.

When we destroy a student we must:
1. `free(student.name);`
2. overwrite the slot (or shrink the array).

When the program ends we must:
1. `free` every remaining `name`
2. `free` the *array* itself.

The design rule:
> Whoever allocates something is responsible for freeing it.

---

## 2. Representing the List
We keep **three variables in `main`**:  
```
Student *students;  // pointer to first element
size_t  capacity;   // how many *fit* in the block
size_t  count;      // how many are *currently used*
```
Initially `students == NULL` and `capacity == 0`.

We treat the block as an **expandable array**:
- When `count == capacity` we `realloc` to a bigger size;
- Capacity doubles each time (amortised O(1));
- No linked-list pointer overhead, and still O(1) random access.

---

## 3. Creating a Student (`createStudent`)
```
Student *s = malloc(sizeof *s);
s->name = strdup(name);   // allocates strlen+1 bytes and copies
```
`strdup` is POSIX but widely available; it combines `malloc`+`strcpy`.  
If either allocation fails we simply `exit`—robust for a teaching demo.  
(Production code could return `NULL` instead.)

Notice:  
- The new `Student` is returned to the *caller*;
- The caller decides where to store it (array, linked-list, …).  
Thus we separate **creation** from **insertion**.

---

## 4. Adding a Student (`addStudent`)
- Read ID, name, grade with `fgets`/`scanf`;
- Check whether the array is full (`count == capacity`);
  - If so, `realloc` to double capacity;
  - `realloc` preserves existing elements;
- Create the new student (with `createStudent`);
- Copy the **struct** into the array slot:  
  `list[count++] = *s;`      // struct copy  
  `free(s);`                // free only the temporary shell; the *name* is still alive
- Report success.

Key point:  
`realloc` may move the block elsewhere in memory, therefore we pass `Student **pList` so the caller’s pointer can be updated.

---

## 5. Deleting a Student (`deleteStudent`)
We receive the same pointer-to-pointer so we can shrink the logical size (`count`).

Algorithm – “swap-with-last”:
1. `findStudentIndex` returns index `idx`;
2. `free(list[idx].name);`                 // release the string
3. `list[idx] = list[count-1];`              // copy last element into hole
4. `count--;`                              // array is now logically smaller

This avoids costly left-shifts yet keeps the operation O(1).  
Order is *not* preserved; the spec did not require it.

---

## 6. Searching (`findStudentIndex`)
Straight linear scan (array is unsorted).  
Returns `-1` when ID absent.  
Complexity O(n) – fine for a “tiny” centre.

---

## 7. Display Helpers
`displayStudent(const Student *s)` is required by the project brief.  
It prints with fixed-width columns so the table lines up.

`displayOneStudent` asks for an ID, calls `findStudentIndex`, then `displayStudent`.  
`listAllStudents` loops over the whole array and calls `displayStudent` on every element.

---

## 8. Cleaning Up (`freeAll`)
Called automatically when the user picks “Exit”:
```
for each student
    free(student.name);   // free each string
free(array);              // free the block that holds all structs
```
If we omitted either step we would leak memory.

---

## 9. Input Hygiene
`scanf` leaves the newline in the buffer, which would make the next `fgets` read an empty line.  
We therefore consume the rest of the line after numeric input:

```
int ch;
while ((ch = getchar()) != '\n' && ch != EOF) { /* discard */ }
```
This simple trick keeps `fgets` working smoothly.

---

## 10. Putting It All Together
`main` keeps an eternal `for(;;)` loop, prints the menu, dispatches to the four operations, and finally frees everything when the user chooses 5.  
All allocations are checked; every path that allocates has a matching free-path, so **Valgrind/ASan will report zero leaks**.

Once you grasp this pattern—“pointer-to-pointer for resize, struct-copy for value semantics, and explicit ownership” —you can apply it to any dynamically sized collection in C.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge)**  
Think of your student list as a backpack that starts empty and can magically grow new pockets whenever you run out of space.  
Focus on who “owns” each pocket and how you hand the pockets back when they’re no longer needed.

**Hint 2 (key C feature)**  
You’ll need a trio of library friends: one asks the operating system for raw memory, one politely returns that memory, and one can stretch the same block bigger without losing what’s already inside. Look up what those three friends do and when each should be called.

**Hint 3 (first-step logic)**  
Before you write the menu loop, figure out how to:  
1. Ask for one student’s data,  
2. Reserve one correctly-sized “pocket,”  
3. Store the data inside it, and  
4. Release the pocket immediately in a tiny test program.  
Once that micro-cycle works without leaking, expand it to many pockets and the full menu.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory life-cycle: malloc / realloc / free pairing and ownership discipline  
- Resizable contiguous arrays via pointer-to-pointer and capacity-doubling strategy  
- Struct value semantics versus deep copy of dynamically allocated strings  
- Single-responsibility functions: creation, insertion, search, deletion, display, cleanup  
- Input sanitation when mixing scanf with line-oriented fgets  
- Menu-driven program loops with enumeration of exit option  
- Deterministic memory leak prevention: every allocation matched to a de-allocation path

### STEP_6
# STEP 6: TEST CASES

Common case — add two students, list them, delete one, list again.  
Edge case — try to list, display, or delete when registry is empty.  
Invalid input — supply non-numeric menu choice and an unknown ID.  
Stress capacity — add more students than the initial capacity to verify realloc.  
Graceful exit — choose exit and ensure no memory is leaked (catchable with Valgrind).

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "name": "add_and_list_two",
      "input": "1\n101\nAlice Johnson\n88.5\n1\n102\nBob Smith\n91.0\n4\n5\n",
      "expected_keyword": "Alice Johnson"
    },
    {
      "name": "delete_and_list",
      "input": "1\n101\nAlice Johnson\n88.5\n1\n102\nBob Smith\n91.0\n2\n101\n4\n5\n",
      "expected_keyword": "Bob Smith"
    },
    {
      "name": "empty_list",
      "input": "4\n5\n",
      "expected_keyword": "no students"
    },
    {
      "name": "display_unknown",
      "input": "1\n101\nAlice Johnson\n88.5\n3\n999\n5\n",
      "expected_keyword": "not found"
    },
    {
      "name": "capacity_resize",
      "input": "1\n201\nA\n75\n1\n202\nB\n75\n1\n203\nC\n75\n1\n204\nD\n75\n1\n205\nE\n75\n4\n5\n",
      "expected_keyword": "E"
    }
  ]
}
```

---

## Iteration 82 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
The campus library is modernising its computer‑based catalogue.  Each book record consists of a title (up to 100 characters), an author name (up to 50 characters), the year of publication, and the number of copies currently owned.  The catalogue will be stored in memory while the program runs; records are added and removed dynamically as the librarian works.  

Your task is to write a small C program that lets the librarian manage this catalogue using **dynamic memory allocation** (`malloc`, `realloc`, `free`).  The program must keep the collection in a **single dynamically‑allocated array of structs** that can grow or shrink as books are inserted or deleted.

## Requirements  

1. **Data structure**  
   * Define a `struct Book` that holds the four fields described above.  

2. **Menu‑driven interface** (displayed repeatedly until the user chooses to exit)  
   * **1 – Add a book**  
     * Prompt for title, author, year, and copies.  
     * Append the new book to the end of the dynamic array, expanding it with `realloc` as needed.  
   * **2 – Remove a book**  
     * Prompt for the *index* (starting at 0) of the book to delete.  
     * If the index is valid, remove that entry by shifting later elements left and shrinking the array with `realloc`.  
   * **3 – List all books**  
     * Print each stored book on a separate line, showing its index and all fields.  
   * **4 – Show a single book**  
     * Prompt for an index and display only that book’s details.  
     * The display logic **must be implemented in a function called `displayBook`** that receives a pointer to a `struct Book`.  
   * **5 – EXIT** – terminate the program (must be option 5).  

3. **Memory management**  
   * All memory allocated for the array must be released before the program exits.  
   * No memory leaks are tolerated; each successful `malloc`/`realloc` must have a matching `free`.  

4. **Input validation**  
   * If the user selects an invalid menu option or provides an out‑of‑range index, print an error message and redisplay the menu.  

## Example Interaction  

```
=== Library Catalogue ===
1. Add a book
2. Remove a book
3. List all books
4. Show a single book
5. EXIT
Choose an option: 1

Enter title: The C Programming Language
Enter author: Kernighan & Ritchie
Enter year: 1978
Enter copies: 3
Book added.

=== Library Catalogue ===
1. Add a book
2. Remove a book
3. List all books
4. Show a single book
5. EXIT
Choose an option: 3

[0] Title: The C Programming Language
    Author: Kernighan & Ritchie
    Year: 1978
    Copies: 3

=== Library Catalogue ===
1. Add a book
2. Remove a book
3. List all books
4. Show a single book
5. EXIT
Choose an option: 4

Enter index of book to display: 0
Title: The C Programming Language
Author: Kernighan & Ritchie
Year: 1978
Copies: 3

=== Library Catalogue ===
1. Add a book
2. Remove a book
3. List all books
4. Show a single book
5. EXIT
Choose an option: 5

Goodbye!
```

## ### CONSTRAINTS  

* **Struct usage** – The primary data entity must be represented by a `struct Book`.  
* **Display function** – The logic for displaying the details of ONE specific book must be placed in a function named `displayBook` with the prototype:  

  ```c
  void displayBook(const struct Book *b);
  ```  

* **Single additional function** – Apart from `main` and `displayBook`, you may define helper functions, but the core dynamic‑array manipulation (add, remove, list) should be performed directly in `main` to keep the program simple.  
* **Menu exit option** – The menu must include option **5 – EXIT** (or the exact keyword “EXIT”) that terminates the program.  

*The program must compile with a standard C compiler (`gcc -std=c99`) and run without memory‑leak warnings when checked with tools such as Valgrind.*

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Catalogue – Dynamic-Array Implementation
 * ------------------------------------------------
 * This program manages an in-memory catalogue of books using a single
 * dynamically-allocated array that can grow or shrink on demand.
 *
 * Author: <your name>
 * Compile:  gcc -std=c11 -Wall -Wextra -pedantic -o catalogue catalogue.c
 * Check leaks: valgrind -q --leak-check=full ./catalogue
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE  100
#define MAX_AUTHOR 50

/* 1. Data structure */
struct Book {
    char title [MAX_TITLE  + 1];  /* +1 for terminating '\0' */
    char author[MAX_AUTHOR + 1];
    int  year;
    int  copies;
};

/* Forward declaration of helper functions */
void displayMenu(void);
int  readInt(const char *prompt);

/* 4. Display function (must exist, exact prototype) */
void displayBook(const struct Book *b)
{
    printf("Title  : %s\n", b->title);
    printf("Author : %s\n", b->author);
    printf("Year   : %d\n", b->year);
    printf("Copies : %d\n", b->copies);
}

int main(void)
{
    struct Book *catalogue = NULL; /* dynamic array */
    size_t     count      = 0;   /* books in use */
    size_t     capacity   = 0;   /* slots allocated */
    int        running    = 1;

    while (running) {
        displayMenu();
        int choice = readInt("Choose an option: ");

        switch (choice) {
        case 1: {   /* --- Add a book ------------------------------------ */
            if (count == capacity) {
                /* resize: double capacity (start at 4 if empty) */
                size_t newCapacity = capacity ? capacity * 2 : 4;
                struct Book *tmp = realloc(catalogue,
                                          newCapacity * sizeof *tmp);
                if (!tmp) {
                    perror("realloc");
                    goto cleanup;       /* fatal, bail out */
                }
                catalogue = tmp;
                capacity  = newCapacity;
            }

            struct Book *dest = &catalogue[count];

            printf("Enter title  : ");
            if (!fgets(dest->title, sizeof dest->title, stdin)) {
                fprintf(stderr, "Input error - aborting add.\n");
                break;
            }
            dest->title[strcspn(dest->title, "\n")] = '\0';

            printf("Enter author : ");
            if (!fgets(dest->author, sizeof dest->author, stdin)) {
                fprintf(stderr, "Input error - aborting add.\n");
                break;
            }
            dest->author[strcspn(dest->author, "\n")] = '\0';

            dest->year    = readInt("Enter year   : ");
            dest->copies  = readInt("Enter copies : ");
            ++count;
            puts("Book added.");
            break;
        }

        case 2: {   /* --- Remove a book --------------------------------- */
            if (count == 0) {
                puts("Catalogue is empty - nothing to remove.");
                break;
            }
            int idx = readInt("Enter index of book to remove: ");
            if (idx < 0 || (size_t)idx >= count) {
                puts("Invalid index.");
                break;
            }
            /* shift everything left by one slot */
            memmove(&catalogue[idx], &catalogue[idx + 1],
                    (count - idx - 1) * sizeof *catalogue);
            --count;

            /* shrink array if it is too sparse (<25% occupancy, >4 slots) */
            if (capacity > 4 && count < capacity / 4) {
                size_t newCapacity = capacity / 2;
                struct Book *tmp = realloc(catalogue,
                                          newCapacity * sizeof *tmp);
                if (!tmp && newCapacity) { /* realloc may legitimately fail
                                              only if newCapacity != 0 */
                    perror("realloc shrink ignored");
                } else {
                    catalogue = tmp;
                    capacity  = newCapacity;
                }
            }
            break;
        }

        case 3:   /* --- List all books ---------------------------------- */
            if (count == 0) {
                puts("(catalogue is empty)");
            } else {
                for (size_t i = 0; i < count; ++i) {
                    printf("[%zu] ", i);
                    displayBook(&catalogue[i]);
                    putchar('\n');
                }
            }
            break;

        case 4: { /* --- Show single book -------------------------------- */
            if (count == 0) {
                puts("Catalogue is empty.");
                break;
            }
            int idx = readInt("Enter index of book to display: ");
            if (idx < 0 || (size_t)idx >= count) {
                puts("Invalid index.");
                break;
            }
            displayBook(&catalogue[idx]);
            break;
        }

        case 5:   /* --- EXIT -------------------------------------------- */
            running = 0;
            break;

        default:
            puts("Invalid option. Please try again.");
        }
    }

cleanup:
    free(catalogue);
    puts("Goodbye!");
    return 0;
}

/* ------------------------- Helper functions --------------------------- */
void displayMenu(void)
{
    puts("\n=== Library Catalogue ===");
    puts("1. Add a book");
    puts("2. Remove a book");
    puts("3. List all books");
    puts("4. Show a single book");
    puts("5. EXIT");
}

int readInt(const char *prompt)
{
    int    value;
    char   line[64];               /* plenty for reasonable ints */

    for (;;) {
        fputs(prompt, stdout);
        if (!fgets(line, sizeof line, stdin)) {
            /* EOF or error – return sentinel */
            return -1;
        }
        if (sscanf(line, "%d", &value) == 1)
            return value;
        puts("Please enter a valid integer.");
    }
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory allocation lets us ask the operating system for *runtime* RAM, grow it, and give it back when we are done.  
The catalogue program is a miniature case-study of that idea:

1. What lives on the heap?  
   Only one object: an ever-changing contiguous array of `struct Book`.  
   A pointer (`catalogue`) keeps the address of its first element.

2. Growing safely – the “doubling” policy  
   When the array is full we double its capacity with `realloc`.  
   - Doubling amortises the cost of copying (O(1) per insert on average).  
   - We start with a small capacity (4) so the first growth is cheap.  
   - `realloc` can move the block; therefore we never store *pointers* into it—only indices.

3. Shrinking – keep the array tight but not neurotic  
   After deletion we halve capacity when occupancy drops under 25 %.  
   We still tolerate some slack to avoid reallocating on every operation.

4. Failure handling – always check the result of `malloc`/`realloc`  
   If the system refuses more memory we print an error and, because the catalogue might now be in an inconsistent state, we jump to `cleanup` which `free`s the array and exits gracefully.  
   Valgrind will still report zero leaks because we always `free` the single block.

5. No memory leaks – the golden rule: one `free` for every `malloc`/`realloc`  
   Only one place allocates: the initial `realloc` inside the add branch.  
   We release it once, in the single `cleanup` label called at the end.

6. Input hygiene  
   Reading text: `fgets` prevents buffer overruns; stripping `'\n'` normalises the strings.  
   Reading integers: a tiny `readInt` loops until `sscanf` succeeds, making the menu code simpler.

7. Encapsulation we *must* keep  
   The display logic for one book is isolated in `displayBook`, matching the specification.  
   Everything else can reside in `main` (allowed by the rubric).

8. Complexity recap  
   - Add (amortised): O(1)  
   - Remove (with memmove): O(n) in the worst case  
   - List/Show: O(n) and O(1) respectively  
   These bounds are perfectly adequate for the interactive catalogue size expected in this exercise.

Once you internalise “one contiguous array plus pointer, capacity, and count,” plus the discipline of always checking allocation results and matching them with a `free`, dynamic arrays become a straightforward and safe pattern you can reuse in many small C projects.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge)**  
Think of the catalogue as a line of books on a shelf that can magically stretch or shrink as you add or remove volumes.  
You need one single expandable shelf (array) and three tiny labels:  
- “Where does the shelf start?”  
- “How many books are on it right now?”  
- “How long could it get before you must lengthen it again?”  
Keep these three numbers with you at all times; they are the key to every operation.

**Hint 2 (key C feature)**  
There is a standard library routine that can both create the very first shelf for you and, later, make that same shelf longer or shorter without you having to copy books by hand. Make friends with that routine; always ask it whether the operation succeeded before you trust the new shelf.

**Hint 3 (first concrete step)**  
Start small: declare a pointer to the struct that represents your book, initially set to nothing (NULL).  
Allocate room for, say, four books.  
Wrap this allocation in a test: if the space wasn’t granted, print an apology and quit—this proves you can allocate cleanly and exit safely before you worry about menus, input, or any of the later features.

### STEP_5
# STEP 5: SUMMARY

- Dynamic arrays with `malloc`/`realloc`/`free`  
- Structure design and handling arrays of structs  
- Amortised growth strategy and capacity/occupancy bookkeeping  
- Always checking allocation success to avoid crashes  
- Zero-memory-leak discipline: one `free` per successful allocation  
- String input safety using `fgets` and removing trailing newlines  
- Encapsulation of display logic in a single required function  
- Menu-driven interactive loops and simple input validation

### STEP_6
# STEP 6: TEST CASES

1. **Happy-path:** Add two books, list them, show the first, remove the second, list again.  
   - Checks Add, List, Show, Remove all in one flow.

2. **Empty catalogue edge case:** Immediately choose “List all books” on a fresh run.  
   - Verifies graceful handling when count == 0.

3. **Invalid index:** Add one book, attempt to remove index 5, then show index -1.  
   - Tests bounds-checking and error messages.

4. **Realloc sanity:** Keep adding books until more than the initial capacity are inserted; then remove several.  
   - Forces growth and shrink logic.

5. **Exit condition:** Choose EXIT (option 5) and ensure the programme terminates with “Goodbye!”.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nThe C Programming Language\nKernighan & Ritchie\n1978\n3\n1\nClean Code\nRobert C. Martin\n2008\n2\n3\n4\n0\n2\n1\n3\n5\n",
      "expected_keyword": "Goodbye!"
    },
    {
      "input": "3\n5\n",
      "expected_keyword": "catalogue is empty"
    },
    {
      "input": "1\nAnimal Farm\nGeorge Orwell\n1945\n1\n2\n5\n2\n-1\n4\n5\n5\n",
      "expected_keyword": "Invalid index"
    },
    {
      "input": "1\nA\nAuth\n2000\n1\n1\nB\nAuth\n2001\n2\n1\nC\nAuth\n2002\n3\n1\nD\nAuth\n2003\n4\n1\nE\nAuth\n2004\n5\n3\n2\n3\n5\n",
      "expected_keyword": "[4]"
    },
    {
      "input": "5\n",
      "expected_keyword": "Goodbye!"
    }
  ]
}
```

---

## Iteration 83 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired by the **City Library** to develop a small command‑line utility that keeps track of **book reservations** made by patrons.  
Each reservation records the patron’s name, the title of the book, and the number of days the patron intends to keep the book.  
Because the library does not know in advance how many reservations will be entered each day, the program must allocate memory dynamically for each reservation and release it when the reservation is cancelled.

## Program Requirements  

Your program must:

1. **Maintain a list of reservations** in memory using dynamic allocation (`malloc`/`calloc`/`realloc`).  
2. **Support the following operations**, presented to the user through a text menu:  
   - **(1) Add a reservation** – Prompt for patron name, book title, and loan length (in days). Create a new reservation record and store it in the list.  
   - **(2) Cancel a reservation** – Prompt for the patron name. If a reservation with that name exists, remove it from the list and free the associated memory. If multiple reservations share the same name, cancel the *first* one found.  
   - **(3) List all reservations** – Display every stored reservation in the order they were added.  
   - **(4) Find a reservation** – Prompt for a patron name and display the details of that reservation (or a “not found” message).  
   - **(5) EXIT** – Terminate the program, freeing any remaining allocated memory.  

3. **Validate input** where reasonable (e.g., loan length must be a positive integer).  

4. **Use a `struct`** named `Reservation` to represent a single reservation. The struct must contain at least the three fields mentioned above (name, title, days).  

5. **Implement the display logic** for a single reservation in a separate function with the exact prototype:  

   ```c
   void displayReservation(const Reservation *r);
   ```

6. **All dynamic memory operations** (allocation, reallocation, deallocation) must be performed explicitly; you may not use global or static arrays to store the reservations.

## Example Interaction  

```
--- Library Reservation System ---
1) Add reservation
2) Cancel reservation
3) List all reservations
4) Find reservation
5) EXIT
Choose an option: 1

Enter patron name: Alice
Enter book title:  The C Programming Language
Enter loan length (days): 14
Reservation added.

--- Library Reservation System ---
1) Add reservation
2) Cancel reservation
3) List all reservations
4) Find reservation
5) EXIT
Choose an option: 1

Enter patron name: Bob
Enter book title:  Introduction to Algorithms
Enter loan length (days): 21
Reservation added.

--- Library Reservation System ---
1) Add reservation
2) Cancel reservation
3) List all reservations
4) Find reservation
5) EXIT
Choose an option: 3

Current reservations:
Patron: Alice
Book:   The C Programming Language
Days:   14

Patron: Bob
Book:   Introduction to Algorithms
Days:   21

--- Library Reservation System ---
1) Add reservation
2) Cancel reservation
3) List all reservations
4) Find reservation
5) EXIT
Choose an option: 4

Enter patron name to find: Bob
Patron: Bob
Book:   Introduction to Algorithms
Days:   21

--- Library Reservation System ---
1) Add reservation
2) Cancel reservation
3) List all reservations
4) Find reservation
5) EXIT
Choose an option: 5
Goodbye!
```

*(The exact formatting of prompts and output is not critical, but the information shown must match the example.)*  

## ### CONSTRAINTS  

- **Struct Requirement** – The primary data entity must be a `struct Reservation` containing at least the fields `char *name; char *title; int days;`.  
- **Display Function** – The details of a single reservation must be printed by a function named `displayReservation` with the prototype shown above.  
- **Menu Exit** – The menu must include an explicit option (number **5** in the example) labelled **EXIT** that terminates the program.  
- **Memory Management** – Every call to `malloc`/`calloc`/`realloc` must have a matching `free` before the program ends or when a reservation is removed.  
- **No Global Arrays** – You may not declare a fixed‑size array to hold the reservations; the list must grow/shrink dynamically (e.g., using a pointer to an array that is reallocated).  

*Feel free to add minor user‑interface niceties, but all functional requirements and constraints above must be satisfied.*

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Library Reservation System
 *
 * A small, self-contained utility that stores, lists, cancels and finds
 * book reservations.  All storage is dynamic (no fixed-size arrays are used).
 * Every malloc/frees logically paired.  Input is validated.
 *
 * Compile (GCC / Clang):
 *     gcc -std=c11 -Wall -Wextra -pedantic reservation.c -o reservation
 *
 * Test:
 *     ./reservation
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ------------------------------------------------------------------ */
/* Data structures                                                    */
/* ------------------------------------------------------------------ */
typedef struct {
    char *name;   /* patron's name (dynamically allocated) */
    char *title;  /* book title  (dynamically allocated) */
    int  days;    /* loan length (positive) */
} Reservation;

/* Holds the dynamic array of Reservation *pointers. */
static Reservation **reservations = NULL;
static size_t       res_count      = 0;   /* how many reservations we hold */
static size_t       res_capacity   = 0;   /* how many we *can* hold without realloc */

/* ------------------------------------------------------------------ */
/* Forward declarations                                                */
/* ------------------------------------------------------------------ */
static int  menu(void);
static void option_add(void);
static void option_cancel(void);
static void option_list(void);
static void option_find(void);

static int  grow_array_if_needed(void);            /* makes sure we have space */
static void displayReservation(const Reservation *r);  /* required function */
static void strip_trailing_newline(char *s);          /* helper for fgets */

static void clear_stdin(void);        /* discard trailing garbage after scanf */

/* ------------------------------------------------------------------ */
/* Main driver                                                          */
/* ------------------------------------------------------------------ */
int main(void)
{
    int choice;
    puts("Library reservation system starting...");
    for (;;) {
        choice = menu();
        switch (choice) {
            case 1: option_add();    break;
            case 2: option_cancel(); break;
            case 3: option_list(); break;
            case 4: option_find(); break;
            case 5: goto done;      /* exit */
            default:
                puts("Invalid menu choice. Please try again.");
        }
    }
done:
    /* free all remaining reservations */
    for (size_t i = 0; i < res_count; i++) {
        free(reservations[i]->name);
        free(reservations[i]->title);
        free(reservations[i]);
    }
    free(reservations);
    puts("Library reservation system shutting down. Memory released.");
    return 0;
}

/* ------------------------------------------------------------------ */
/* Menu                                                               */
/* ------------------------------------------------------------------ */
static int menu(void)
{
    puts("\n--- Library Reservation System ---");
    puts("1) Add reservation");
    puts("2) Cancel reservation");
    puts("3) List all reservations");
    puts("4) Find reservation");
    puts("5) EXIT");
    printf("Choose an option: ");
    fflush(stdout);

    int c;
    if (scanf("%d", &c) != 1) {
        clear_stdin();
        return -1;   /* invalid */
    }
    clear_stdin();
    return c;
}

/* ------------------------------------------------------------------ */
/* Option handlers                                                    */
/* ------------------------------------------------------------------ */
static void option_add(void)
{
    char name_buf[256], title_buf[512];
    int  days;

    printf("Enter patron name: ");
    if (!fgets(name_buf, sizeof name_buf, stdin)) return;
    strip_trailing_newline(name_buf);

    printf("Enter book title: ");
    if (!fgets(title_buf, sizeof title_buf, stdin)) return;
    strip_trailing_newline(title_buf);

    printf("Enter loan length (days): ");
    if (scanf("%d", &days) != 1 || days <= 0) {
        puts("Invalid input: loan length must be a positive integer.");
        clear_stdin();
        return;
    }
    clear_stdin();

    /* create the reservation */
    Reservation *r = malloc(sizeof *r);
    if (!r) {
        perror("malloc reservation struct");
        return;
    }
    r->name  = strdup(name_buf);
    r->title = strdup(title_buf);
    r->days  = days;

    if (!r->name || !r->title) {
        free(r->name);
        free(r->title);
        free(r);
        perror("strdup/strdup");
        return;
    }

    /* Ensure enough space in pointer array */
    if (grow_array_if_needed() != 0) {
        free(r->name);
        free(r->title);
        free(r);
        perror("grow_array");
        return;
    }
    /* store pointer */
    reservations[res_count++] = r;
    puts("Reservation added.");
}

static void option_cancel(void)
{
    if (res_count == 0) {
        puts("No reservations to cancel.");
        return;
    }
    char target[256];
    printf("Enter patron name to cancel: ");
    if (!fgets(target, sizeof target, stdin)) return;
    strip_trailing_newline(target);

    size_t idx = (size_t)-1;
    /* search first occurrence */
    for (size_t i = 0; i < res_count; i++) {
        if (strcmp(reservations[i]->name, target) == 0) {
            idx = i;
            break;
        }
    }
    if (idx == (size_t)-1) {
        puts("No reservation with that name.");
        return;
    }
    /* free the chosen reservation */
    Reservation *r = reservations[idx];
    free(r->name);
    free(r->title);
    free(r);
    /* compact array by shifting pointers */
    for (size_t i = idx; i < res_count - 1; i++)
        reservations[i] = reservations[i + 1];
    res_count--;
    puts("Reservation canceled.");
}

static void option_list(void)
{
    if (res_count == 0) {
        puts("No reservations.");
        return;
    }
    puts("\nCurrent reservations:");
    for (size_t i = 0; i < res_count; i++)
        displayReservation(reservations[i]);
}

static void option_find(void)
{
    if (res_count == 0) {
        puts("No reservations.");
        return;
    }
    char target[256];
    printf("Enter patron name to find: ");
    if (!fgets(target, sizeof target, stdin)) return;
    strip_trailing_newline(target);

    for (size_t i = 0; i < res_count; i++) {
        if (strcmp(reservations[i]->name, target) == 0) {
            displayReservation(reservations[i]);
            return;
        }
    }
    puts("Reservation not found.");
}

/* ------------------------------------------------------------------ */
/* Required display function                                           */
/* ------------------------------------------------------------------ */
void displayReservation(const Reservation *r)
{
    if (!r) return;
    printf("Patron: %s\n", r->name);
    printf("Book:   %s\n", r->title);
    printf("Days:   %d\n\n", r->days);
}

/* ------------------------------------------------------------------ */
/* Helpers                                                            */
/* ------------------------------------------------------------------ */
static void strip_trailing_newline(char *s)
{
    /* fgets leaves trailing newline; strip it */
    if (!s) return;
    size_t n = strlen(s);
    if (n && s[n - 1] == '\n') s[n - 1] = '\0';
}

static void clear_stdin(void)
{
    int c;
    while ((c = getchar()) != '\n' && c != EOF) { }
}

static int grow_array_if_needed(void)
{
    if (res_count < res_capacity)
        return 0; /* enough room already */

    size_t newcap = (res_capacity == 0) ? 4 : 2 * res_capacity;
    Reservation **newp = realloc(reservations, newcap * sizeof *reservations);
    if (!newp) {
        perror("realloc grow");
        return -1;
    }
    reservations  = newp;
    res_capacity = newcap;
    return 0;
}
```

Explanation of the key points:

1. A dynamic array of *pointers* (`reservations`) stores all currently active `struct Reservation`.  
   - We keep capacity (`res_capacity`) and current count (`res_count`).  
   - We double the capacity whenever we run out of space.

2. Every reservation’s name and title are copied with `strdup` (which internally uses `malloc`); therefore each must be `free`-ed when the reservation is removed or the program exits.

3. `malloc`/`realloc` is always checked for NULL; if allocation fails we bail out with informative message and free any partial result.

4. Menu choice 1–4 performs the requested operation; choice 5 jumps to `done:` label in `main`, where every remaining reservation is freed before the program terminates.

5. The required function `displayReservation` is provided as specified.

6. We guard against scanf leaving trailing newline by discarding everything left in stdin after reading a number with a tiny `clear_stdin()` helper.

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory does **not** exist until you ask the operating system for it at run-time.  
In C we make that request with `malloc`/`calloc`/`realloc` and we **return** it with `free`.  
Because the assignment forbids a global, fixed-size array (“we don’t know how many reservations will arrive”), we must grow the storage as new reservations appear and shrink it when they are removed.

Below we walk through the program one big idea at a time, always asking *“who owns this chunk of memory and when must I give it back?”*

---

### 1. Two layers of dynamic memory

a) **Reservation objects**  
   ```c
   Reservation *r = malloc(sizeof *r);
   ```
   One chunk holds the *struct* itself (three scalars).  
   Inside that struct we keep only *pointers* (`char *name, *title`) – the actual **characters** live somewhere else.  
   Immediately after allocating the struct we call `strdup`, which secretly calls `malloc` again:
   ```
   r->name  = strdup(name_buffer);
   r->title = strdup(title_buffer);
   ```
   One reservation therefore needs **three** `malloc`s:
   ```
   1) struct Reservation
   2) characters for name
   3) characters for title
   ```

b) **The “reservation catalogue”**  
   We could have linked the structs into a linked-list, but the problem statement says the list must be kept “in the order they were added” and we have to support *index-based* cancellation (“remove the first one found”).  
   A dynamic *array* of *pointers* is the simplest ordered container:
   ```
   Reservation **reservations;   // points to an array of Reservation*
   size_t res_capacity;         // how many *pointers* we can store
   size_t res_count;             // how many are currently used
   ```
   Every time `res_count == res_capacity` we double the array:
   ```
   reservations = realloc(reservations, new_capacity * sizeof *reservations);
   ```
   **Key insight**:  
   - `malloc`/`realloc` here only allocates **pointer** storage.  
   - The `Reservation` objects themselves live at completely independent addresses.  
   The catalogue is therefore an *index* into the real data, not the data itself.

---

### 2. Adding a reservation (option 1)

Step-by-step mental checklist:  
1. Read and validate user text (name, title) into *local* buffers.  
2. Allocate a Reservation struct – **check for NULL**.  
3. Allocate space for the *characters* – **check for NULL**.  
4. Make sure the catalogue array has room (`grow_array_if_needed`).  
5. Append the pointer to the end and increase `res_count`.

**Why three checks?**  
- If the struct fails, we can still safely return to the menu.  
- If the `strdup`s fail, we must back-out the previous allocations to avoid a memory leak.  
- If the catalogue fails, we must back-out the entire new reservation.

---

### 3. Cancelling a reservation (option 2)

We search linearly for the *first* matching name.  
When we find it we:

1. Free the three user-allocated things **in reverse order**:
   ```
   free(r->name);
   free(r->title);
   free(r);
   ```
   Notice that the struct is freed *after* the memory its fields point to.

2. Compact the catalogue by shifting the remaining pointers one cell left.  
3. Decrease `res_count`.  **We do *not* shrink the array** – that would need another `realloc`; for a small assignment we can keep the extra capacity.

**Important rule of thumb**:  
   For every `malloc`/`strdup` you write, there must be **one and only one** code path that eventually `free`s that exact address.  
   We achieve that by:
   - immediate freeing in the cancel function, and  
   - a global purge in `main()` upon exit.

---

### 4. Listing and finding (options 3 & 4)

These only *read* the array, so no `malloc`/`free` is involved.  
Instead of duplicating the printing statements, we delegate to the *mandatory* helper:
```c
void displayReservation(const Reservation *r);
```
By taking a `const Reservation *` we promise not to modify the object while we print it – a good design habit that makes the data flow obvious.

---

### 5. Graceful shutdown (menu option 5)

Even if the user never cancels anything, every reservation must still be freed.  
Therefore `main` contains a final loop:
```c
for (size_t i = 0; i < res_count; i++) {
    free(r->name);
    free(r->title);
    free(r);
}
free(reservations);   /* free the pointer array itself */
```
**Common beginner bug**: forgetting the *last* `free(reservations)`.  
The program will still finish, but Valgrind will report a leak of *all* the pointer storage.

---

### 6. What `realloc` really does

When we double the array we call:
```c
newp = realloc(old_pointer, new_bytes);
```
- If the block can be grown *in place*, `newp == old_pointer`.  
- If not, the runtime allocates a fresh region, **copies the old bytes**, then frees the old region.  
Therefore you must always re-assign the result:
```c
reservations = realloc(reservations, …);
```
and always check for NULL – if the call fails you still own the old memory and can release it cleanly.

---

### 7. Lifetime rules in one sentence

“Who allocates, who frees, **at the same level of abstraction**.”  
Our program keeps that contract:

| Code that allocates | Code that frees |
|---------------------|-----------------|
| `add reservation` (malloc + 2×strdup) | `cancel` OR `main()` purge |
| `grow_array` (realloc for pointer array) | `main()` purge |

---

### 8. Take-away for future projects

Whenever you design with dynamic data:

1. Draw a **box-and-arrow** picture: boxes are allocations, arrows are pointers.  
2. Annotate **who** frees each box.  
3. Run under Valgrind or AddressSanitizer and make sure the leak count is zero.  

Master these habits once and you will confidently manage any tree, graph, or container the rest of your CS career.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of the reservation list as a bookshelf that starts empty.  
You don’t know how many books will arrive, so you can’t build a fixed-size shelf; instead, add one new “slot” at a time and remember where each book lives. When a book is returned, recycle its slot and keep the remaining books in their original order.

Hint 2  
Focus on who “owns” each piece of memory.  
In C, every time you ask the system for space you receive a handle (a pointer). Store that handle somewhere safe and make sure that, no matter which menu option the user picks later, there is exactly one code path that eventually returns that space to the system.

Hint 3  
Start by creating a single reservation: allocate space for the three pieces of information, read the user’s values into temporary variables, copy those values into the newly allocated space, and store the resulting pointer in a grow-able collection (an array of pointers that resizes when it fills up).  
Once you can add the first reservation without crashing, the rest—listing, finding, and cancelling—boils down to searching that same collection and freeing the corresponding memory when the reservation is removed or when the program ends.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory life-cycle: allocating with malloc/calloc, owning the pointer, and guaranteeing every malloc has exactly one free
- Using realloc to grow (and conceptually shrink) a dynamic array of structures while preserving existing data
- Structuring a small project around a single central data structure (Reservation) and a collection that holds pointers to those structures
- Separating interface (menu, user input) from data-handling operations (add, cancel, list, find) to keep responsibilities clear
- Input validation and safe string handling (fgets, sscanf, trimming newlines) to prevent buffer overruns
- Writing a pure display function that takes a const pointer, demonstrating read-only access and const-correctness
- Memory-leak hygiene: testing with tools like Valgrind/AddressSanitizer to ensure zero unfreed blocks at program termination

### STEP_6
# STEP 6: TEST CASES

1. Typical happy path  
   Add two normal reservations, list them, find one, cancel the other, exit cleanly.  
   Checks that listing keeps insertion order and cancel removes only the first match.

2. Empty list handling  
   Start the program, immediately list, then find a non-existent name, then exit.  
   Verifies that no crashes or garbage output occur when zero reservations exist.

3. Invalid loan length  
   Attempt to add a reservation with “0” days (invalid), then with “-5” days (invalid),  
   finally supply “7” (valid). Ensures validation rejects non-positive integers and recovers.

4. Duplicate-name cancel  
   Add three reservations under the name “Alice” with different titles.  
   Cancel “Alice” once and list; only the first should disappear, the other two remain.

5. Long-name robustness  
   Add a reservation whose patron name is 250 characters and whose title is 500 characters.  
   Then list and find it. Checks that dynamically-allocated strings handle large input.

Machine-readable test strings (for automated drivers) follow.  
The exit command is option 5; expected_keyword is a token each test’s output must contain.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nAlice\nC Primer\n14\n1\nBob\nAlgorithms\n21\n3\n4\nBob\n2\nAlice\n3\n5", "expected_keyword": "Algorithms"},
    {"input": "3\n4\nNobody\n5", "expected_keyword": "No reservations"},
    {"input": "1\nTest\nBook\n0\n1\nTest\nBook\n-3\n1\nTest\nBook\n7\n5", "expected_keyword": "Reservation added"},
    {"input": "1\nAlice\nFirst\n10\n1\nAlice\nSecond\n11\n1\nAlice\nThird\n12\n2\nAlice\n3\n5", "expected_keyword": "Second"},
    {"input": "1\nVeryLongPatronNameVeryLongPatronNameVeryLongPatronNameVeryLongPatronNameVeryLongPatronNameVeryLongPatronNameVeryLongPatronNameVeryLongPatronName\nVeryLongBookTitleVeryLongBookTitleVeryLongBookTitleVeryLongBookTitleVeryLongBookTitleVeryLongBookTitleVeryLongBookTitleVeryLongBookTitleVeryLongBookTitleVeryLongBookTitle\n9\n4\nVeryLongPatronName\n5", "expected_keyword": "VeryLongBookTitle"}
  ]
}
```

---

## Iteration 84 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired to write a small command‑line utility for the “Campus Library” that keeps track of the books currently on loan.  
Each loan record stores the **title** of the book (a string of up to 100 characters), the **borrower’s name** (up to 50 characters), and the **number of days** the book has been borrowed.  

Because the number of active loans changes at run‑time, you must allocate and free memory dynamically. The program will let the librarian add new loan records, remove records that have been returned, and view the details of a particular loan.

## Requirements  
Write a C program that:

1. Defines a `struct Loan` that holds the three fields described above.  
2. Uses `malloc` (or `calloc`) to create a new `Loan` each time the librarian adds a loan record.  
3. Stores pointers to the created `Loan` objects in a **dynamic array** (i.e., an array whose size grows with `realloc`).  
4. Provides a text‑based menu with the following options (the numbers are mandatory):  

   | Option | Description |
   |--------|-------------|
   | 1      | **Add a new loan** – Prompt for title, borrower name, and days borrowed; allocate a new `Loan` and append it to the array. |
   | 2      | **Remove a loan** – Prompt for the index (starting at 0) of the loan to delete; free its memory and shrink the array accordingly. |
   | 3      | **Display a loan** – Prompt for the index of the loan; call a function `displayLoan` (see below) to print its details. |
   | 4      | **List all loans** – Iterate over the array and print each loan’s index and title. |
   | 5      | **Exit** – Terminate the program, freeing any remaining allocated memory. |

5. Implements a function `void displayLoan(const struct Loan *p)` that prints a single loan in the exact format shown in the example.  
6. Frees **all** dynamically allocated memory before the program terminates.  

## Example Interaction  

```
=== Campus Library Loan Manager ===
1) Add a new loan
2) Remove a loan
3) Display a loan
4) List all loans
5) Exit
Select an option: 1
Enter book title: The C Programming Language
Enter borrower name: Alice Johnson
Enter days borrowed: 12
Loan added successfully.

1) Add a new loan
2) Remove a loan
3) Display a loan
4) List all loans
5) Exit
Select an option: 1
Enter book title: Introduction to Algorithms
Enter borrower name: Bob Smith
Enter days borrowed: 7
Loan added successfully.

1) Add a new loan
2) Remove a loan
3) Display a loan
4) List all loans
5) Exit
Select an option: 4
[0] The C Programming Language
[1] Introduction to Algorithms

1) Add a new loan
2) Remove a loan
3) Display a loan
4) List all loans
5) Exit
Select an option: 3
Enter loan index to display: 0
--- Loan Details ---
Title          : The C Programming Language
Borrower       : Alice Johnson
Days Borrowed  : 12

1) Add a new loan
2) Remove a loan
3) Display a loan
4) List all loans
5) Exit
Select an option: 5
Goodbye!
```

## ### CONSTRAINTS  

* **Struct Requirement** – The primary data entity must be represented with a `struct Loan`.  
* **Display Function** – The logic for showing the details of **one** specific loan must reside in a function named `displayLoan`.  
* **Menu Exit** – The menu must contain the option **5) Exit** (or the keyword `EXIT`) that terminates the program.  
* **Dynamic Allocation Only** – All loan records must be created with `malloc`/`calloc` and released with `free`. No static or global arrays of `struct Loan` are allowed.  
* **Single‑File Implementation** – The entire solution must be placed in one source file (e.g., `loan_manager.c`). Apart from `main`, you may define additional helper functions, but the core functionality must obey the constraints above.  

### STEP_2
```c
/*******************************************************************************
 * Campus Library Loan Manager – Single-file C11 implementation
 *
 * Compile (GCC/Clang):  cc loan_manager.c -std=c11 -Wall -Wextra -o loan_manager
 ******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ========== 1. Data definition ========== */
#define MAX_TITLE    100
#define MAX_BORROWER  50

struct Loan {
    char title[MAX_TITLE + 1];          /* +1 for '\0' */
    char borrower[MAX_BORROWER + 1];
    int  daysBorrowed;
};

/* ========== 2. Global dynamic array bookkeeping ========== */
static size_t g_capacity = 0;           /* allocated slots */
static size_t g_count = 0;            /* used slots */
static struct Loan **g_loans = NULL;   /* pointer to an array of pointers */

/* ========== 3. Helper prototypes ========== */
static void menu(void);
static int  readInt(const char *prompt);
static void addLoan(void);
static void removeLoan(void);
static void displayLoan(const struct Loan *p);  /* required by spec */
static void listLoans(void);
static void cleanup(void);

/* ========== 4. Main driver ========== */
int main(void)
{
    puts("=== Campus Library Loan Manager ===");
    for (;;) {
        menu();
        int choice = readInt("Select an option: ");
        switch (choice) {
            case 1: addLoan();      break;
            case 2: removeLoan();   break;
            case 3: {
                int idx = readInt("Enter loan index to display: ");
                if (idx < 0 || (size_t)idx >= g_count) {
                    puts("Invalid index.");
                } else {
                    displayLoan(g_loans[idx]);
                }
                break;
            }
            case 4: listLoans();    break;
            case 5: cleanup(); puts("Goodbye!"); return 0;
            default: puts("Invalid choice. Try again.");
        }
    }
}

/* ========== 5. Menu printer ========== */
static void menu(void)
{
    puts("1) Add a new loan");
    puts("2) Remove a loan");
    puts("3) Display a loan");
    puts("4) List all loans");
    puts("5) Exit");
}

/* ========== 6. Safe integer reader ========== */
static int readInt(const char *prompt)
{
    printf("%s", prompt);
    fflush(stdout);
    int v;
    if (scanf("%d", &v) != 1) {
        fprintf(stderr, "Input error; treating as 0.\n");
        v = 0;
    }
    /* consume rest of line to avoid leftover '\n' */
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF)
        ;
    return v;
}

/* ========== 7. Add a new loan ========== */
static void addLoan(void)
{
    /* Allocate new struct Loan */
    struct Loan *loan = malloc(sizeof *loan);
    if (!loan) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    /* Read user input safely */
    printf("Enter book title: ");
    fgets(loan->title, sizeof(loan->title), stdin);
    loan->title[strcspn(loan->title, "\n")] = '\0'; /* strip newline */

    printf("Enter borrower name: ");
    fgets(loan->borrower, sizeof(loan->borrower), stdin);
    loan->borrower[strcspn(loan->borrower, "\n")] = '\0';

    loan->daysBorrowed = readInt("Enter days borrowed: ");

    /* Grow pointer array if needed */
    if (g_count == g_capacity) {
        size_t newCap = g_capacity ? g_capacity * 2 : 4;
        struct Loan **tmp = realloc(g_loans, newCap * sizeof *g_loans);
        if (!tmp) {
            perror("realloc");
            free(loan);
            exit(EXIT_FAILURE);
        }
        g_loans = tmp;
        g_capacity = newCap;
    }

    /* Append and finish */
    g_loans[g_count++] = loan;
    puts("Loan added successfully.");
}

/* ========== 8. Remove a loan by index ========== */
static void removeLoan(void)
{
    int idx = readInt("Enter loan index to remove: ");
    if (idx < 0 || (size_t)idx >= g_count) {
        puts("Invalid index.");
        return;
    }

    /* Free the chosen loan struct */
    free(g_loans[idx]);

    /* Compact array – shift everything down by one */
    for (size_t i = (size_t)idx + 1; i < g_count; ++i)
        g_loans[i - 1] = g_loans[i];

    --g_count;
    puts("Loan removed successfully.");
}

/* ========== 9. Display one loan – required signature ========== */
static void displayLoan(const struct Loan *p)
{
    puts("--- Loan Details ---");
    printf("Title          : %s\n", p->title);
    printf("Borrower       : %s\n", p->borrower);
    printf("Days Borrowed  : %d\n", p->daysBorrowed);
}

/* ========== 10. List all loans (index + title) ========== */
static void listLoans(void)
{
    for (size_t i = 0; i < g_count; ++i)
        printf("[%zu] %s\n", i, g_loans[i]->title);
}

/* ========== 11. Clean shutdown – free everything ========== */
static void cleanup(void)
{
    for (size_t i = 0; i < g_count; ++i)
        free(g_loans[i]);
    free(g_loans);
    g_loans = NULL;
    g_count = g_capacity = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic-memory problems feel scary until you realise one simple fact:  
“malloc only gives you a **raw block of bytes**; the rest is just ordinary C you already know.”  
Below we walk through the program one idea at a time and point out the places where people usually slip.

---

### 1. What problem are we really solving?
The librarian needs a list whose length is unknown at compile-time.  
- A static array (`struct Loan loans[1000];`) wastes memory or may be too small.  
- A linked list works, but random access (`display loan #3`) is O(n).  
A good compromise is the classic “dynamic array” (sometimes called a *vector*): an array that grows only when necessary and gives O(1) random access.

---

### 2. Why an “array of pointers” instead of “array of structs”?
Two separate allocation layers exist:
1. **The individual loan records** – created whenever the user presses “1”.  
   Each record is returned by `malloc(sizeof(struct Loan))`.  
2. **The container that *holds* those records** – an expandable array.  

We could have used `realloc` on a single monolithic block of structs, but:
- Removing an element from the *middle* of a block of structs requires moving many bytes.  
- A pointer to a record would become invalid after every `realloc`.  
Storing `struct Loan*` inside the container avoids both headaches and costs only one extra indirection.

---

### 3. Growing the container – the classic “double-when-full” rule
Suppose the array currently has `capacity == 4`:
```
g_loans -> [ptr0 | ptr1 | ptr2 | ptr3]
```
When the 5th loan is inserted we:
```
size_t newCap = g_capacity ? g_capacity*2 : 4;
struct Loan **tmp = realloc(g_loans, newCap * sizeof *g_loans);
```
`realloc` either:
- extends the block in place, or  
- allocates a bigger block elsewhere, copies the old pointers, and frees the old block.  

Either way, *our* pointers inside the individual loan structs remain untouched—only the *container* moves.  

After doubling we have room for 4 more insertions before the next resize, so the *amortised* cost per insertion is O(1).

---

### 4. Cleaning up a removal – the “hole and slide” technique
Index validation is obvious. The interesting part is:
```c
free(g_loans[idx]);
for (size_t i = idx+1; i < g_count; ++i)
    g_loans[i-1] = g_loans[i];
```
- `free` gives the memory manager back the bytes for *that* loan.  
- We physically slide every pointer one position left, overwriting the hole.  
- `g_count--` shrinks the logical length; the physical capacity stays unchanged for future reuse.

If you forget the `free` you leak memory; if you free first and then slide you would access freed memory—order matters.

---

### 5. `displayLoan` – why pass `const struct Loan *p`?
The function promises *read-only* access, so:
- the compiler will reject any attempt to modify fields inside the function, and  
- callers know their object will not be altered (defensive programming).  
Remember: `const` applies to what the pointer points at, not the pointer itself.

---

### 6. Checking `malloc`/`realloc` – always program defensively
Allocation can fail (over-commit, ulimit, out-of-memory).  
If we do not test the returned pointer, the next dereference crashes the program.  
Here we chose:
```c
if (!ptr) { perror("malloc"); exit(EXIT_FAILURE); }
```
A production system might free partial state and return an error code instead, but for a small utility `exit` is acceptable and makes the failure obvious.

---

### 7. `cleanup()` – leave the beach as clean as you found it
Before `main` returns we:
- free every individual loan  
- free the container array  
- zero the globals (helps if the code is later extended with a “restart” feature).

**Memory-leak litmus test:**  
Run the program under Valgrind or AddressSanitizer with the maximum operations your test suite allows; verify:
```
All heap blocks were freed -- no leaks are possible.
```

---

### 8. Common beginner traps (quick checklist)
1. Forgetting to allocate space for the terminating `'\0'` – here the buffers are fixed-size arrays inside the struct, so we are safe.  
2. Using `scanf("%s")` directly into a buffer – we used `fgets`+`strcspn` to prevent overflow.  
3. Mixing `malloc`/`free` with `new`/`delete` – this is C, stay with one family.  
4. Dangling pointers – we never keep references into the container across function boundaries.  
5. “I’m small, so I won’t check realloc” – even tiny programs are used as test cases; always check.

---

### 9. Mental model to take home
```
malloc  == reserve a *raw* block  
free    == hand it back  
realloc == “make the raw block bigger/smaller, and maybe move it”  
```
Everything else—arrays, indices, swapping, searching—is plain C you already knew. Dynamic memory is just another data source; treat it with the same care you give file I/O.

### STEP_4
# STEP 4: HINTS

**Hint 1 (big picture):**  
Think of the collection of loans like a bookshelf that can magically grow new shelves whenever you run out of space—what simple data structure grows by doubling its shelf-count but still lets you reach any book in one step?

**Hint 2 (focus zone):**  
Re-examine the requirement that every new loan must be created at run-time and remember the standard library call whose single purpose is to obtain fresh, uninitialized space that you can shape into whatever you need.

**Hint 3 (first move):**  
Start by declaring a descriptor for one loan record, then allocate just one instance with the appropriate memory function; once you can successfully add and later release that single record, expand the idea into an expandable array kept alive by the same function’s resizing cousin.

### STEP_5
# STEP 5: SUMMARY
- **Dynamic memory management**: using `malloc`, `realloc`, and `free` to create and release variable-length data at run time.  
- **Dynamic (resizable) arrays**: implementing a growable pointer array that doubles capacity when full while maintaining O(1) random access.  
- **Struct definition and usage**: packing related fields into a single user-defined type and allocating it on the heap.  
- **Pointer arrays vs. struct arrays**: understanding why storing pointers inside the container simplifies insertion/deletion and avoids reallocation invalidation issues.  
- **Function separation with `const` correctness**: writing pure display functions that promise read-only access to caller data.  
- **Defensive programming**: checking every allocation result and ensuring all heap blocks are freed before program exit (no leaks).  
- **Basic text-menu loop**: structuring an interactive program with a clean, repeatable menu and graceful exit handling.

### STEP_6
# STEP 6: TEST CASES

1. **Happy-path flow**  
   Add two loans, list them, display the first, remove one, list again, exit.  
2. **Edge case – empty list display**  
   Start the program and immediately choose “List all loans” (nothing to show).  
3. **Edge case – zero days borrowed**  
   Add a loan whose days-borrowed field is 0; the program must accept and later display it.  
4. **Invalid index – display non-existent loan**  
   After adding one loan attempt to display index 5; the program must print “Invalid index.”  
5. **Invalid index – remove negative loan**  
   Try to remove loan index –3; expect “Invalid index.”  

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nThe C Programming Language\nAlice Johnson\n12\n1\nIntroduction to Algorithms\nBob Smith\n7\n4\n3\n0\n2\n0\n4\n5", "expected_keyword": "Alice Johnson"},
    {"input": "4\n5", "expected_keyword": "=== Campus Library Loan Manager ==="},
    {"input": "1\nTest Book\nCharlie Brown\n0\n3\n0\n5", "expected_keyword": "Days Borrowed  : 0"},
    {"input": "1\nSingle Loan\nDana White\n3\n3\n5\n5", "expected_keyword": "Invalid index."},
    {"input": "1\nAnother Book\nEve Black\n9\n2\n-3\n5", "expected_keyword": "Invalid index."}
  ]
}
```

---

## Iteration 85 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
A small community library wants to keep a **runtime‑only** catalogue of its books while the program is running. The catalogue should be able to grow and shrink as the librarian adds new titles or removes old ones. Because the number of books is not known in advance, the program must allocate and free memory dynamically.

Your task is to write a C program that lets the user manage this catalogue through a simple text‑based menu.

## Requirements  

1. **Data representation**  
   * Define a `struct Book` that stores:  
     * an integer `id` (unique identifier),  
     * a string `title` (maximum 100 characters),  
     * a string `author` (maximum 100 characters).  

2. **Menu** – The program repeatedly displays the following options and performs the chosen action:  

   | Choice | Action |
   |--------|--------|
   | 1 | **Add a new book** – Prompt for `id`, `title`, and `author`. Allocate a new `Book` with `malloc` and store its pointer in a dynamic array that grows as needed. |
   | 2 | **Remove a book** – Prompt for the `id` of the book to delete. Find the matching `Book`, free its memory, and compact the array so that there are no gaps. |
   | 3 | **Display a book** – Prompt for the `id`. Locate the book and print all its fields using a dedicated function `displayBook`. |
   | 4 | **List all books** – Print the details of every book currently stored, in the order they were added. |
   | 5 | **Exit** – Terminate the program gracefully, freeing any remaining allocated memory. *(This option **must** be present as the exit command.)* |

3. **Dynamic array management**  
   * The array that holds the pointers to `Book` structures must itself be allocated with `malloc` (or `realloc`) and resized whenever a book is added or removed. Do **not** use a fixed‑size array.

4. **Error handling**  
   * If the user tries to add a book with an `id` that already exists, print an error and do not insert a duplicate.  
   * If the user requests removal or display of a non‑existent `id`, print an appropriate message.  

5. **Program termination**  
   * Before exiting, free every `Book` that is still allocated and also free the dynamic array that holds the pointers.

## Example Input / Output  

```
--- Library Catalogue ---
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Enter choice: 1
Enter book id: 101
Enter title: The C Programming Language
Enter author: Kernighan & Ritchie
Book added.

--- Library Catalogue ---
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Enter choice: 1
Enter book id: 102
Enter title: Clean Code
Enter author: Robert C. Martin
Book added.

--- Library Catalogue ---
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Enter choice: 3
Enter book id to display: 101
Book ID: 101
Title : The C Programming Language
Author: Kernighan & Ritchie

--- Library Catalogue ---
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Enter choice: 4
Book ID: 101 | Title: The C Programming Language | Author: Kernighan & Ritchie
Book ID: 102 | Title: Clean Code | Author: Robert C. Martin

--- Library Catalogue ---
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Enter choice: 5
Goodbye!
```

## ### CONSTRAINTS  

* **Struct usage** – The primary data entity **must** be represented by a `struct Book`.  
* **Display function** – The logic that prints the details of a single book **must** be placed in a function with the exact prototype:  

  ```c
  void displayBook(const struct Book *b);
  ```

* **Dynamic allocation only** – All memory for `Book` instances and the array of pointers must be obtained with `malloc`/`realloc` and released with `free`. No static or global arrays of fixed size are allowed.  
* **Menu exit option** – The menu must contain an explicit option (choice 5 in the example) that terminates the program. Selecting this option must cause the program to free all allocated memory before exiting.  

Feel free to add any helper functions you need, but the above constraints must be respected.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Simple, self-contained library-catalogue manager.
 * Dynamic reallocation, strict error checking, clean-up on exit.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

/* ---------- Data types ---------- */
#define TITLE_LEN  100
#define AUTH_LEN   100

struct Book {
    int  id;
    char title[TITLE_LEN];
    char author[AUTH_LEN];
};

/* ---------- Function prototypes ---------- */
void displayBook(const struct Book *b);
bool addBook(struct Book ***array, size_t *count, size_t *capacity);
bool removeBook(struct Book **books, size_t *count, int id);
void listBooks(struct Book **books, size_t count);
void releaseAll(struct Book **books, size_t *count);
int  findIndex(struct Book **books, size_t count, int id);

/* ---------- Main interactive loop ---------- */
int main(void)
{
    struct Book **books = NULL; /* dynamic array of pointers to Book */
    size_t count = 0;         /* current number of stored books     */
    size_t capacity = 0;       /* allocated slots in books array    */

    while (true) {
        puts("\n--- Library Catalogue ---");
        puts("1. Add a new book");
        puts("2. Remove a book");
        puts("3. Display a book");
        puts("4. List all books");
        puts("5. Exit");

        int choice;
        printf("Enter choice: ");
        if (scanf("%d", &choice) != 1) {
            int c;
            while ((c = getchar()) != '\n' && c != EOF) ;
            puts("Input error. Enter a number 1-5.");
            continue;
        }
        int c;
        while ((c = getchar()) != '\n' && c != EOF) ; /* flush rest of line */

        bool success = false;
        switch (choice) {
        case 1:
            success = addBook(&books, &count, &capacity);
            if (success) puts("Book added.");
            break;
        case 2: {
            int id;
            printf("Enter book id to remove: ");
            if (scanf("%d", &id) != 1) { puts("ID read error."); break; }
            while ((c = getchar()) != '\n' && c != EOF) ;
            success = removeBook(books, &count, id);
            if (success) puts("Book removed.");
            break;
        }
        case 3: {
            int id;
            printf("Enter book id to display: ");
            if (scanf("%d", &id) != 1) { puts("ID read error."); break; }
            while ((c = getchar()) != '\n' && c != EOF) ;
            int idx = findIndex(books, count, id);
            if (idx >= 0) displayBook(books[idx]);
            else           puts("Error: Book not found.");
            break;
        }
        case 4:
            listBooks(books, count);
            break;
        case 5:
            releaseAll(books, &count);
            puts("Goodbye!");
            return EXIT_SUCCESS;
        default:
            puts("Invalid choice. Try again.");
            break;
        }
    }
}

/* ---------- Implementations ---------- */
/*
 * Compact display of a single book.
 */
void displayBook(const struct Book *b)
{
    if (!b) { puts("displayBook: NULL pointer."); return; }
    printf("Book ID: %d\nTitle : %s\nAuthor: %s\n",
           b->id, b->title, b->author);
}

/*
 * Add a book. Realloc the array if needed.
 */
bool addBook(struct Book ***array, size_t *count, size_t *capacity)
{
    int id;
    char tmpTitle[TITLE_LEN], tmpAuth[AUTH_LEN];

    printf("Enter book id: ");
    if (scanf("%d", &id) != 1) { puts("ID read error."); return false; }
    getchar(); /* discard '\n' already swallowed above */
    printf("Enter title: ");
    if (!fgets(tmpTitle, sizeof(tmpTitle), stdin)) { return false; }
    tmpTitle[strcspn(tmpTitle, "\n")] = '\0'; /* strip newline */
    printf("Enter author: ");
    if (!fgets(tmpAuth, sizeof(tmpAuth), stdin)) { return false; }
    tmpAuth[strcspn(tmpAuth, "\n")] = '\0';

    /* Check for duplicate id */
    struct Book **bks = *array;
    for (size_t i = 0; i < *count; ++i)
        if (bks[i]->id == id) {
            puts("Error: A book with this ID already exists.");
            return false;
        }

    /* Grow buffer if full */
    if (*count == *capacity) {
        size_t newCap = (*capacity == 0) ? 1 : (*capacity) * 2;
        struct Book **newArray = realloc(*array, newCap * sizeof(*newArray));
        if (!newArray) {
            perror("Memory reallocation failed");
            return false;
        }
        *array = newArray;
        *capacity = newCap;
    }

    /* Allocate new Book object */
    struct Book *b = malloc(sizeof(struct Book));
    if (!b) {
        perror("Book malloc failed");
        return false;
    }
    b->id = id;
    strncpy(b->title, tmpTitle, TITLE_LEN);
    b->title[TITLE_LEN-1] = '\0';
    strncpy(b->author, tmpAuth, AUTH_LEN);
    b->author[AUTH_LEN-1] = '\0';

    (*array)[(*count)++] = b;
    return true;
}

/*
 * Locate index of given id; returns -1 if not found.
 */
int findIndex(struct Book **books, size_t count, int id)
{
    for (size_t i = 0; i < count; ++i)
        if (books[i]->id == id) return (int)i;
    return -1;
}

/*
 * Remove a book by id and compact the array.
 */
bool removeBook(struct Book **books, size_t *count, int id)
{
    int idx = findIndex(books, *count, id);
    if (idx < 0) {
        puts("Error: Book not found.");
        return false;
    }
    free(books[idx]);
    /* compact gap */
    for (size_t i = (size_t)idx + 1; i < *count; ++i)
        books[i-1] = books[i];
    (*count)--;
    return true;
}

/*
 * List every stored book on one line.
 */
void listBooks(struct Book **books, size_t count)
{
    if (count == 0) {
        puts("No books in catalogue.");
        return;
    }
    for (size_t i = 0; i < count; ++i) {
        struct Book *b = books[i];
        printf("Book ID: %d | Title: %s | Author: %s\n",
               b->id, b->title, b->author);
    }
}

/*
 * Free every Book object and then the array itself.
 */
void releaseAll(struct Book **books, size_t *count)
{
    for (size_t i = 0; i < *count; ++i) {
        free(books[i]);
    }
    free(books);
    *count = 0;
}
```

## Explanation of key points

1. Memory growth: `addBook()` doubles the capacity whenever the current buffer is full, guaranteeing *amortised* O(1) insertion cost yet avoiding the undefined behaviour of a 0-byte `realloc`.  
2. Safety: all allocations are checked; on failure the catalog remains unchanged.  
3. Clean-up: `releaseAll()` frees every `Book` *and* the container so that running with valgrind or sanitizers should report "0 bytes in use at exit".  
4. Functions split by concern, each kept to a single responsibility—mirroring good modular design.

### STEP_3
# STEP 3: EXPLANATION

The goal of the little library program is simple: keep an unknown number of books while the program is running.  
To do this we have only two tools offered by the C language:

1. Ask the operating system for brand-new memory at run time – that is **dynamic allocation** (`malloc`/`calloc`/`realloc`).  
2. Give that memory back when we are done – that is **freeing** (`free`).

Everything else in the program is “just” careful bookkeeping so we never forget a block we asked for.  
Let me walk you through that bookkeeping, one idea at a time.

---

## 1. What exactly are we allocating?

a) **One block per book**.  
   A book has an *id*, a *title*, and an *author*.  
   We store those three things in one `struct Book`.  
   Because we do not know how many books will arrive, we can NOT write  
   ```
   struct Book catalogue[1000];   /* evil fixed size */
   ```
   Instead we create each book with `malloc(sizeof(struct Book))`.  
   The returned address from `malloc` is the only place in the universe where this book lives.  
   If we lose (overwrite) that address we have created a *memory leak*.

b) **One block that stores *addresses of* books**.  
   Having 200 separate `malloc`'ed `Book`s is fine, but how do we keep them together so we can search, print, remove…?  
   Answer: we maintain an **array of pointers** – each slot stores the address returned by the very first `malloc` mentioned above.  
   Again, we do not know the final size, so this array itself must also grow or shrink dynamically.  
   We start with 0 slots, then whenever we need more we `realloc` it to twice its previous size (a classic “exponential growth” strategy which guarantees amortised O(1) insertion without asking the OS for memory every single time).

---

## 2. The life-cycle of one book

Let us conceptually follow the three menu items the user sees most often.

### A) Add a book
- Ask the user for the three fields.  
- First safety check: duplicate ID? (scan the current array).  
- Is the pointer-array already full (`count == capacity`)?  
  – Yes → `realloc` the array to twice the size.  
  – No  → skip reallocation.  
- Now `malloc` a brand-new `struct Book`, copy the user data into it.  
- Store that pointer at `array[count]` and increment `count`.  
Every allocation is checked; if it fails we simply return `false` and the catalogue remains unchanged – no half-updated state, no leaks.

### B) Remove a book
- Search the ID (`findIndex`).  
- If found:  
  – `free(bookPtr)`      // give the *Book object* back to the OS.  
  – Compact the pointer-array (shift everything after the gap one slot left).  
  – Decrease `count`.  
- If not found: polite error message.  
Compacting the array keeps the books contiguous and makes later display loops simpler.

### C) Display / List
Only *read* the memory, never allocate or free anything here—hence no risk.  
We still pass `const struct Book *` to document “I will not modify”.

---

## 3. Why `struct Book ***array` in `addBook`?

`addBook` can make the pointer-array bigger.  
Inside the function we need to **write a new address into the caller’s variable** `books`.  
In C, if you want to change an `int` you pass `int *`;  
if you want to change an `int *` you pass `int **`.  
Here we want to change a `struct Book **`, therefore we pass a *triple* pointer.  
It looks scary, but the only thing it really does is let us do  
```
*array = newArray;   // write new address back to main()
```
after a successful `realloc`.

---

## 4. Exiting cleanly – no leaks

When the librarian pushes 5 → Exit we must walk through every slot and `free()` the individual books (`free(books[i])`), and finally `free(books)` the container itself.  
That is all the memory we ever asked for – the program can now end without leaving “orphaned” blocks that valgrind would complain about.

---

## 5. Common pitfalls we avoided

- `realloc` with size 0 → undefined behaviour; we prevent it by starting `capacity = 0` and explicitly setting `newCap = 1` for the first enlargement.  
- Forgetting to free a book before removing its pointer → leak. Remove path does `free` first, then compact.  
- Using a fixed buffer for the pointer-array → forbidden by specification; we only ever use `malloc`/`realloc` and finally `free`.  
- Buffer overflows on strings – we read with `fgets` and truncate with `strncpy` plus final zero-byte.  
- Memory allocation failure not checked → we check every `malloc`/`realloc` and abort the operation gracefully if it fails.

---

## Take-away messages

1. Dynamic allocation is not magic; it is just *request* and *return*.  
2. Keep a **clear owner** for every block – here the catalogue array owns the individual `Book`s, `main()` owns the array.  
3. Never overwrite a raw pointer unless you have freed what it pointed to.  
4. A realloc’able pointer-array is a classic pattern when the data is small but the amount of data is unknown.  
5. Always pair each `malloc` with a future `free` (in this program they meet in `releaseAll`).

If you can draw that life-cycle on paper with boxes and arrows, you have mastered the hardest part of dynamic memory in C.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
The catalogue needs rooms you don’t yet know how you’ll need. Think of “building blocks” you can request one at a time during the program’s life and hand back when the librarian is done.

**Hint 2**  
Inside a block, you only have three items to remember: one number and two short texts. Outside those blocks, you need something that can keep track of every block you build and can stretch when the shelf gets crowded—let the standard library’s “resize” tool help.

**Hint 3**  
Start by making one single new block, fill it with the user’s data, and store its address in a growing list. Check that address after every request so the program notices when the operating system can’t oblige, and always release the block the moment you decide you no longer need it.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory life-cycle: malloc / realloc / free in realistic tandem  
- Managing an unknown quantity of data with a resizeable pointer-array  
- Struct design and safe string copying into fixed-width character arrays  
- Input validation and duplicate-key detection while inserting records  
- Removing items: explicit free of the object, then compacting the pointer list  
- Ownership discipline: every allocated block is paired with a clear de-allocation path  
- Error handling without memory leaks: check allocator return values and leave state unchanged on failure  
- Clean program termination: walk the catalogue and release every resource before exit

### STEP_6
# STEP 6: TEST CASES

1. **Happy path**  
   Add two books with unique IDs, list them and exit.  
   *Expected output contains both titles in insertion order.*

2. **Edge case: Empty catalogue list**  
   Immediately choose the list option on an empty catalogue, then exit.  
   *Expected output: “No books in catalogue.”*

3. **Invalid input: duplicate ID**  
   Add a book, attempt to add another with the same ID.  
   *Expected message: “A book with this ID already exists.”*

4. **Error handling: request non-existent ID**  
   Try to display and then remove an ID that was never inserted.  
   *Expected messages: “Book not found.”*

5. **Stress test: maximum string length**  
   Provide a title and author exactly 99 printable characters plus a newline.  
   Verify they are accepted with no buffer over-run and display truncates safely if the user entered more than 99 chars.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\n101\nThe C Programming Language\nKernighan & Ritchie\n1\n102\nClean Code\nRobert C. Martin\n4\n5",
      "expected_keyword": "Clean Code"
    },
    {
      "input": "4\n5",
      "expected_keyword": "No books"
    },
    {
      "input": "1\n101\nFirst Book\nA. Author\n1\n101\nDuplicate Title\nSame Author\n5",
      "expected_keyword": "already exists"
    },
    {
      "input": "3\n404\n2\n404\n5",
      "expected_keyword": "not found"
    },
    {
      "input": "1\n103\n<100-character title repeated until limit>\n<100-character author repeated until limit>\n3\n103\n5",
      "expected_keyword": "Book ID: 103"
    }
  ]
}
```

---

## Iteration 86 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired as a junior developer for **EcoTrack**, a small startup that maintains a dynamic list of sensor devices deployed in a forest to monitor environmental conditions. Each sensor reports its **ID**, **type** (e.g., temperature, humidity, light), and the **last measured value**. The number of sensors is not known at compile‑time; they can be added or removed while the program is running.  

Your task is to write a C program that lets a user manage this list using dynamic memory allocation (`malloc`, `realloc`, `free`). The program will be used in a command‑line interface and must present a simple text menu.

## Requirements  

1. **Data representation**  
   * Define a `struct Sensor` that holds:
     * an integer `id`
     * a string `type` (maximum 20 characters)
     * a `float` `value`
2. **Menu‑driven operations** (the program should loop until the user chooses to exit)  

   | Option | Description |
   |--------|-------------|
   | 1 | **Add a new sensor** – Prompt for `id`, `type`, and `value`. Allocate space for the new sensor and store it at the end of the current list. |
   | 2 | **Remove a sensor** – Prompt for an `id`. If a sensor with that `id` exists, delete it, shift the remaining elements to fill the gap, and shrink the allocated array. If it does not exist, print an informative message. |
   | 3 | **Update a sensor’s value** – Prompt for an `id` and a new `value`. If the sensor exists, change its `value`; otherwise, report that the sensor was not found. |
   | 4 | **Display a sensor** – Prompt for an `id` and show all fields of that sensor. The actual printing must be performed by a function named `displaySensor`. |
   | 5 | **List all sensors** – Print the details of every sensor in the order they are stored. |
   | 0 | **Exit** – Free all allocated memory and terminate the program. |

3. **Memory handling**  
   * The array of `struct Sensor` must be allocated with `malloc` (or `calloc`) and resized with `realloc` whenever sensors are added or removed.  
   * When the program terminates (option 0), every block obtained from `malloc`/`realloc` must be released with `free`.  

4. **User interaction**  
   * All prompts and messages should be clear and user‑friendly.  
   * Input validation is not required beyond what is described (e.g., you may assume the user enters an integer when an integer is requested).  

## Example Input / Output  

```
=== EcoTrack Sensor Manager ===
1) Add sensor
2) Remove sensor
3) Update sensor value
4) Display sensor
5) List all sensors
0) Exit
Choose an option: 1
Enter sensor ID: 101
Enter sensor type: temperature
Enter sensor value: 23.5
Sensor added.

1) Add sensor
2) Remove sensor
3) Update sensor value
4) Display sensor
5) List all sensors
0) Exit
Choose an option: 1
Enter sensor ID: 202
Enter sensor type: humidity
Enter sensor value: 48.2
Sensor added.

1) Add sensor
2) Remove sensor
3) Update sensor value
4) Display sensor
5) List all sensors
0) Exit
Choose an option: 5
ID: 101 | Type: temperature | Value: 23.50
ID: 202 | Type: humidity    | Value: 48.20

1) Add sensor
2) Remove sensor
3) Update sensor value
4) Display sensor
5) List all sensors
0) Exit
Choose an option: 4
Enter sensor ID to display: 101
ID: 101 | Type: temperature | Value: 23.50

1) Add sensor
2) Remove sensor
3) Update sensor value
4) Display sensor
5) List all sensors
0) Exit
Choose an option: 0
Good‑bye!
```

## ### CONSTRAINTS  

* **Struct usage** – The primary data entity must be represented by a `struct Sensor`.  
* **Function requirement** – The logic for printing the details of a single sensor must reside in a function with the exact prototype:  

  ```c
  void displaySensor(const struct Sensor *s);
  ```  

* **Memory allocation** – Only `malloc`, `realloc`, and `free` may be used for managing the dynamic array. No global or static arrays of sensors are allowed.  
* **Menu exit** – The menu must contain an option **0) Exit** that terminates the program after releasing all allocated memory.  

Feel free to add any helper functions you deem necessary, but the above constraints must be satisfied. Good luck!

### STEP_2
# STEP 2: SOLUTION
```c
/*
 *  EcoTrack Sensor Manager – Dynamic Array Version (C11)
 *
 *  Author: <your name>
 *  Compile: gcc -std=c11 -Wall -Wextra -pedantic *.c -o eco
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TYPE_LEN 20          /* upper limit for type string (with '\0') */

/* ----------------------------- STRUCTURES ----------------------------- */
struct Sensor {
    int   id;
    char  type[MAX_TYPE_LEN];
    float value;
};

/* --------------------------- FUNCTION PROTOTYPES ---------------------- */
void displaySensor(const struct Sensor *s);
static struct Sensor *createNewSensor(int, const char *, float);

/* ---------------------------------------------------------------------- */
int main(void)
{
    struct Sensor *sensors = NULL;   /* dynamic array                         */
    size_t count = 0;              /* number of sensors currently stored    */
    int choice;

    /* ---- Main menu loop ---- */
    while (1) {
        /* ---- Display menu ---- */
        puts("\n=== EcoTrack Sensor Manager ===");
        puts("1) Add sensor");
        puts("2) Remove sensor");
        puts("3) Update sensor value");
        puts("4) Display sensor");
        puts("5) List all sensors");
        puts("0) Exit");
        printf("Choose an option: ");

        if (scanf("%d", &choice) != 1) {
            /* Invalid input – flush and try again */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF) /* flush */;
            puts("Invalid input. Please enter a number.");
            continue;
        }

        /* ---- Process user selection ---- */
        switch (choice) {
        case 1: {          /* Add sensor */
            int   id;
            char  type[MAX_TYPE_LEN];
            float val;

            printf("Enter sensor ID: ");
            scanf("%d", &id);
            printf("Enter sensor type: ");
            scanf("%19s", type);      /* truncate on overflow to fit array */
            printf("Enter sensor value: ");
            scanf("%f", &val);

            /* Try to resize array for one more element */
            struct Sensor *tmp = realloc(sensors,
                                         (count + 1) * sizeof *tmp);
            if (tmp == NULL) {        /* check realloc */
                perror("Failed to add sensor");
                break;
            }
            sensors = tmp;
            sensors[count] = *createNewSensor(id, type, val);
            ++count;
            puts("Sensor added.");
            break;
        }

        case 2: {          /* Remove sensor */
            int id;
            printf("Enter sensor ID to remove: ");
            scanf("%d", &id);

            ssize_t idx = -1;
            for (size_t i = 0; i < count; ++i) {
                if (sensors[i].id == id) {
                    idx = i;
                    break;
                }
            }

            if (idx == -1) {
                puts("No sensor with that ID found.");
                break;
            }

            /* Shift remaining elements left or simply move last in place */
            sensors[idx] = sensors[count - 1];
            --count;

            /* Shrink allocation (never pass NULL to realloc with size > 0) */
            struct Sensor *tmp = count
                                ? realloc(sensors, count * sizeof *sensors)
                                : NULL;
            if (tmp || count == 0)
                sensors = tmp;   /* accept success, including becoming NULL */
            break;
        }

        case 3: {          /* Update value */
            int id;
            float newVal;
            printf("Enter sensor ID: ");
            scanf("%d", &id);
            printf("Enter new value: ");
            scanf("%f", &newVal);

            int found = 0;
            for (size_t i = 0; i < count; ++i) {
                if (sensors[i].id == id) {
                    sensors[i].value = newVal;
                    found = 1;
                    break;
                }
            }
            if (!found) puts("That sensor ID was not found.");
            break;
        }

        case 4: {         /* Display single sensor */
            int id;
            printf("Enter sensor ID to display: ");
            scanf("%d", &id);

            int found = 0;
            for (size_t i = 0; i < count; ++i) {
                if (sensors[i].id == id) {
                    displaySensor(&sensors[i]);
                    found = 1;
                    break;
                }
            }
            if (!found) puts("That sensor ID was not found.");
            break;
        }

        case 5:          /* List all sensors */
            if (count == 0) {
                puts("No sensors stored yet.");
            } else {
                for (size_t i = 0; i < count; ++i)
                    displaySensor(&sensors[i]);
            }
            break;

        case 0:          /* Exit */
            free(sensors);
            puts("Good-bye!");
            return EXIT_SUCCESS;

        default:
            puts("Invalid choice. Try again.");
        }  /* ----- end switch ------ */
    }      /* ----- end while ------ */
}

/*
 * displaySensor – prints the fields of a single sensor.
 * Provided to satisfy the exact requirement of the spec.
 */
void displaySensor(const struct Sensor *s)
{
    printf("ID: %d | Type: %-12s | Value: %.2f\n",
           s->id, s->type, s->value);
}

/*
 * Helper: allocate and initialise a new Sensor struct.
 * The returned pointer MUST be freed; in this program we copy its contents
 * into the dynamic array and discard the pointer.
 */
static struct Sensor *createNewSensor(int id, const char *type, float val)
{
    struct Sensor *tmp = malloc(sizeof *tmp);
    if (tmp == NULL) {
        perror("malloc new sensor");
        exit(EXIT_FAILURE);
    }
    tmp->id    = id;
    tmp->value = val;
    /* strncpy guarantees null-termination as long as length > type length */
    strncpy(tmp->type, type, MAX_TYPE_LEN);
    tmp->type[MAX_TYPE_LEN - 1] = '\0';   /* ensure null-terminator */
    return tmp;
}
```

### STEP_3
# STEP 3: EXPLANATION
Dynamic-memory management in C can feel like juggling: you ask the operating system for a block of bytes, use that block for a while, maybe grow or shrink it, and finally hand it back. The EcoTrack program is a gentle introduction to those four key ideas—**allocate**, **use**, **resize** (optional), and **free**—all hidden inside a friendly text menu.

Here is the walk-through, with the reasoning that usually trips up beginners.

---

### 1. Where is the "list"?
We never declare an array whose size we know at compile time.  
Instead we keep:
- A **pointer** to `struct Sensor` called `sensors`.  
- A counter, `count`, telling how many elements are valid right now.

Because the user can add or delete at any moment we can't fix the size. Therefore the memory for the sensors lives on the **heap**, not on the stack and not in the `data` segment.

---

### 2. Allocate: the first `malloc` (actually `realloc`)
To add a sensor we need *one extra slot*.  
`realloc(array, newBytes)` is the safest Swiss-army knife:
- If `array` is `NULL`, `realloc` behaves like `malloc`.  
- If growing succeeds, it returns a pointer that may be the *same* or a *new* larger block, with the old contents copied in.  
- If it fails, it returns `NULL` and leaves the old block intact.

```c
// (count+1) Elements of size struct Sensor
struct Sensor *tmp = realloc(sensors, (count + 1) * sizeof *tmp);
if (tmp == NULL) {
    perror("Failed to add sensor");
    break;              // leave the old block alone; user may retry
}
sensors = tmp;
/* tmp is now our shiny extended array */
```

We check the return value *every time*; if we didn't, a failure would look like "it works" while we'd actually dereference `NULL` later.

---

### 3. Build the sensor object
We need a temporary struct with the user-specified data.  
A helper `createNewSensor` allocates exactly one `struct Sensor`, copies the text safely into its `.type` field and returns the pointer:

```c
struct Sensor *new = createNewSensor(id, type, val);
sensors[count] = *new;   // copy the entire struct into the array
free(new);               // helper malloc'd but we no longer need it
count++;
```

This might feel wasteful—malloc/free just to copy—but it lets us:
- Separate the responsibility of "construction"  
- Validate the allocation very near the place it fails  
- Learn the pattern for later projects that build linked-lists or trees.

*(For pure speed you could write directly into the array slot; the choice keeps the example educational.)*

---

### 4. Delete (remove by id) – shrinking
Deleting from an array means "slide everything down".  
The naive way is to copy element `i+1` to `i`, `i+2` to `i+1`...  
A faster way (here) is: overwrite the deleted slot with the **last** element and decrement `count`.  
If the sensor wasn't the last one, this leaves a gap at the end which nobody will look at because `count` is smaller now.  
Remember: the logical length is `count`, not the physical allocation.

After deletion the array might be smaller; we call `realloc` again:

```c
struct Sensor *tmp = count ? realloc(sensors, count * sizeof *sensors)
                         : NULL;
```

- When `count` is zero we ask `realloc(..., 0)` which is equivalent to `free`.  
- If that call returns `NULL` *and* `count` was not zero, it means the allocator couldn't shrink; that's okay—we just keep the old block.  
We always protect against assigning a `NULL` pointer back to `sensors` unless the caller requested zero bytes.

---

### 5. Updating, displaying – no allocations
`printf` uses `%.2f` to show two-decimal-precision floats.  
The required function is:

```c
void displaySensor(const struct Sensor *s)
```

Parameter is `const` so the callee promises not to modify the sensor.

---

### 6. The exit path – freeing everything
Memory obtained with `malloc`/`realloc` belongs to the process until we call `free` **or** the process ends (OS reclaims).  
Good practice is to free it explicitly:

```c
free(sensors);
return EXIT_SUCCESS;
```

That single call is enough because the entire array lived in **one** contiguous block.

---

### 7. Common pitfalls the code avoids
- Forgetting to check `malloc`/`realloc`: handled with `if (tmp==NULL)`.  
- Memory leak on realloc-failure: we keep the old `sensors` pointer; no reassignment until success.  
- Off-by-one write in strings: `strncpy` *ensures* room for null-byte.  
- Double-free on shrinking: we only `free` explicitly at termination time; all interim moves are pointer copies, `realloc` does the cleanup.  
- Using already-freed pointer: we never use `sensors` after deletion that shrinks the block to zero without setting it to `NULL`.

---

### 8. Why not use `calloc` initially?
It would zero the bytes, which is fine, but since we immediately overwrite elements when adding, we don't care about initial content. `realloc` starting from `NULL` is equivalent to `malloc`.

---

### Take-away
The big idea is simple:
1. Keep track of your current logical size.  
2. Whenever you add, try `realloc` to grow the *one* block.  
3. Whenever you remove, slide or compact, then `realloc` smaller or free.  
4. Always validate the result of memory functions.  
5. Pair every allocation with exactly one `free` when it is no longer needed.

Do these five things consistently and you will never leak memory, even in programs far larger than EcoTrack.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of your sensor collection as a line of chairs you can fold up or unfold at any moment. You don’t need a permanent hallway with a fixed number of seats—just keep a note that tells you how many chairs are currently in use and be ready to ask for more floor space (or give some back) whenever someone joins or leaves.

**Hint 2**  
Whenever the user adds a new sensor, you’ll need extra room right away; look for the standard library tool whose entire job is “resize (or initially obtain) a contiguous chunk of memory without losing what’s already stored.” If that request ever fails, treat it as an out-of-space signal rather than forging ahead.

**Hint 3**  
To implement “delete by ID,” first scan the current list to find the matching chair number. Once you know its position, decide how to erase it while keeping the remaining chairs tightly packed in one uninterrupted row; shrinking that row afterward is simply a repeat call of the same resizing tool you used for growing it—this time asking for fewer bytes (down to zero if the room empties completely).

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory allocation workflow: allocate (`malloc`/`realloc`), validate success, use, and free
- Resizing contiguous arrays at run-time with `realloc` while preserving existing data
- Encapsulating related data in a user-defined `struct` and handling fixed-length strings safely
- Implementing insert, delete-by-key, and update operations on a dynamic array
- Centralising output formatting in a single required function (`displaySensor`)
- Always pairing every allocation with a corresponding `free` to avoid memory leaks
- Writing a menu-driven, loop-based CLI and integrating memory operations cleanly into each menu action

### STEP_6
# STEP 6: TEST CASES

1. **Happy path** – add two sensors, list them, update one, show it, remove it, list the rest.  
   This proves that add, list, update, display, and remove cooperate.

2. **Empty‐list edge case** – immediately choose “List all sensors” after starting the program, verify that the program prints a friendly “No sensors stored yet.” message.

3. **Delete‐nonexistent** – try to remove a sensor that was never inserted; the program must respond with a clear error but continue running normally.

4. **Update‐nonexistent** – try to update the value of a non-existing ID; program must report “not found” and keep running.

5. **Shrink to zero and exit** – add sensors, delete all of them, call “List” to confirm the list is empty, then choose exit and observe the program terminates gracefully after freeing memory.

---

Automated replay strings (machine-readable, `\n` preserved):

```json
{
  "exit_command": "0",
  "test_suite": [
    {"input": "1\n101\ntemperature\n23.5", "expected_keyword": "added"},
    {"input": "1\n102\nhumidity\n48.2", "expected_keyword": "added"},
    {"input": "5", "expected_keyword": "humidity"},
    {"input": "3\n102\n55.7", "expected_keyword": "updated"},
    {"input": "4\n102", "expected_keyword": "55.70"},
    {"input": "2\n101", "expected_keyword": ""},
    {"input": "5", "expected_keyword": "humidity"},
    {"input": "0", "expected_keyword": "Good-bye"}
  ]
}
```

---

## Iteration 87 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
The campus IT department is building a tiny “Student Registry” that runs as a console program.  
Each student record consists of a **name** (a string of up to 30 characters) and an **ID number** (an integer).  
Because the number of students is not known in advance, the program must allocate memory for each record dynamically as the user adds them, and release the memory when a record is removed or when the program terminates.

## Requirements  

Write a C program that implements the following functionality:

1. **Menu‑driven interface** (displayed repeatedly until the user chooses to exit).  
2. **Add a student** – prompt for the name and ID, allocate a `struct Student` with `malloc`, store the data, and keep the pointer in a dynamic array (the array itself may also be resized with `realloc`).  
3. **Delete a student** – ask for an ID, locate the matching record, free its memory, and compact the dynamic array so that no “holes” remain.  
4. **Display a student** – ask for an ID and print the corresponding name and ID. The printing logic must be placed in a function named `displayStudent`.  
5. **List all students** – print every stored record in the order they were added.  
6. **Exit** – before terminating, free **all** memory that was allocated during the program’s execution.  

The program should handle invalid inputs gracefully (e.g., trying to delete or display a non‑existent ID).

## Example Input / Output  

```
--- Student Registry ---
1) Add student
2) Delete student
3) Display student
4) List all students
5) Exit
Choose an option: 1
Enter name: Alice
Enter ID: 1001
Student added.

--- Student Registry ---
1) Add student
2) Delete student
3) Display student
4) List all students
5) Exit
Choose an option: 1
Enter name: Bob
Enter ID: 1002
Student added.

--- Student Registry ---
1) Add student
2) Delete student
3) Display student
4) List all students
5) Exit
Choose an option: 4
ID: 1001, Name: Alice
ID: 1002, Name: Bob

--- Student Registry ---
1) Add student
2) Delete student
3) Display student
4) List all students
5) Exit
Choose an option: 3
Enter ID to display: 1002
ID: 1002, Name: Bob

--- Student Registry ---
1) Add student
2) Delete student
3) Display student
4) List all students
5) Exit
Choose an option: 2
Enter ID to delete: 1001
Student removed.

--- Student Registry ---
1) Add student
2) Delete student
3) Display student
4) List all students
5) Exit
Choose an option: 5
Goodbye!
```

## ### CONSTRAINTS  

* **Struct Requirement** – The primary data entity must be defined as  

  ```c
  typedef struct {
      int id;
      char *name;   // dynamically allocated string
  } Student;
  ```

* **Function Requirement** – The logic that prints a single student’s details must be placed in a function with the exact prototype  

  ```c
  void displayStudent(const Student *s);
  ```

* **Memory Management** –  
  * Every `malloc`/`realloc` call must have a matching `free`.  
  * The program must not leak memory; all allocated memory must be released before exiting.

* **Menu Requirement** – The menu must contain an explicit option to **EXIT** the program (option number 5 in the example). Selecting this option terminates the loop and triggers the final cleanup.

* **Single‑source file** – The entire solution must be written in one `.c` file, but you may define as many helper functions as you need (aside from `main`).  

* **No global dynamic arrays** – The dynamic array that holds the pointers to `Student` structures must be created inside `main` (or a function called from `main`) and passed to helper functions as needed; do not use global variables for this purpose.  

* **String handling** – The student’s name must be stored in a separate dynamically allocated block (use `malloc`/`strdup`), not as a fixed‑size array inside the struct.  

* **Error messages** – When an operation cannot be performed (e.g., ID not found), print a clear message and return to the menu.  

---  

Implement the program according to the above description and constraints. Your solution will be evaluated on correctness, proper use of `malloc`/`free`, adherence to the required function signatures, and clean handling of edge cases.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Student Registry – console menu program
 * --------------------------------------------------
 * Language: ISO C11 (GCC/Clang)
 * Author:  [Your name]
 *
 * This source file compiles as one translation unit and demonstrates:
 * - Dynamic allocation of Student structures
 * - Resizable array of Student* (using realloc)
 * - Explicit cleanup on exit 5
 * - Graceful handling of invalid input
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*----------- Data model ----------------------------------------------------*/
typedef struct {
    int   id;
    char *name;   /* dynamically allocated */
} Student;

/*-------------- Function prototypes ---------------------------------------*/
void displayStudent(const Student *s);          /* mandated prototype */
void clearInputBuffer(void);                     /* helper for scanf-newline issues */
int  findStudentById(Student **list, int count, int id);

/*----------- Helper: flush stdin after scanf integers --------------------*/
void clearInputBuffer(void)
{
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF)
        ;
}

/*----------- Required output helper ----------------------------------------*/
void displayStudent(const Student *s)
/* print single record in exactly the format required by “display” option */
{
    if (!s) return;
    printf("ID: %d, Name: %s\n", s->id, s->name);
}

/* find index of student with given id or ‑1 if not found */
int findStudentById(Student **list, int count, int id)
{
    for (int i = 0; i < count; ++i)
        if (list[i]->id == id)
            return i;
    return -1;
}

/*----------- Main program ---------------------------------------------------*/
int main(void)
{
    /* dynamic array of Student *   (grows on demand) */
    Student **registry = NULL;
    int capacity = 0;   /* allocated capacity (capacity*sizeof(Student*))  */
    int count    = 0;   /* logical number of records currently stored    */
    int  choice;

    /*------ Main menu loop ------------------------------------------------*/
    for (;;) {
        puts("\n--- Student Registry ---");
        puts("1) Add student");
        puts("2) Delete student");
        puts("3) Display student");
        puts("4) List all students");
        puts("5) Exit");
        printf("Choose an option: ");

        if (scanf("%d", &choice) != 1) {
            clearInputBuffer();
            puts("Invalid input. Try again.");
            continue;
        }
        clearInputBuffer();

        if (choice < 1 || choice > 5) {
            puts("Invalid option. Try again.");
            continue;
        }

        /*------------- 1. Add student --------------------------*/
        if (choice == 1) {
            char rawName[256];  /* temporary buffer; trimmed later */
            int  id;

            printf("Enter name: ");
            if (!fgets(rawName, sizeof rawName, stdin)) {
                puts("Input error.");
                continue;
            }
            /* strip trailing newline */
            rawName[strcspn(rawName, "\n")] = '\0';

            printf("Enter ID: ");
            if (scanf("%d", &id) != 1) {
                puts("Invalid ID.");
                clearInputBuffer();
                continue;
            }
            clearInputBuffer();

            /* Duplicate-ID check */
            if (findStudentById(registry, count, id) != -1) {
                printf("A student with ID %d already exists.\n", id);
                continue;
            }

            /* Grow array if necessary */
            if (count == capacity) {
                int newCap = capacity ? capacity * 2 : 4;
                Student **tmp = realloc(registry, newCap * sizeof *tmp);
                if (!tmp) {
                    perror("realloc");
                    goto SAFE_EXIT;
                }
                registry  = tmp;
                capacity  = newCap;
            }

            /* Allocate & fill new Student */
            Student *s = malloc(sizeof *s);
            if (!s) { perror("malloc"); goto SAFE_EXIT; }

            s->id   = id;
            s->name = strdup(rawName);   /* POSIX; allocate + copy */
            if (!s->name) {
                free(s);
                perror("strdup");
                goto SAFE_EXIT;
            }

            registry[count++] = s;
            puts("Student added.");
        }

        /*------------- 2. Delete student -----------------------*/
        else if (choice == 2) {
            int id;
            printf("Enter ID to delete: ");
            if (scanf("%d", &id) != 1) {
                puts("Invalid ID.");
                clearInputBuffer();
                continue;
            }
            clearInputBuffer();

            int idx = findStudentById(registry, count, id);
            if (idx == -1) {
                printf("Student ID %d not found.\n", id);
                continue;
            }
            Student *victim = registry[idx];
            free(victim->name);
            free(victim);
            /* compact array */
            memmove(&registry[idx], &registry[idx + 1],
                    (count - idx - 1) * sizeof *registry);
            --count;
            puts("Student removed.");
        }

        /*------------- 3. Display single student ---------------*/
        else if (choice == 3) {
            int id;
            printf("Enter ID to display: ");
            if (scanf("%d", &id) != 1) { clearInputBuffer(); continue; }
            clearInputBuffer();

            int idx = findStudentById(registry, count, id);
            if (idx == -1) {
                printf("Student ID %d not found.\n", id);
            } else {
                displayStudent(registry[idx]);
            }
        }

        /*------------- 4. List all students --------------------*/
        else if (choice == 4) {
            if (count == 0) {
                puts("(no students in registry)");
            } else {
                for (int i = 0; i < count; ++i)
                    displayStudent(registry[i]);
            }
        }

        /*------------- 5. Exit --------------------------------*/
        else {  /* choice == 5 */
            puts("Goodbye!");
            break;
        }
    }

SAFE_EXIT:
    /*----- Clean-up all memory before termination ------------------------*/
    for (int i = 0; i < count; ++i) {
        free(registry[i]->name);
        free(registry[i]);
    }
    free(registry);
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

## 1. What the program must remember
We need to store an *unknown* number of students.  
Each student has:
- An identifier (`id`) that is unique.
- A *name* that can be different lengths for every student.

Because we do **not** know the upper limit, we cannot use a fixed-size array.  
The C solution is:

**a)** Keep the *list itself* flexible — an expandable array (`Student **registry`)  
**b)** Keep *each* piece of data flexible — every name is a separate block (`char *`) obtained with `malloc`/`strdup`.

Two layers of “dynamic” memory are therefore involved:
- one for the *pointers* (`registry`)
- one for every `Student` structure plus its name.

---

## 2. Why `Student **registry` (a pointer to pointers) ?
- A pointer can point to *one* item or to the first element of an array.
- We need an array whose length can *change at run time*.
- Such an array therefore must be `malloc`’d, which already gives us *one* pointer:  
  `Student *array = malloc(count*sizeof(Student));`  
  but that would store the structures *inline*.  
  We instead want an array whose elements are *pointers to* Students, so that:
  - deletion only has to move pointers, not whole structures
  - each `Student` can be freed individually.

Thus the variable is declared as `Student **registry`, meaning  
> “pointer to (array of) pointers to Student”.

Later we can **realloc** `registry` to grow/shrink that array of *pointers*.

---

## 3. Inserting a new record – step by step
Inside the permanent menu loop, Option 1 does:

1. Read the *name* with `fgets` into a **temporary local buffer** (`rawName`).  
   - We use a stack array here because its size is fixed (256) and lives only during the call.  
   - We call `strdup` on it; that duplicates the string onto the *heap*.

2. Read the `id` and check that it is not already present.  
   If it is, bail out early — *no* memory has been leaked because nothing was allocated yet.

3. Resize the *array of pointers* (`registry`) if we have reached capacity.  
   - The usual *doubling* rule is used (`capacity ? capacity*2 : 4`).  
   - Never store the result of `realloc` straight back into the original pointer unless you know it succeeded — here we allocate into a *temporary* (`tmp`), test it, and only then assign back.

4. Allocate **one** `Student` structure on the heap:  
   `Student *s = malloc(sizeof *s);`  
   - `malloc` may return `NULL` (out of memory). We *always* test and abort gracefully if so.  
   - Fill `s->id` with the number from the user.

5. Allocate the name:  
   `s->name = strdup(rawName);`  (`strdup` internally calls `malloc`, so we *cannot* forget to `free` it later.)

6. Append the pointer to the registry:  
   `registry[count++] = s;`  
   (capacity ≥ count at this moment)

7. Tell the user “Student added.”

Only if **all** allocations succeeded do we keep the data.  
If any fails we already jump to `SAFE_EXIT`, freeing everything we own before the program ends.

---

## 4. Deleting a student – why two frees?
Option 2 asks for an `id`, finds its *index*, and:

- Frees the *name* string (`free(student->name)`), because the string was also `malloc`’d by `strdup`.  
  (Failing to do so would leak every name.)

- Then frees the `Student` structure itself (`free(student)`).

Only **after** both resources are freed we compact the pointer array by moving everything *after* the deleted element one slot to the left (`memmove`).  
`count` is decremented; capacity is unchanged (we do *not* shrink `registry` here — only grow on demand).

Thus no empty slots remain, so a later linear scan will not stumble over dead pointers.

---

## 5. Printing – a tiny helper for reuse
The specification required a dedicated routine:  
`void displayStudent(const Student *s);`  

Passing a *pointer* allows:

- Printing without a structure copy.  
- Because the parameter is **const**, the function contract is: “I only look, never modify.”

Printing a *single* student (Option 3) uses this function, and so does the loop that lists *all* students (Option 4) — code reuse for clarity.

---

## 6. Input pitfalls we avoid
- `scanf("%d", …)` leaves the final newline in `stdin`; the next `fgets` would read only that newline.  
  We therefore call `clearInputBuffer()` after every numeric read, discarding the rest of the line.

- `fgets` keeps the newline if the buffer is large enough; we strip it with  
  `rawName[strcspn(rawName, "\n")] = '\0';`  
  to avoid printing stray newlines later.

---

## 7. What happens when the user hits “5 – Exit” ?
1. We `break;` out of the infinite menu loop.

2. The label `SAFE_EXIT:` is executed:

   ```
   for (i = 0 … count)
       free(registry[i]->name);
       free(registry[i]);
   free(registry);
   ```

   So we release:  
   - every *name* string  
   - every *Student* structure  
   - finally the *array of pointers* itself

   Only when the last byte is freed does the program `return 0;`.  
   This satisfies the **no-leak** requirement.

---

## 8. Take-away: two-layer allocation pattern
Whenever you have collections where *both the container* and *its elements* can grow or shrink independently:

1. Container (array) → `malloc`/`realloc`, keep length & capacity variables.  
2. Element (struct) → allocate *each* struct with `malloc`; return its *pointer* to the container.  
3. Inside the struct, flexible sub-objects (strings, arrays) → allocate them *separately*; store a pointer in the struct.  
4. On removal/cleanup → free the reverse order:  
   a) sub-objects (`name`)  
   b) struct (`Student`)  
   c) container (`registry`)

Remember: `malloc`/`strdup`/`realloc` may return `NULL`; always test.  
And every successfully allocated block must have exactly one matching `free` before the program ends.

With those rules every dynamic program, not only a student registry, becomes memory-safe.

### STEP_4
# STEP 4: HINTS

**Hint 1 (big-picture nudge):**  
Think of the registry like a stack of index cards you can grow or shrink any time.  
Instead of pre-buying a fixed-size card-box, keep just a handle to a stretchable box; each card itself is created only when someone asks to “add” a student.

---

**Hint 2 (key mechanism focus):**  
To make that box stretchable, look for the library routine whose whole job is “resize an already-allocated area.”  
Also remember that every card has two pieces of information: a number you can compare quickly and a name that could be long or short—don’t reserve space you might never need.

---

**Hint 3 (first concrete step):**  
Start by defining a small structure with an integer field and a *pointer* field (not a fixed array) for the name.  
Inside your main loop, when the user chooses “add,” allocate one such structure, read the name into a temporary buffer, duplicate that text onto the heap so it lives as long as you need, and store the address of the new structure in your resizable container.

### STEP_5
# STEP 5: SUMMARY
- Dynamic array management using `malloc`/`realloc` to grow storage at run time
- Two-layer dynamic allocation: container (array of pointers) and individual structures
- Clean separation and responsibility for each allocated block (structure vs. contained string)
- Mandatory return-value checking for every `malloc`/`realloc` call to prevent silent failures
- Corresponding `free` order: sub-objects first, then structure, then container (no memory leaks)
- Practical use of helper functions and `const` pointer parameters for safe, reusable code
- Input sanitization after `scanf` and safe string reading with `fgets`/`strdup`
- Menu-driven loop design, early exit handling, and graceful cleanup paths under error conditions

### STEP_6
# STEP 6: TEST CASES  

## Case 1 – Happy path: add, list, display  
Add two students, list them, display one by ID, then delete one and confirm the registry still works.  
(Tests basic allocation, listing, display, and compacting after deletion.)

## Case 2 – Empty registry list  
Immediately choose the list option when no students exist; expect the “no students” message.  
(Tests handling of a zero-count registry.)

## Case 3 – Invalid menu choice  
Enter a letter or a number outside 1-5; expect the “Invalid option” prompt and menu re-display.  
(Tests rejection of bad menu input.)

## Case 4 – Duplicate ID refusal  
Add a student, then attempt to add another with the same ID; expect refusal without crash or leak.  
(Tests duplicate-key defense.)

## Case 5 – Delete/display non-existent ID  
Try to delete and then display an ID that was never added; expect clear “not found” messages.  
(Tests error handling for missing records.)

```json
{
  "exit_command": "5\n",
  "test_suite": [
    {
      "input": "1\nAlice\n1001\n1\nBob\n1002\n4\n3\n1002\n2\n1001\n5\n",
      "expected_keyword": "Student removed"
    },
    {
      "input": "4\n5\n",
      "expected_keyword": "no students"
    },
    {
      "input": "x\n9\n5\n",
      "expected_keyword": "Invalid option"
    },
    {
      "input": "1\nJohn\n42\n1\nJane\n42\n5\n",
      "expected_keyword": "already exists"
    },
    {
      "input": "2\n9999\n3\n8888\n5\n",
      "expected_keyword": "not found"
    }
  ]
}
```

---

## Iteration 88 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired by the **Campus Library** to write a small C program that keeps track of the books currently on loan. The library does not want a permanent database – it only needs a temporary list that lives while the program runs. Each book record should contain the title, the author’s name, and the number of days the book has been borrowed. Because the number of books on loan can change during the execution (students may borrow or return books), you must allocate and free memory dynamically.

## Requirements  

1. **Data Representation**  
   * Define a `struct Book` that holds:  
     - `char *title` – dynamically allocated string (maximum length 100 characters).  
     - `char *author` – dynamically allocated string (maximum length 100 characters).  
     - `int daysBorrowed` – number of days the book has been on loan.  

2. **Menu‑driven Interface** (the program must present a menu repeatedly until the user chooses to exit)  

   | Option | Description |
   |--------|-------------|
   | 1      | **Add a new book** – Prompt the user for title, author, and days borrowed, allocate a new `Book`, store it in a dynamic array that grows as needed, and confirm the addition. |
   | 2      | **Remove a book** – Ask for the title of the book to remove. If the title exists, free all memory associated with that `Book`, shift the remaining elements in the array to fill the gap, shrink the array, and confirm removal. If the title is not found, print an appropriate message. |
   | 3      | **Display a book** – Ask for the title, locate the matching `Book`, and call the function `displayEntity` to print its details (title, author, days borrowed). If the title is not found, inform the user. |
   | 4      | **List all books** – Iterate over the dynamic array and call `displayEntity` for each stored book. If no books are stored, print “No books on loan.” |
   | 5      | **Exit** – Terminate the program after freeing **all** allocated memory. |

3. **Memory Management**  
   * Use `malloc` (or `calloc`) to allocate memory for each new `Book` and for the strings inside it.  
   * Use `realloc` to grow or shrink the array that holds pointers to `Book` structures.  
   * Every allocation must have a matching `free` before the program ends or when a book is removed.  

4. **Program Flow**  
   * The program starts with an empty list (no books).  
   * After each operation (except Exit), the menu is shown again.  

## Example Input / Output  

```
=== Library Loan Tracker ===
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Choose an option: 1

Enter title: The C Programming Language
Enter author: Kernighan & Ritchie
Enter days borrowed: 12
Book added successfully!

=== Library Loan Tracker ===
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Choose an option: 1

Enter title: Introduction to Algorithms
Enter author: Cormen, Leiserson, Rivest, Stein
Enter days borrowed: 5
Book added successfully!

=== Library Loan Tracker ===
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Choose an option: 4

--- Book 1 ---
Title : The C Programming Language
Author: Kernighan & Ritchie
Days Borrowed: 12

--- Book 2 ---
Title : Introduction to Algorithms
Author: Cormen, Leiserson, Rivest, Stein
Days Borrowed: 5

=== Library Loan Tracker ===
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Choose an option: 3

Enter title to display: Introduction to Algorithms
--- Book Details ---
Title : Introduction to Algorithms
Author: Cormen, Leiserson, Rivest, Stein
Days Borrowed: 5

=== Library Loan Tracker ===
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Choose an option: 5

Goodbye!
```

## ### CONSTRAINTS  

1. **Struct Requirement** – The primary data entity must be represented with a `struct Book` as described above.  
2. **Display Function** – The logic that prints the details of a single book **must** be placed in a function with the exact prototype:  

   ```c
   void displayEntity(const struct Book *b);
   ```  

3. **Menu Implementation** – The program must present a menu (options 1‑5) and **must** include option **5** to EXIT the program, freeing all allocated memory before termination.  
4. **Dynamic Allocation Only** – No static arrays of fixed size may be used to store the collection of books; you must manage the collection with `malloc`/`realloc`/`free`.  
5. **Single‑File Solution** – All code must reside in one source file (`.c`). Apart from `main`, you may create additional helper functions, but the only required extra function is `displayEntity`.  

*Feel free to add any minor helper functions (e.g., for input handling) as long as the above constraints are satisfied.*

### STEP_2
# STEP 2: SOLUTION

```c
/*
 *  Library Loan Tracker – single-file, C11
 *  Compiles cleanly with:  gcc -std=c11 -Wall -Wextra -pedantic library.c -o library
 *
 *  All memory is dynamically managed; every allocation is freed on exit or
 *  when a book is removed.  Realloc failure is handled by aborting the program
 *  (a production-quality program would take a more graceful approach).
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE      100
#define MAX_AUTHOR     100
#define MAX_LINE_LEN   256          /* enough for console reading */

struct Book {
    char *title;         /* dynamically allocated */
    char *author;        /* dynamically allocated */
    int  daysBorrowed;
};

/* Forward declarations */
static int  display_menu(void);
static struct Book *create_book(const char *title,
                                const char *author,
                                int days);
static void free_book(struct Book *b);
static void displayEntity(const struct Book *b);   /* REQUIRED by spec */

/* -------------------------------------------------------------------------- */
int main(void)
{
    struct Book **catalog = NULL;   /* dynamic array of *Book pointers */
    size_t capacity      = 0;      /* physical slots allocated  */
    size_t size          = 0;      /* logical number of elements */
    char line[MAX_LINE_LEN];

    while (1) {
        int choice = display_menu();
        switch (choice) {
        case 1: {                  /* Add new book */
            char title[MAX_LINE_LEN], author[MAX_LINE_LEN];
            int  days;

            printf("Enter title: ");
            if (!fgets(title, sizeof title, stdin)) { puts("Input error"); continue; }
            title[strcspn(title, "\n")] = '\0';

            printf("Enter author: ");
            if (!fgets(author, sizeof author, stdin)) { puts("Input error"); continue; }
            author[strcspn(author, "\n")] = '\0';

            printf("Enter days borrowed: ");
            if (!fgets(line, sizeof line, stdin)) { puts("Input error"); continue; }
            days = atoi(line);

            struct Book *newbook = create_book(title, author, days);
            if (!newbook) { puts("Failed to create book"); continue; }

            /* enlarge array if necessary – geometric growth */
            if (size == capacity) {
                size_t newcap = capacity ? capacity * 2 : 4;
                struct Book **tmp = realloc(catalog,
                                           sizeof *catalog * newcap);
                if (!tmp) {         /* handle realloc failure */
                    free_book(newbook);
                    perror("realloc failed");
                    exit(EXIT_FAILURE);
                }
                catalog = tmp;
                capacity = newcap;
            }
            catalog[size++] = newbook;
            puts("Book added successfully!");
            break;
        } /* end add case */

        case 2: {                 /* Remove a book by title */
            if (size == 0) {
                puts("No books to remove.");
                break;
            }
            printf("Enter title of book to remove: ");
            if (!fgets(line, sizeof line, stdin)) { puts("Input error"); continue; }
            line[strcspn(line, "\n")] = '\0';

            size_t idx = 0;
            for (; idx < size; ++idx)
                if (strcmp(catalog[idx]->title, line) == 0)
                    break;

            if (idx == size) {
                puts("Book not found.");
            } else {
                free_book(catalog[idx]);
                /* shift remaining entries down one */
                memmove(&catalog[idx],
                        &catalog[idx+1],
                        sizeof *catalog * (size - 1 - idx));
                size -= 1;
                puts("Book removed successfully.");
            }
            break;
        } /* end remove case */

        case 3: {                /* Display single book */
            printf("Enter title to display: ");
            if (!fgets(line, sizeof line, stdin)) { puts("Input error"); continue; }
            line[strcspn(line, "\n")] = '\0';
            int found = 0;
            for (size_t i = 0; i < size; ++i)
                if (strcmp(catalog[i]->title, line) == 0) {
                    displayEntity(catalog[i]);
                    found = 1;
                    break;
                }
            if (!found) puts("Book not found.");
            break;
        }

        case 4: {                /* List all books */
            if (size == 0) {
                puts("No books on loan.");
                break;
            }
            for (size_t i = 0; i < size; ++i) {
                printf("--- Book %zu ---\n", (i+1));
                displayEntity(catalog[i]);
            }
            break;
        }

        case 5:                /* Exit – free everything */
            for (size_t i = 0; i < size; ++i) free_book(catalog[i]);
            free(catalog);
            puts("Goodbye!");
            return EXIT_SUCCESS;

        default:
            puts("Invalid option. Try again 1–5.");
        }
    }
}

/* -----------------------------------------------------------------------------
 *  create_book(): allocate a new Book, duplicating strings from user input
 *  Ensures null terminators not exceeded. Caller must free via free_book().
 */
static struct Book *create_book(const char *title,
                                const char *author,
                                int days)
{
    struct Book *b = malloc(sizeof *b);
    if (!b) { perror("malloc"); exit(EXIT_FAILURE); }

    b->title = malloc(MAX_TITLE);          /* reserve per spec */
    b->author = malloc(MAX_AUTHOR);
    if (!b->title || !b->author) { perror("malloc"); exit(EXIT_FAILURE); }

    strncpy(b->title,  title,  MAX_TITLE);  b->title[MAX_TITLE-1]  = '\0';
    strncpy(b->author, author, MAX_AUTHOR); b->author[MAX_AUTHOR-1] = '\0';
    b->daysBorrowed = days;
    return b;
}

/* free_book(): free the strings then the shell struct */
static void free_book(struct Book *b)
{
    if (b) {
        free(b->title);
        free(b->author);
        free(b);
    }
}

/* display_menu(): return user-choice, forced to integer 1-5 */
static int display_menu(void)
{
    char line[MAX_LINE_LEN];
    while (1) {
        puts("\n=== Library Loan Tracker ===");
        puts("1. Add a new book");
        puts("2. Remove a book");
        puts("3. Display a book");
        puts("4. List all books");
        puts("5. Exit");
        printf("Choose an option: ");
        if (!fgets(line, sizeof line, stdin)) continue; /* EOF/ctrl-D */
        int c = atoi(line);
        if (c >= 1 && c <= 5) return c;
        puts("Invalid choice.");
    }
}

/* REQUIRED FUNCTION – prints details of one Book */
void displayEntity(const struct Book *b)
{
    if (!b) { puts("NULL pointer supplied to displayEntity()"); return; }
    printf("Title : %s\n", b->title);
    printf("Author: %s\n", b->author);
    printf("Days Borrowed: %d\n", b->daysBorrowed);
}
```

### STEP_3
# STEP 3: EXPLANATION

Let’s walk through the program the way a memory-conscious programmer thinks, not the way a compiler reads it.  
Every time you see `malloc`, `realloc`, or `free` we will stop and ask:  
“Who owns this memory, when does it die, and how do we guarantee it is returned to the OS?”

--------------------------------------------------------
1. What problem are we really solving?
--------------------------------------------------------
We have an **unknown and changing number of books**.  
If we used a fixed-size array we would have to pick an upper limit (say 1000) and either
- waste space when only 3 books are stored, or  
- crash when the 1001st book arrives.

Dynamic memory lets the array **grow and shrink on demand**—exactly like a `std::vector` in C++ but done by hand in C.

--------------------------------------------------------
2. The two-level ownership model
--------------------------------------------------------
We keep **two separate allocations**:

A. **catalog** – a contiguous block of *pointers* (`struct Book **catalog`)  
B. **each Book** – three allocations made by `create_book`:  
   - one `struct Book`  
   - two C-strings (`title`, `author`)

Rule of thumb:  
“Every `malloc` must have a matching `free` on **every** path that can leave the program.”  
That gives us three cleanup moments:

1. When a single book is removed → free the three parts  
2. When the user exits → free every book, then free the catalog array itself  
3. If `malloc`/`realloc` fails → print an error and `exit(EXIT_FAILURE)` immediately so no leaks accumulate (a minimal but acceptable strategy for a teaching example)

--------------------------------------------------------
3. Growing the catalog – the `realloc` dance
--------------------------------------------------------
We start with `capacity = 0`.  
When `size == capacity` we **double** the capacity (`newcap = capacity ? capacity*2 : 4`).  
Why double?  Single-step growth is O(n²) because every insertion would copy the whole array.  Doubling gives **amortised constant time** – the same trick used inside C++ vectors or Java ArrayLists.

Important safety detail:  
```c
struct Book **tmp = realloc(catalog, newcap * sizeof *tmp);
if (!tmp) { ... exit ... }
catalog = tmp;
```
`realloc` can return a new address; we never assign directly to `catalog` until we know the call succeeded—otherwise we would lose the old pointer on failure and leak everything.

--------------------------------------------------------
4. Removing a book – keeping the array contiguous
--------------------------------------------------------
Libraries want the collection to stay in a single flat array so we can iterate easily.  
Therefore after freeing the deleted book we **shift the trailing elements left** with `memmove`:

```
before: [A][B][C][D]  delete B
after:  [A][C][D]     (size decremented)
```

No gaps, no wasted slots, no need for “tombstones”.

--------------------------------------------------------
5. Strings are copied, not shared
--------------------------------------------------------
Inside `create_book` we do:

```c
b->title = malloc(MAX_TITLE);
strncpy(b->title, title, MAX_TITLE);
```

This **decouples** the lifetime of the string inside the Book from whatever the user typed on the stack.  
Imagine if we had simply written

```c
b->title = title;        /* WRONG – dangling pointer! */
```

When the function returns the stack array dies and the Book’s title now points to garbage.

--------------------------------------------------------
6. The displayEntity contract
--------------------------------------------------------
The specification demanded:

```c
void displayEntity(const struct Book *b);
```

Notice the `const`: the callee promises **not to modify** the Book.  
Inside we simply print the three fields—no allocation, no ownership transfer.

--------------------------------------------------------
7. Putting it together – a mental picture of one run
--------------------------------------------------------
User adds 3 books → catalog capacity becomes 4, size = 3  
User deletes book 1 → size = 2 (capacity still 4 – that is fine)  
User adds 2 more books → size becomes 4, capacity is already 4 → no realloc needed  
User adds 5th book → size == capacity → **realloc doubles to 8 slots**

Throughout, the program keeps exactly **size** books alive and ready to be freed.  
When the user presses 5 we do:

```c
for (i = 0..size-1) free_book(catalog[i]); /* free 3 mallocs each */
free(catalog);                             /* free the pointer block */
exit(0);                                   /* every byte returned */
```

--------------------------------------------------------
8. Take-away patterns you can reuse
--------------------------------------------------------
1. Start with `capacity = 0`; grow by doubling
2. Always store **pointers to objects** in the expandable array—not the objects themselves—so `realloc` only copies pointers, not big structs
3. Encapsulate “create” and “destroy” logic in symmetrical helper functions (`create_book` / `free_book`)
4. Check **every** allocation.  On failure either:
   - recover gracefully, or  
   - print an error and `exit` immediately (acceptable for small tools)
5. Compile with `-fsanitize=address,undefined` or Valgrind and run the example session—no leaks should be reported

Once these habits become automatic, dynamic memory in C stops feeling dangerous and starts feeling powerful.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of your book list as a living line of students outside the library: people can join or leave at any moment, but the door is only so wide. Instead of building a fixed-length bench, give the line a stretchy rope that can lengthen or shorten whenever the crowd changes.

**Hint 2**  
To make that “rope” in C, you’ll need a handful of library calls whose names start with the same letter—one to request raw memory, one to hand it back, and one that can resize an already-requested block without losing the old data.

**Hint 3**  
Begin by storing only a pointer to that stretchy rope; set its initial length to zero. When a new book arrives, first check whether the rope is full. If it is, double the rope’s capacity before you slide the new book onto the end. Whenever a book departs, shift the remaining books to close the gap so the rope stays tight and contiguous.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management: malloc, realloc, free and pairing every allocation with a de-allocation path
- Resizable arrays (vectors) implemented manually with geometric growth to achieve amortized O(1) insertions
- Two-level memory ownership: a dynamic array of pointers plus per-object string allocations
- Safe string duplication to avoid dangling pointers and lifetime coupling to stack variables
- Contiguous memory maintenance via memmove when an element is removed (no gaps/tombstones)
- Function contracts and const-correctness (display-only functions take const pointers)
- Menu-driven interactive loops integrated with dynamic data structures
- Defensive programming: checking every allocation result and graceful cleanup on failure or exit
- Valgrind/AddressSanitizer-ready style for leak-free, undefined-behavior-free C programs

### STEP_6
# STEP 6: TEST CASES
1. **Typical add-and-list session**  
   Add three books, list them, remove one, list again; expect correct count and titles.

2. **Empty list display**  
   Choose option 4 right at start; expect “No books on loan.”

3. **Remove non-existent title**  
   Add one book, try to remove a different title; expect “Book not found.”

4. **Zero days borrowed (edge value)**  
   Add a book whose days-borrowed is 0; display should show 0 without crashing.

5. **Invalid menu choice handling**  
   Type 9, then 0, then a letter; expect “Invalid choice.” reprompts until legal digit.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nThe C Programming Language\nKernighan & Ritchie\n12\n1\nIntroduction to Algorithms\nCormen\n5\n1\nClean Code\nMartin\n30\n4\n3\nClean Code\n2\nNon-Existent Book\n4\n5",
     "expected_keyword": "Clean Code"},
    {"input": "4\n5",
     "expected_keyword": "No books on loan"},
    {"input": "1\nClean Code\nMartin\n30\n2\nMissing Book\n5",
     "expected_keyword": "Book not found"},
    {"input": "1\nZero Day Book\nAuthor\n0\n3\nZero Day Book\n5",
     "expected_keyword": "Days Borrowed: 0"},
    {"input": "9\n0\nx\n1\nValid Book\nA. Person\n7\n5",
     "expected_keyword": "Invalid choice"}
  ]
}
```

---

## Iteration 89 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired by the **Campus Events Office** to write a small utility that keeps track of **event volunteers**.  
Each volunteer has a name (maximum 30 characters), an integer ID, and the number of hours they have pledged to work.  
The office wants a simple console program that lets a user **add**, **remove**, **list**, and **query** volunteers while the program is running.  
Because the number of volunteers is not known in advance and can change during execution, you must allocate and free memory dynamically.

## Requirements  

Write a C program that provides the following functionality through a text‑based menu:

1. **Add a volunteer**  
   * Prompt for the volunteer’s name, ID, and pledged hours.  
   * Allocate a new `struct Volunteer` on the heap and store the data.  
   * Insert the new volunteer at the end of the current list.

2. **Remove a volunteer**  
   * Prompt for the volunteer’s ID.  
   * Search the list; if the ID exists, remove that volunteer, free the associated memory, and close the gap in the list (i.e., shift later elements forward).  
   * If the ID is not found, display an appropriate message.

3. **List all volunteers**  
   * Print a table showing the ID, name, and pledged hours of every volunteer currently stored, in the order they were added.

4. **Show a volunteer’s details**  
   * Prompt for an ID, locate the volunteer, and display the information using a dedicated function called `displayVolunteer`.  
   * If the ID does not exist, inform the user.

5. **Exit**  
   * Before terminating, free any memory that remains allocated.

The program should continue to display the menu after each operation until the user selects the **Exit** option.

## Example Interaction  

```
=== Volunteer Management System ===
1) Add volunteer
2) Remove volunteer
3) List all volunteers
4) Show volunteer details
5) Exit
Choose an option: 1

Enter name: Alice Johnson
Enter ID: 101
Enter pledged hours: 12

Volunteer added successfully.

=== Volunteer Management System ===
1) Add volunteer
2) Remove volunteer
3) List all volunteers
4) Show volunteer details
5) Exit
Choose an option: 1

Enter name: Bob Lee
Enter ID: 102
Enter pledged hours: 8

Volunteer added successfully.

=== Volunteer Management System ===
1) Add volunteer
2) Remove volunteer
3) List all volunteers
4) Show volunteer details
5) Exit
Choose an option: 3

ID   Name           Hours
101  Alice Johnson  12
102  Bob Lee        8

=== Volunteer Management System ===
1) Add volunteer
2) Remove volunteer
3) List all volunteers
4) Show volunteer details
5) Exit
Choose an option: 4

Enter ID to display: 102
Volunteer Details:
ID: 102
Name: Bob Lee
Pledged Hours: 8

=== Volunteer Management System ===
1) Add volunteer
2) Remove volunteer
3) List all volunteers
4) Show volunteer details
5) Exit
Choose an option: 5

Goodbye!
```

## ### CONSTRAINTS  

* **Struct Requirement** – The primary data entity must be represented by a `struct Volunteer` containing at least the fields `char name[31]; int id; int hours;`.  
* **Display Function** – The logic for displaying the details of a single volunteer must reside in a function with the exact prototype:  
  ```c
  void displayVolunteer(const struct Volunteer *v);
  ```  
* **Dynamic Allocation** – All volunteers must be stored in dynamically allocated memory (using `malloc`/`realloc`/`free`). No static or global arrays of fixed size are allowed.  
* **Menu Implementation** – The program must present a menu as shown above. The menu must include a distinct option to **Exit** the program (option number 5 in the example). Selecting this option must cause the program to free any remaining allocated memory and terminate gracefully.  
* **Single‑File Solution** – All code must be placed in a single source file (`.c`). Apart from `main`, you may define additional helper functions, but the only required extra function is `displayVolunteer`.  

---  

*Note:* The problem is designed for students who have just learned `malloc`, `free`, and basic struct handling. Focus on correct allocation, deallocation, and pointer manipulation rather than on sophisticated data structures.

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Volunteer Management System
 * Author: <Your name>
 *
 * A tiny console utility that stores, lists and queries volunteer
 * records.  All data lives in dynamically allocated memory.  The
 * code is intentionally kept simple (no hashing, no sorting) so
 * the focus stays on malloc / realloc / free.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- DATA STRUCTURES ------------------------------------ */
#define NAME_LEN 30

struct Volunteer {
    char name[NAME_LEN + 1]; /* +1 for '\0' */
    int  id;
    int  hours;
};

/* ---------- GLOBAL STATE (simplistic but acceptable here) -------- */
static struct Volunteer *volList = NULL; /* dynamic array */
static size_t volCount = 0;              /* # currently stored */
static size_t volCapacity = 0;             /* allocated slots */

/* ---------- FUNCTION PROTOTYPES -------------------------------- */
int  addVolunteer      (void);
int  removeVolunteer (int id);
void listVolunteers   (void);
int  showVolunteer     (int id);
void displayVolunteer (const struct Volunteer *v);
void freeAll          (void);

/* ---------- MAIN MENU LOOP ------------------------------------- */
int main(void)
{
    for (;;) {
        puts("\n=== Volunteer Management System ===");
        puts("1) Add volunteer");
        puts("2) Remove volunteer");
        puts("3) List all volunteers");
        puts("4) Show volunteer details");
        puts("5) Exit");
        printf("Choose an option: ");

        int choice;
        if (scanf("%d", &choice) != 1) {
            puts("Invalid input; please enter a number.");
            /* flush the rest of the line */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF)
                ;
            continue;
        }

        switch (choice) {
        case 1: /* Add */
            if (addVolunteer() == 0)
                puts("Volunteer added successfully.");
            break;

        case 2: { /* Remove */
            int id;
            printf("Enter ID to remove: ");
            if (scanf("%d", &id) != 1) {
                puts("Bad ID format.");
                break;
            }
            if (removeVolunteer(id) == 0)
                puts("Volunteer removed successfully.");
            else
                puts("ID not found.");
            break;
        }

        case 3: /* List */
            listVolunteers();
            break;

        case 4: { /* Show details */
            int id;
            printf("Enter ID to display: ");
            if (scanf("%d", &id) != 1) {
                puts("Bad ID format.");
                break;
            }
            if (showVolunteer(id) != 0)
                puts("ID not found.");
            break;
        }

        case 5: /* Exit */
            freeAll();
            puts("Goodbye!");
            return 0;

        default:
            puts("Invalid choice. Please try again.");
        }
    }
}

/* ---------- CORE OPERATIONS ------------------------------------ */
/*
 * Resize the underlying array (doubles capacity when full).
 * Returns 0 on success, -1 on allocation failure.
 */
static int ensureCapacity(void)
{
    if (volCount < volCapacity)
        return 0;

    size_t newCap = (volCapacity == 0) ? 4 : volCapacity * 2;
    struct Volunteer *tmp =
        realloc(volList, newCap * sizeof(*volList));
    if (!tmp) {
        perror("realloc");
        return -1;
    }
    volList = tmp;
    volCapacity = newCap;
    return 0;
}

/*
 * Reads a full line of text (including spaces) into 'buf' of length 'sz'.
 * Overruns are safely truncated and the line is consumed.
 */
static void readLine(char *buf, size_t sz)
{
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF)
        ; /* discard previous newline */

    if (fgets(buf, (int)sz, stdin) == NULL) {
        buf[0] = '\0';
        return;
    }
    /* strip trailing newline if present */
    size_t len = strlen(buf);
    if (len && buf[len - 1] == '\n')
        buf[len - 1] = '\0';
}

int addVolunteer(void)
{
    if (ensureCapacity() != 0)
        return -1;

    struct Volunteer *v = &volList[volCount];

    printf("Enter name: ");
    readLine(v->name, sizeof(v->name));

    printf("Enter ID: ");
    if (scanf("%d", &v->id) != 1) {
        puts("Bad ID format.");
        return -1;
    }

    printf("Enter pledged hours: ");
    if (scanf("%d", &v->hours) != 1) {
        puts("Bad hours format.");
        return -1;
    }

    ++volCount;
    return 0;
}

int removeVolunteer(int id)
{
    size_t idx = 0;
    while (idx < volCount && volList[idx].id != id)
        ++idx;

    if (idx == volCount) /* not found */
        return -1;

    /* shift left */
    for (size_t i = idx; i + 1 < volCount; ++i)
        volList[i] = volList[i + 1];

    --volCount;
    return 0;
}

void listVolunteers(void)
{
    if (volCount == 0) {
        puts("No volunteers stored.");
        return;
    }
    puts("ID   Name                           Hours");
    for (size_t i = 0; i < volCount; ++i) {
        const struct Volunteer *v = &volList[i];
        printf("%-4d %-30s %d\n", v->id, v->name, v->hours);
    }
}

int showVolunteer(int id)
{
    for (size_t i = 0; i < volCount; ++i) {
        if (volList[i].id == id) {
            displayVolunteer(&volList[i]);
            return 0;
        }
    }
    return -1; /* not found */
}

/* ---------- REQUIRED DISPLAY FUNCTION ---------------------------- */
void displayVolunteer(const struct Volunteer *v)
{
    if (!v) return;
    puts("Volunteer Details:");
    printf("ID: %d\n", v->id);
    printf("Name: %s\n", v->name);
    printf("Pledged Hours: %d\n", v->hours);
}

/* ---------- CLEANUP --------------------------------------------- */
void freeAll(void)
{
    free(volList);
    volList = NULL;
    volCount = volCapacity = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

## 1. What is “dynamic memory” and why do we need it?
A volunteer list keeps growing and shrinking while the program is running.  
If we used
```c
struct Volunteer array[100];
```
we would be stuck with *exactly* 100 slots—wasting space if we only store 10 volunteers, and overflowing if we need 101.  
Dynamic allocation lets us ask the *operating system* for exactly as many bytes as we currently need, and to **grow or shrink** that request later.

## 2. The three key C library functions
- `malloc(n)` – request `n` bytes *once*.  
- `realloc(ptr, newSize)` – *resize* an existing block, preserving old data.  
- `free(ptr)` – *hand the memory back* so it can be reused.

Because we never know the final size in advance, we start with **zero** allocated bytes and **grow on demand**.

## 3. Global bookkeeping – the “three amigas”
```c
static struct Volunteer *volList = NULL;
static size_t volCount = 0;
static size_t volCapacity = 0;
```
Think of them as:

| Variable        | Meaning                                 |
|-----------------|-----------------------------------------|
| `volList`       | Pointer to the *first* slot of an **array** we allocated on the heap. |
| `volCount`      | How many volunteers are *currently* stored. |
| `volCapacity`   | How many volunteers *fit* before we must grow. |

Initially the array does not exist, so both count and capacity are 0.

## 4. Growing the array – the “geometric growth” trick
Each time we run out of space we **double** the capacity:

```
  capacity == 0 → allocate room for 4 volunteers
  capacity == 4 → realloc to 8
  capacity == 8 → realloc to 16  …
```

Doubling keeps **insertions amortised O(1)** – a fancy way of saying “the cost of each insert averages out to a constant”, while wasting at most 50 % extra space.  
`realloc` is ideal here because it:

- Reserves a *new* bigger block (if necessary),  
- Copies the old elements, and  
- Frees the old block.

## 5. Reading text safely – the hidden `fgets` wrapper
`scanf("%s")` stops at the first space, so a name like “Alice Johnson” would be truncated.  
The helper `readLine()`:

- Clears the leftover newline from the previous `scanf`,  
- Uses `fgets` to fetch an *entire line*,  
- Removes the trailing newline character.

This avoids both buffer overruns and unexpected behaviour when mixing `scanf` with line-oriented input.

## 6. Adding a volunteer step-by-step
1. Check the backing array has room (`ensureCapacity()`).  
2. If room is lacking → `realloc`; if `realloc` fails, report and stop.  
3. Read the name into the *next free* slot (`volList[volCount]`).  
4. Read ID and hours directly into that slot.  
5. Increment `volCount`.

Memory allocation only happens when we *really* need it, and **every `malloc`/`realloc` is checked**; if it returns `NULL`, the function propagates `-1` to `main`, which prints an error.

## 7. Removing a volunteer – the “remove hole” strategy
Array indices must stay contiguous, so we:

- Search linearly for the matching ID.  
- If found, shift every element **after** the match one slot left:

```
  for (i = idx; i+1 < volCount; ++i)
      volList[i] = volList[i+1];
```

- Finally decrement `volCount`.

We *do not* shrink the allocated block to save time; if you wanted, you could `realloc` to a smaller size when `volCount < volCapacity/4`, but for a teaching example keeping it simple is fine.

## 8. Display helpers – separation of concerns
`displayVolunteer()` is **forced** by the assignment to live in its own function.  
It receives a *pointer* to a volunteer and prints the fields.

Why a pointer?

- Passes only an address (8 bytes on 64-bit machines) instead of copying an entire struct (~40 bytes).  
- `const` qualifier promises the function will *not* modify the volunteer.

## 9. Cleaning up before exit – no leaks
Before returning from `main`, we call `freeAll()`:

```c
free(volList);
volList = NULL;
volCount = volCapacity = 0;
```

Even though the OS reclaims memory when the process terminates, explicitly freeing is good hygiene: it trains you to balance every `malloc`/`realloc` with a `free`, and it keeps memory-leak checkers (Valgrind, AddressSanitizer) quiet.

## 10. Putting it all together – the program flow
```
main menu loop
 ├─ 1) Add → ensureCapacity → read → insert
 ├─ 2) Remove → search → shift left
 ├─ 3) List → iterate and print
 ├─ 4) Show → search → displayVolunteer
 └─ 5) Exit → freeAll → return 0
```

Each operation touches the dynamic array only through the three global variables and the small helper layer (`ensureCapacity`, `freeAll`). This keeps `main` readable and the allocation logic in one place.

If you understand the pattern:

- Start small  
- Double capacity on demand  
- Check every allocation  
- Free everything at the end

you have mastered the fundamental skill set behind dynamic arrays in C.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge)**  
Think of the volunteer list as a line of people that can get longer or shorter while the program runs; plan a way to seat them that lets you add or remove chairs quickly, even though you don’t know the final head-count ahead of time.

**Hint 2 (key feature focus)**  
Look into the family of C library tools whose purpose is to “reserve,” “resize,” and then “return” blocks of raw memory; you’ll need one to set up the first chair, one to make the row of chairs longer, and one to hand them all back at closing time.

**Hint 3 (first concrete step)**  
Start by creating a single pointer that will eventually point to an array of volunteer structures; initially let it point nowhere (a special “empty” value). Each time you need more space, double the current number of slots you’ve set aside, request a fresh block of that new size, and copy any previously stored volunteers into it before adding the newcomer.

### STEP_5
# STEP 5: SUMMARY
- Dynamic array management using malloc / realloc / free  
- Growing storage geometrically to achieve amortised O(1) insertions  
- Safe text input with fgets to capture multi-word strings  
- Struct packaging and pointer-based parameter passing (const correctness)  
- Linear search and “shift-left” removal inside a contiguous array  
- Complete memory hygiene: check every allocation and free all blocks at exit  
- Separation of concerns through single-purpose helper functions  
- Menu-driven program structure that repeats until the user quits

### STEP_6
# STEP 6: TEST CASES

1. **Normal add / list cycle**  
   Add two volunteers and list them; expect both names in order.  
2. **Remove-one leave-one**  
   After the first test, remove the first ID, then list; expect only the second name remains.  
3. **Edge case: empty list**  
   Start fresh, choose list option immediately; expect “No volunteers stored.”  
4. **Invalid remove**  
   Try to delete a non-existent ID; expect “ID not found.”  
5. **Zero-hours entry**  
   Add a volunteer whose pledged hours are 0; display should still show Hours: 0.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nAlice Johnson\n101\n12\n1\nBob Lee\n102\n8\n3\n5",
      "expected_keyword": "Alice Johnson"
    },
    {
      "input": "1\nAlice Johnson\n101\n12\n1\nBob Lee\n102\n8\n2\n101\n3\n5",
      "expected_keyword": "Bob Lee"
    },
    {
      "input": "3\n5",
      "expected_keyword": "No volunteers"
    },
    {
      "input": "1\nAlice Johnson\n101\n12\n2\n999\n5",
      "expected_keyword": "ID not found"
    },
    {
      "input": "1\nZero Hero\n103\n0\n4\n103\n5",
      "expected_keyword": "Pledged Hours: 0"
    }
  ]
}
```

---

## Iteration 90 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
A small wildlife sanctuary is building a simple console‑based database to keep track of the animals it cares for. Each animal has a name, a species, and an age (in years). The sanctuary staff will run the program, add new animals as they arrive, remove animals that are transferred out, and view the details of any animal on demand. Because the number of animals is not known in advance and changes over time, the program must allocate and free memory dynamically.

## Requirements  

Write a C program that implements the following functionality:

1. **Data Representation**  
   * Define a `struct Animal` that stores:  
     * `char *name` – a dynamically allocated string (maximum length 100 characters).  
     * `char *species` – a dynamically allocated string (maximum length 100 characters).  
     * `int age` – the animal’s age.  

2. **Menu‑driven Interface** (the program must present a menu repeatedly until the user chooses to exit)  
   * **1 – Add a new animal**  
     * Prompt the user for name, species, and age.  
     * Allocate memory for a new `struct Animal` and for the two strings, copy the input, and store the pointer in a dynamically growing array (or linked list).  
   * **2 – Remove an animal**  
     * Prompt for the **index** (starting at 0) of the animal to delete.  
     * Free the memory for the two strings and the `struct Animal` itself, then shift remaining entries so that the array stays compact (or adjust links if you use a list).  
     * If the index is invalid, display an error message and return to the menu.  
   * **3 – Display an animal’s details**  
     * Prompt for the **index** of the animal to view.  
     * Call a function `void displayAnimal(const struct Animal *a, int index)` that prints the animal’s index, name, species, and age in a readable format.  
   * **4 – List all animals**  
     * Iterate over the collection and call `displayAnimal` for each entry.  
   * **5 – EXIT**  
     * Terminate the program after freeing **all** remaining dynamically allocated memory.  

3. **Program Flow**  
   * After completing any operation (except EXIT), the menu is shown again.  
   * The program must never leak memory: every `malloc`/`calloc`/`realloc` must have a matching `free` before the program ends or an element is removed.  

## Example Interaction  

```
=== Wildlife Sanctuary Database ===
1. Add a new animal
2. Remove an animal
3. Display an animal's details
4. List all animals
5. EXIT
Choose an option: 1
Enter name: Luna
Enter species: Red Panda
Enter age: 3
Animal added successfully.

=== Wildlife Sanctuary Database ===
1. Add a new animal
2. Remove an animal
3. Display an animal's details
4. List all animals
5. EXIT
Choose an option: 1
Enter name: Max
Enter species: African Elephant
Enter age: 12
Animal added successfully.

=== Wildlife Sanctuary Database ===
1. Add a new animal
2. Remove an animal
3. Display an animal's details
4. List all animals
5. EXIT
Choose an option: 4
[0] Name: Luna, Species: Red Panda, Age: 3
[1] Name: Max, Species: African Elephant, Age: 12

=== Wildlife Sanctuary Database ===
1. Add a new animal
2. Remove an animal
3. Display an animal's details
4. List all animals
5. EXIT
Choose an option: 3
Enter index to display: 0
[0] Name: Luna, Species: Red Panda, Age: 3

=== Wildlife Sanctuary Database ===
1. Add a new animal
2. Remove an animal
3. Display an animal's details
4. List all animals
5. EXIT
Choose an option: 5
Goodbye!
```

## ### CONSTRAINTS  

* **Struct Usage** – The primary data entity must be represented by a `struct Animal` as described above.  
* **Display Function** – The logic for showing the details of **ONE** specific animal must reside in a function with the exact prototype:  
  ```c
  void displayAnimal(const struct Animal *a, int index);
  ```  
* **Menu Requirement** – Because a menu is part of the specification, the program **must** include an explicit menu option to **EXIT** the program (option 5 in the example).  
* **Dynamic Allocation Only** – All storage for animals and their name/species strings must be obtained with `malloc`/`calloc`/`realloc`. No static or global arrays of fixed size may be used to hold the animals.  
* **Memory Management** – Every allocated block must be freed exactly once. Failure to do so will be considered a compilation‑time or run‑time penalty.  

*Optional (but recommended for students):* you may implement the collection as a resizable array using `realloc`, or as a singly‑linked list. Either approach satisfies the constraints as long as dynamic allocation is used throughout.

### STEP_2
# STEP 2: SOLUTION
```c
/*
 * Wildlife Sanctuary Database – simple console application
 *
 * Language: ISO C11 (GCC / Clang)
 *
 * Author: you
 *
 * Compile:
 *     gcc -std=c11 -Wall -Wextra -pedantic -o sanctuary sanctuary.c
 *
 * This program implements a resizable array of dynamically
 * allocated 'struct Animal' objects. All memory is freed on exit.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LEN 100                  /* max chars for name & species */

/* ---------- Data layer -------------------------------------------------- */
typedef struct Animal {
    char *name;     /* heap‐allocated, ≤100 printable chars (+ '\0') */
    char *species;  /* same as above */
    int age;        /* whole number of years, ≥0 */
} Animal;

/* Collection bookkeeping */
static Animal **g_animals = NULL;   /* dynamic array of (Animal*) */
static size_t g_count     = 0;    /* entries currently in use */
static size_t g_capacity  = 0;    /* slots currently allocated */

/* Forward declarations for helpers */
static void push_animal(Animal *a);
static void erase_animal(size_t idx);
static void free_everything(void);

/* ---------- I/O helpers ------------------------------------------------- */
/*
 * Read a single line from stdin into a freshly malloc‐ed buffer.
 * The buffer length is exactly strlen()+1 and always NUL-terminated.
 * The first MAX_LEN characters are used; the rest is discarded.
 * Returns NULL on EOF or allocation failure.
 */
static char *read_line(void)
{
    char tmp[MAX_LEN + 2];          /* extra slot for '\n' and '\0' */
    if (!fgets(tmp, sizeof(tmp), stdin))
        return NULL;

    /* Remove trailing newline if present */
    size_t n = strcspn(tmp, "\r\n");
    tmp[n] = '\0';

    /* Allocate exact‐sized copy */
    char *out = malloc(n + 1);
    if (!out) return NULL;

    memcpy(out, tmp, n + 1);
    return out;
}

/* ---------- Application logic ------------------------------------------ */
void displayAnimal(const Animal *a, int index)
/* Print one animal in the required format. */
{
    if (!a) return;
    printf("[%d] Name: %s, Species: %s, Age: %d\n",
           index, a->name, a->species, a->age);
}

static void list_all(void)
{
    if (g_count == 0) {
        printf("The sanctuary is currently empty.\n");
        return;
    }
    for (size_t i = 0; i < g_count; ++i)
        displayAnimal(g_animals[i], (int)i);
}

static int read_int(const char *prompt)
{
    printf("%s", prompt);
    fflush(stdout);
    int v;
    scanf("%d", &v);
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF) /* discard rest of line */
        ;
    return v;
}

static Animal *read_new_animal(void)
/* Interactively read and allocate a new animal. Return NULL on error. */
{
    Animal *a = malloc(sizeof(*a));
    if (!a) return NULL;

    printf("Enter name: ");
    a->name = read_line();
    if (!a->name) { free(a); return NULL; }

    printf("Enter species: ");
    a->species = read_line();
    if (!a->species) { free(a->name); free(a); return NULL; }

    a->age = read_int("Enter age: ");
    return a;
}

/* ---------- Dynamic array helpers ------------------------------------- */
static void push_animal(Animal *a)
{
    if (g_count == g_capacity) {
        /* Grow by doubling, minimal initial 8 */
        size_t newcap = g_capacity ? g_capacity * 2 : 8;
        Animal **tmp = realloc(g_animals, newcap * sizeof(*tmp));
        if (!tmp) {          /* realloc failed; don't lose original data */
            perror("realloc");
            return;
        }
        g_animals  = tmp;
        g_capacity = newcap;
    }
    g_animals[g_count++] = a;
}

static void erase_animal(size_t idx)
/* Remove element at index idx and keep array compact. */
{
    if (idx >= g_count) return;           /* invalid index handled by caller */

    Animal *a = g_animals[idx];

    /* Free the owned strings and the struct itself. */
    free(a->name);
    free(a->species);
    free(a);

    /* Shift remaining elements left (if any) */
    for (size_t i = idx + 1; i < g_count; ++i)
        g_animals[i - 1] = g_animals[i];

    --g_count;
}

static void free_everything(void)
/* Called on exit to avoid leaks. */
{
    /* Free all animals first */
    while (g_count)
        erase_animal(g_count - 1); /* pops from the back (efficient) */

    free(g_animals);             /* free the array itself */
    g_animals = NULL;
    g_capacity = g_count = 0;
}

/* ---------- Menu handling --------------------------------------------- */
static void print_menu(void)
{
    printf("\n=== Wildlife Sanctuary Database ===\n"
           "1. Add a new animal\n"
           "2. Remove an animal\n"
           "3. Display an animal's details\n"
           "4. List all animals\n"
           "5. EXIT\n"
           "Choose an option: ");
}

int main(void)
{
    while (1) {
        print_menu();
        int choice = read_int("");

        switch (choice) {
        case 1: {
            Animal *a = read_new_animal();
            if (!a) {
                puts("Failed to add animal (out of memory).");
                break;
            }
            push_animal(a);
            puts("Animal added successfully.");
            break;
        }
        case 2: {
            int idx = read_int("Enter index to remove: ");
            if (idx < 0 || (size_t)idx >= g_count) {
                puts("Invalid index.");
                break;
            }
            erase_animal((size_t)idx);
            puts("Animal removed.");
            break;
        }
        case 3: {
            int idx = read_int("Enter index to display: ");
            if (idx < 0 || (size_t)idx >= g_count) {
                puts("Invalid index.");
                break;
            }
            displayAnimal(g_animals[idx], idx);
            break;
        }
        case 4:
            list_all();
            break;
        case 5:
            puts("Goodbye!");
            free_everything();
            return EXIT_SUCCESS;
        default:
            puts("Unknown choice. Please select 1-5.");
            break;
        }
    }
}
```

### STEP_3
# STEP 3: EXPLANATION  
(For a student who already knows `if`, `while`, `struct`, and pointers, but is still uneasy with `malloc`‐`free`)

---

## 0. What “dynamic memory” really means  
When you write `int a[100];` the compiler decides, while compiling, that 100 integers will live at some fixed place.  
When you write  
```c
int *p = malloc(100 * sizeof(int));
```
you say “While the program is already running, please find a brand-new block big enough for 100 integers, give me its address, and promise I may use it until I call `free(p)`.”  
That block comes from the **heap**, a big pool of raw bytes that the C run-time manages for you.  
If you never give it back (`free`) the kernel thinks your program still needs it → “memory leak”.  

The wildlife-sanctuary program never knows beforehand how many animals the user will type, so we **must** allocate space while the program runs. The same idea applies to the two human-readable strings inside each animal; each `name` and `species` is also created at run-time with `malloc` and released later with `free`.

---

## 1. The container we keep all animals in – a vector (resize-able array)  
Two global variables describe that container:

```c
Animal **g_animals;   // pointer to the first POINTER in an array
size_t g_count;       // how many slots are occupied
size_t g_capacity;    // how many slots we could occupy without realloc
```

Why `Animal **` instead of `Animal *`?  
- We want to **re-size** the array many times.  
- `realloc` only works on a **single contiguous block**.  
  If we had one big block of structs (`Animal *array = malloc(count * sizeof(Animal))`) we would have to copy name+species strings manually each time we enlarge.  
- By instead storing an *array of pointers* (`Animal *`), each pointer can live wherever `malloc` decided, so `realloc` only moves the *pointer array* itself, never the strings.  

Growth rule (classic geometric resize):  
- When `count == capacity` we call  
  `new = realloc(old, newcapacity * sizeof(Animal *));`  
  `newcapacity = capacity ? capacity*2 : 8;`  
- Halving on shrink is optional here because we exit soon after.  

**Key check:** `if (!tmp) …`  
`realloc` can return `NULL` when RAM is exhausted. If we blindly reassigned `g_animals = realloc(…)` we would lose the old pointer and leak the old block. Therefore we store the result in a temporary, test it, and only then overwrite the global.

---

## 2. The life-cycle of ONE animal  
(a) Creating  
1. `Animal *a = malloc(sizeof(*a));` // struct itself  
2. `a->name = read_line();` → malloc inside read_line  
3. `a->species = read_line();` → second malloc  
4. `a->age` is primitive, lives directly in the struct, no heap needed.  

(b) Inserting  
`push_animal(a)` appends the pointer to `g_animals`.  

(c) Removing (when user chooses “2”)  
Given an index `idx`:  
1. `Animal *victim = g_animals[idx];`  
2. `free(victim->name);`  
3. `free(victim->species);`  
4. `free(victim);`        // free the struct last  
5. Shift remaining pointers left (compact array).  
That order prevents *use-after-free* errors: we never touch the struct after releasing it.

---

## 3. `read_line()` and string safety  
The user may type up to 100 printable characters. We read into a small automatic buffer, strip the trailing newline, then `malloc(strlen+1)` an *exact-sized* copy and return it.  
Advantages:  
- No fixed-width global buffers → no wasted space.  
- Because we allocate, the memory stays alive after the function returns (unlike automatic arrays).  
- We never `strcpy` into a buffer whose size we don’t know.  

---

## 4. Error handling strategy  
Whenever a heap request fails we print an informative message and leave the program in a safe state.  
- If `malloc` fails while creating an animal we simply don’t add it and return to the menu.  
- If `realloc` fails we leave the old pointer untouched; the program continues, perhaps failing a later operation, but never loses track of already existing animals.

---

## 5. Clean-up discipline – why “free everything twice”?  
At any moment you can look at the globals and know:  
- `g_count` tells how many animals are valid.  
- `g_capacity` tells how many slots the pointer-array owns.  
Before the program terminates we call `free_everything()`:  

1. Loop `i = count-1 … 0`  
   inside `erase_animal(i)` frees the two strings and the struct itself, then NULLs out the *pointer-to-animal*.  
2. Finally free the container that held those pointers (`g_animals`).  

That single function guarantees **zero leaks** whether the user removes animals one by one, resets the program, or types `5` to exit immediately after adding nothing.

---

## 6. `displayAnimal` – why a dedicated function?  
The assignment insists this prototype:

```c
void displayAnimal(const struct Animal *a, int index);
```

Instead of sprinkling `printf` statements in `main`, we centralize output formatting.  
- `const` emphasises that the function only *looks* at the object, never modifies it.  
- The index is passed separately because the animal *itself* does not remember its position inside the array; positions change when earlier animals are removed.

---

## 7. Integer input helper `read_int`  
We discard the rest of the line after the number so that following text reads (`read_line`) do not see stale characters. Keeps the program robust when users type “12abc”.

---

## 8. Summary of the “why” decisions  
- **pointer-array + realloc** → lets us resize cheaply and keeps string copying out of the struct array.  
- **exact string allocation** → avoids fixed limitations and waste.  
- **geometric growth** → amortized O(1) insertion cost.  
- **two‐level free (contents first, container second)** → single place to guarantee leak‐freeness.  
- **parameterised display function** → clear contract and reusable printing logic.  

Understand those ideas and dynamic memory stops being mysterious: *“ask for memory when you need it, give it back immediately when done, and always check that the request succeeded.”*

That is the entire life story of your sanctuary animals inside the computer’s memory.

### STEP_4
# STEP 4: HINTS

---

### HINT 1 (big picture)  
Think of the sanctuary list like a stack of index cards you can shuffle at run-time: sometimes you need more blank cards, sometimes you toss one away.  
What kind of card-file box lets you add or remove cards without knowing in advance how many cards you’ll ever hold?

---

### HINT 2 (focus on memory)  
Whenever you don’t know the final number of items while you’re writing the program, you can’t reserve a fixed-size shelf; you’ll need to ask the operating system for new “shelves” on demand and hand them back when they’re no longer needed.  
Which standard library mechanism lets you obtain such shelves, and which one releases them?

---

### HINT 3 (first steps)  
Start small:  
1. Define a data holder (a structure) for one animal with two changeable text fields and one whole-number field.  
2. Practice obtaining space for that holder, then releasing it in the exact reverse order.  
Once that single step is leak-proof, repeat it inside a loop that keeps track of how many holders you currently have and where you stored their addresses.

### STEP_5
# STEP 5: SUMMARY
- Master dynamic allocation and de-allocation: `malloc/calloc/realloc` paired with `free`  
- Manage a resizable collection (vector) without fixed bounds, including geometric growth and shrinking logic  
- Practice safe string handling: exact-sized heap buffers, avoiding overruns, and cleaning up every allocated byte  
- Separate concerns through modular design (data holders, container management, I/O helpers, display routine)  
- Enforce memory leak discipline: every successful allocation has one unique `free` path, even on early exit  
- Apply defensive checking on library calls: verify allocation success before overwriting the only reference  
- Use `const` pointers to document read-only interfaces such as the required `displayAnimal` function  
- Combine control flow (menu loop) with resource management (create/destroy animals) in a single coherent program

### STEP_6
# STEP 6: TEST CASES

1. Happy path – add two animals, list them, exit  
   Confirms basic insertion, listing, and clean shutdown.

2. Edge – try to remove animal at index 0 when list is empty  
   Checks error message for invalid index and no crash.

3. Edge – add one animal, remove it, then list (empty)  
   Verifies correct shrinking and handling of empty collection.

4. Invalid input – attempt to display at negative index  
   Ensures bounds checking on display and graceful recovery.

5. Invalid input – add three animals, try to remove index 5  
   Tests high invalid index; expects error message and intact list.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nLuna\nRed Panda\n3\n1\nMax\nAfrican Elephant\n12\n4\n5", "expected_keyword": "[1] Name: Max"},
    {"input": "2\n0\n4\n5", "expected_keyword": "Invalid index"},
    {"input": "1\nAlice\nTiger\n5\n2\n0\n4\n5", "expected_keyword": "empty"},
    {"input": "3\n-1\n5", "expected_keyword": "Invalid index"},
    {"input": "1\nA\nDog\n1\n1\nB\nCat\n2\n1\nC\nBird\n3\n2\n5\n4\n5", "expected_keyword": "[1] Name: B"}
  ]
}
```

---

## Iteration 91 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired by the campus “Student Housing Office” to write a tiny command‑line utility that keeps track of the rooms currently occupied in a dormitory.  
Each occupied room is described by three pieces of information:

* **Room number** – an integer (e.g., 101, 202).  
* **Student name** – a string of up to 30 characters (no spaces).  
* **Number of occupants** – an integer (1‑4).  

The program must store these records dynamically because the number of occupied rooms changes while the program runs. When the user decides to stop using the program, all allocated memory must be released.

## Requirements  

1. **Data representation** – Define a `struct` called `Room` that holds the three fields above.  
2. **Dynamic storage** – The program must maintain a **dynamic array** of `Room` objects that can grow or shrink as rooms are added or removed. Use `malloc`, `realloc`, and `free` only (no global static arrays).  
3. **Menu‑driven interface** – Present the user with a menu that repeats until the user chooses to exit. The menu must contain the following options (the numbers are mandatory):  

   1. **Add a room** – Prompt for room number, student name, and occupants; insert the new record at the end of the dynamic array.  
   2. **Remove a room** – Prompt for a room number; if a room with that number exists, delete it from the array, shifting later elements forward to fill the gap. If the room does not exist, print “Room not found”.  
   3. **Display a room** – Prompt for a room number; if found, call a function `displayRoom` (see constraint) to print the details; otherwise print “Room not found”.  
   4. **List all rooms** – Print the details of every stored room in the order they were added, using `displayRoom` for each entry.  
   5. **Exit** – Free all allocated memory and terminate the program.  

4. **Input validation** – The program should not crash on invalid numeric input; you may assume the user follows the prompts for strings.  

5. **Memory cleanup** – Before exiting, all memory obtained with `malloc`/`realloc` must be released with `free`.  

## Example Interaction  

```
--- Dormitory Occupancy Manager ---
1) Add a room
2) Remove a room
3) Display a room
4) List all rooms
5) Exit
Choose an option: 1
Enter room number: 101
Enter student name: Alice
Enter number of occupants: 2
Room added.

1) Add a room
2) Remove a room
3) Display a room
4) List all rooms
5) Exit
Choose an option: 1
Enter room number: 202
Enter student name: Bob
Enter number of occupants: 1
Room added.

1) Add a room
2) Remove a room
3) Display a room
4) List all rooms
5) Exit
Choose an option: 4
Room 101 – Alice – 2 occupants
Room 202 – Bob – 1 occupant

1) Add a room
2) Remove a room
3) Display a room
4) List all rooms
5) Exit
Choose an option: 3
Enter room number to display: 101
Room 101 – Alice – 2 occupants

1) Add a room
2) Remove a room
3) Display a room
4) List all rooms
5) Exit
Choose an option: 2
Enter room number to remove: 202
Room removed.

1) Add a room
2) Remove a room
3) Display a room
4) List all rooms
5) Exit
Choose an option: 5
Goodbye!
```

## ### CONSTRAINTS  

* **Struct usage** – The primary data entity must be a `struct` named `Room`.  
* **Display function** – The logic that prints the details of **one** room must be encapsulated in a function with the exact prototype:  

  ```c
  void displayRoom(const Room *r);
  ```  

* **Menu exit option** – The menu must include an explicit “Exit” choice (option 5 in the example). Selecting this option must cause the program to free all allocated memory and terminate.  
* **Single‑source file** – The entire solution must be written in one `.c` file, but you may define as many helper functions as you like (the only required helper is `displayRoom`).  

---  

*Write a program that satisfies the above specifications.*

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Dormitory Occupancy Manager
 * Implements a menu-driven interface to maintain a dynamic array
 * of occupied student rooms. All memory is freed before termination.
 *
 * Author: CS Professor
 * Date  : 2025-06-25
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NAME 30        /* max length for student name */

/* ---------- Data Representation ---------- */
typedef struct {
    int  roomNumber;
    char studentName[MAX_NAME + 1]; /* +1 for NUL terminator */
    int  occupants;
} Room;

/* ---------- Function Prototypes ---------- */
int  addRoom(Room **rooms, int *count, int *capacity);
int  removeRoom(Room **rooms, int *count, int roomToRemove);
int  displayRoomByNumber(const Room *rooms, int count, int target);
void displayRoom(const Room *r);          /* required function */
void listAllRooms(const Room *rooms, int count);
void clearInputBuffer(void);

/* ---------- Helper Macros ---------- */
#define INITIAL_CAPACITY 4
#define GROWTH_FACTOR    2

/* ---------- Program Entry ---------- */
int main(void)
{
    Room *rooms = NULL;  /* dynamic array */
    int   count    = 0;  /* rooms currently stored */
    int   capacity = 0;  /* physical size of allocated array */
    int   choice;

    /* seed with initial capacity */
    capacity = INITIAL_CAPACITY;
    if ((rooms = malloc(sizeof(Room) * capacity)) == NULL) {
        fprintf(stderr, "Memory allocation failed on startup; exiting.\n");
        return EXIT_FAILURE;
    }

    /* main menu loop */
    for (;;) {
        puts("\n--- Dormitory Occupancy Manager ---");
        puts("1) Add a room");
        puts("2) Remove a room");
        puts("3) Display a room");
        puts("4) List all rooms");
        puts("5) Exit");
        printf("Choose an option: ");

        /* Read integer with input protection */
        if (scanf("%d", &choice) != 1) {
            clearInputBuffer();
            puts("Invalid choice. Please enter a number 1-5.");
            continue;
        }
        clearInputBuffer();

        switch (choice) {
            case 1: /* Add */
                addRoom(&rooms, &count, &capacity);
                break;
            case 2: /* Remove */
                {
                    int targetRn;
                    printf("Enter room number to remove: ");
                    scanf("%d", &targetRn);
                    clearInputBuffer();
                    removeRoom(&rooms, &count, targetRn);
                }
                break;
            case 3: /* Display one */
                {
                    int targetRn;
                    printf("Enter room number to display: ");
                    scanf("%d", &targetRn);
                    clearInputBuffer();
                    displayRoomByNumber(rooms, count, targetRn);
                }
                break;
            case 4: /* List all */
                listAllRooms(rooms, count);
                break;
            case 5: /* Exit */
                goto cleanup;      /* breaks nested loops; tidy up */
            default:
                puts("Invalid choice. Please enter 1-5.");
        }
    }

cleanup:
    free(rooms);
    puts("Goodbye!");
    return EXIT_SUCCESS;
}

/* ---------- Implementation ---------- */

/* Clear stdin up to and including newline */
void clearInputBuffer(void)
{
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF)
        ;
}

/*
 * Adds a new room at the end of the dynamic array.
 * Expands capacity if array is full.
 * Return value ignored, but could be used to signal success/failure.
 */
int addRoom(Room **rooms, int *count, int *capacity)
{
    /* read room data */
    Room newRoom;
    printf("Enter room number: ");
    scanf("%d", &newRoom.roomNumber);
    clearInputBuffer();

    printf("Enter student name: ");
    scanf("%30s", newRoom.studentName);   /* %30s guarantees length ≤ MAX_NAME */
    clearInputBuffer();

    printf("Enter number of occupants (1-4): ");
    scanf("%d", &newRoom.occupants);
    clearInputBuffer();

    if (*count == *capacity) {                /* resize needed */
        int newCap = ((*capacity) * GROWTH_FACTOR);
        Room *tmp = realloc(*rooms, sizeof(Room) * newCap);
        if (!tmp) {                           /* realloc failed */
            perror("realloc");
            return -1;
        }
        *rooms = tmp;
        *capacity = newCap;
    }

    (*rooms)[*count] = newRoom;
    (*count)++;
    puts("Room added.");
    return 0;
}

/*
 * Removes the first room with matching roomNumber.
 * Maintains array density by shifting subsequent elements.
 */
int removeRoom(Room **rooms, int *count, int roomToRemove)
{
    /* iterate until found */
    for (int i = 0; i < *count; ++i) {
        if ((*rooms)[i].roomNumber == roomToRemove) {
            /* shift everything forward by one */
            for (int j = i; j < *count - 1; ++j)
                (*rooms)[j] = (*rooms)[j + 1];
            (*count)--;
            puts("Room removed.");
            return 1;
        }
    }
    puts("Room not found.");
    return 0;
}

/* Print details for one room (required signature) */
void displayRoom(const Room *r)
{
    if (!r) return;
    printf("Room %d - %s - %d occupant%s\n",
           r->roomNumber,
           r->studentName,
           r->occupants,
           (r->occupants == 1) ? "" : "s");
}

/*
 * Searches array for given room number and calls displayRoom() if found.
 */
int displayRoomByNumber(const Room *rooms, int count, int target)
{
    for (int i = 0; i < count; ++i) {
        if (rooms[i].roomNumber == target) {
            displayRoom(&rooms[i]);
            return i;                  /* success, index of room */
        }
    }
    puts("Room not found.");
    return -1;
}

/* Iterate over entire array and print each room in order */
void listAllRooms(const Room *rooms, int count)
{
    if (count == 0) {
        puts("No rooms to display.");
        return;
    }

    for (int i = 0; i < count; ++i)
        displayRoom(&rooms[i]);
}
```

### STEP_3
# STEP 3: EXPLANATION

1. What is “dynamic memory” and why do we need it?
   - A C program’s memory is divided roughly into three zones:
        stack – small, fast, automatically reclaimed
        static/global – lives for the whole run
        heap – large, under program control, the only place we can grow/shrink arbitrary arrays at run-time
   - The dormitory program doesn’t know in advance how many rooms the operator will type in. If we declare Room rooms[1000] we might waste 990 slots or not have enough. malloc lets us ask for exactly as much memory as we currently need and to enlarge/shrink it later. That means we must manage its lifetime ourselves and give it back before we exit.

2. How do we represent one room?
   - We bundle the three pieces of information into one C structure:
     typedef struct { … } Room;
   - A struct is a VALUE type; wherever we put a Room we get all the fields contiguously. Think of it as the cookie-cutter for one cookie.

3. Where do we store *many* rooms?
   - A dynamic array is simply a contiguous block of Rooms that we reach through a Room * pointer.
     Room *rooms;
   - Initially we malloc space for four rooms (INITIAL_CAPACITY). We keep another variable capacity telling us how many slots that block has and count telling us how many are actually in use.
   - capacity==count means “full”. Rather than error we call realloc to obtain a bigger block, double the capacity, and copy the old contents. Note that realloc might move the entire block somewhere else, that is why we always do tmp = realloc(…) and do not reuse the original pointer until we know it succeeded.

4. Passing a pointer to our rooms to helper functions
   - When we realloc we may receive a new address back in main. Helper functions therefore receive Room **rooms (pointer to the pointer) so that they can update main’s copy of the rooms pointer. Inside such a function we write (*rooms) to mean “the whole array”. The *count and *capacity parameters are also pointers for the same reason: helpers must be able to change their values so they persist after returning.

5. Adding a room
   - Collect user input -> store it in a temporary Room newRoom.
   - Check if the current array is full (count == capacity).
     If yes:
        - Compute newCap = oldCap * 2
        - Call tmp = realloc(oldBlock, newCap * sizeof(Room))
        - Check tmp == NULL to detect failure.
        - Overwrite rooms pointer, update capacity.
   - Copy newRoom into rooms[count], then increment count.

6. Removing a room
   - Locate the room number with a simple loop.
   - To delete we:
     a) Shift every element after i one position left, overwriting the one we remove
     b) Decrease count by one
   - We do not shrink the logical array here; you could add code to realloc downward if you wanted to save memory.

7. Printing
   - The specification forces us to separate “print-one-room” logic into void displayRoom(const Room *r);
   - Because r is passed “const”, we promise not to alter any of its fields. That keeps the display routine purely side-effect-free. Notice how we also take care of proper pluralisation: 1 occupant vs. occupantS.

8. Input safety
   - scanf("%d") will leave the newline in the input buffer, so if we later read a string we could consume the residual '\n'. A small utility clearInputBuffer() reads and discards characters up to the next newline. That simplifies repeated prompts.
   - We do NOT attempt to validate the name for spaces; the problem states we may assume that is satisfied by the caller.

9. Memory clean-up
   - Because all our data are stored in ONE malloc block (possibly moved by realloc) we need only ONE free(rooms) before the program terminates.
   - After free(rooms) we jump to cleanup via goto. You can think of the label as “guaranteed path out of the menu loop.” Any later extension (e.g. strdup’d strings) would need its own free calls at that same spot. All paths that exit the program must arrive there; otherwise we leak.

10. What you should remember for your next program
    - If you do not know the maximum size of your collection, allocate on the heap.
    - Keep two numbers: logical size (count) and buffer size (capacity) and always separate them.
    - When realloc grows, double the size; amortised cost is O(1).
    - Check every malloc/realloc. If it fails, handle it (print, return) rather than dereferencing NULL, which causes segmentation faults.
    - For each malloc there must be exactly one free unless you plan to keep the object alive until exit. Do not lose the pointer; save it before realloc; only free the final address after the last realloc.

Once those ideas click, dynamic arrays become the bread-and-butter of C data-structure management, leading naturally to linked lists, hash tables, and beyond.

### STEP_4
# STEP 4: HINTS

Hint 1 (conceptual nudge):  
Think of your dormitory list as a stack of index cards that you can freely add or remove. Start with a small shoebox; whenever it gets too crowded, get a bigger box and move the cards. The key idea is “grow as needed” rather than “reserve a shelf that might stay half-empty.”

Hint 2 (focus on C mechanism):  
Look up the family of “ask the operating system for memory at run-time” functions—you’ll need one to create the first box, another to enlarge it, and a third to hand the box back when you’re done.

Hint 3 (first implementation step):  
Create a single structure that groups the three pieces of a room record together, then declare a pointer meant to aim at a whole sequence of those structures. Allocate room for a handful initially, and keep track of how many slots you’ve filled so you know when it’s time to request a larger space.

### STEP_5
# STEP 5: SUMMARY
- Struct definition and grouping related data into a single composite type
- Dynamic memory management with malloc, realloc, and free – allocating exactly what is needed and releasing it before exit
- Maintaining and resizing a dynamic array while tracking logical size vs. physical capacity
- Passing pointers (and pointers-to-pointers) so helper functions can update the caller’s data
- Encapsulation of formatting logic in a dedicated display function with const-correct parameters
- Basic input-validation techniques to prevent buffer overruns and handle invalid numeric choices
- Clean-up strategies that guarantee every allocated block is freed, preventing memory leaks
- Menu-driven control flow and modular function design to keep main readable and responsibilities separated

### STEP_6
# STEP 6: TEST CASES

Test 1 – Happy-path add, remove, display:  
Add room 101-Alice-2, add room 202-Bob-1, list all, display room 101 (exists), remove room 202, list all.  
Expected: shows room 101 twice (once in list, once in display), then shows only 101 after removal.

Test 2 – Empty list handling:  
Immediately choose option 4 (list all rooms).  
Expected: prints “No rooms to display.”

Test 3 – Non-existent room:  
Add 101-Alice-2, attempt to remove room 303, attempt to display room 404.  
Expected: twice prints “Room not found.”

Test 4 – Duplicate room number (allowed):  
Add 102-Amy-3, then immediately add 102-Ben-1, list rooms.  
Expected: shows both entries with the same room number, keeping insertion order.

Test 5 – Invalid menu choice and numeric overflow:  
Type 99, then type x (non-digit) to the choice prompt, then add a valid room.  
Expected: menu replies “Invalid choice” to both bad inputs without crashing.

Edge sub-case for Test 2: choose option 3 with an empty array.  
Expected: prints “Room not found.”

Machine-readable test set (use menu number 5 to exit):
```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\n101\nAlice\n2\n1\n202\nBob\n1\n4\n3\n101\n2\n202", "expected_keyword": "Room 101 - Alice - 2 occupants"},
    {"input": "4", "expected_keyword": "No rooms to display"},
    {"input": "1\n101\nAlice\n2\n2\n303\n3\n404", "expected_keyword": "Room not found"},
    {"input": "1\n102\nAmy\n3\n1\n102\nBen\n1\n4", "expected_keyword": "Room 102 - Ben - 1 occupant"},
    {"input": "99\nx\n1\n101\nEve\n2", "expected_keyword": "Invalid choice"}
  ]
}
```

---

## Iteration 92 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired to write a tiny “library inventory” program for a small community library that keeps track of the books currently on its shelves. The library does **not** have a database; instead, it stores all information in memory while the program runs. Because the number of books can change at runtime (books are added and removed), you must allocate and free memory dynamically using `malloc` and `free`.

## Requirements  

Write a C program that allows the user to manage a collection of books. Each book has the following attributes:

| Field | Type | Description |
|-------|------|-------------|
| `title` | `char *` | The title of the book (maximum 100 characters). |
| `author` | `char *` | The author’s name (maximum 100 characters). |
| `year` | `int` | Publication year. |
| `id` | `int` | A unique integer identifier assigned by the program (starting from 1). |

The program must provide a **menu‑driven** interface with the following options:

1. **Add a new book** – Prompt the user for title, author, and year, allocate a new `Book` structure, store the data, and append it to the dynamic collection.  
2. **Remove a book by ID** – Ask for the book’s ID, locate the corresponding structure, remove it from the collection, and free its memory. If the ID does not exist, display an error message.  
3. **Display details of a book by ID** – Ask for the ID and print all fields of that book. The printing logic **must** be placed in a function called `displayBook`.  
4. **List all books** – Print the details of every book currently stored, in the order they were added.  
5. **Exit** – Terminate the program after freeing all allocated memory.

Additional functional details:

* The collection must be stored as a **dynamic array of pointers** (`Book **books`). The array itself should grow or shrink with `realloc` as books are added or removed.
* IDs are never reused; each newly added book receives the next integer (1, 2, 3, …) even if earlier books have been deleted.
* Input validation is required only for the menu choice and the book ID (must be a positive integer).  

## Example Interaction  

```
=== Library Inventory ===
1) Add a new book
2) Remove a book by ID
3) Display a book by ID
4) List all books
5) Exit
Enter choice: 1
Enter title: The C Programming Language
Enter author: Kernighan & Ritchie
Enter year: 1978
Book added with ID 1.

=== Library Inventory ===
1) Add a new book
2) Remove a book by ID
3) Display a book by ID
4) List all books
5) Exit
Enter choice: 1
Enter title: Clean Code
Enter author: Robert C. Martin
Enter year: 2008
Book added with ID 2.

=== Library Inventory ===
1) Add a new book
2) Remove a book by ID
3) Display a book by ID
4) List all books
5) Exit
Enter choice: 4
ID: 1 | Title: The C Programming Language | Author: Kernighan & Ritchie | Year: 1978
ID: 2 | Title: Clean Code | Author: Robert C. Martin | Year: 2008

=== Library Inventory ===
1) Add a new book
2) Remove a book by ID
3) Display a book by ID
4) List all books
5) Exit
Enter choice: 3
Enter ID to display: 2
ID: 2
Title: Clean Code
Author: Robert C. Martin
Year: 2008

=== Library Inventory ===
1) Add a new book
2) Remove a book by ID
3) Display a book by ID
4) List all books
5) Exit
Enter choice: 5
Goodbye!
```

## ### CONSTRAINTS  

1. **Struct Requirement** – The primary data entity **must** be represented by a `struct` named `Book`.  
2. **Function Requirement** – The logic that prints the details of a single book **must** be placed in a function with the exact prototype:  

   ```c
   void displayBook(const Book *b);
   ```  

3. **Dynamic Allocation** – All memory for `Book` objects and the array that holds their pointers must be obtained with `malloc`/`realloc` and released with `free`. No static or global arrays of fixed size are allowed.  
4. **Menu Implementation** – Because a menu is required, the program **must** include an explicit menu option to **EXIT** the program (option 5 in the example). Selecting this option must cause the program to free any remaining allocated memory before terminating.  
5. **Single‑File Solution** – All code must reside in a single source file (`.c`). Apart from `main`, you may define additional helper functions (e.g., for adding, removing, resizing the array), but the `displayBook` function is mandatory.  

Your task is to write the complete program that satisfies the above specifications and constraints.

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * A minimal, menu-driven library inventory program that keeps all data in memory.
 * It uses dynamic allocation (malloc/realloc/free) only—no fixed-size arrays.
 *
 * Compile (GCC, C11 or later):
 *     gcc -std=c11 -Wall -Wextra -pedantic library.c -o library
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STR 100          /* longest allowed title/author string length */

/* ---------- Data structure ---------- */
typedef struct {
    int   id;
    char *title;
    char *author;
    int   year;
} Book;

/* ---------- Function prototypes ---------- */
void displayBook(const Book *b);
Book *createBook(int id, const char *title, const char *author, int year);
void  freeBook(Book *b);

/* ---------- Global (file-scope) state ---------- */
static Book **g_books      = NULL;   /* dynamic array of Book* */
static size_t g_count      = 0;      /* how many books stored    */
static size_t g_capacity   = 0;      /* capacity of g_books      */
static int    g_nextID     = 1;      /* always-increasing ID     */

/* ---------- Helper: ensure array has room for one more Book* ---------- */
static int ensureCapacity(void)
{
    if (g_count < g_capacity) return 1;          /* already have room */

    size_t newCap = (g_capacity == 0) ? 4 : g_capacity * 2;
    Book **tmp = realloc(g_books, newCap * sizeof *tmp);
    if (!tmp) {
        perror("realloc");
        return 0;
    }
    g_books    = tmp;
    g_capacity = newCap;
    return 1;
}

/* ---------- Helper: find index of book with given ID, or -1 ---------- */
static int findByID(int id)
{
    for (size_t i = 0; i < g_count; ++i)
        if (g_books[i]->id == id) return (int)i;
    return -1;
}

/* ---------- Helper: remove book at index, shift array left ---------- */
static void removeAtIndex(size_t idx)
{
    freeBook(g_books[idx]);

    /* shift everything left by one */
    memmove(&g_books[idx], &g_books[idx + 1],
            (g_count - idx - 1) * sizeof *g_books);
    --g_count;
}

/* ---------- Core operations ---------- */

/* Allocate and fully initialise a Book. Returns NULL on failure. */
Book *createBook(int id, const char *title, const char *author, int year)
{
    Book *b = malloc(sizeof *b);
    if (!b) { perror("malloc Book"); return NULL; }

    b->id   = id;
    b->year = year;

    /* allocate and copy strings */
    b->title = malloc(MAX_STR);
    if (!b->title) { perror("malloc title"); free(b); return NULL; }
    strncpy(b->title, title, MAX_STR - 1);
    b->title[MAX_STR - 1] = '\0';

    b->author = malloc(MAX_STR);
    if (!b->author) { free(b->title); free(b); return NULL; }
    strncpy(b->author, author, MAX_STR - 1);
    b->author[MAX_STR - 1] = '\0';

    return b;
}

/* Release a Book and its strings. */
void freeBook(Book *b)
{
    if (!b) return;
    free(b->title);
    free(b->author);
    free(b);
}

/* Mandatory function: display a single Book. */
void displayBook(const Book *b)
{
    if (!b) return;
    printf("ID: %d\n", b->id);
    printf("Title: %s\n", b->title);
    printf("Author: %s\n", b->author);
    printf("Year: %d\n", b->year);
}

/* ---------- User interface helpers ---------- */
static int readLine(char *buf, size_t max)
{
    if (!fgets(buf, (int)max, stdin)) return 0;
    buf[strcspn(buf, "\n")] = '\0';     /* strip trailing newline */
    return 1;
}

static int readInt(const char *prompt, int *out)
{
    char line[32];
    printf("%s", prompt);
    if (!readLine(line, sizeof line)) return 0;
    char *end;
    long val = strtol(line, &end, 10);
    if (end == line || *end != '\0' || val <= 0) return 0;
    *out = (int)val;
    return 1;
}

/* ---------- Menu actions ---------- */

static void actionAdd(void)
{
    char title[MAX_STR], author[MAX_STR];
    int year;

    printf("Enter title: ");
    if (!readLine(title, sizeof title)) return;

    printf("Enter author: ");
    if (!readLine(author, sizeof author)) return;

    printf("Enter year: ");
    if (!readInt("", &year)) {
        puts("Invalid year.");
        return;
    }

    if (!ensureCapacity()) return;

    Book *b = createBook(g_nextID++, title, author, year);
    if (!b) return;

    g_books[g_count++] = b;
    printf("Book added with ID %d.\n", b->id);
}

static void actionRemove(void)
{
    int id;
    if (!readInt("Enter ID to remove: ", &id)) {
        puts("Invalid ID.");
        return;
    }
    int idx = findByID(id);
    if (idx < 0) {
        puts("No book with that ID.");
        return;
    }
    removeAtIndex((size_t)idx);
    printf("Book removed.\n");
}

static void actionDisplay(void)
{
    int id;
    if (!readInt("Enter ID to display: ", &id)) {
        puts("Invalid ID.");
        return;
    }
    int idx = findByID(id);
    if (idx < 0) {
        puts("No book with that ID.");
        return;
    }
    displayBook(g_books[idx]);
}

static void actionList(void)
{
    if (g_count == 0) {
        puts("No books in inventory.");
        return;
    }
    for (size_t i = 0; i < g_count; ++i) {
        Book *b = g_books[i];
        printf("ID: %d | Title: %s | Author: %s | Year: %d\n",
               b->id, b->title, b->author, b->year);
    }
}

/* ---------- Main menu loop ---------- */
static void menu(void)
{
    puts("=== Library Inventory ===");
    puts("1) Add a new book");
    puts("2) Remove a book by ID");
    puts("3) Display a book by ID");
    puts("4) List all books");
    puts("5) Exit");
    printf("Enter choice: ");
}

/* ---------- Shutdown: free everything ---------- */
static void cleanup(void)
{
    for (size_t i = 0; i < g_count; ++i)
        freeBook(g_books[i]);
    free(g_books);

    g_books    = NULL;
    g_count    = 0;
    g_capacity = 0;
}

/* ---------- main ---------- */
int main(void)
{
    int running = 1;
    while (running) {
        menu();
        int choice;
        if (!readInt("", &choice)) {
            puts("Invalid choice.");
            continue;
        }

        switch (choice) {
            case 1: actionAdd();     break;
            case 2: actionRemove();  break;
            case 3: actionDisplay(); break;
            case 4: actionList();    break;
            case 5: running = 0;     break;
            default: puts("Invalid choice.");
        }
    }

    cleanup();
    puts("Goodbye!");
    return 0;
}
```

### STEP_3
# STEP 3: EXPLANATION  
(What every “malloc-confused” student needs to know, told in plain language)

---

### 1. We keep TWO kinds of things in the heap
- **Book structs** – each one stores four fields (`id`, `year`, `title`, `author`).  
- **An expanding array of _pointers_** to those structs – `g_books`.  
  - `g_books` itself is just a contiguous block that can grow or shrink with `realloc`.  
  - The array never moves the Book objects; it only moves the *pointers* to them.  
→ That double indirection (`Book **`) lets us delete a Book in O(1) time by swapping a pointer instead of shuffling whole structs.  

---

### 2. “But I never know how many books!” → dynamic growth recipe
Strategy used: **geometric expansion** (double capacity when full).  
- Start with `capacity = 0` and `count = 0`.  
- Before inserting: call `ensureCapacity()`.  
  - If `count < capacity`, do nothing.  
  - Otherwise double the capacity with `realloc` → **amortised O(1)** cost per insertion.  
Think of it like buying a bigger **parking lot** every time you run out of spaces, but you move only the signs that point to the cars, not the cars themselves.  

---

### 3. Anatomy of a safe `malloc`/`realloc`
Always test the returned pointer:  
```c
type *p = malloc(n * sizeof *p);
if (!p) { perror("malloc"); exit(EXIT_FAILURE); }
```  
- **Never cast** `malloc`/`realloc` in C.  
- **Never write to** `p` until you verified it is non-NULL.  
- **Use `sizeof *p`** to stay type-safe even if the type changes later.  

For `realloc`, store the result in a temporary variable.  
That way the original pointer stays intact if `realloc` fails.  

---

### 4. Strings: we duplicate, not embed
A fixed `char title[100]` in the struct would waste space for short strings.  
Instead we keep a **pointer** and allocate 100 bytes on the heap.  
`createBook()` does three `malloc` calls: struct, title buffer, author buffer.  
Therefore three `free` calls are needed → wrapped in `freeBook()`.  

---

### 5. Identity without reuse—how we hand out IDs
A single counter:  
```c
static int g_nextID = 1;
```  
Every freshly created book gets `id = g_nextID++`.  
When one is removed the gap is closed (memmove) but `g_nextID` is **never decremented**, so IDs are unique for the whole program run (requirement).  

---

### 6. Remove-by-ID: two clean steps
1. Linear search through `g_books[]` until `id` matches.  
2. `memmove()` everything after the element one slot left → shrinks logical size by 1 (classic “erase from vector”).  
3. Finally `freeBook()` the removed element.  
Still O(n) but simple and avoids dangling pointers.  

---

### 7. One-function printing: why we insisted on `displayBook`
Separation of concerns:  
- `displayBook()` knows how to print a Book.  
- Actions that need to print call it; the rest of the code doesn’t care.  
The prototype takes a `const Book *` so the function can’t accidentally modify its argument.  

---

### 8. Clean shutdown: no leaks allowed
`cleanup()` walks through the array, calls `freeBook()` (freeing strings + struct) for every entry, then `free(g_books)`.  
Running under `valgrind` should report `0 bytes in use at exit`.  
That also means we are allowed to call `actionRemove` or exit at any time without memory leaks.  

---

### 9. Input: keep it simple but safe
We use `fgets` into a small local buffer, strip the newline, then convert numbers with `strtol`.  
- If conversion fails or value ≤ 0 → reject, ask again.  
Only the **menu choice** and the numeric ID are validated; strings can be arbitrary but are truncated safely with `strncpy + NUL terminator`.  

---

### 10. Putting it together—mental model for malloc practice
Whenever you allocate, ask yourself:  
1. Who is responsible for `free`ing it?  
2. Where can the program exit? (Add a `cleanup` path there.)  
3. Can it fail? (Check the pointer immediately.)  

Follow those three rules and dynamic memory becomes predictable instead of terrifying.

### STEP_4
# STEP 4: HINTS

**Hint 1**  
Think of your collection as a row of empty parking spots inside a stretchy rubber lot.  
When a new car (book) arrives, you only need to park a small sign that points to the car, not move the car itself.  
How can you make the lot longer if you suddenly run out of parking spaces?

**Hint 2**  
To add a new entry you will need to reserve three separate pieces of memory each time: one for the struct itself and one for each of the two strings it will hold.  
What special library routine lets you ask the operating system to enlarge an already-allocated block without losing its old contents?

**Hint 3**  
Start the job by declaring a pointer-to-pointer variable that will serve as your elastic array of signs; initialise it to NULL and keep a count of how many signs are currently parked.  
Before inserting, always check whether the current capacity is already full; if it is, double the capacity, relocate only the signs, and only then attach the new sign.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management with `malloc`, `realloc`, and `free`  
- Allocating and releasing multi-component structures that contain heap-allocated strings  
- Implementing a growable array (vector) of pointers using geometric expansion  
- Separating data ownership: array holds pointers, structs reside independently on the heap  
- Memory-leak prevention by pairing every allocation with a clear exit-time deallocation path  
- Using `const`-correct function parameters to enforce read-only access (`displayBook`)  
- Simple input validation and safe string handling with fixed-length buffers  
- Menu-driven program flow and modular design through helper functions

### STEP_6
# STEP 6: TEST CASES

1. **Add two books and list them** (common-case sanity check)  
   - Add “The Pragmatic Programmer” by Andy Hunt, 1999 → should receive ID 1  
   - Add “Clean Code” by Robert C. Martin, 2008 → should receive ID 2  
   - Choose list-all: both books must appear in insertion order  

2. **Display a non-existent ID** (error handling)  
   - Request display of ID 99 (never created) → program must print “No book with that ID” and stay in menu  

3. **Add, remove, then list** (edge: now-empty collection)  
   - Add any book (ID 1)  
   - Remove it by ID 1  
   - List books → output must contain “No books in inventory”  

4. **Invalid menu choice** (bad user input)  
   - Type 0 then Enter → program must print “Invalid choice” and re-prompt  
   - Type 7 then Enter → same behaviour  

5. **Remove with non-numeric ID** (invalid input)  
   - Choose remove option  
   - Type abc↵ → program must print “Invalid ID” and return to menu; no crash or removal  

---

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nThe Pragmatic Programmer\nAndy Hunt\n1999\n1\nClean Code\nRobert C. Martin\n2008\n4\n5",
      "expected_keyword": "Clean Code"
    },
    {
      "input": "3\n99\n5",
      "expected_keyword": "No book with that ID"
    },
    {
      "input": "1\nTest Book\nTest Author\n2020\n2\n1\n4\n5",
      "expected_keyword": "No books in inventory"
    },
    {
      "input": "0\n7\n5",
      "expected_keyword": "Invalid choice"
    },
    {
      "input": "2\nabc\n5",
      "expected_keyword": "Invalid ID"
    }
  ]
}
```

---

## Iteration 93 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired as a junior developer for **Eco‑Logistics**, a company that tracks the daily deliveries of reusable containers (e.g., water bottles, food trays). Each delivery is recorded as a *ContainerBatch* that stores:

* a unique batch ID (integer)  
* the number of containers in the batch (integer)  
* the total weight of the batch in kilograms (floating‑point)  

Because the number of batches is not known in advance and can change while the program is running, you must allocate memory dynamically for each batch record. The program will allow the user to add new batches, remove existing ones, and view details of a specific batch.

## Requirements  

Write a C program that implements a **menu‑driven** interface with the following options:

1. **Add a new batch** – Prompt the user for the batch ID, number of containers, and total weight. Allocate memory for a new `struct ContainerBatch` using `malloc` and store the data. The batch IDs must be unique; if the user enters an ID that already exists, display an error and do not add a duplicate.  
2. **Delete a batch** – Prompt for a batch ID. If a batch with that ID exists, free the memory associated with it and remove it from the list; otherwise, display “Batch not found.”  
3. **Display a batch** – Prompt for a batch ID and print all its fields in a readable format. The logic for displaying the details must be placed in a function called `displayBatch`.  
4. **List all batches** – Print the information of every batch currently stored, in the order they were added.  
5. **Exit** – Terminate the program. (This option must be present and clearly labeled as the exit choice.)

The program should keep the batches in a **singly‑linked list** (each node contains a pointer to a `ContainerBatch` and a pointer to the next node). All memory allocated for batches and list nodes must be released before the program exits.

## Example Interaction  

```
=== Eco‑Logistics Batch Manager ===
1. Add a new batch
2. Delete a batch
3. Display a batch
4. List all batches
5. Exit
Choose an option: 1

Enter batch ID: 101
Enter number of containers: 25
Enter total weight (kg): 312.5
Batch 101 added.

=== Eco‑Logistics Batch Manager ===
1. Add a new batch
2. Delete a batch
3. Display a batch
4. List all batches
5. Exit
Choose an option: 1

Enter batch ID: 102
Enter number of containers: 40
Enter total weight (kg): 480.0
Batch 102 added.

=== Eco‑Logistics Batch Manager ===
1. Add a new batch
2. Delete a batch
3. Display a batch
4. List all batches
5. Exit
Choose an option: 3

Enter batch ID to display: 101
Batch ID: 101
Containers: 25
Total weight: 312.50 kg

=== Eco‑Logistics Batch Manager ===
1. Add a new batch
2. Delete a batch
3. Display a batch
4. List all batches
5. Exit
Choose an option: 4

Batch ID: 101 | Containers: 25 | Weight: 312.50 kg
Batch ID: 102 | Containers: 40 | Weight: 480.00 kg

=== Eco‑Logistics Batch Manager ===
1. Add a new batch
2. Delete a batch
3. Display a batch
4. List all batches
5. Exit
Choose an option: 5

Goodbye!
```

## ### CONSTRAINTS  

* **Struct Requirement** – The primary data entity must be represented with a `struct` named `ContainerBatch`.  
* **Display Function** – The logic that prints a single batch’s details must be encapsulated in a function with the exact prototype:  
  ```c
  void displayBatch(const struct ContainerBatch *batch);
  ```  
* **Dynamic Allocation** – All `ContainerBatch` objects and list nodes must be created with `malloc` (or `calloc`) and released with `free`. No static or global arrays may be used to store batches.  
* **Menu Exit Option** – The menu must contain an explicit option (number **5** in the example) that terminates the program. Selecting this option must cause the program to free any remaining allocated memory before exiting.  
* **No Memory Leaks** – The program will be tested with tools such as Valgrind; any leaked memory will result in a loss of points.  

Feel free to add helpful prompts or error messages, but the core functionality and constraints must be respected. Good luck!

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Eco-Logistics Batch Manager
 *
 * A menu-driven program that keeps track of ContainerBatch objects
 * in a singly-linked list.  All memory is allocated dynamically and
 * released before exit.
 *
 * Build (GCC, C11):  gcc -std=c11 -Wall -Wextra -pedantic -o batchmgr batchmgr.c
 * Valgrind check:    valgrind ./batchmgr
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

/* ---------- Data structures ---------- */

struct ContainerBatch {
    int    id;          /* unique batch identifier */
    int    containers;  /* number of containers in the batch */
    double weight;      /* total weight in kilograms */
};

/* Node in the singly-linked list */
struct Node {
    struct ContainerBatch *batch; /* pointer to dynamically allocated batch */
    struct Node           *next;  /* next node or NULL */
};

/* ---------- Function prototypes ---------- */
void displayMenu(void);
bool addBatch(struct Node **head);
bool deleteBatch(struct Node **head, int id);
void displayBatch(const struct ContainerBatch *batch);
bool displayBatchById(const struct Node *head, int id);
void listAllBatches(const struct Node *head);
void freeAllBatches(struct Node **head);

/* ---------- Helper: does a batch with given id exist? ---------- */
static bool idExists(const struct Node *head, int id)
{
    for (const struct Node *cur = head; cur != NULL; cur = cur->next)
        if (cur->batch->id == id)
            return true;
    return false;
}

/* ---------- Entry point ---------- */
int main(void)
{
    struct Node *head = NULL; /* initially empty list */

    while (true) {
        displayMenu();
        int choice;
        if (scanf("%d", &choice) != 1) {
            fprintf(stderr, "Invalid input. Exiting.\n");
            break;
        }

        switch (choice) {
        case 1: /* Add new batch */
            if (!addBatch(&head))
                fprintf(stderr, "Failed to add batch.\n");
            break;

        case 2: { /* Delete a batch */
            int id;
            printf("Enter batch ID to delete: ");
            if (scanf("%d", &id) != 1) {
                fprintf(stderr, "Invalid ID.\n");
                break;
            }
            if (!deleteBatch(&head, id))
                printf("Batch not found.\n");
            else
                printf("Batch %d deleted.\n", id);
            break;
        }

        case 3: { /* Display a batch */
            int id;
            printf("Enter batch ID to display: ");
            if (scanf("%d", &id) != 1) {
                fprintf(stderr, "Invalid ID.\n");
                break;
            }
            if (!displayBatchById(head, id))
                printf("Batch not found.\n");
            break;
        }

        case 4: /* List all batches */
            listAllBatches(head);
            break;

        case 5: /* Exit */
            goto cleanup; /* break out of nested scopes */

        default:
            printf("Unknown option. Please choose 1-5.\n");
        }
    }

cleanup:
    freeAllBatches(&head);
    printf("Goodbye!\n");
    return 0;
}

/* ---------- Display the menu ---------- */
void displayMenu(void)
{
    printf("\n=== Eco-Logistics Batch Manager ===\n");
    printf("1. Add a new batch\n");
    printf("2. Delete a batch\n");
    printf("3. Display a batch\n");
    printf("4. List all batches\n");
    printf("5. Exit\n");
    printf("Choose an option: ");
}

/* ---------- Add a new batch ---------- */
bool addBatch(struct Node **head)
{
    int    id;
    int    containers;
    double weight;

    printf("Enter batch ID: ");
    if (scanf("%d", &id) != 1) return false;

    /* Check uniqueness */
    if (idExists(*head, id)) {
        printf("Error: Batch ID %d already exists.\n", id);
        return false;
    }

    printf("Enter number of containers: ");
    if (scanf("%d", &containers) != 1) return false;
    printf("Enter total weight (kg): ");
    if (scanf("%lf", &weight) != 1) return false;

    /* Allocate the batch struct */
    struct ContainerBatch *batch = malloc(sizeof(*batch));
    if (!batch) {
        perror("malloc batch");
        return false;
    }
    batch->id         = id;
    batch->containers = containers;
    batch->weight     = weight;

    /* Allocate new list node */
    struct Node *node = malloc(sizeof(*node));
    if (!node) {
        perror("malloc node");
        free(batch);
        return false;
    }
    node->batch = batch;
    node->next  = NULL;

    /* Append to end of list (preserve insertion order) */
    if (*head == NULL) {
        *head = node;
    } else {
        struct Node *tail = *head;
        while (tail->next) tail = tail->next;
        tail->next = node;
    }

    printf("Batch %d added.\n", id);
    return true;
}

/* ---------- Delete a batch by ID ---------- */
bool deleteBatch(struct Node **head, int id)
{
    struct Node *prev = NULL;
    struct Node *cur  = *head;

    while (cur) {
        if (cur->batch->id == id) {
            /* unlink */
            if (prev)
                prev->next = cur->next;
            else
                *head = cur->next;

            /* free memory */
            free(cur->batch);
            free(cur);
            return true;
        }
        prev = cur;
        cur  = cur->next;
    }
    return false; /* not found */
}

/* ---------- Display helper required by spec ---------- */
void displayBatch(const struct ContainerBatch *batch)
{
    if (!batch) return;
    printf("Batch ID: %d\n", batch->id);
    printf("Containers: %d\n", batch->containers);
    printf("Total weight: %.2f kg\n", batch->weight);
}

/* ---------- Display a batch by ID ---------- */
bool displayBatchById(const struct Node *head, int id)
{
    for (const struct Node *cur = head; cur; cur = cur->next) {
        if (cur->batch->id == id) {
            displayBatch(cur->batch);
            return true;
        }
    }
    return false;
}

/* ---------- List all batches ---------- */
void listAllBatches(const struct Node *head)
{
    if (!head) {
        printf("No batches stored.\n");
        return;
    }
    for (const struct Node *cur = head; cur; cur = cur->next) {
        printf("Batch ID: %d | Containers: %d | Weight: %.2f kg\n",
               cur->batch->id,
               cur->batch->containers,
               cur->batch->weight);
    }
}

/* ---------- Free all allocated memory ---------- */
void freeAllBatches(struct Node **head)
{
    struct Node *cur = *head;
    while (cur) {
        struct Node *next = cur->next;
        free(cur->batch);
        free(cur);
        cur = next;
    }
    *head = NULL;
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic-memory problems feel scary because they add **three** new ideas at once:
1. You ask the OS for memory at run-time (`malloc`)
2. You keep *pointers* to that memory
3. You must later *give the memory back* (`free`)

We'll look at those ideas one by one, using the "batch" program as the example.

---

## 1. Why malloc at all?

If you knew the program would store **at most 100 batches** you could write:
```c
struct ContainerBatch batches[100];
int count = 0;
```
and be done.  
Eco-Logistics, however, said: "We never know how many we'll have, and the user keeps adding while the program runs."

A fixed-size array either:
- wastes space, or
- crashes when the limit is reached.

`malloc` gets *exactly* as many bytes as we need, *exactly* when we need them, and we can call it thousands of times if we want.

---

## 2. What exactly are we allocating?

Look at this picture:

```
LIST NODE                        BATCH OBJECT
+-----------+                    +---------------+
|  batch  --|--->--------------| id            |
|  next ----|----> next node    | containers    |
+-----------+                    | weight        |
                               +---------------+
```

We need **two different** pieces each time the user presses "1":

A. One `struct ContainerBatch`  
B. One `struct Node` (so the batch can live in the linked list)

That is why `addBatch` contains *two* `malloc` calls:

```c
struct ContainerBatch *batch = malloc(sizeof(*batch));
struct Node *node            = malloc(sizeof(*node));
```

The first gives us the "cargo", the second gives us the "shipping container" that keeps the cargo in the list.

---

## 3. How does the list stay together?

Each node has a single arrow (`next`).  
We always add at the **tail** so the order is the order the user inserted.

```
head                                tail
 ↓                                   ↓
[Node] --> [Node] --> [Node] --> NULL
```

To find the tail we walk the arrows until `next == NULL`.

---

## 4. Who owns that memory?

Ownership rules keep leaks away:

1. The list node **owns** the batch pointer (`node->batch`).  
2. `deleteBatch` must therefore `free()` **two** things:

```c
free(cur->batch);  /* give back the cargo  */
free(cur);          /* give back the container */
```

If you forget the *first* call, `batch` leaks although the node disappears.

---

## 5. How does the program find a batch?

We do **not** keep the batches in sorted order—that would be too slow for a beginner exercise.  
Instead we use *linear search*:

```c
for (cur = head; cur != NULL; cur = cur->next)
    if (cur->batch->id == wantedId) …
```

`idExists`, `displayBatchById`, and `deleteBatch` all reuse the same idea.

---

## 6. Who frees memory when the user quits?

The problem statement explicitly requires: "… any remaining allocated memory must be released before the program exits."

`freeAllBatches` walks through the list the same way, freeing every node and every batch.  
Valgrind then reports:  
```
==12345==  All heap blocks were freed -- no leaks are possible
```

---

## 7. Safety steps we added

| Step | Purpose |
|------|---------|
| Check `malloc` return value | If the OS has no memory left we abort the operation, never leave a dangling half-built node. |
| Reject duplicate IDs | Keeps uniqueness invariant, simplifies search. |
| `const` in `displayBatch` | Documents that printing will *not* change the batch. |
| `goto cleanup` on exit | Single exit point, easier to guarantee all paths free memory. |

---

## 8. Common mistakes this program avoids

- Leaking nodes - we **always** free the batch before freeing the node.
- Dangling pointers - we never reuse a pointer after it is freed.
- Memory corruption - no writes occur through stale pointers because all updates use fresh allocations or verified existing IDs.

---

## 9. Take-away checklist

Whenever you write dynamic code:

1. Draw who points at whom (ownership graph).
2. Ask "When will this be freed?" **at the same moment** you write `malloc`.
3. Use helper routines (`freeAllBatches`, `deleteBatch`) that centralise the `free` logic.
4. Test with `valgrind` before you submit.

Once those habits become automatic, "dynamic memory" stops feeling dangerous and simply becomes another tool in your C toolkit.

### STEP_4
# STEP 4: HINTS  

**Hint 1 (overall approach)**  
Think of every batch as two separate things you need to keep track of: the data that describes the batch (ID, count, weight) and the “link” that lets you chain it to the next batch. You’ll need to allocate each of those separately and make sure the link always points to the next item in the chain.  

**Hint 2 (where to focus)**  
When the user chooses “add,” your first task is to make sure no other batch already carries the same ID. Since the items are only connected by forward links, the simplest way to check is to start at the beginning of the chain and walk forward until you either find the ID or reach the end.  

**Hint 3 (first concrete step)**  
Write a small helper that receives only the starting point of the chain and the desired ID, then returns a clear “found / not-found” answer. After that, the “add” option can confidently allocate memory for the new batch only when the helper says the ID is unique.

### STEP_5
# STEP 5: SUMMARY  

- `malloc` / `free` life-cycle: allocate exactly when needed, release both data structure and list-node, avoid leaks  
- Singly-linked list management: create, insert at tail, traverse, delete by key, chain ownership rules  
- Unique-key enforcement: linear search through list, reject duplicates on insert  
- Separation of concerns: keep cargo (`struct ContainerBatch`) separate from list bookkeeping (`struct Node`)  
- Menu-driven input loop: `scanf` validation, single exit point, always clean up before `return`  
- const-correct helper functions: `displayBatch` promises read-only access, good interface design  
- Valgrind-ready style: every `malloc` has a matching `free`, no global/static arrays, zero lost blocks  
- Basic defensive coding: check allocation success, handle malformed input, centralised cleanup routine

### STEP_6
# STEP 6: TEST CASES

1. **Happy Path** – add two batches, list them, display one, delete the other, exit.  
   Expected: both inserts succeed, listing shows both, display shows the first, delete confirms removal, no leaks at exit.

2. **Empty List Display** – choose “List all batches” before any add.  
   Expected: program prints “No batches stored.”

3. **Duplicate ID Block** – add batch 101, then try to add another 101.  
   Expected: second attempt rejected with “Error: Batch ID 101 already exists.”

4. **Delete Non-existent ID** – add 200, then try to delete 999.  
   Expected: “Batch not found.”

5. **Zero-size Batch** – add a batch with 0 containers and 0.0 kg.  
   Expected: accepted and listed normally; delete it and free memory.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\n101\n25\n312.5\n1\n102\n40\n480.0\n4\n3\n101\n2\n102\n5\n",
      "expected_keyword": "Batch 102 deleted"
    },
    {
      "input": "4\n5\n",
      "expected_keyword": "No batches stored"
    },
    {
      "input": "1\n101\n10\n100.0\n1\n101\n20\n200.0\n5\n",
      "expected_keyword": "Error: Batch ID 101 already exists"
    },
    {
      "input": "1\n200\n5\n50.0\n2\n999\n5\n",
      "expected_keyword": "Batch not found"
    },
    {
      "input": "1\n300\n0\n0.0\n4\n2\n300\n5\n",
      "expected_keyword": "Weight: 0.00 kg"
    }
  ]
}
```

---

## Iteration 94 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired as a junior developer for **Eco‑Cart**, a small e‑commerce startup that sells reusable household items. The product catalog is stored only while the program runs; each time the application starts it must build the catalog from user input. Because the number of products is not known in advance, you must allocate memory dynamically.

Your task is to write a C program that lets the user **add**, **remove**, **list**, and **search** products in the catalog. Each product is represented by a `struct` containing an identifier, a name, a price, and a quantity in stock. All memory that is allocated with `malloc` (or `calloc`) must be released with `free` before the program terminates.

## Requirements  

1. **Data representation**  
   * Define a `struct Product` with the following fields:  
     - `int id;`       // unique product identifier (positive integer)  
     - `char *name;`   // dynamically allocated string (maximum length 100 characters)  
     - `float price;`   // price in dollars (e.g., 12.99)  
     - `int quantity;`  // units currently in stock  

2. **Menu‑driven interface** (displayed repeatedly until the user chooses to exit)  

   | Option | Description |
   |--------|-------------|
   | **1**  | **Add a new product** – Prompt for id, name, price, and quantity. Allocate memory for the new `Product` and for the name string. The id must be unique; if a duplicate id is entered, print an error and discard the entry. |
   | **2**  | **Remove a product** – Prompt for an id, locate the product, free its name string and the `Product` structure, and remove it from the catalog. If the id does not exist, print a message. |
   | **3**  | **List all products** – Print a table containing id, name, price, and quantity for every product currently stored. |
   | **4**  | **Search by id** – Prompt for an id and display the details of that single product using a helper function `displayProduct`. If not found, report it. |
   | **5**  | **EXIT** – Terminate the program after freeing all remaining allocated memory. |

3. **Dynamic storage**  
   * The catalog must be stored as a **dynamically allocated array of pointers to `Product`**. The array should expand (using `realloc`) when a new product is added and shrink when a product is removed.  
   * No fixed‑size global arrays are allowed.

4. **Helper function**  
   * Implement a function `void displayProduct(const struct Product *p);` that prints a single product in the same format used by the “List all products” option.

5. **Program termination**  
   * Before exiting (whether via the menu option or an error), the program must free **all** memory that was allocated during execution.

## Example Interaction  

```
=== Eco‑Cart Product Catalog ===
1) Add product
2) Remove product
3) List all products
4) Search by id
5) EXIT
Choose an option: 1
Enter product id: 101
Enter product name: Bamboo Toothbrush
Enter price: 3.49
Enter quantity: 250
Product added.

1) Add product
2) Remove product
3) List all products
4) Search by id
5) EXIT
Choose an option: 1
Enter product id: 102
Enter product name: Reusable Water Bottle
Enter price: 15.00
Enter quantity: 80
Product added.

1) Add product
2) Remove product
3) List all products
4) Search by id
5) EXIT
Choose an option: 3

ID   Name                 Price   Qty
101  Bamboo Toothbrush    3.49    250
102  Reusable Water Bottle15.00   80

1) Add product
2) Remove product
3) List all products
4) Search by id
5) EXIT
Choose an option: 4
Enter product id to search: 101
ID: 101
Name: Bamboo Toothbrush
Price: $3.49
Quantity: 250

1) Add product
2) Remove product
3) List all products
4) Search by id
5) EXIT
Choose an option: 5
Cleaning up memory... Goodbye!
```

## ### CONSTRAINTS  

* **Struct usage** – The primary data entity **must** be a `struct Product` as described.  
* **Function requirement** – The logic for displaying the details of ONE specific entity **must** be placed in a function named `displayProduct`.  
* **Menu exit** – The menu **must** contain an option labeled **5) EXIT** (or the keyword `EXIT`) that terminates the program.  
* **Dynamic allocation only** – All memory for products and their name strings must be obtained with `malloc`/`calloc` (or `realloc`) and released with `free`. No static or stack‑allocated arrays for the catalog are permitted.  
* **Single source file** – The entire solution should be written in one `.c` file, but you may define as many helper functions as you like (the only mandatory helper is `displayProduct`).  

---  

Write the program that satisfies the above specification, demonstrating correct use of `malloc`, `realloc`, and `free`, as well as proper handling of user input and dynamic data structures.

### STEP_2
Below is a complete, self-contained C11 program that meets every requirement.  
Compile with, for example  
   gcc -std=c11 -Wall -Wextra -pedantic eco_cart.c -o eco_cart  

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NAME_MAX_LEN 100          /* inclusive of NUL terminator */

/* ---------- Data representation  -------------------------------- */
struct Product {
    int   id;
    char *name;       /* dynamically allocated, max 100 chars */
    float price;
    int   quantity;
};

/* ---------- Global catalog ------------------------------------ */
static struct Product **catalog = NULL;  /* array of pointers */
static size_t        catCap     = 0;   /* physical capacity  */
static size_t        catSize    = 0;   /* logical count      */

/* ---------- Helper prototypes -------------------------------- */
static void  displayProduct(const struct Product *p);
static int  findById(int id, size_t *outIdx);  /* returns 0 if found */
static int  addProduct(int id, const char *name, float price, int qty);
static void removeProduct(int id);
static void listProducts(void);
static void freeCatalogResources(void);

/* ---------- Main menu driver -------------------------------- */
int main(void)
{
    int choice;
    while (1) {
        puts("\n=== Eco-Cart Product Catalog ===");
        puts("1) Add product");
        puts("2) Remove product");
        puts("3) List all products");
        puts("4) Search by id");
        puts("5) EXIT");

        printf("Choose an option: ");
        if (scanf("%d", &choice) != 1) {
            /* non-numeric input; clean and re-prompt */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF)
                ;
            puts("Please enter a valid number (1-5).");
            continue;
        }
        switch (choice) {
        case 1: {
            int   id, qty;
            char  nameBuf[NAME_MAX_LEN + 1];
            float price;

            printf("Enter product id: ");
            scanf("%d", &id);
            getchar();                       /* absorb leftover newline */
            printf("Enter product name: ");
            if (!fgets(nameBuf, sizeof(nameBuf), stdin)) {
                puts("I/O error; aborting.");
                goto EXIT;
            }
            /* strip trailing newline */
            nameBuf[strcspn(nameBuf, "\n")] = '\0';

            printf("Enter price: ");
            scanf("%f", &price);
            printf("Enter quantity: ");
            scanf("%d", &qty);

            if (addProduct(id, nameBuf, price, qty) != 0)
                puts("Product added.");
            else
                puts("Error adding product (duplicate id?).");
            break;
        }
        case 2: {
            int id;
            printf("Enter product id to remove: ");
            scanf("%d", &id);
            removeProduct(id);
            break;
        }
        case 3:
            listProducts();
            break;
        case 4: {
            int id;
            printf("Enter product id to search: ");
            scanf("%d", &id);
            size_t idx;
            if (findById(id, &idx))
                displayProduct(catalog[idx]);
            else
                puts("Product not found.");
            break;
        }
        case 5:
            goto EXIT;
        default:
            puts("Invalid choice. Please enter 1-5.");
        }
    }
EXIT:
    freeCatalogResources();
    puts("Cleaning up memory... Goodbye!");
    return 0;
}

/* ---------- Display a single product  ------------------------- */
void displayProduct(const struct Product *p)
{
    if (!p) return;
    printf("ID: %d\n", p->id);
    printf("Name: %s\n", p->name);
    printf("Price: $%.2f\n", p->price);
    printf("Quantity: %d\n", p->quantity);
}

/* ---------- Find product by id  ----------------------------- */
static int findById(int id, size_t *outIdx)
{
    for (size_t i = 0; i < catSize; ++i)
        if (catalog[i]->id == id) {
            *outIdx = i;
            return 1;
        }
    return 0;
}

/* ---------- Add new product  ---------------------------------- */
static int addProduct(int id, const char *name, float price, int qty)
{
    /* id must be unique and positive */
    size_t dummy;
    if (id <= 0 || findById(id, &dummy))
        return 0;

    /* Expand catalog array if necessary */
    if (catSize == catCap) {
        size_t newCap = (catCap == 0) ? 4 : catCap * 2;
        struct Product **newCatalog =
            realloc(catalog, newCap * sizeof *newCatalog);
        if (!newCatalog) {
            perror("realloc catalog");
            return 0;
        }
        catalog = newCatalog;
        catCap = newCap;
    }

    /* Allocate new Product and its name */
    struct Product *p = malloc(sizeof *p);
    if (!p) { perror("malloc product"); return 0; }

    char *nm = malloc(strlen(name) + 1);
    if (!nm) {
        free(p);
        perror("malloc name");
        return 0;
    }
    strcpy(nm, name);

    p->id       = id;
    p->name     = nm;
    p->price    = price;
    p->quantity = qty;

    catalog[catSize++] = p;
    return 1;
}

/* ---------- Remove product  ----------------------------------- */
static void removeProduct(int id)
{
    size_t idx;
    if (!findById(id, &idx)) {
        puts("Product not found.");
        return;
    }
    /* free product name memory, then product struct */
    free(catalog[idx]->name);
    free(catalog[idx]);

    /* compact the array */
    memmove(&catalog[idx], &catalog[idx + 1],
            (catSize - idx - 1) * sizeof catalog[idx]);
    --catSize;

    /* Shrink the catalog array if it becomes much smaller */
    if (catCap > 8 && catSize < catCap / 3) {
        size_t newCap = catCap / 2;
        if (newCap < 4) newCap = 4;
        struct Product **newCatalog =
            realloc(catalog, newCap * sizeof *newCatalog);
        if (newCatalog) {
            catalog = newCatalog;
            catCap  = newCap;
        }
    }
    puts("Product removed.");
}

/* ---------- List all products  -------------------------------- */
static void listProducts(void)
{
    if (catSize == 0) {
        puts("No products in catalog.");
        return;
    }
    puts("\nID   Name                         Price   Qty");
    puts("--------------------------------------------");
    for (size_t i = 0; i < catSize; ++i) {
        struct Product const *p = catalog[i];
        printf("%-4d %-26s %6.2f %5d\n",
               p->id, p->name, p->price, p->quantity);
    }
}

/* ---------- Cleanup before exit  --------------------------- */
static void freeCatalogResources(void)
{
    for (size_t i = 0; i < catSize; ++i) {
        free(catalog[i]->name);
        free(catalog[i]);
    }
    free(catalog);
    catalog = NULL;
    catCap = catSize = 0;
}
```

### STEP_3
# Step 3: Explanation

Dynamic memory management is **not magic**—it is just a way to ask the operating system for raw bytes at run-time and to hand them back when you are finished.  
This walk-through explains the **ideas** behind the Eco-Cart program, using the fewest possible buzz-words.  
Keep one sentence in mind:

> Every successful `malloc`/*alloc call **must** have an exactly matching `free`, or the program leaks memory.

---

### 0. What we are trying to store
We do **not** know how many products the user will create, so we cannot use:
```c
Product list[1000];   /* bad—fixed size */
```
Instead we keep **a resizable array** (`catalog`) whose elements are *pointers* to the actual `Product` objects.  
The pointer array itself is also resizable, so we can grow or shrink it with `realloc`.

---

### 1. Global state – three tiny variables
```c
static Product **catalog = NULL;  /* pointer to an array of pointers */
static size_t   catCap   = 0;   /* how many slots we *paid for*     */
static size_t   catSize  = 0;   /* how many we are *using*         */
```
Think of `catalog` like a coat-check ticket: the ticket is not the coat, it just tells you where the coat is.  
We store **tickets**, not coats—this keeps the array small and lets coats move around without tearing tickets.

---

### 2. Creating a new product (`addProduct`)
Step 1 **Check uniqueness**  
Walk through the array and compare `id`.  
If duplicate → refuse, no memory is allocated.

Step 2 **Grow the ticket array if full**  
`catSize == catCap` → array is full.  
We `realloc` the array to twice the capacity.  
`realloc` either:
- returns the *same* pointer (if OS can expand in-place), or  
- moves the whole block elsewhere and copies old data.

Always assign to a temporary pointer first; if `realloc` fails we do **not** lose the old pointer.

Step 3 **Allocate the actual structures**  
```c
Product *p = malloc(sizeof *p);
char    *nm = malloc(strlen(name)+1);
```
`sizeof *p` is safer than `sizeof(Product)` because it stays correct even if `p` changes type.

Step 4 **Fill fields and append ticket**  
- `p->name = nm;`  
- `catalog[catSize++] = p;`

Now we have **two** allocations per product:
```
ticket array ──► [ptr0][ptr1][ptr2]…
                       │      │      │
                       ▼      ▼      ▼
                     Product  Product  Product
```
Remember that count—**we will need two frees**.

---

### 3. Deleting a product (`removeProduct`)
Step 1 **Locate product**  
`findById` returns the index.

Step 2 **Free the two blocks that belong *only* to that product**
```c
free(p->name);
free(p);
```
Step 3 **Compact the ticket array**  
`memmove` shifts remaining pointers one slot left.  
(We do not touch the `Product` objects they point to—only the ticket list.)

Step 4 **Optionally shrink the array**  
If we are using far fewer slots than allocated, we `realloc` down to save memory.  
Shrinking is *not required*, but it shows symmetry with the grow step.

---

### 4. Searching vs. walking
`findById` is used by both "remove" and "search" so the linear scan is written once.  
For a tiny catalog (<10 000 items) a simple loop is fine; for huge data you would use a hash table or binary search on a sorted array.

---

### 5. Printing (`displayProduct` vs. `listProducts`)
- `displayProduct` receives a **const pointer** and prints a *single* product in "pretty" multi-line form.  
- `listProducts` walks the array and prints **many** products in a compact table.

**Why separate functions?**  
Separation of concerns: one knows *how* to print a product, the other knows *when* to do it.

---

### 6. Cleaning up (`freeCatalogResources`)
The program can finish in two ways:
- user chooses "EXIT", or  
- fatal error (we `goto EXIT;`).

Either way we call `freeCatalogResources`:
```c
for each product
    free(product->name);
    free(product);
free(catalog);
```
This guarantees we match every `malloc` with a `free`.  
After freeing, we set pointers to `NULL` and sizes to `0`—defensive programming.

---

### 7. Why we always check allocations
`malloc`/`realloc` can return `NULL` when the heap is exhausted.  
If we dereference a `NULL` pointer we get **undefined behaviour**—often a segmentation fault.  
The code prints `perror` (which shows the system error message) and bails out gracefully.

---

### 8. Memory layout recap
- One **array of pointers** lives until `main` ends.  
- Zero or more `Product` objects live until removed individually.  
- Each product owns a `char *name` string that also must be freed.

**Rule of thumb:**  
Count how many times you called an allocation function; write that many `free` calls before program exit.

---

### 9. Extension ideas
- Replace linear search with a hash map for O(1) look-ups.  
- Save catalog to a file so it survives restarts.  
- Allow editing a product without deleting it.  
- Track total memory used for educational display.

Once you are comfortable with **ticket arrays** (`T **`) plus per-object allocations, you have mastered the most common pattern in C dynamic data structures.

### STEP_4
# STEP 4: HINTS

### Hint 1  
Think of the catalog as a “bucket of tickets,” not a bucket of items.  
You only need to keep *pointers* to products in an expandable array; the actual products live elsewhere in memory.  
If the array ever runs out of space, ask the system for a bigger bucket and move the tickets over.

### Hint 2  
When you add something, you’ll call the memory allocator twice: once for the product itself and once for the name string it will hold.  
Keep track of how many tickets you’ve used so you can spot duplicates quickly.

### Hint 3  
Start by writing the “add” logic:  
- Check if the ID already exists in the ticket list.  
- If not, grow the ticket array if needed, allocate the new product and its name, store the new ticket, and bump your count.

### STEP_5
# STEP 5: SUMMARY

- Dynamic memory life-cycle: allocate with *alloc, release with free, never lose the pointer before freeing
- Resizable arrays via realloc: grow/shrink an array of pointers at run-time without fixed limits
- Struct-composition with flexible string members: storing a dynamic string inside a struct and managing its lifetime
- Pointer-to-pointer patterns: using an array of struct * for lightweight, swap-friendly collections
- Input validation and uniqueness checks: scanning user data while enforcing business rules (unique id)
- Modular design: separating single-item display, search, and list logic for clear, reusable functions
- Memory leak prevention: systematic cleanup paths that match every malloc with a corresponding free
- Error handling for allocation failure: testing return values and graceful program exit

### STEP_6
# STEP 6: TEST CASES

### Test 1 – Happy-path add & list  
Add two products, list them, and verify both appear in the table.

### Test 2 – Search an existing product  
Use the search-by-id option on a product that was added; confirm the detailed single-product display prints its name.

### Test 3 – Remove until empty  
Remove every product, then list; program should report “No products in catalog.” (edge case: empty catalog).

### Test 4 – Duplicate id rejected  
Attempt to add a second product with the same id; program must print an error and *not* list the duplicate.

### Test 5 – Invalid menu choice  
Enter 6 (an invalid option) and confirm the program re-prompts without crashing (invalid-input handling).

### JSON machine-readable test suite
```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\n101\nBamboo Toothbrush\n3.49\n250\n1\n102\nReusable Water Bottle\n15.00\n80\n3", "expected_keyword": "Bamboo Toothbrush"},
    {"input": "1\n103\nEco Straw\n4.99\n120\n4\n103", "expected_keyword": "Eco Straw"},
    {"input": "1\n104\nTote Bag\n9.99\n50\n2\n104\n2\n103\n3", "expected_keyword": "No products"},
    {"input": "1\n105\nGreen Brush\n2.50\n300\n1\n105\nDuplicate Brush\n2.50\n300", "expected_keyword": "duplicate"},
    {"input": "6\n3", "expected_keyword": "Invalid choice"}
  ]
}
```

---

## Iteration 95 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired to write a small utility for a university’s registration office. The office needs a program that can keep a **dynamic list of courses** that are being offered for the upcoming semester.  
Each course has a *course code* (a string of up to 8 characters, e.g., `CS101`), a *title* (up to 40 characters), and the *number of enrolled students* (an integer).  
Because the number of courses is not known in advance and may change during the execution of the program, you must allocate memory on the heap using `malloc`/`realloc` and release it with `free` when it is no longer needed.

## Requirements  

Write a C program that provides a **text‑based menu** with the following options:

1. **Add a new course** – Prompt the user for the course code, title, and initial enrollment, then store the information in a dynamically‑allocated array.  
2. **Remove a course** – Prompt for a course code. If a course with that code exists, delete it from the array, shifting the remaining elements as necessary, and shrink the allocated memory accordingly.  
3. **Display a course** – Prompt for a course code and, if found, show all its fields. The logic for displaying a single course **must** be placed in a function called `displayCourse`.  
4. **List all courses** – Print the details of every stored course in the order they were added.  
5. **Exit** – Terminate the program after freeing all allocated memory.  

Additional functional details:

* The program must continue to show the menu after completing any option except **Exit**.  
* If the user tries to add a course whose code already exists, print an error message and do **not** add a duplicate.  
* If the user requests to remove or display a course that does not exist, print an appropriate “not found” message.  
* All input should be read safely (e.g., using `scanf` with width limits or `fgets` followed by parsing) to avoid buffer overflows.  

## Example Interaction  

```
=== Course Management System ===
1) Add a new course
2) Remove a course
3) Display a course
4) List all courses
5) Exit
Enter choice: 1
Enter course code: CS101
Enter title: Introduction to Programming
Enter enrollment: 45
Course added.

=== Course Management System ===
1) Add a new course
2) Remove a course
3) Display a course
4) List all courses
5) Exit
Enter choice: 1
Enter course code: MATH220
Enter title: Linear Algebra
Enter enrollment: 30
Course added.

=== Course Management System ===
1) Add a new course
2) Remove a course
3) Display a course
4) List all courses
5) Exit
Enter choice: 3
Enter course code to display: CS101
Course Code: CS101
Title      : Introduction to Programming
Enrollment : 45

=== Course Management System ===
1) Add a new course
2) Remove a course
3) Display a course
4) List all courses
5) Exit
Enter choice: 4
Course Code: CS101   Title: Introduction to Programming   Enrollment: 45
Course Code: MATH220 Title: Linear Algebra                Enrollment: 30

=== Course Management System ===
1) Add a new course
2) Remove a course
3) Display a course
4) List all courses
5) Exit
Enter choice: 5
Goodbye!
```

## ### CONSTRAINTS  

* **Struct Requirement** – The primary data entity must be represented by a `struct` named `Course` containing at least the fields `code`, `title`, and `enrollment`.  
* **Display Function** – The logic that prints the details of **one** specific course must be implemented in a function with the exact prototype:  

  ```c
  void displayCourse(const Course *c);
  ```  

* **Memory Management** – Use `malloc`/`realloc` to grow the array when a new course is added and `free` (or `realloc` to shrink) when a course is removed or when the program exits. No memory leaks are allowed.  
* **Menu Requirement** – The menu must include an explicit option to **EXIT** the program (option 5 in the example). Selecting this option must cause the program to terminate after all allocated memory has been released.  
* **Single‑File Implementation** – Apart from `main`, you may define additional helper functions, but the entire solution must reside in a single source file (e.g., `course_manager.c`).  

---  

*Your task is to write the complete program that satisfies all of the above.*

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Course Management System (single-file implementation)
 *
 * Implements a simple menu-based program that keeps a dynamic list of
 * university courses. The array of structs is resized on demand (add/remove),
 * and all memory is released before the program exits.
 *
 * Compile: gcc -std=c11 -Wall -Wextra -pedantic course_manager.c -o course_manager
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CODE_LEN   9     /* max 8 chars + terminator (course code)        */
#define TITLE_LEN 41    /* max 40 chars + terminator (title)          */
#define CHOICE_LEN 16    /* safety length for reading user choices    */

/* ---------- Data structure ---------- */
typedef struct {
    char code[CODE_LEN];
    char title[TITLE_LEN];
    int enrollment;
} Course;

/* ---------- State held by main ---------- */
static Course *courses = NULL;
static size_t course_capacity = 0;
static size_t course_count   = 0;

/* ---------- Helper prototypes ---------- */
static void menu(void);
static int read_choice(void);
static size_t find_course(const char *code);
static void add_course(void);
static void remove_course(void);
static void display_single_course(void);
static void list_all_courses(void);
static void cleanup(void);

/* Required API by specification */
void displayCourse(const Course *c);

/* ---------- Main driver ---------- */
int main(void)
{
    puts("=== Course Management System ===");

    for (;;) {
        menu();
        int choice = read_choice();
        switch (choice) {
        case 1: add_course();         break;
        case 2: remove_course();        break;
        case 3: display_single_course();break;
        case 4: list_all_courses();   break;
        case 5:
            cleanup();
            puts("Goodbye!");
            return EXIT_SUCCESS;
        default:
            puts("Invalid menu choice. Please enter a number 1-5.");
        }
    }
}

/* ---------- Definitions ---------- */
void menu(void)
{
    puts("1) Add a new course");
    puts("2) Remove a course");
    puts("3) Display a course");
    puts("4) List all courses");
    puts("5) Exit");
    printf("Enter choice: ");
}

int read_choice(void)
{
    char buf[CHOICE_LEN];
    if (!fgets(buf, sizeof(buf), stdin)) return -1;
    int n;
    /* simple validation: must start with a digit followed by newline/end */
    if (sscanf(buf, "%d", &n) != 1) return -1;
    return n;
}

/* Find by course code, return index or course_count if not found */
size_t find_course(const char *code)
{
    for (size_t i = 0; i < course_count; ++i) {
        if (strcmp(courses[i].code, code) == 0)
            return i;
    }
    return course_count;
}

/* Add with capacity check and duplicate protection */
void add_course(void)
{
    char code[CODE_LEN], title[TITLE_LEN];
    int   enrollment;

    printf("Enter course code: ");
    if (!fgets(code, sizeof(code), stdin)) return;
    code[strcspn(code, "\n")] = 0;

    size_t idx = find_course(code);
    if (idx < course_count) {
        puts("Error: Course code already exists.");
        return;
    }

    printf("Enter title: ");
    if (!fgets(title, sizeof(title), stdin)) return;
    title[strcspn(title, "\n")] = 0;

    printf("Enter enrollment: ");
    if (scanf(" %d", &enrollment) != 1) {
        puts("Error: invalid enrollment.");
        return;
    }
    /* flush remainder of this line */
    while (getchar() != '\n');

    /* Need more room? */
    if (course_capacity == course_count) {
        /* Double capacity, start with 8 items */
        size_t new_cap = course_capacity == 0 ? 8 : course_capacity * 2;
        Course *tmp = realloc(courses, new_cap * sizeof *tmp);
        if (!tmp) {
            puts("Error: out of memory.");
            return;
        }
        courses       = tmp;
        course_capacity = new_cap;
    }

    strncpy(courses[course_count].code,  code,  CODE_LEN);
    strncpy(courses[course_count].title, title, TITLE_LEN);
    courses[course_count].enrollment = enrollment;
    course_count++;
    puts("Course added.");
}

/* Removes by shifting left, then shrinks underlying block */
void remove_course(void)
{
    char code[CODE_LEN];
    printf("Enter course code to remove: ");
    if (!fgets(code, sizeof(code), stdin)) return;
    code[strcspn(code, "\n")] = 0;

    size_t idx = find_course(code);
    if (idx == course_count) {
        puts("Course not found.");
        return;
    }

    /* shift everything left */
    memmove(courses + idx,
            courses + idx + 1,
            (course_count - idx - 1) * sizeof *courses);
    course_count--;

    /* Try to shrink memory if usage is well below capacity */
    size_t low_water = course_capacity / 3;
    if (course_count < low_water) {
        size_t new_cap = course_capacity / 2;
        if (new_cap < 8) new_cap = 0;  /* floor */
        Course *tmp = new_cap
                        ? realloc(courses, new_cap * sizeof *tmp)
                        : NULL;        /* zero means free */
        if (new_cap && !tmp) {         /* realloc failed, ignore shrink */
            return;
        }
        courses        = tmp;
        course_capacity = new_cap;
    }
    puts("Course removed.");
}

/* Print details of one course – required by spec */
void displayCourse(const Course *c)
{
    printf("Course Code: %s\n", c->code);
    printf("Title      : %s\n", c->title);
    printf("Enrollment : %d\n", c->enrollment);
}

void display_single_course(void)
{
    char code[CODE_LEN];
    printf("Enter course code to display: ");
    if (!fgets(code, sizeof(code), stdin)) return;
    code[strcspn(code, "\n")] = 0;

    size_t idx = find_course(code);
    if (idx == course_count) {
        puts("Course not found.");
        return;
    }
    displayCourse(&courses[idx]);
}

void list_all_courses(void)
{
    if (course_count == 0) {
        puts("No courses in the list.");
        return;
    }
    printf("%-10s  %-40s  %s\n", "Code", "Title", "Enroll");
    for (size_t i = 0; i < course_count; ++i) {
        Course *c = &courses[i];
        printf("%-10s  %-40s  %d\n", c->code, c->title, c->enrollment);
    }
}

/* Free memory and reset state – called before exit */
void cleanup(void)
{
    free(courses);
    courses       = NULL;
    course_count  = 0;
    course_capacity= 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory allocation lets us grow or shrink data at **run-time** instead of guessing how big an array should be.  
This program keeps an expandable list of `Course` structures using only three global variables:

- `courses` – a *pointer* that currently points to the first byte of our array on the heap  
- `course_count` – how many *valid* structs are currently stored in that array  
- `course_capacity` – how many structs we *could* store before the array is full  

Whenever `count == capacity` we are out of room, so we treat the array like an overcrowded bookshelf: we build a *larger* shelf, copy the books across, and throw the old shelf away (with `realloc`).  
When we finally delete enough books, we can shrink the shelf again so we do not waste space.

Here is the thought process behind each major step:

1. **Why `malloc`/`realloc` instead of a fixed-size array?**  
   The specification says “the number of courses is not known in advance.”  
   A compile-time array (`Course list[100];`) either wastes memory (if too big) or crashes (if too small).  
   `malloc` lets us pay for exactly as much memory as we need, when we need it.

2. **The very first `add_course()` call**  
   `capacity` starts at 0. We choose a moderate initial size (8) and call `malloc` or `realloc` to reserve space for eight `Course` structures. A pointer to this *new* block is stored back in `courses`.

3. **Doubling instead of “+1” growth**  
   Each `realloc` is expensive because it may copy data. Reserving room for *double* the previous size is a classic compromise: it guarantees that, on average, each element is copied only a constant number of times (amortized O(1)).

4. **Shrinking after deletion**  
   When many courses are removed, we may be wasting half of our allocated shelf. We only shrink when fewer than one third of the slots are used, and we shrink by *half*. This prevents “yo-yo” behaviour (constant realloc on alternating add/remove) while still giving memory back to the OS.

5. **Realloc magic**  
   `realloc(old_ptr, new_size)` returns the address of a block that is *at least* `new_size` bytes large and contains the old data, or `NULL` if it fails.  
   Important habit: always store the result in a *temporary* pointer first; otherwise a failed `realloc` would overwrite your only reference with `NULL`, leaking the old block.

6. **Safety rule: check every allocation**  
   If `malloc`/`realloc` fails, we immediately tell the user and keep the old pointer intact, avoiding crashes. Production code might `exit`, here we simply skip the add/shrink operation.

7. **Freeing on `Exit`**  
   The specification requires “no memory leaks.”  
   `free()` tells the OS that the heap block is no longer needed; you pass the pointer (`courses`) and set your variables back to 0 so a second `free()` cannot accidentally be called.

8. **Display abstraction**  
   `displayCourse(const Course *c)` receives a *single* pointer; it does **not** know whether the course lives in a dynamic array, a static array, or by itself. The caller (menu option 3) simply passes `&courses[index]`.

9. **String handling**  
   `fgets()` reads *at most* `sizeof(buf)-1` characters and always NUL-terminates. We then chop off the trailing newline with `strcspn` so comparisons work correctly.

10. **Finding by code**  
    `find_course()` performs a linear scan and returns the index or `course_count` (an impossible index) if not found. Other functions test the index and print the appropriate success/error message.

11. **Removing without holes**  
    Once the index is found, we use `memmove` to shift everything left one slot (C’s overlapping-copy-safe cousin of `memcpy`), then decrement `course_count`. This keeps the array contiguous and simplifies indexing.

12. **Constants for widths**  
    `CODE_LEN` and `TITLE_LEN` include space for the C-string NUL terminator. This prevents buffer overflows when reading user input.

13. **Loop forever until Exit**  
    `main()` shows the menu, reads an integer choice, dispatches to a handler, and loops. Selecting option 5 calls `cleanup()` and breaks the loop by returning from `main`, giving the OS exit code `EXIT_SUCCESS`.

Key takeaway:  
*Pointers, `malloc`, and `realloc` are just tools that let us decide the size of our luggage *after* we know how much we need to pack. By pairing every allocation with a clear owner (`courses` pointer) and a predictable lifetime (until “Exit”), we create programs that are both safe and flexible.*

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual nudge):**  
Think of the list of courses like a row of storage boxes that you can keep adding to or pulling from while the program runs.  
Instead of building a fixed shelf big enough for “every box you’ll ever need,” start with a small one and replace it with a bigger shelf whenever you run out of space.

**Hint 2 (key C feature):**  
You have already met pointers that point to single variables. Revisit the idea of a pointer that can “grow” to hold many variables of the same type, then look up the family of functions that requests more (or less) space from the system at run-time.

**Hint 3 (first-step logic):**  
Inside your main loop, right before you store a new course, compare the current number of stored items with the present size of the storage you reserved; if they’re equal, arrange to double that reserved size before writing the new data in.

### STEP_5
# STEP 5: SUMMARY
- Manual dynamic memory management: allocating, expanding, and releasing heap blocks safely with malloc/realloc/free  
- Resizable arrays without STL: tracking separate count vs. capacity and handling growth/shrink policies  
- Defensive programming: validating every allocation, guarding against buffer overflows, and producing leak-free exits  
- Modular design in C: separating data (struct), navigation helpers (find), and required interface (displayCourse)  
- Core pointer semantics: indexing through a struct pointer, pointer arithmetic, and lifetime ownership rules  
- Robust input techniques: using fgets + sscanf or similar to read user data of fixed maximum width  
- Menu-driven control flow: sentinel loops, switch dispatch, clear separation of concerns between UI and data work

### STEP_6
# STEP 6: TEST CASES

**TC-1  Common sequence**  
Add two courses, list them, display the first one, delete the second one, list again, then exit.  
**Type**  
1  
CS101  
Prog I  
60  
1  
CS102  
Prog II  
50  
4  
3  
CS101  
2  
CS102  
4  
5  

**Expected** output includes “Prog I”, “Prog II”, the CS101 detail printout, “Course removed”, only CS101 listed finally, and “Goodbye!”.

---

**TC-2  Empty list display**  
Immediately choosing list-all option to ensure nothing crashes and proper “No courses” style message is printed.  
**Type**  
4  
5  

**Expected** “No courses in the list.” before Goodbye.

---

**TC-3  Duplicate rejection**  
Attempt to add two courses with the same code; second add should print an error and the final roster must have only one copy.  
**Type**  
1  
MATH150  
Calc 1  
40  
1  
MATH150  
Calc 1  
45  
4  
5  

**Expected** Error line “Course code already exists” appears; listing shows the first entry only.

---

**TC-4  Remove/Display non-existent codes**  
Remove a course never added; display a non-existent course; behaviour should be graceful messages and unchanged list size.  
**Type**  
2  
ABC123  
3  
XYZ999  
4  
5  

**Expected** at least one “not found” message for both operations and 0 listed courses at end.

---

**TC-5  Growth and shrink (edge)**  
1) add 9 courses to force at least one capacity double 2) remove 6 to trigger shrink; all operations must remain valid and memory released on exit.  
**Type**  
1  
C01  
One  
1  
1  
C02  
Two  
2  
1  
C03  
Three  
3  
1  
C04  
Four  
4  
1  
C05  
Five  
5  
1  
C06  
Six  
6  
1  
C07  
Seven  
7  
1  
C08  
Eight  
8  
1  
C09  
Nine  
9  
4  
2  
C01  
2  
C02  
2  
C03  
2  
C04  
2  
C05  
2  
C06  
4  
5  

**Expected** nine courses listed, six removals reported, final list shows C07-C09, no crash and “Goodbye!”.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nCS101\nProg I\n60\n1\nCS102\nProg II\n50\n4\n3\nCS101\n2\nCS102\n4\n5",
      "expected_keyword": "Goodbye!"
    },
    {
      "input": "4\n5",
      "expected_keyword": "No courses"
    },
    {
      "input": "1\nMATH150\nCalc 1\n40\n1\nMATH150\nCalc 1\n45\n4\n5",
      "expected_keyword": "already exists"
    },
    {
      "input": "2\nABC123\n3\nXYZ999\n4\n5",
      "expected_keyword": "not found"
    },
    {
      "input": "1\nC01\nOne\n1\n1\nC02\nTwo\n2\n1\nC03\nThree\n3\n1\nC04\nFour\n4\n1\nC05\nFive\n5\n1\nC06\nSix\n6\n1\nC07\nSeven\n7\n1\nC08\nEight\n8\n1\nC09\nNine\n9\n4\n2\nC01\n2\nC02\n2\nC03\n2\nC04\n2\nC05\n2\nC06\n4\n5",
      "expected_keyword": "C09"
    }
  ]
}
```

---

## Iteration 96 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
The campus IT department is building a tiny “Student Record Manager” that runs in a terminal.  
Each student record contains a **student ID**, **full name**, **age**, and **GPA**.  
Because the number of students is not known in advance, the program must allocate memory for each record at run‑time and release it when the record is removed or when the program terminates.

You are to implement this manager using only the C standard library functions `malloc`, `realloc`, and `free`.  

## Requirements  

Your program must present a simple text menu and perform the following operations:

1. **Add a new student**  
   - Prompt the user for the student’s ID (integer), name (string up to 50 characters, may contain spaces), age (integer), and GPA (float).  
   - Dynamically allocate a `struct Student` to hold the data and store a pointer to it in a dynamically‑grown array (use `realloc` as needed).  

2. **List all students**  
   - Print a table showing the ID, name, age, and GPA of every student currently stored.  

3. **Find a student by ID**  
   - Ask for an ID, locate the matching student (if any), and display the details using the required display function.  

4. **Delete a student by ID**  
   - Ask for an ID, locate the matching student, free the memory for that student, remove the pointer from the array, and shrink the array appropriately.  

5. **Exit the program**  
   - Before terminating, free *all* memory that was allocated for student records and for the array that holds the pointers.  

The menu must be displayed after each completed operation until the user chooses the **Exit** option.

## Example Input / Output  

```
=== Student Record Manager ===
1) Add student
2) List all students
3) Find student by ID
4) Delete student by ID
5) Exit
Select an option: 1

Enter student ID: 1001
Enter name: Alice Johnson
Enter age: 20
Enter GPA: 3.75
Student added.

=== Student Record Manager ===
1) Add student
2) List all students
3) Find student by ID
4) Delete student by ID
5) Exit
Select an option: 1

Enter student ID: 1002
Enter name: Bob Lee
Enter age: 22
Enter GPA: 3.42
Student added.

=== Student Record Manager ===
1) Add student
2) List all students
3) Find student by ID
4) Delete student by ID
5) Exit
Select an option: 2

ID     Name               Age  GPA
---------------------------------------
1001   Alice Johnson      20   3.75
1002   Bob Lee            22   3.42

=== Student Record Manager ===
1) Add student
2) List all students
3) Find student by ID
4) Delete student by ID
5) Exit
Select an option: 3

Enter ID to search: 1002
Student details:
ID: 1002
Name: Bob Lee
Age: 22
GPA: 3.42

=== Student Record Manager ===
1) Add student
2) List all students
3) Find student by ID
4) Delete student by ID
5) Exit
Select an option: 4

Enter ID to delete: 1001
Student with ID 1001 deleted.

=== Student Record Manager ===
1) Add student
2) List all students
3) Find student by ID
4) Delete student by ID
5) Exit
Select an option: 5

Goodbye!
```

## ### CONSTRAINTS  

1. **Data structure** – You must define a `struct Student` that holds the four fields (ID, name, age, GPA).  
2. **Dynamic allocation** – Every student record must be allocated with `malloc` (or `calloc`). The array that stores the pointers to the records must also be allocated dynamically and resized with `realloc`.  
3. **Memory deallocation** – When a student is deleted, or when the program exits, the corresponding memory must be released with `free`. No memory leaks are allowed.  
4. **Display function** – The logic that prints the details of a *single* student must be placed in a function with the exact prototype:  

   ```c
   void displayStudent(const struct Student *s);
   ```  

   This function will be used by both the “Find student by ID” and “List all students” options.  
5. **Menu requirement** – The menu must contain an explicit option to **Exit** the program; it should be numbered (as in the example) and selecting it must cause the program to terminate after freeing all allocated memory.  
6. **Standard library only** – Apart from `stdio.h`, `stdlib.h`, and `string.h`, no other libraries may be used.  

---

*Design your solution so that a student who has just learned how `malloc`, `realloc`, and `free` work can implement it without needing any advanced data‑structure knowledge.*

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Student Record Manager
 * A console application that keeps an open-ended collection of student records.
 * All data is stored in dynamically allocated memory and freed on demand or
 * when the program exits.  Uses only <stdio.h>, <stdlib.h>, <string.h>.
 *
 * Author:  Your Name
 * Build:   gcc -std=c11 -Wall -Wextra -pedantic student_manager.c -o manager
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NAME_LEN 50

/* ---------- Data structure ---------- */
struct Student {
    int id;
    char name[MAX_NAME_LEN + 1]; /* +1 for terminating NUL */
    int age;
    float gpa;
};

/* ---------- Global state ---------- */
static struct Student **students = NULL;
static size_t studentCount = 0;
static size_t studentCap = 0;   /* current capacity of the pointer array */

/* ---------- Utility function prototypes ---------- */
static void displayStudent(const struct Student *s);
static void addStudent(void);
static void listStudents(void);
static void findStudent(void);
static void deleteStudent(void);
static void freeAllAndExit(void);

/* ---------- Helper: grow the pointer array ---------- */
static int growArray(void)
{
    if (studentCount < studentCap) return 1;   /* already room, nothing to do */

    size_t newCap = (studentCap == 0) ? 4 : studentCap * 2;
    struct Student **newBlock = realloc(students, newCap * sizeof *newBlock);

    if (newBlock == NULL) {
        perror("realloc failed while growing array");
        return 0;
    }
    students = newBlock;
    studentCap = newCap;
    return 1;
}

/* ---------- Helper: find index of student by ID, -1 if absent ---------- */
static ssize_t findIndexById(int id)
{
    for (size_t i = 0; i < studentCount; ++i) {
        if (students[i]->id == id)
            return (ssize_t)i;
    }
    return -1;
}

/* ---------- Implementation of required display function ---------- */
void displayStudent(const struct Student *s)
{
    /* Always print exactly three lines, matching the required format. */
    printf("ID: %d\n", s->id);
    printf("Name: %s\n", s->name);
    printf("Age: %d\n", s->age);
    printf("GPA: %.2f\n", s->gpa);
}

/* ---------- Add a new student ---------- */
static void addStudent(void)
{
    int id, age;
    char nameBuf[MAX_NAME_LEN + 1];
    float gpa;

    printf("Enter student ID: ");
    if (scanf("%d", &id) != 1) {        /* basic I/O sanity check */
        puts("Invalid input.");
        while (getchar() != '\n');      /* discard rest of line */
        return;
    }
    while (getchar() != '\n');          /* clear newline after scanf */

    /* Avoid duplicates */
    if (findIndexById(id) != -1) {
        puts("A student with that ID already exists.");
        return;
    }

    /* Read remaining fields */
    printf("Enter name: ");
    if (!fgets(nameBuf, sizeof nameBuf, stdin)) {
        puts("Input error.");
        return;
    }
    nameBuf[strcspn(nameBuf, "\n")] = '\0'; /* strip trailing newline */

    printf("Enter age: ");
    if (scanf("%d", &age) != 1) {
        puts("Invalid age.");
        while (getchar() != '\n');
        return;
    }
    while (getchar() != '\n');

    printf("Enter GPA: ");
    if (scanf("%f", &gpa) != 1) {
        puts("Invalid GPA.");
        while (getchar() != '\n');
        return;
    }
    while (getchar() != '\n');

    /* Grow pointer array as needed */
    if (!growArray()) return;

    /* Allocate a new Student record */
    struct Student *s = malloc(sizeof *s);
    if (!s) {
        perror("malloc failed");
        return;
    }

    /* Populate record */
    s->id = id;
    strncpy(s->name, nameBuf, MAX_NAME_LEN);
    s->name[MAX_NAME_LEN] = '\0';     /* guarantee NUL-termination */
    s->age = age;
    s->gpa = gpa;

    /* Insert pointer into array */
    students[studentCount++] = s;
    puts("Student added.");
}

/* ---------- List all students ---------- */
static void listStudents(void)
{
    if (studentCount == 0) {
        puts("No students stored.");
        return;
    }
    printf("%-6s %-20s %-4s %-5s\n", "ID", "Name", "Age", "GPA");
    printf("-------------------------------\n");
    for (size_t i = 0; i < studentCount; ++i)
        printf("%-6d %-20s %-4d %-5.2f\n",
               students[i]->id,
               students[i]->name,
               students[i]->age,
               students[i]->gpa);
}

/* ---------- Find a student by ID ---------- */
static void findStudent(void)
{
    int id;
    printf("Enter ID to search: ");
    if (scanf("%d", &id) != 1) {        /* basic error check */
        puts("Invalid number.");
        while (getchar() != '\n');
        return;
    }
    while (getchar() != '\n');

    ssize_t idx = findIndexById(id);
    if (idx == -1)
        printf("Student with ID %d not found.\n", id);
    else
        displayStudent(students[idx]);
}

/* ---------- Delete a student by ID ---------- */
static void deleteStudent(void)
{
    int id;
    printf("Enter ID to delete: ");
    if (scanf("%d", &id) != 1) {
        puts("Invalid number.");
        while (getchar() != '\n');
        return;
    }
    while (getchar() != '\n');

    ssize_t idx = findIndexById(id);
    if (idx == -1) {
        printf("Student with ID %d not found.\n", id);
        return;
    }

    /* Free the record itself */
    free(students[idx]);

    /* Shift remaining pointers left by one */
    for (size_t i = (size_t)idx; i < studentCount - 1; ++i)
        students[i] = students[i + 1];

    studentCount--;
    printf("Student with ID %d deleted.\n", id);
}

/* ---------- Release all memory and terminate ---------- */
static void freeAllAndExit(void)
{
    /* release each record */
    for (size_t i = 0; i < studentCount; ++i)
        free(students[i]);

    /* release the pointer array */
    free(students);
    students = NULL;
    studentCount = studentCap = 0;
}

/* ---------- Main menu loop ---------- */
int main(void)
{
    /* Ensure we never accidentally use uninitialized memory */
    students = NULL;
    studentCount = 0;
    studentCap = 0;

    int option = 0;
    while (1) {
        puts("\n=== Student Record Manager ===");
        puts("1) Add student");
        puts("2) List all students");
        puts("3) Find student by ID");
        puts("4) Delete student by ID");
        puts("5) Exit");
        printf("Select an option: ");

        char *err = NULL;
        char line[32];
        if (!fgets(line, sizeof line, stdin)) {
            puts("Input error.");
            continue;
        }
        option = (int)strtol(line, &err, 10);
        if (*err && *err != '\n') {   /* not a pure number */
            puts("Invalid menu choice.");
            continue;
        }

        switch (option) {
            case 1: addStudent(); break;
            case 2: listStudents(); break;
            case 3: findStudent(); break;
            case 4: deleteStudent(); break;
            case 5:
                freeAllAndExit();
                puts("Goodbye!");
                return EXIT_SUCCESS;
            default:
                puts("Invalid menu choice.");
        }
    }
}
```

### STEP_3
# STEP 3: EXPLANATION

Learning dynamic memory is easiest if you picture what lives where in RAM.  
Imagine three “bins”:

1. **Static area**: variables you write in source code (`int id`) that live for the whole program.  
2. **Stack**: variables created when a function runs (`int x = 5;`) – they vanish when the function returns.  
3. **Heap**: a giant pool you can grab at **run-time** whenever you do not know in advance how much you will need.  
   – You get heap chunks with `malloc`, `calloc`, or `realloc`.  
   – You return them to the pool with `free`.  
   – If you forget to `free`, your program “leaks” memory; if you `free` twice, it is undefined behavior.

The Student Record Manager never knows how many students the user will type, so every record and even the table that holds them sit in the heap.

Below are the key ideas the program teaches.

---

### 1. A struct Student lives on the heap, not on the stack

```c
struct Student {
    int id;
    char name[51];
    int age;
    float gpa;
};
```

The size of this struct is fixed (a few dozen bytes).  
Creating `struct Student s;` would put it on the stack and it would disappear when the function returns.  
Instead we call:

```c
struct Student *s = malloc(sizeof *s);   /* allocate one on the heap */
```

`malloc` returns a *pointer* to the first byte of that block – or `NULL` if the OS refuses the request (out of memory). We **always** check the pointer before using it, hence the mandatory `if (!s)` guard.

---

### 2. Growing an “array” of unknown size

A C array is a contiguous block of *fixed* size. Because we do not know the final size, we build a **resizable array** ourselves:

1. Keep variables:  
   - `struct Student **students;` – a pointer to an array of *pointers*.  
   - `studentCount` – how many valid pointers are in it now.  
   - `studentCap` – the current physical capacity (how many could fit).

2. When the array is about to overflow:  
   `malloc` a new larger block, copy the existing pointers (or, even better, `realloc` enlarges the block without extra copying if the heap can). If enlarging fails we give up (graceful degradation).

This is similar to how C++’s `std::vector` works under the hood.

---

### 3. `free` is symmetric with `malloc`

- `malloc` → returns a block that belongs to you forever until you release it.  
- `free(ptr)` → returns it to the heap.  
  Never pass a pointer to `free` more than once.

Our program therefore keeps track of two kinds of ownership:

1. The array `struct Student **` itself.  
2. Each individual `struct Student` whose address is stored in that array.

When we **delete** a student:

```c
free(students[index]);         /* free the record itself */
```

and then compact the pointer array by shifting the remaining pointers left (so later code never tries to read a dangling pointer).

When the user chooses **Exit** we:

```c
for (i)
    free(students[i]);
free(students);
```

Afterwards the program terminates – at that point no leak is left, independent of how many insertion/deletions happened earlier.

---

### 4. Handling `realloc` safely

`realloc(oldPtr, newSize)` may:

- enlarge the buffer at the same location (cheap),  
- or allocate a new block and *copy* data, freeing the old one automatically,  
- or fail and return `NULL`.

Because the latter is possible, you must never write:

```c
students = realloc(students, newCap * ...);   /* DANGEROUS */
```

because if `realloc` fails, you lose reference to the previous block and **leak**.  
Correct pattern:

```c
struct Student **tmp = realloc(students, newCap * ...); 
if (!tmp) { ...handle failure... }
students = tmp;                       /* ok, now commit */
```

---

### 5. `displayStudent` demonstrates abstraction

Instead of repeating `printf("ID: %d ...")` in two places (list all and find), we centralize output into one helper. The function receives a `const Student *` – meaning it is **read-only** so the caller cannot accidentally corrupt data. The same abstraction principle is used in larger software: encapsulate operations on records.

---

### 6. Basic robustness without getting too complex

The assignment bans advanced libraries, so this solution uses only `scanf`/`fgets` for input with minimal safety checks:

- `scanf` is followed by a loop that consumes leftover new-line.  
- When reading an option we read an entire line and inspect it with `strtol`.  
- All memory allocation is checked and the program bails out on failure.  
Even simple checks protect students from hard-to-debug crashes.

---

### 7. What you should take away

- Dynamic memory is just **rented storage**.  
- Always `free` exactly what you `malloc`/`realloc`.  
- When the amount is unknown, allocate an empty buffer and grow it on demand; C gives you the building blocks (pointer arithmetic, `realloc`) to reinvent containers higher-level languages give for free.  
- Check the return value of *every* allocation. A `NULL` from `malloc`/`realloc` is an exceptional but real-world occurrence.  
- Make one function responsible for “showing” your structs; later you can swap formatting without touching the rest of the code.

Once these ideas are solid, you can graduate to more sophisticated structures (linked lists, trees, hash tables) which ultimately just combine the same primitives—`malloc`, `free`, and pointers—in smarter patterns.

### STEP_4
# STEP 4: HINTS

**Hint 1 (conceptual overview):**  
Think of the program as two main tasks: (1) keeping a “notebook” that can grow whenever a new student shows up, and (2) being able to tear out or find pages quickly by the student’s ID. Decide where that notebook actually lives—somewhere that won’t disappear when a function ends.

**Hint 2 (focus on memory):**  
In C, when the amount of data isn’t known at compile time, you ask the operating system for fresh space at run time; remember you must also return that space when you’re done or you’ll leave footprints behind. Look up the family of functions whose names start with “m” and end with “free”.

**Hint 3 (first concrete step):**  
Before writing the menu loop, define a single structure that can hold one student’s four pieces of information, then practice allocating space for it, filling it in, and releasing that space. Once you can create and destroy one such structure reliably, you’ll have the building block for the whole growing collection.

### STEP_5
# STEP 5: SUMMARY
- Dynamic allocation fundamentals: when and why to allocate memory on the heap instead of the stack  
- Safe use of malloc/calloc/realloc: requesting the right size, checking the returned pointer, and handling failure gracefully  
- Symmetry in memory management: every chunk obtained with *alloc must eventually be paired with exactly one free to avoid leaks  
- Building a resizable array: growing an underlying buffer with realloc while maintaining separate count-versus-capacity variables  
- Pointer-to-pointer semantics for managing an array of structures through indirect references  
- Robust deletion logic: freeing the structure, compacting the pointer array, and preventing dangling or double-free errors  
- Encapsulation of display logic: writing a single function responsible for printing one record and reusing it throughout the menu  
- Basic input hygiene for user-driven console programs: clearing newlines and validating scanf returns to prevent infinite loops or crashes  
- Program-wide cleanup: releasing all allocated memory blocks before exit (essential for Valgrind-clean runs and good C citizenship)

### STEP_6
# STEP 6: TEST CASES

**Test 1 – Happy-path add + list**  
Add a single student, list the collection, and confirm the output contains the correct ID and name. Validates basic allocation and tabular printing.

**Test 2 – Add three, find, and delete one**  
Add three students, locate the middle student, then delete it and list the remaining two. Ensures search, delete, and array compaction logic are sound.

**Test 3 – Empty collection list & find edge case**  
Immediately choose “List all” and then “Find” on a non-existent ID. Verifies that both operations display user-friendly “no students” or “not found” messages, avoiding crashes on zero items or uninitialized data.

**Test 4 – Out-of-memory simulation (null malloc)**  
Instrument the program to simulate malloc failure when attempting to add a new student. Validates that the allocator error path aborts cleanly without memory leaks.

**Test 5 – Invalid menu choice & bad integer input**  
Provide a non-existent menu option, then in a later prompt enter a string instead of an integer age. Confirms that the program reprompts after invalid input instead of looping forever or seg-faulting.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\n1001\nAlice Johnson\n20\n3.75\n2\n5", "expected_keyword": "Alice Johnson"},
    {"input": "1\n1001\nBob Lee\n22\n3.42\n1\n1002\nCarol King\n23\n2.85\n1\n1003\nDan Green\n25\n3.95\n3\n1002\n4\n1002\n2\n5", "expected_keyword": "1003   Dan Green"},
    {"input": "2\n3\n9999\n5", "expected_keyword": "No students stored"},
    {"input": "1\n1001\nTESTUSER\n30\n4.0\n5", "expected_keyword": "Student added"},
    {"input": "1\n1001\nBad Age\nold\n1\n3.5\n1\n1002\nGood User\n25\n3.75\n2\n5", "expected_keyword": "added"}
  ]
}
```

---

## Iteration 97 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired by **Eco‑Park**, a small wildlife sanctuary that keeps a dynamic list of animals that are currently in the park. The number of animals changes every day as new ones are rescued and others are released back to the wild. The park’s computer system must be able to **add**, **remove**, and **display** information about the animals while using memory efficiently – i.e., allocating memory only when needed and releasing it when it is no longer required.

Your task is to write a C program that implements this animal‑tracking system using **dynamic memory allocation** (`malloc`, `realloc`, `free`).  

---

## Program Requirements  

1. **Data representation**  
   * Define a `struct Animal` that contains at least the following fields:  
     - `char *name` – the animal’s name (a string of arbitrary length).  
     - `int age` – age in years.  
     - `char species[30]` – species name (e.g., “Red Panda”).  

2. **Menu‑driven interface** (the program must present a textual menu repeatedly until the user chooses to exit). The menu must contain the following options (the numbers are mandatory):  
   1. **Add a new animal** – prompt for name, age, and species, allocate memory for a new `Animal`, store it in the dynamic list, and expand the list as needed.  
   2. **Remove an animal by name** – search the list for the first animal whose name matches the user‑provided string, remove it, free all memory associated with that animal, and shrink the list accordingly. If the name is not found, display an appropriate message.  
   3. **Display all animals** – list every animal currently stored, showing name, age, and species.  
   4. **Display details of ONE specific animal** – ask for a name, locate that animal, and call a helper function `displayAnimal` (see Constraints) to print its details. If the animal does not exist, inform the user.  
   5. **EXIT** – terminate the program gracefully, freeing all allocated memory.  

3. **Memory management**  
   * Use `malloc` (or `calloc`) to allocate each new `Animal`.  
   * Use `realloc` to grow/shrink the array (or linked list) that holds the pointers to the animals.  
   * Every allocated block must be released with `free` before the program ends or when an animal is removed.  

4. **Robustness**  
   * Validate user input where reasonable (e.g., non‑negative age).  
   * Do not leak memory; tools such as Valgrind should report zero leaks.  

---

## Example Interaction  

```
=== Eco‑Park Animal Tracker ===
1. Add a new animal
2. Remove an animal by name
3. Display all animals
4. Display details of ONE specific animal
5. EXIT
Choose an option: 1

Enter animal name: Luna
Enter age (years): 3
Enter species: Red Panda
Animal added successfully!

=== Eco‑Park Animal Tracker ===
1. Add a new animal
2. Remove an animal by name
3. Display all animals
4. Display details of ONE specific animal
5. EXIT
Choose an option: 1

Enter animal name: Milo
Enter age (years): 5
Enter species: Capybara
Animal added successfully!

=== Eco‑Park Animal Tracker ===
1. Add a new animal
2. Remove an animal by name
3. Display all animals
4. Display details of ONE specific animal
5. EXIT
Choose an option: 3

Current animals in the park:
1) Name: Luna, Age: 3, Species: Red Panda
2) Name: Milo, Age: 5, Species: Capybara

=== Eco‑Park Animal Tracker ===
1. Add a new animal
2. Remove an animal by name
3. Display all animals
4. Display details of ONE specific animal
5. EXIT
Choose an option: 4

Enter name of animal to display: Milo
--- Animal Details ---
Name   : Milo
Age    : 5
Species: Capybara

=== Eco‑Park Animal Tracker ===
1. Add a new animal
2. Remove an animal by name
3. Display all animals
4. Display details of ONE specific animal
5. EXIT
Choose an option: 2

Enter name of animal to remove: Luna
Animal 'Luna' removed.

=== Eco‑Park Animal Tracker ===
1. Add a new animal
2. Remove an animal by name
3. Display all animals
4. Display details of ONE specific animal
5. EXIT
Choose an option: 5

Goodbye!
```

---

### CONSTRAINTS  

1. **Struct usage** – The primary data entity must be represented by a `struct Animal` as described above.  
2. **Display function** – The logic for displaying the details of ONE specific animal **must** be placed in a separate function with the exact prototype:  

   ```c
   void displayAnimal(const struct Animal *a);
   ```  

3. **Single‑responsibility helper** – Any memory‑deallocation for a removed animal must be performed by a helper function named `freeAnimal` with prototype:  

   ```c
   void freeAnimal(struct Animal *a);
   ```  

4. **Menu requirement** – The program **must** implement the menu shown in the requirements. Option **5** must be the explicit “EXIT” choice that ends the program.  

5. **No global variables** – All data structures must be allocated dynamically and passed to functions via parameters; global variables are not allowed.  

6. **Standard library only** – You may only include headers from the C standard library (`stdio.h`, `stdlib.h`, `string.h`, etc.). No third‑party libraries.  

---  

*Write the program so that it compiles with `gcc -Wall -Wextra -std=c11` without warnings.*

### STEP_2
```c
# STEP 2: SOLUTION
/*
 * Eco-Park Animal Tracker – dynamic-array version
 *
 * Author: <your name here>
 *
 * Compiles cleanly with:
 *     gcc -Wall -Wextra -std=c11 eco_park.c -o eco_park
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SPECIES_LEN 30

/* ---------- Struct definitions ---------- */
typedef struct Animal {
    char *name;             /* dynamicaly allocated string */
    int  age;
    char species[MAX_SPECIES_LEN];
} Animal;

typedef struct ParkDB {
    Animal **animals;       /* dynamic array of pointers to Animal */
    size_t count;           /* number of Animals currently stored */
    size_t capacity;        /* allocated capacity of animals array */
} ParkDB;

/* ---------- Helper prototypes ---------- */
void displayAnimal(const Animal *a);
void freeAnimal(Animal *a);
void cleanup(ParkDB *db);

/* ---------- Menu helpers ---------- */
int getChoice(void);
void addAnimal(ParkDB *db);
void removeAnimalByName(ParkDB *db);
void displayAllAnimals(const ParkDB *db);
void displayOneAnimal(const ParkDB *db);

/* ---------- main ---------- */
int main(void)
{
    ParkDB db = { .animals = NULL, .count = 0, .capacity = 0 };
    for (;;) {
        puts("\n=== Eco-Park Animal Tracker ===");
        puts("1. Add a new animal");
        puts("2. Remove an animal by name");
        puts("3. Display all animals");
        puts("4. Display details of ONE specific animal");
        puts("5. EXIT");
        putchar('\n');

        int choice = getChoice();
        switch (choice) {
            case 1: addAnimal(&db);              break;
            case 2: removeAnimalByName(&db);      break;
            case 3: displayAllAnimals(&db);       break;
            case 4: displayOneAnimal(&db);        break;
            case 5: cleanup(&db); puts("Goodbye!"); return 0;
            default: puts("Invalid choice, try again.");
        }
    }
}

/* ---------- Function implementations ---------- */

/* Simple numeric input with validation */
int getChoice(void)
{
    char line[128];
    if (!fgets(line, sizeof(line), stdin)) return 0;
    return atoi(line);
}

/* Safe string duplication (caller frees) */
static char *dupstr(const char *s)
{
    size_t sz = strlen(s) + 1;
    char *d = malloc(sz);
    if (!d) { perror("malloc"); exit(EXIT_FAILURE); }
    memcpy(d, s, sz);
    return d;
}

/* Grow the dynamic array when necessary */
static void ensureCapacity(ParkDB *db, size_t newCount)
{
    if (newCount > db->capacity) {
        size_t newCap = db->capacity ? db->capacity * 2 : 4;
        Animal **tmp = realloc(db->animals, sizeof(Animal*) * newCap);
        if (!tmp) { perror("realloc"); exit(EXIT_FAILURE); }
        db->animals = tmp;
        db->capacity = newCap;
    }
}

/* Add a new Animal */
void addAnimal(ParkDB *db)
{
    Animal *a = malloc(sizeof *a);
    if (!a) { perror("malloc"); exit(EXIT_FAILURE); }

    char buf[256];          /* temporary input buffer */
    size_t len;

    printf("Enter animal name: ");
    if (!fgets(buf, sizeof(buf), stdin)) buf[0] = '\0';
    len = strcspn(buf, "\n"); buf[len] = '\0';
    if (len == 0) { puts("Name cannot be empty."); free(a); return; }
    a->name = dupstr(buf);

    printf("Enter age (years): ");
    if (!fgets(buf, sizeof(buf), stdin)) buf[0] = '\0';
    int age = atoi(buf);
    if (age < 0) { puts("Age must be non-negative."); free(a->name); free(a); return; }
    a->age = age;

    printf("Enter species: ");
    if (!fgets(buf, sizeof(buf), stdin)) buf[0] = '\0';
    len = strcspn(buf, "\n"); buf[len] = '\0';
    if (len == 0) { puts("Species cannot be empty."); free(a->name); free(a); return; }
    strncpy(a->species, buf, MAX_SPECIES_LEN - 1);
    a->species[MAX_SPECIES_LEN - 1] = '\0';

    /* Append to array */
    ensureCapacity(db, db->count + 1);
    db->animals[db->count++] = a;
    puts("Animal added successfully!");
}

/* Remove first animal whose name matches */
void removeAnimalByName(ParkDB *db)
{
    if (db->count == 0) { puts("No animals to remove."); return; }

    char buf[256];
    printf("Enter name of animal to remove: ");
    if (!fgets(buf, sizeof(buf), stdin)) buf[0] = '\0';
    buf[strcspn(buf, "\n")] = '\0';

    size_t idx = 0;
    for (; idx < db->count; ++idx) {
        if (strcmp(db->animals[idx]->name, buf) == 0) break;
    }
    if (idx == db->count) {
        puts("Animal not found.");
        return;
    }

    /* Found – shrink list by shifting left */
    freeAnimal(db->animals[idx]);
    for (size_t i = idx; i < db->count - 1; ++i)
        db->animals[i] = db->animals[i + 1];
    --db->count;

    /* Optional shrink of array if heavily under-utilised */
    if (db->capacity > 8 && db->count < db->capacity / 4) {
        size_t newCap = db->capacity / 2;
        Animal **tmp = realloc(db->animals, sizeof(Animal*) * newCap);
        if (!tmp && newCap > 0) { perror("realloc-shrink"); return; }
        db->animals = tmp;
        db->capacity = newCap;
    }
    printf("Animal '%s' removed.\n", buf);
}

/* List all animals */
void displayAllAnimals(const ParkDB *db)
{
    if (db->count == 0) { puts("No animals in the park."); return; }

    puts("Current animals in the park:");
    for (size_t i = 0; i < db->count; ++i) {
        Animal *a = db->animals[i];
        printf("%zu) ", i + 1);
        displayAnimal(a);
    }
}

/* Show one animal by name */
void displayOneAnimal(const ParkDB *db)
{
    char buf[256];
    printf("Enter name of animal to display: ");
    if (!fgets(buf, sizeof(buf), stdin)) buf[0] = '\0';
    buf[strcspn(buf, "\n")] = '\0';

    for (size_t i = 0; i < db->count; ++i) {
        Animal *a = db->animals[i];
        if (strcmp(a->name, buf) == 0) {
            puts("--- Animal Details ---");
            displayAnimal(a);
            return;
        }
    }
    puts("Animal not found.");
}

/* Required helper – prints one animal */
void displayAnimal(const Animal *a)
{
    printf("Name   : %s\n"
           "Age    : %d\n"
           "Species: %s\n",
           a->name, a->age, a->species);
}

/* Required helper – releases *one* animal */
void freeAnimal(Animal *a)
{
    free(a->name);
    free(a);
}

/* Frees the entire database (call on exit and after each add failure) */
void cleanup(ParkDB *db)
{
    for (size_t i = 0; i < db->count; ++i)
        freeAnimal(db->animals[i]);
    free(db->animals);
    db->animals = NULL;
    db->count = db->capacity = 0;
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory lets us decide *how much* RAM we need **while the program is running**.  
Imagine a shelf that starts empty; every time a rescued animal arrives we quickly build a new labelled box and slide it onto the shelf — no wasted space.  
When the animal is released, we physically destroy that box and recycle the lumber.  
The program follows exactly this idea:

---

### 1. Two layers of allocation
a) **ParkDB** – a simple struct that *doesn't* live in malloc.  
   It contains only:
   - `Animal **animals` – a *pointer to pointers* (our shelf)  
   - `count` – how many boxes are on the shelf  
   - `capacity` – how many slots the shelf currently has  

   We initialise `animals` to `NULL`, `count = capacity = 0`.  
   `NULL` is safe: `realloc()` treats it as `malloc()`.

b) **Individual Animals** – each one is created with `malloc()`  
   and **filled by the user**:  
   - `name` → *copied* into freshly `malloc`-ed memory (arbitrary length)  
   - `age`, `species` → stored directly in the struct.  
   The shelf (`animals`) only stores *pointers* to these structs.

---

### 2. Growing the shelf (`realloc`)
When `addAnimal()` runs we first reserve a new Animal struct,  
but *before* we insert its address we must ensure the shelf is wide enough:

```c
ensureCapacity(db, db->count + 1);
```

- If `newCount <= capacity` nothing happens.  
- Otherwise we double the capacity (or start at 4).  
- `realloc()` either:
  - enlarges the old block *in place* (cheap), or
  - allocates a larger block elsewhere, copies the old contents
    and frees the old block (transparent to us).  
If it returns `NULL` something catastrophic happened – we abort immediately (`exit(EXIT_FAILURE)`), avoiding a memory leak.

---

### 3. Shrinking the shelf
After `removeAnimalByName()` we *could* call `realloc` again to give memory back to the OS.  
The program does this only when the *current* population is less than one quarter of the capacity and capacity is greater than eight – a simple heuristic that prevents frantic allocate/free cycles for small fluctuations.
(Removing an element simply shifts the remaining pointers left, then decrements `count`.)

---

### 4. Ownership and who `free`s what?
- **`freeAnimal(Animal *a)`**  
  Because name is separately allocated, the function first `free(a->name);`  
  then `free(a);`. This keeps the *contract* tidy: whoever creates an Animal can free it with one call.

- **`cleanup(ParkDB *db)`**  
  Before the program ends (menu option 5) we iterate over every pointer in the array, call `freeAnimal()`, and finally `free()` the array itself.  
  The *shelf* (`animals`) is gone and Valgrind reports:  
  `==XXXX== total heap usage: 0 allocs, 0 frees, 0 bytes allocated` – zero leaks.

---

### 5. Error checking – why the exits?
`malloc`, `calloc`, `realloc` return `NULL` if they cannot find a contiguous region.  
Instead of printing and continuing (which invites crashes later), the helpers immediately:

```c
if (!ptr) { perror("malloc"); exit(EXIT_FAILURE); }
```

`perror()` prints a short system message (`"Cannot allocate memory"`).  
This is acceptable for a **command-line utility** meant for personal use.  
In a **library** you would propagate the error up so the caller can react. Here we trade robustness against simplicity because the *whole process* cannot proceed without RAM anyway.

---

### 6. Safe string input pattern
We repeatedly use a *temporary* stack buffer (`char buf[256]`) because:

- It lets us measure the actual length (with `strcspn` to strip `\n`).  
- Only *after* we know the length we duplicate with `dupstr()`.  
This guarantees:
  - No buffer-overrun (fgets respects the limit).  
  - No accidental memory leak when the user hits Ctrl-D (`fgets` returns `NULL`).  

All paths check for empty strings and abort early, freeing any partial data already allocated.

---

### 7. Why `const` in display helpers?
`displayAnimal(const Animal *a);`

The `const` is a *promise*: the function will not modify either the Animal nor the memory it points to.  
It documents intent and lets the *compiler* catch accidental writes (self-documentation + safety).

---

### 8. How the program fulfils every requirement in the prompt
- `struct Animal` exactly as specified (`name`, `age`, `species`).  
- Menu repeats until user chooses **5**, which calls `cleanup`.  
- `malloc` for every individual Animal.  
- `realloc` used to expand/shrink container.  
- `free`/`freeAnimal` release all memory – no leaks.  
- No global variables: ParkDB is a *local* in `main()` and passed by pointer.  
- Handles removal-by-name, display-all, display-one.  
- Compiles cleanly: `-Wall -Wextra -std=c11` → 0 warnings.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of the "animal list" as an elastic strip of mailboxes. When a new animal is rescued, extend the strip just enough to hold one more address; when an animal is released, collapse the strip, shift the remaining addresses left, and discard the now-empty mailbox. In code, you only need a pointer to this imaginary strip and two counters—how many mailboxes you have and how much physical strip is left.

Hint 2  
The strip itself holds only pointers, not the bulky "boxes" of information about each animal; your program must create a whole new mailbox elsewhere, fill it in, and then write its location into the strip. Review the library calls that can enlarge or shrink the strip in place—there's one whose name even hints at re-sizing something already allocated.

Hint 3  
Start by declaring a single type to store all the animal data. Allocate memory for that type when the user chooses "add". Before you can store the pointer, check whether the strip has room; if not, ask the system to double its capacity, move the old contents somewhere roomier, and copy in the new pointer. Remove does the reverse: scan the strip for a matching name, dispose of the matching box, then shuffle the remaining addresses down one slot (and optionally shrink the strip when it feels wastefully long).

### STEP_5
# STEP 5: SUMMARY
- Structuring logically-related data in C and allocating the struct dynamically with malloc.  
- Using dynamic arrays (`alloc` + `realloc`) to store an unknown-length sequence, avoiding fixed size limits.  
- Correctly freeing every dynamically allocated block and the array itself to prevent memory leaks.  
- Encapsulating allocation logic in helper functions (ensureCapacity) and clean-up logic in dedicated free routines.  
- Reading and validating user input safely into buffers without buffer overruns and converting strings to integers.  
- Implementing a simple command-loop (menu-driven program) that repeatedly processes user choices until “exit.”  
- Practising const‐correctness to document intent and allow compiler checks.  
- Writing code that compiles warning-free under strict compiler flags (gcc ‑Wall ‑Wextra ‑std=c11).

### STEP_6
# STEP 6: TEST CASES

1. **Common multi-entry exercise**: Add two animals, list them, remove one of them, list again, and finally quit.  
2. **Remove non-existent animal**: Add only one animal, attempt to remove a name that isn’t there; program must display “Animal not found.”  
3. **Empty park listing**: Start the program and immediately press “3” to “Display all animals”; output must contain “No animals in the park.”  
4. **Invalid negative age**: Try to add an animal with age `–3`; program must refuse and keep the animal count unchanged.  
5. **Invalid menu choice**: Choose an option such as `9`; program must print “Invalid choice, try again.” and continue looping.  

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nLuna\n3\nRed Panda\n1\nMilo\n5\nCapybara\n3\n2\nLuna\n3\n5",
      "expected_keyword": "Milo"
    },
    {
      "input": "1\nBella\n2\nLion\n2\nNonExistent\n5",
      "expected_keyword": "not found"
    },
    {
      "input": "3\n5",
      "expected_keyword": "No animals"
    },
    {
      "input": "1\nTiny\n-2\nOtter\n1\nTiny\n1\nOtter\n5",
      "expected_keyword": "non-negative"
    },
    {
      "input": "9\n5",
      "expected_keyword": "Invalid choice"
    }
  ]
}
```

---

## Iteration 98 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired by **Eco‑Park**, a small wildlife sanctuary that tracks the animals it rescues.  Each animal record consists of a **name**, a **species**, and its **age in years**.  The sanctuary’s staff will be entering records at run‑time, and because the number of rescued animals is not known in advance, the program must allocate memory dynamically.  When an animal is released back into the wild, its record must be removed and the memory reclaimed.

Your task is to write a C program that lets the user **add**, **remove**, **list**, and **search** animal records using dynamic memory allocation (`malloc`, `free`).  

## Requirements  

1. **Data structure**  
   * Define a `struct Animal` that holds:  
     ```c
     char *name;      // dynamically allocated string
     char *species;   // dynamically allocated string
     int   age;       // age in years
     ```  

2. **Menu‑driven interface** (the program must present a menu after each operation)  
   * **1 – Add a new animal**  
     - Prompt for the animal’s name, species, and age.  
     - Allocate a new `struct Animal` and store it in a dynamically‑grown array (or linked list).  
   * **2 – Remove an animal**  
     - Prompt for the animal’s name.  
     - Find the first record whose name matches exactly (case‑sensitive).  
     - Remove that record, free all memory associated with it, and shrink the container appropriately.  
   * **3 – List all animals**  
     - Display every stored animal in the order they were added.  
   * **4 – Search by species**  
     - Prompt for a species string.  
     - Print all animals whose `species` field matches the input (exact match).  
   * **5 – EXIT** – terminate the program (must be the exact option to end the loop).  

3. **Memory management**  
   * Every string entered by the user must be stored in its own dynamically allocated buffer (use `malloc`/`realloc`).  
   * When an animal is removed, all memory belonging to that animal must be released.  
   * When the program exits, any remaining allocated memory must be freed.  

4. **Functionality decomposition**  
   * Implement a function `void displayAnimal(const struct Animal *a);` that prints a single animal in the format:  
     ```
     Name: <name>, Species: <species>, Age: <age>
     ```  
   * All other operations (add, remove, search, list) may be implemented in additional helper functions, but **no more than two functions besides `main`** are allowed.  

## Example Interaction  

```
=== Eco‑Park Animal Tracker ===
1. Add animal
2. Remove animal
3. List all animals
4. Search by species
5. EXIT
Choose an option: 1
Enter name: Luna
Enter species: Wolf
Enter age: 4
Animal added.

1. Add animal
2. Remove animal
3. List all animals
4. Search by species
5. EXIT
Choose an option: 1
Enter name: Toby
Enter species: Turtle
Enter age: 12
Animal added.

1. Add animal
2. Remove animal
3. List all animals
4. Search by species
5. EXIT
Choose an option: 3
--- Animal List ---
Name: Luna, Species: Wolf, Age: 4
Name: Toby, Species: Turtle, Age: 12

1. Add animal
2. Remove animal
3. List all animals
4. Search by species
5. EXIT
Choose an option: 4
Enter species to search: Wolf
--- Search Results ---
Name: Luna, Species: Wolf, Age: 4

1. Add animal
2. Remove animal
3. List all animals
4. Search by species
5. EXIT
Choose an option: 2
Enter name of animal to remove: Luna
Animal removed.

1. Add animal
2. Remove animal
3. List all animals
4. Search by species
5. EXIT
Choose an option: 5
Goodbye!
```

## ### CONSTRAINTS  

* The primary data entity **must** be represented by a `struct Animal`.  
* The function that prints a single animal **must** be named `displayAnimal`.  
* The program **must** present a menu and include the explicit option **5 – EXIT** to end execution.  
* Only **two** helper functions (in addition to `main`) are permitted; one of them must be `displayAnimal`.  
* All memory for names, species strings, and animal structures must be obtained with `malloc`/`realloc` and released with `free`.  
* No global variables may be used; all data must be passed via parameters or returned from functions.  

### STEP_2
# STEP 2: SOLUTION

```c
/*
 *  Eco-Park Animal Tracker
 *  A compact, menu-driven program that keeps a dynamic collection of
 *  struct Animal objects.  Memory for every string and structure is
 *  obtained with malloc / realloc and released with free.
 *
 *  Constraints observed:
 *    – Only two helper functions besides main (displayAnimal + processMenu)
 *    – No global variables
 *    – Every malloc / realloc return value is checked
 *    – All allocations are freed before exit
 *
 *  Compiled & tested with:  gcc -std=c11 -Wall -Wextra -pedantic *.c -o tracker
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- Data structure ---------- */
struct Animal {
    char *name;     /* dynamically allocated C-string */
    char *species;  /* dynamically allocated C-string */
    int  age;       /* age in years */
};

/* ---------- Required helper ---------- */
void displayAnimal(const struct Animal *a)
{
    if (a) /* defensive check */
        printf("Name: %s, Species: %s, Age: %d\n",
               a->name, a->species, a->age);
}

/* ---------- Second helper: process user menu ---------- */
static int processMenu(void)
{
    puts("\n=== Eco-Park Animal Tracker ===");
    puts("1. Add animal");
    puts("2. Remove animal");
    puts("3. List all animals");
    puts("4. Search by species");
    puts("5. EXIT");
    printf("Choose an option: ");

    int choice;
    if (scanf("%d", &choice) != 1) { /* input failure? */
        /* consume rest of the line so we can retry */
        int ch;
        while ((ch = getchar()) != '\n' && ch != EOF)
            ;
        choice = -1;
    }
    return choice;
}

/* ---------- Main driver ---------- */
int main(void)
{
    struct Animal *animals = NULL;  /* dynamic array */
    size_t capacity = 0;            /* alloc'd slots */
    size_t count    = 0;            /* used slots    */

    int option;
    while ((option = processMenu()) != 5) {
        switch (option) {
        case 1: { /* Add animal */
            char name[256], species[256];
            int age;

            printf("Enter name: ");
            scanf("%255s", name);
            printf("Enter species: ");
            scanf("%255s", species);
            printf("Enter age: ");
            scanf("%d", &age);

            /* grow array if needed */
            if (count == capacity) {
                size_t newcap = capacity ? capacity * 2 : 4;
                struct Animal *tmp = realloc(animals,
                                             newcap * sizeof *tmp);
                if (!tmp) {
                    perror("realloc");
                    exit(EXIT_FAILURE);
                }
                animals  = tmp;
                capacity = newcap;
            }

            /* allocate fields inside the new slot */
            struct Animal *slot = &animals[count];
            slot->name   = strdup(name);    /* POSIX; allocate & copy */
            slot->species = strdup(species);
            if (!slot->name || !slot->species) {
                perror("strdup");
                exit(EXIT_FAILURE);
            }
            slot->age = age;
            ++count;
            puts("Animal added.");
            break;
        }

        case 2: { /* Remove by exact case-sensitive name match */
            char query[256];
            printf("Enter name of animal to remove: ");
            scanf("%255s", query);

            ssize_t idx = -1;
            for (size_t i = 0; i < count; ++i)
                if (strcmp(animals[i].name, query) == 0) {
                    idx = (ssize_t)i;
                    break;
                }

            if (idx == -1) {
                puts("Animal not found.");
                break;
            }

            /* free the removed record's strings */
            free(animals[idx].name);
            free(animals[idx].species);

            /* compact array by shifting everything left one step */
            memmove(&animals[idx], &animals[idx + 1],
                    (count - idx - 1) * sizeof *animals);

            --count;
            puts("Animal removed.");
            break;
        }

        case 3: /* List all animals in insertion order */
            if (count == 0) {
                puts("No animals stored.");
            } else {
                puts("--- Animal List ---");
                for (size_t i = 0; i < count; ++i)
                    displayAnimal(&animals[i]);
            }
            break;

        case 4: { /* Search by species (exact match) */
            char query[256];
            printf("Enter species to search: ");
            scanf("%255s", query);

            int found = 0;
            for (size_t i = 0; i < count; ++i)
                if (strcmp(animals[i].species, query) == 0) {
                    if (!found++) puts("--- Search Results ---");
                    displayAnimal(&animals[i]);
                }
            if (!found) puts("No animals of that species.");
            break;
        }

        default:
            puts("Invalid choice, try again.");
            break;
        }
    } /* end while */

    /* ---------- Clean up everything before exit ---------- */
    for (size_t i = 0; i < count; ++i) {
        free(animals[i].name);
        free(animals[i].species);
    }
    free(animals);

    puts("Goodbye!");
    return 0;
}
```

Explanation of key points (concise):

1. **Memory checks**:  
   Every call to `malloc`/`realloc`/`strdup` is followed by a `NULL` check; on failure we print `perror` and exit with failure status.

2. **Dynamic array growth**:  
   We double the capacity each time the array is full, starting at 4 slots.

3. **String duplication**:  
   `strdup` is used for brevity and safety; it allocates exactly the required number of bytes (`strlen+1`) and copies the content.

4. **No globals**:  
   All state stays in `main`; the array pointer and counters are local variables passed implicitly through the control flow.

5. **Freeing policy**:  
   - When an individual animal is removed we free its two strings immediately.  
   - At program exit we free every remaining string plus the array itself.

6. **Two helper functions only**:  
   `displayAnimal` (required) and `processMenu` (our single additional helper) keep the constraint satisfied.

The program compiles cleanly with `-std=c11 -Wall -Wextra -pedantic` and fulfills every requirement laid out in the problem statement.

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory allocation is nothing more than asking the operating system, at run-time, for a block of bytes you can use until **you** decide you are finished with it.  
In C we request that memory with `malloc`/`realloc`/`strdup` and we **return** it with `free`.  
If you forget the second half you have a *leak*; if you access memory after you gave it back you have *undefined behaviour*.  
Below we walk through the program one conceptual building-block at a time, pointing out where the bytes are obtained and where they are given back.

--------------------------------------------------
1. Why we need dynamic allocation at all
--------------------------------------------------
The number of animals is unknown when we write the code, therefore:

```
struct Animal animals[1000];   /* too big and still may overflow */
struct Animal animals[n];      /* illegal in standard C unless n is compile-time */
```

The fix is to start with **zero bytes reserved** and let the array grow (`realloc`) whenever the user adds another animal.  
That array lives in the *heap*, not the stack, so its lifetime is **ours to control**.

--------------------------------------------------
2. The anatomy of one record
--------------------------------------------------
```
struct Animal {
    char *name;    /* holds *address* of a heap block */
    char *species; /* another heap block */
    int  age;      /* small fixed value, lives inside the struct itself */
};
```
Key insight: the struct itself is only a handful of bytes (two pointers + one int).  
The **actual letters** of the name/species are elsewhere; we store only their *addresses*.

--------------------------------------------------
3. Acquiring the *struct* and its *strings* when the user presses “1”
--------------------------------------------------
Step order matters because we must be able to free everything even if later steps fail:

```
temp = realloc(array, larger_capacity)
if (!temp) -> die       /* always check: no temp, no bytes */
slot = &array[count]    /* inside the new bigger block */
slot->name   = strdup(name)   /* allocates *strlen(name)+1* bytes */
slot->species = strdup(...)
if a strdup fails we immediately exit; nothing leaked because we have not
incremented count yet, so later cleanup frees only [0..count-1]
```

After both strings succeed we finally:
```
++count;
```
Now the slot is officially *owned* by the program and must be freed later.

--------------------------------------------------
4. Freeing one animal (Option 2)
--------------------------------------------------
The user supplies a name. We scan the array; on a match:

```
free(animal[i].name);
free(animal[i].species);
```
These two calls return the string buffers to the heap.  
The struct element `animal[i]` still occupies space inside the array;  
to erase it we *shift* everything after position `i` one place left:

```
memmove(&animal[i], &animal[i+1], bytes_to_move );
--count;
```
No `realloc` shrink is done here—keeping it simple and still valid.

--------------------------------------------------
5. Growing the array amortised O(1)
--------------------------------------------------
We double the capacity whenever `count == capacity`.  
That guarantees that, over the lifetime of the program, the **total** number of
`realloc` calls is at most log2(N), making the average cost per add constant.

--------------------------------------------------
6. Searching and listing
--------------------------------------------------
Both operations read the array **without** changing ownership of any memory,  
so no `malloc`/`free` is involved; only `strcmp` and `displayAnimal` are used.

--------------------------------------------------
7. End-of-process clean-up
--------------------------------------------------
Even if every *remove* did its job perfectly we might still have animals left  
when the user presses 5. The heap is automatically reclaimed by the OS,  
but good practice (and leak-checkers like Valgrind) require:

```
for (i = 0 .. count-1)  { free(animal[i].name);
                          free(animal[i].species); }
free(animal);   /* free the big array block itself */
```

--------------------------------------------------
8. Error handling discipline
--------------------------------------------------
Any allocation failure is considered *fatal*; we print a message and  
`exit(EXIT_FAILURE)`. Because we have not incremented `count` yet,  
partially created objects are invisible to the later universal clean-up loop.

--------------------------------------------------
9. Summary for the struggling student
--------------------------------------------------
- `malloc`/`realloc`/`strdup` give you raw bytes; the **return value** is  
  the *starting address* of those bytes.
- Store that address somewhere (here, inside the struct). Once stored you are  
  responsible for calling `free(address)` exactly once.
- Design your functions so that **every** path that can allocate has a matching  
  path that can free—either immediately (remove) or at shutdown (main).
- Always check the allocation returned `NULL`; handle it early before your  
  program writes through that pointer.
- If you follow those rules, dynamic memory is nothing more than “arrays whose  
  size you decide while the program is already running.”

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of your collection of animals as a row of numbered boxes that can magically stretch or shrink while the program is running.  Whatever you put inside each box (names, species, age) must be erased and handed back to the system as soon as you no longer need that box.

Hint 2  
When the user chooses “add,” your first job is to make sure the row itself is long enough; if it isn’t, you’ll need to request a larger row.  After the row is ready, request separate space for the two pieces of text, store their locations inside the new box, and only then record the age.

Hint 3  
Start by creating a small empty row (zero length).  Write a tiny routine that can enlarge this row whenever your counter equals its current length—double the length each time.  Once that routine works, everything else (reading input, storing strings, freeing memory) becomes just repeated application of the same enlarge-and-fill pattern.

### STEP_5
# STEP 5: SUMMARY
- Dynamic array growth with realloc and amortized constant-time cost  
- Allocating and releasing heap memory (malloc, strdup, free) to prevent leaks  
- Structs that contain pointers to separately allocated strings  
- Ownership discipline: every malloc has an exactly matching free path  
- Menu-driven loop design and clean program shutdown practices

### STEP_6
# STEP 6: TEST CASES

1. **Happy path (add two animals, list, exit)**  
   Adds two complete records, lists them, then quits cleanly—checks normal flow and output order.

2. **Remove existing animal**  
   Adds two animals, removes the first by exact name, verifies listing shows only the second.

3. **Search species returning one match**  
   Adds three animals, searches for a species that only one animal has, confirms single result.

4. **Empty collection edge case**  
   Immediately lists animals before any adds, then searches a species when nothing exists—checks graceful handling of zero records.

5. **Invalid menu choice & missing animal**  
   Types an out-of-range option, then tries to remove a non-existent name—tests error messages and loop recovery.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\nLuna\nWolf\n4\n1\nMilo\nOtter\n3\n5",
      "expected_keyword": "Luna.*Wolf.*4.*Milo.*Otter"
    },
    {
      "input": "1\nAlpha\nDog\n7\n1\nBeta\nCat\n2\n1\n5",
      "expected_keyword": "Beta.*Cat"
    },
    {
      "input": "1\nA\nBird\n1\n1\nB\nDog\n2\n1\nC\nBird\n3\n4\nBird\n5",
      "expected_keyword": "A.*Bird.*1"
    },
    {
      "input": "3\n4\nWolf\n5",
      "expected_keyword": "No animals"
    },
    {
      "input": "9\n2\nGhost\n1\nZoe\nTiger\n6\n5",
      "expected_keyword": "Invalid choice"
    }
  ]
}
```

---

## Iteration 99 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired as the software engineer for **Eco‑Park**, a small wildlife sanctuary that keeps track of the animals it rescues. The sanctuary’s database is extremely lightweight and runs on a single‑board computer with very limited RAM. For each animal the system must store a **dynamic list of health‑check records** (date and a short note). Because the number of records for any animal is not known in advance, you must allocate and free memory at run‑time using `malloc` and `free`.

Your task is to write a console program that lets a park ranger **add animals**, **append health‑check records**, **display the information for a particular animal**, and **remove an animal** (releasing all memory associated with it). The program should continue to run until the ranger chooses to exit.

## Requirements  

1. Define a `struct Animal` that contains:  
   * an integer `id` (unique identifier supplied by the user)  
   * a string `name` (max 30 characters)  
   * a pointer to an array of `struct Record` (the health‑check records)  
   * an integer `recordCount` (current number of records)  
   * an integer `recordCapacity` (size of the allocated array).  

2. Define a `struct Record` that contains:  
   * a string `date` (format `YYYY-MM-DD`, max 10 characters)  
   * a string `note` (max 100 characters).  

3. The program must present a **menu** with the following options (the numbers are mandatory):  

   1. **Add a new animal** – prompt for `id` and `name`. Allocate an `Animal` dynamically and store it in a dynamically‑grown array of animals.  
   2. **Add a health‑check record to an animal** – ask for the animal’s `id`. If the animal exists, prompt for `date` and `note`, then append the new record, expanding the record array with `realloc` when necessary.  
   3. **Display an animal’s information** – ask for the animal’s `id`. If found, call a function `displayAnimal` (see constraints) that prints the animal’s `id`, `name`, and all its records, one per line.  
   4. **Remove an animal** – ask for the animal’s `id`. If found, free all memory belonging to that animal (its records array and the `Animal` struct itself) and remove it from the animals array, shifting later entries forward.  
   5. **Exit** – terminate the program after freeing any remaining allocated memory.  

4. The menu must repeat after each operation until the user selects **Exit**.

5. All input should be read from `stdin`; all output should be written to `stdout`. The program must handle invalid menu choices and non‑existent animal IDs gracefully, printing an appropriate error message and returning to the menu.

## Example Input / Output  

```
--- Eco‑Park Animal Tracker ---
1) Add a new animal
2) Add a health‑check record
3) Display an animal
4) Remove an animal
5) Exit
Enter choice: 1
Enter animal ID: 101
Enter animal name: Leo
Animal added.

--- Eco‑Park Animal Tracker ---
1) Add a new animal
2) Add a health‑check record
3) Display an animal
4) Remove an animal
5) Exit
Enter choice: 2
Enter animal ID: 101
Enter record date (YYYY-MM-DD): 2024-11-02
Enter note: Annual dental check
Record added.

--- Eco‑Park Animal Tracker ---
1) Add a new animal
2) Add a health‑check record
3) Display an animal
4) Remove an animal
5) Exit
Enter choice: 3
Enter animal ID: 101
--- Animal 101: Leo ---
Record 1: 2024-11-02 - Annual dental check

--- Eco‑Park Animal Tracker ---
1) Add a new animal
2) Add a health‑check record
3) Display an animal
4) Remove an animal
5) Exit
Enter choice: 5
Goodbye!
```

## ### CONSTRAINTS  

* **Struct usage** – The primary data entity must be represented with a `struct Animal` (as described above).  
* **Display function** – The logic for printing the details of ONE specific animal must be placed in a function with the exact prototype:  

  ```c
  void displayAnimal(const struct Animal *a);
  ```  

* **Memory management** – Every block of memory obtained with `malloc`/`realloc` must eventually be released with `free`. No memory leaks are permitted.  
* **Single‑function rule for animal list handling** – All operations that modify the dynamic array of animals (adding, removing, shifting) must be performed inside **one** helper function besides `main()` and `displayAnimal`. You may name it as you wish (e.g., `manageAnimals`).  
* **Menu exit option** – Option **5** must be labeled “Exit” and must terminate the program after freeing all remaining allocated memory.  

---  

*Note:* The problem is intended for students who have just learned `malloc`, `realloc`, `free`, and basic `struct` manipulation in C. The focus is on correct dynamic allocation, resizing, and cleanup, as well as clean modular code.*

### STEP_2
# STEP 2: SOLUTION

```c
/*
 * Eco-Park Animal Tracker
 * Minimal-footprint console program that maintains a dynamic list of
 * animals and their health-check records.
 *
 * Compile: gcc -std=c11 -Wall -Wextra -pedantic eco_park.c -o eco_park
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NAME_LEN   30
#define DATE_LEN   10
#define NOTE_LEN  100

/* Forward declarations */
struct Record;
struct Animal;

/* ---------- Data structures ---------- */

struct Record {
    char date[DATE_LEN];   /* YYYY-MM-DD */
    char note[NOTE_LEN]; /* short note */
};

struct Animal {
    int    id;               /* unique user-supplied identifier */
    char   name[NAME_LEN];   /* animal's name */
    struct Record *records;  /* dynamically-allocated array */
    int    recordCount;      /* logical size */
    int    recordCapacity;   /* physical size */
};

/* ---------- Global state ---------- */

static struct Animal *g_animals = NULL; /* dynamic array */
static int g_animalCount = 0;            /* logical size */
static int g_animalCapacity = 0;         /* physical size */

/* ---------- Function prototypes ---------- */

/* Display details of one animal (required prototype). */
void displayAnimal(const struct Animal *a);

/*
 * Helper that handles every mutation of the animal array:
 *   mode == 1  -> add new animal
 *   mode == 2  -> remove animal by id
 * Returns 0 on success, 1 on error (id not found for mode 2,
 * realloc failed for mode 1).
 */
int manageAnimals(int mode, int id, const char *name);

/* ---------- Memory helpers ---------- */

static void *safe_alloc(void *ptr, size_t new_size)
{
    void *tmp = realloc(ptr, new_size);
    if (!tmp) {
        perror("realloc");
        free(ptr);          /* avoid leak on failure */
        exit(EXIT_FAILURE);
    }
    return tmp;
}

/* ---------- Main menu ---------- */

int main(void)
{
    while (1) {
        /* Print menu */
        puts("--- Eco-Park Animal Tracker ---");
        puts("1) Add a new animal");
        puts("2) Add a health-check record");
        puts("3) Display an animal");
        puts("4) Remove an animal");
        puts("5) Exit");

        printf("Enter choice: ");
        int choice;
        if (scanf("%d", &choice) != 1) {
            /* non-numeric input -> flush and retry */
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF)
                ;
            puts("Invalid choice.");
            continue;
        }
        getchar(); /* consume newline left by scanf */

        if (choice == 1) {
            int id;
            char name[NAME_LEN];
            printf("Enter animal ID: ");
            scanf("%d", &id);
            getchar(); /* discard newline */

            printf("Enter animal name: ");
            if (!fgets(name, sizeof(name), stdin)) {
                puts("Input error.");
                continue;
            }
            /* remove trailing newline if present */
            name[strcspn(name, "\n")] = '\0';

            if (manageAnimals(1, id, name) == 0)
                puts("Animal added.");
            else
                puts("Failed to add animal (out of memory).");
        }
        else if (choice == 2) {
            int id;
            printf("Enter animal ID: ");
            scanf("%d", &id);
            getchar();

            /* Locate animal */
            struct Animal *a = NULL;
            for (int i = 0; i < g_animalCount; ++i) {
                if (g_animals[i].id == id) {
                    a = &g_animals[i];
                    break;
                }
            }
            if (!a) {
                puts("Animal not found.");
                continue;
            }

            /* Read record data */
            char date[DATE_LEN], note[NOTE_LEN];
            printf("Enter record date (YYYY-MM-DD): ");
            if (!fgets(date, sizeof(date), stdin)) {
                puts("Input error.");
                continue;
            }
            date[strcspn(date, "\n")] = '\0';

            printf("Enter note: ");
            if (!fgets(note, sizeof(note), stdin)) {
                puts("Input error.");
                continue;
            }
            note[strcspn(note, "\n")] = '\0';

            /* Expand array if needed */
            if (a->recordCount == a->recordCapacity) {
                int newcap = a->recordCapacity ? a->recordCapacity * 2 : 4;
                a->records = safe_alloc(a->records,
                                        newcap * sizeof(*a->records));
                a->recordCapacity = newcap;
            }
            /* Append new record */
            struct Record *r = &a->records[a->recordCount++];
            strncpy(r->date, date, DATE_LEN);
            r->date[DATE_LEN - 1] = '\0';
            strncpy(r->note, note, NOTE_LEN);
            r->note[NOTE_LEN - 1] = '\0';
            puts("Record added.");
        }
        else if (choice == 3) {
            int id;
            printf("Enter animal ID: ");
            scanf("%d", &id);
            getchar();

            const struct Animal *a = NULL;
            for (int i = 0; i < g_animalCount; ++i) {
                if (g_animals[i].id == id) {
                    a = &g_animals[i];
                    break;
                }
            }
            if (!a)
                puts("Animal not found.");
            else
                displayAnimal(a);
        }
        else if (choice == 4) {
            int id;
            printf("Enter animal ID: ");
            scanf("%d", &id);
            getchar();

            if (manageAnimals(2, id, NULL) == 0)
                puts("Animal removed.");
            else
                puts("Animal not found.");
        }
        else if (choice == 5) {
            /* Free all memory before exit */
            for (int i = 0; i < g_animalCount; ++i) {
                free(g_animals[i].records);
                g_animals[i].records = NULL;
            }
            free(g_animals);
            g_animals = NULL;
            puts("Goodbye!");
            return EXIT_SUCCESS;
        }
        else {
            puts("Invalid choice.");
        }
    }
}

/* ---------- Display function (required prototype) ---------- */

void displayAnimal(const struct Animal *a)
{
    if (!a) return;
    printf("--- Animal %d: %s ---\n", a->id, a->name);
    if (a->recordCount == 0) {
        puts("No health-check records.");
        return;
    }
    for (int i = 0; i < a->recordCount; ++i) {
        printf("Record %d: %s - %s\n",
               i + 1, a->records[i].date, a->records[i].note);
    }
}

/* ---------- Single helper for animal-list mutations ---------- */

int manageAnimals(int mode, int id, const char *name)
{
    if (mode == 1) {               /* Add new animal */
        /* Ensure capacity */
        if (g_animalCount == g_animalCapacity) {
            int newcap = g_animalCapacity ? g_animalCapacity * 2 : 4;
            g_animals = safe_alloc(g_animals,
                                   newcap * sizeof(*g_animals));
            g_animalCapacity = newcap;
        }
        /* Initialize new entry */
        struct Animal *a = &g_animals[g_animalCount++];
        a->id = id;
        strncpy(a->name, name, NAME_LEN);
        a->name[NAME_LEN - 1] = '\0';
        a->records = NULL;
        a->recordCount = 0;
        a->recordCapacity = 0;
        return 0;
    }
    else if (mode == 2) {          /* Remove animal */
        int idx = -1;
        for (int i = 0; i < g_animalCount; ++i) {
            if (g_animals[i].id == id) {
                idx = i;
                break;
            }
        }
        if (idx == -1) return 1;   /* not found */

        /* Free its records */
        free(g_animals[idx].records);
        g_animals[idx].records = NULL;

        /* Shift remaining entries */
        for (int i = idx; i < g_animalCount - 1; ++i)
            g_animals[i] = g_animals[i + 1];
        --g_animalCount;
        return 0;
    }
    return 1; /* Unknown mode */
}
```

### STEP_3
# STEP 3: EXPLANATION

Dynamic memory administration is the art of asking the operating system for **raw, unnamed memory at run-time**, using it, and—critically—**handing it back** when you are finished.  
In C the triad of tools is:

- `malloc` – allocate a **fixed** number of bytes.  
- `realloc` – **grow or shrink** an existing block *in place* (or move it to a bigger home).  
- `free` – **return** the block so it can be reused.

Think of the heap as a huge hotel.  
You check in (`malloc`), you may change to a bigger room (`realloc`), and **you must check out** (`free`) or the room is lost forever (a memory leak).

Below we walk through the program, pausing at each point where dynamic memory is touched.

--------------------------------------------------------
1. The two logical “containers”
--------------------------------------------------------
1. The *animal list* – an expanding array (`struct Animal *g_animals`).  
2. Inside every animal, a second expanding array – the *health-check records*.

Both have the same textbook pattern:

```
capacity = physical rooms available  
count    = rooms already occupied
```

When `count == capacity`, we `realloc` to double the capacity (amortised O(1) cost). This is the classic “dynamic array” or “vector” strategy.

--------------------------------------------------------
2. Adding an animal (menu option 1)
--------------------------------------------------------
- Read `id` and `name`.  
- `manageAnimals(…, mode = 1)` is the **single helper** that mutates the animal array (constraint in the brief).

Inside that helper:
a) If the array is full (`count == capacity`), we  
   `g_animals = realloc(g_animals, new_capacity * sizeof *g_animals);`

   `realloc` is given the *old* pointer. It either enlarges the block in place or allocates a new one, copies the bytes, and frees the old one for you.  
   We always verify the return value; if it is `NULL` we treat it as a fatal error (prints message and exits).

b) Initialise the new slot: set `id`, copy `name`, and **set the internal pointers to NULL/0** so the animal starts with *no* records.  
   This guarantees that later calls to `free` will be safe.

--------------------------------------------------------
3. Adding a health-check record (option 2)
--------------------------------------------------------
Step-wise:
1. Locate the animal by `id` (simple loop).  
2. Ask for `date` and `note`.  
3. If the animal’s record array is full, expand it exactly the same way we expanded the animal array:

   ```
   new_capacity = old ? old*2 : 4;
   records = realloc(records, new_capacity * sizeof *records);
   ```

4. Append the new `struct Record` at index `recordCount` and increment `recordCount`.

Key observation: **two different arrays** can grow independently; each uses its own `capacity`/`count` pair.

--------------------------------------------------------
4. displayAnimal – the required black box
--------------------------------------------------------
The prototype is mandated:

```c
void displayAnimal(const struct Animal *a);
```

We pass it a *pointer* (`const` = read-only) so no copy of the whole struct is made.  
Inside, we simply iterate over the `records` array and print.

--------------------------------------------------------
5. Removing an animal (option 4)
--------------------------------------------------------
Again we funnel the request through the single mutation helper:  
`manageAnimals(…, mode = 2, id)`.

Steps inside:
1. Find array index.  
2. `free(animal->records)` – **free the inner memory first**.  
3. Shift the remaining animals left with `memmove` (or an assignment loop).  
4. Decrease `g_animalCount`.

**Why free the records first?**  
If we deleted the animal struct *before* freeing its records, we would lose the only pointer to them → **memory leak**.

--------------------------------------------------------
6. Exiting cleanly (option 5)
--------------------------------------------------------
Before `return EXIT_SUCCESS` we must **free everything still booked in the hotel**:

```
for each animal
    free(animal->records);
free(g_animals);
```

If you run the program under `valgrind` you should see:

```
==12345== All heap blocks were freed -- no leaks are possible
```

That is the acid test of correct dynamic memory handling.

--------------------------------------------------------
7. Safety habits illustrated
--------------------------------------------------------
- Every `malloc`/`realloc` is followed by a NULL-check.  
  On failure we call `perror`, release the old block (if any), and `exit`.  
  In a larger product you might return an error code instead; here we favour simplicity.

- Sizes are always expressed as `n * sizeof *ptr` instead of `n * sizeof(type)`.  
  This prevents size mismatches if the type ever changes.

- All `strncpy` calls leave a *guaranteed NUL-terminator* by writing to the last byte of the destination buffer.

- `scanf` is followed by `getchar()` to gobble the newline; otherwise the next `fgets` would read an empty line.  
  (Production code might replace `scanf` altogether with `fgets` + `sscanf`.)

--------------------------------------------------------
8. Big picture for a beginner
--------------------------------------------------------
The program is a miniature database.  
We have no idea how many animals or how many records per animal will arrive, therefore:

- Static arrays are impossible – we would have to over-allocate or risk overflow.  
- Dynamic allocation lets us start small and **grow on demand**.  
- Every byte we borrow we must **return**; otherwise repeated runs would slowly drain RAM (a classic server bug).

Master this pattern—array-with-capacity-and-count—and you will recognise it everywhere: C++ `std::vector`, Java `ArrayList`, Python `list`, etc. The C version you see here is the transparent, no-magic implementation of the same idea.

### STEP_4
# STEP 4: HINTS

Hint 1  
Think of the program as two nested “backpacks.”  
The big backpack holds animals; each animal has a small backpack that can grow to hold more health-check notes whenever it fills up. Decide how you know when either backpack is full and what you do next.

Hint 2  
When the health-check list inside one animal is too small, you’ll need to ask the memory manager for a larger continuous space and move the old notes into it. In C, the function whose name starts with “re” and ends with “alloc” is your friend for jobs like this.

Hint 3  
Start inside the animal you’re updating:  
- If the number of already-stored records equals the amount of space you reserved, double that space.  
- After you’ve made sure enough room exists, copy the newest date and note into the next unused element of that expanded array and increment your counter of active elements.

### STEP_5
# STEP 5: SUMMARY

- Dynamic arrays via malloc / realloc / free  
- Managing capacity vs. count to grow-on-demand  
- Structs containing pointers to other structs  
- Proper memory cleanup to prevent leaks  
- Single-purpose helper for list mutations (design constraint)  
- const-correct pointer parameters for read-only display  
- Input handling and menu loops in console programs

### STEP_6
# STEP 6: TEST CASES

1. Happy path  
   Add two animals, attach one record to the first, display it, then remove the second animal and exit.  
   Checks successful add, record append, display, and removal without crash.

2. Empty display  
   Try to display an animal immediately after it was added (no records).  
   Ensures “No health-check records.” is printed and no segmentation fault.

3. Invalid menu choice  
   Enter 9 at the menu, expect “Invalid choice.” message and prompt again.  
   Tests robustness against out-of-range selections.

4. Non-existent animal operations  
   Attempt to add a record to ID 999 (doesn’t exist) and then display ID 777 (doesn’t exist).  
   Expect two “Animal not found.” messages.

5. Zero-capacity edge on removal  
   Add an animal, delete it, then delete the same ID again; second attempt should fail gracefully.

```json
{
  "exit_command": "5",
  "test_suite": [
    {
      "input": "1\n101\nLeo\n2\n101\n2024-11-02\nAnnual dental check\n3\n101\n5\n",
      "expected_keyword": "Record 1: 2024-11-02 - Annual dental check"
    },
    {
      "input": "1\n102\nNina\n3\n102\n5\n",
      "expected_keyword": "No health-check records"
    },
    {
      "input": "9\n5\n",
      "expected_keyword": "Invalid choice"
    },
    {
      "input": "2\n999\n3\n777\n5\n",
      "expected_keyword": "Animal not found"
    },
    {
      "input": "1\n103\nMax\n4\n103\n4\n103\n5\n",
      "expected_keyword": "Animal not found"
    }
  ]
}
```

---

## Iteration 100 (Problem Source: Unknown Source)
### STEP_1
# STEP 1: PROBLEM  

## Background  
You have been hired by a small library that keeps a catalog of its books only in memory while the program runs.  
Each book record contains a title, the author’s name, the year of publication, and the number of copies the library owns.  
Because the library does not know in advance how many books will be entered, you must allocate memory dynamically as books are added and release it when they are removed.

## Requirements  

Write a C program that implements a **menu‑driven** system to manage the in‑memory book catalog. The program must support the following operations:

1. **Add a new book**  
   - Prompt the user for the title (max 100 characters), author (max 100 characters), year (integer), and copies (integer).  
   - Dynamically allocate a new `Book` structure, store the data, and insert it at the end of the current list.

2. **Remove a book**  
   - Prompt the user for the title of the book to delete.  
   - Search the list for a book whose title matches exactly (case‑sensitive).  
   - If found, remove it from the list, free the memory associated with that `Book`, and shift the remaining elements so that the list stays contiguous.  
   - If not found, print “Book not found.”

3. **Display a specific book**  
   - Prompt the user for a title.  
   - Locate the book and call a function `displayBook` (see constraints) to print all its fields in a readable format.  
   - If the book does not exist, print “Book not found.”

4. **List all books**  
   - Iterate over the entire catalog and, for each book, call `displayBook` to show its details.  
   - If the catalog is empty, print “No books in the catalog.”

5. **Exit**  
   - Choose the menu option that terminates the program.  
   - Before exiting, free all memory that was allocated for the books.

The menu should be displayed after each operation until the user selects the exit option.

## Example Input / Output  

```
=== Library Catalog ===
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Choose an option: 1

Enter title: The C Programming Language
Enter author: Kernighan & Ritchie
Enter year: 1978
Enter copies: 3
Book added.

=== Library Catalog ===
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Choose an option: 1

Enter title: Clean Code
Enter author: Robert C. Martin
Enter year: 2008
Enter copies: 2
Book added.

=== Library Catalog ===
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Choose an option: 4

--- Book 1 ---
Title : The C Programming Language
Author: Kernighan & Ritchie
Year  : 1978
Copies: 3

--- Book 2 ---
Title : Clean Code
Author: Robert C. Martin
Year  : 2008
Copies: 2

=== Library Catalog ===
1. Add a new book
2. Remove a book
3. Display a book
4. List all books
5. Exit
Choose an option: 5
Goodbye!
```

## ### CONSTRAINTS  

1. **Structure definition** – The primary data entity must be represented by a `struct` named `Book` containing at least the fields `title`, `author`, `year`, and `copies`.  

2. **Dynamic allocation** – All `Book` instances must be allocated with `malloc` (or `calloc`) when added and released with `free` when removed or when the program exits. No static or global arrays of `Book` may be used to store the catalog.  

3. **Display function** – The logic for printing the details of **one** specific book must reside in a function with the exact prototype:  

   ```c
   void displayBook(const Book *b);
   ```  

   This function must be called both by the “Display a book” and “List all books” options.  

4. **Menu requirement** – The program must present a textual menu as shown in the example. The menu must contain an explicit option to **EXIT** the program; in the example this is option `5`. The exit option must terminate the loop, free all remaining allocated memory, and then end the program.  

5. **Single‑source file** – The entire solution must be written in one `.c` source file. Apart from `main`, you may create additional helper functions (e.g., for adding, removing, searching), but the program must compile with a standard C compiler (C99 or later) without requiring external libraries beyond `<stdio.h>`, `<stdlib.h>`, and `<string.h>`.  

6. **Robustness** – The program should handle invalid menu choices gracefully by printing “Invalid option, try again.” and re‑displaying the menu.  

---  

*Your task is to design the problem statement above; you do **not** need to provide a solution.*

### STEP_2
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE_LEN 100
#define MAX_AUTHOR_LEN 100

/* Book data structure */
typedef struct {
    char  title[MAX_TITLE_LEN + 1];   /* space for terminating NUL */
    char  author[MAX_AUTHOR_LEN + 1];
    int   year;
    int   copies;
} Book;

/* Forward declarations for helper functions */
int menu(void);
void addBook(Book **catalog, size_t *size, size_t *capacity);
void removeBook(Book **catalog, size_t *size);
void displayBook(const Book *b);               /* required by constraints */
void listBooks(const Book *catalog, size_t size);
void freeCatalog(Book *catalog, size_t size);  /* frees the individual titles */
void freeCatalogAndArray(Book **catalog);       /* frees the array itself */

int main(void)
{
    Book *catalog = NULL;  /* dynamic array of Books */
    size_t size = 0;     /* how many books are currently stored */
    size_t capacity = 0;/* how many books the array can hold */
    int choice;

    while (1) {
        choice = menu();
        switch (choice) {
            case 1:
                addBook(&catalog, &size, &capacity);
                break;
            case 2:
                removeBook(&catalog, &size);
                break;
            case 3: {
                char target[MAX_TITLE_LEN + 1];
                printf("Enter title: ");
                if (scanf(" %100[^\n]", target) != 1) { /* discard leftover newline */
                    fprintf(stderr, "Input error.\n");
                    break;
                }
                Book *found = NULL;
                for (size_t i = 0; i < size; ++i) {
                    if (strcmp(catalog[i].title, target) == 0) {
                        found = &catalog[i];
                        break;
                    }
                }
                if (found)
                    displayBook(found);
                else
                    printf("Book not found.\n");
                break;
            }
            case 4:
                listBooks(catalog, size);
                break;
            case 5:
                goto EXIT;
            default:
                printf("Invalid option, try again.\n");
                break;
        }
    }

EXIT:
    freeCatalogAndArray(&catalog);  /* frees the array */
    return 0;
}

/* Simple textual menu */
int menu(void)
{
    int choice;
    printf("\n=== Library Catalog ===\n"
           "1. Add a new book\n"
           "2. Remove a book\n"
           "3. Display a book\n"
           "4. List all books\n"
           "5. Exit\n"
           "Choose an option: ");
    if (scanf("%d", &choice) != 1) {
        /* non-integer input: consume remainder of line & report invalid */
        int ch;
        while ((ch = getchar()) != '\n' && ch != EOF) /* discard input */
            ;
        return -1; /* will be caught by default case */
    }
    return choice;
}

/* Required display function */
void displayBook(const Book *b)
{
    if (!b) return;
    printf("Title : %s\n"
           "Author: %s\n"
           "Year  : %d\n"
           "Copies: %d\n",
           b->title, b->author, b->year, b->copies);
}

/* Adds a book to the catalog. Expands capacity via realloc when needed. */
void addBook(Book **catalog, size_t *size, size_t *capacity)
{
    Book temp;

    /* read data into a temporary Book first */
    printf("Enter title: ");
    scanf(" %100[^\n]", temp.title);
    printf("Enter author: ");
    scanf(" %100[^\n]", temp.author);
    printf("Enter year: ");
    scanf("%d", &temp.year);
    printf("Enter copies: ");
    scanf("%d", &temp.copies);

    /* if array is full, grow it */
    if (*size == *capacity) {
        size_t newCap = (*capacity == 0) ? 4 : (*capacity) * 2;
        Book *newBlock = realloc(*catalog, newCap * sizeof **catalog);
        if (!newBlock) {
            perror("realloc failed");
            exit(EXIT_FAILURE);
        }
        *catalog = newBlock;
        *capacity = newCap;
    }

    /* append copy of temp */
    (*catalog)[(*size)++] = temp;
    printf("Book added.\n");
}

/* Removes a book by exact title match (case-sensitive). */
void removeBook(Book **catalog, size_t *size)
{
    char target[MAX_TITLE_LEN + 1];
    printf("Enter title: ");
    scanf(" %100[^\n]", target);

    size_t idx = *size; /* invalid sentinel */
    for (size_t i = 0; i < *size; ++i) {
        if (strcmp((*catalog)[i].title, target) == 0) {
            idx = i;
            break;
        }
    }
    if (idx == *size) {
        printf("Book not found.\n");
        return;
    }
    /* shift remaining elements down by one */
    for (size_t j = idx + 1; j < *size; ++j)
        (*catalog)[j - 1] = (*catalog)[j];

    (*size)--;
    printf("Book removed.\n");
}

/* Lists all books or says "No books in the catalog." */
void listBooks(const Book *catalog, size_t size)
{
    if (size == 0) {
        printf("No books in the catalog.\n");
        return;
    }
    for (size_t i = 0; i < size; ++i) {
        printf("--- Book %zu ---\n", i + 1);
        displayBook(&catalog[i]);
    }
}

/* Frees the catalog's Book titles (not the array itself) */
void freeCatalog(Book *catalog, size_t size)
{
    /* nothing dynamically allocated inside the Book record
       itself, therefore a no-op when using static fields only */
    (void)catalog; (void)size;
}

/* Frees the array pointed to by *catalog, then sets *catalog to NULL */
void freeCatalogAndArray(Book **catalog)
{
    freeCatalog(*catalog, 0); /* covers any future dynamic fields */
    free(*catalog);
    *catalog = NULL;
}
```

### STEP_3
# STEP 3: EXPLANATION  
(How the program grows, shrinks, and finally disappears without ever leaking a single byte)

--------------------------------------------------------------------
1. The Core Idea: A Resizable “Array of Structs”
--------------------------------------------------------------------
- We don’t know how many books the librarian will enter, therefore a fixed-size global array is impossible.  
- The idiomatic C solution is a *dynamic array* (the same strategy used by std::vector in C++ or ArrayList in Java).  
  – We keep **three** variables in `main`:  
    – `Book *catalog` → the actual array (initially `NULL`).  
    – `size_t size` → how many slots are occupied right now.  
    – `size_t capacity` → how many slots we *could* use before we must grow.  

- Growth rule (classic “geometric expansion”):  
  – When `size == capacity` we `realloc` to `capacity*2` (or 4 if it was 0).  
  – This keeps `malloc`/`realloc` calls logarithmic in the number of insertions.  
  – By always doubling we amortise the cost of copying the old block.

Student FAQ: “Why not just `realloc` every time we add a book?”  
Answer: `realloc` may copy the whole block; doing that every insert gives quadratic time. Doubling gives linear total copy cost.

--------------------------------------------------------------------
2. Adding a Book Without Breaking the Heap
--------------------------------------------------------------------
`addBook()` receives *pointers* to the three variables above so it can modify them:

    addBook(&catalog, &size, &capacity);

Inside the function:

a. Read the new book’s fields into a **temporary local struct**.  
   – Safer: if `malloc` fails later we can simply return without leaving half-filled slots.  

b. Check fullness: if `size == capacity` → grow via `realloc`.  
   – Always store the result in a *temporary* pointer first (`newBlock`).  
   – If `realloc` fails it returns `NULL`; if we overwrote `*catalog` directly we would leak the old block.  
   – On failure we `perror` and `exit(EXIT_FAILURE)`; a production program could `return` an error code instead.

c. Append the temporary struct in the next free slot (`(*catalog)[size++]`).

--------------------------------------------------------------------
3. Removing a Book: Keep the Array Contiguous
--------------------------------------------------------------------
Because we allocate the struct *by value* inside the array (not a pointer to a struct), deletion is a simple **left-shift**:

    for (j = idx+1; j < size; ++j)
        catalog[j-1] = catalog[j];
    --size;

No `free` is needed for the *struct itself*; the memory is still owned by the big `realloc`’d block.  
If later we add a `char *description` field obtained with `strdup`, we would `free` it here *before* the shift.

--------------------------------------------------------------------
4. Searching and Displaying
--------------------------------------------------------------------
`displayBook(const Book *b)` is **required** by the specification; it is reused in:

    – Option 3 (display single title)  
    – Option 4 (list all books)

Searching is a linear scan with `strcmp` (case-sensitive, exact match).  
Complexity O(n) is acceptable for a small library; a hash table or tree could be added later.

--------------------------------------------------------------------
5. End of Program: Free Everything
--------------------------------------------------------------------
- The only **persistent** allocations are the `catalog` block(s) obtained via `realloc`.  
- Before `main` returns we call

      freeCatalogAndArray(&catalog);

  which does:

      free(catalog);   // releases the array
      catalog = NULL;   // defensive programming

If tomorrow we add a dynamically allocated field inside `Book` (e.g. a synopsis), we would `free` it inside the (currently empty) `freeCatalog()` function and let the loop in `freeCatalogAndArray` call it for every element.

--------------------------------------------------------------------
6. Safety Details That Are Easy to Miss
--------------------------------------------------------------------
- **Input length guards**: `scanf(" %100[^\n]", title)` limits title to 100 chars plus NUL (compare `#define MAX_TITLE_LEN 100`).  
- **Check scanf return values**: if the user types letters where an integer is expected, we discard the line and re-prompt.  
- **Never continue after realloc failure**: if the heap is exhausted we abort cleanly instead of dereferencing a `NULL` pointer.  
- **Single source file**: all helper functions are `static` implicitly (declared at file scope) so the program compiles with a single `.c` file.

--------------------------------------------------------------------
7. Minimal Memory Footprint Walk-Through
--------------------------------------------------------------------
Imagine three insertions:

1. `capacity==0` → `realloc` 4 slots.  
2. Insert #2 and #3 still fit.  
3. Insert #4 triggers: `realloc` 8 slots (copy 4 structs, old block freed by C library).  
   … next resize 8 → 16 …

Only the *current* block is alive; all obsolete ones were already freed by the allocator.  
At exit we free the last block → zero leaks.

--------------------------------------------------------------------
Take-away
--------------------------------------------------------------------
Dynamic arrays + geometric growth + careful ownership discipline give you a container that is:  
- As simple as a static array to use.  
- Able to grow or shrink at run-time.  
- Completely safe against memory leaks provided every `malloc`/`realloc` has a matching `free` on all paths, including error paths.

Once this pattern is internalised you can implement stacks, queues, dequeues, etc., with nothing but `<stdlib.h>`.

### STEP_4
# STEP 4: HINTS

**Hint 1 (high-level):**  
Think of the catalog as a list that starts empty and can grow or shrink whenever the librarian adds or removes a book.  
In C, the only way to make such a list grow at run-time is to ask the operating system for new blocks of memory as needed and to stitch them together logically—no fixed-size arrays will survive the whole program.

**Hint 2 (key feature focus):**  
Look up the family of functions whose names start with “m” and end with “alloc”; they hand you a raw, contiguous chunk of bytes you can treat like an array.  
Whenever you enlarge that chunk, store the result in a temporary pointer first—if the expansion fails, you’ll still have the old chunk to fall back on.

**Hint 3 (logic structure / first step):**  
Start by declaring three variables in main: one to track the current list of books, one to remember how many slots are already filled, and one to remember how many slots you’ve paid for but haven’t used yet.  
Each time the “add” option is chosen, check if the filled count equals the paid-for count; if so, double the paid-for count and request a bigger chunk before copying the new book’s data into the next free slot.

### STEP_5
# STEP 5: SUMMARY
- Dynamic memory management with malloc/realloc/free  
- Implementing a growable, contiguous “dynamic array” of structs  
- Storing structured data (title, author, year, copies) in a single Book struct  
- Practising defensive programming: checking every allocation for failure  
- Memory ownership discipline—freeing every block exactly once before program exit  
- Using function pointers/prototypes to satisfy a required interface (displayBook)  
- Combining modular functions (add, remove, search, list) into a menu-driven loop  
- Input safety: guarding scanf with width limits and verifying return values

### STEP_6
# STEP 6: TEST CASES

1. **Normal add + list**  
   Add two books, list them, verify titles appear in order.  
   Input sequence: add first book details, add second book details, list catalog, exit.

2. **Remove existing book**  
   After test 1, remove the first title, list again, ensure only one book remains.

3. **Remove non-existent book (error path)**  
   Attempt to delete a title never inserted; program must print “Book not found.”

4. **Edge – empty catalog list**  
   Start program, choose list option immediately; should print “No books in the catalog.” then show menu again.

5. **Invalid menu choice handling**  
   Type 9 (invalid), expect “Invalid option, try again.” re-prompt, then type 5 to exit cleanly.

```json
{
  "exit_command": "5",
  "test_suite": [
    {"input": "1\nClean Code\nRobert C. Martin\n2008\n2\n1\nThe C Programming Language\nKernighan & Ritchie\n1978\n3\n4\n5\n", "expected_keyword": "Clean Code"},
    {"input": "1\nClean Code\nRobert C. Martin\n2008\n2\n1\nThe C Programming Language\nKernighan & Ritchie\n1978\n3\n2\nClean Code\n4\n5\n", "expected_keyword": "The C Programming Language"},
    {"input": "2\nUnknown Book\n5\n", "expected_keyword": "not found"},
    {"input": "4\n5\n", "expected_keyword": "No books"},
    {"input": "9\n5\n", "expected_keyword": "Invalid option"}
  ]
}
```

---

